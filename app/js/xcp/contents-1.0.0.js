
/* ckeditor/content/ckeditor/load.js */

(function() {
    function loadScript(url, callback) {

        var script = document.createElement("script");
        script.type = "text/javascript";

        if (script.readyState) {  //IE
            script.onreadystatechange = function() {
                if (script.readyState == "loaded" ||
                    script.readyState == "complete") {
                    script.onreadystatechange = null;
                    //callback();
                }
            };
        } else {  //Others
            script.onload = function() {
                //callback();
            };
        }

        script.src = url;
        document.getElementsByTagName("head")[0].appendChild(script);
    }	
	loadScript('js/ckeditor/ckeditor.js', null)

})();
/* extjs-ux/content/extjs-ux/ux/TabScrollerMenu.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.ns('Ext.ux');
/**
 * @class Ext.ux.TabScrollerMenu
 * @extends Object
 * Plugin (ptype = 'tabscrollermenu') for adding a tab menu to a TabBar is the Tabs overflow.
 * @constructor
 * @param {Object} config Configuration options
 * @ptype tabscrollermenu
 */
Ext.define('Ext.ux.TabScrollerMenu', {
    alias: 'plugin.tabscrollermenu',

    uses: ['Ext.menu.Menu'],

    /**
     * @cfg {Number} pageSize How many items to allow per submenu.
     */
    pageSize: 10,
    /**
     * @cfg {Number} maxText How long should the title of each {@link Ext.menu.Item} be.
     */
    maxText: 15,
    /**
     * @cfg {String} menuPrefixText Text to prefix the submenus.
     */
    menuPrefixText: 'Items',
    constructor: function(config) {
        config = config || {};
        Ext.apply(this, config);
    },
    //private
    init: function(tabPanel) {
        var me = this;

        Ext.apply(tabPanel, me.parentOverrides);
        me.tabPanel = tabPanel;

        tabPanel.on({
            render: function() {
                me.tabBar = tabPanel.tabBar;
                me.layout = me.tabBar.layout;
                me.layout.overflowHandler.handleOverflow = Ext.Function.bind(me.showButton, me);
                me.layout.overflowHandler.clearOverflow = Ext.Function.createSequence(me.layout.overflowHandler.clearOverflow, me.hideButton, me);
            },
            single: true
        });
    },

    showButton: function() {
        var me = this,
            result = Ext.getClass(me.layout.overflowHandler).prototype.handleOverflow.apply(me.layout.overflowHandler, arguments);

        if (!me.menuButton) {
            me.menuButton = me.tabBar.body.createChild({
                cls: Ext.baseCSSPrefix + 'tab-tabmenu-right'
            }, me.tabBar.body.child('.' + Ext.baseCSSPrefix + 'box-scroller-right'));
            me.menuButton.addClsOnOver(Ext.baseCSSPrefix + 'tab-tabmenu-over');
            me.menuButton.on('click', me.showTabsMenu, me);
        }
        me.menuButton.show();
        result.reservedSpace += me.menuButton.getWidth();
        return result;
    },

    hideButton: function() {
        var me = this;
        if (me.menuButton) {
            me.menuButton.hide();
        }
    },

    /**
     * Returns an the current page size (this.pageSize);
     * @return {Number} this.pageSize The current page size.
     */
    getPageSize: function() {
        return this.pageSize;
    },
    /**
     * Sets the number of menu items per submenu "page size".
     * @param {Number} pageSize The page size
     */
    setPageSize: function(pageSize) {
        this.pageSize = pageSize;
    },
    /**
     * Returns the current maxText length;
     * @return {Number} this.maxText The current max text length.
     */
    getMaxText: function() {
        return this.maxText;
    },
    /**
     * Sets the maximum text size for each menu item.
     * @param {Number} t The max text per each menu item.
     */
    setMaxText: function(t) {
        this.maxText = t;
    },
    /**
     * Returns the current menu prefix text String.;
     * @return {String} this.menuPrefixText The current menu prefix text.
     */
    getMenuPrefixText: function() {
        return this.menuPrefixText;
    },
    /**
     * Sets the menu prefix text String.
     * @param {String} t The menu prefix text.
     */
    setMenuPrefixText: function(t) {
        this.menuPrefixText = t;
    },

    showTabsMenu: function(e) {
        var me = this;

        if (me.tabsMenu) {
            me.tabsMenu.removeAll();
        } else {
            me.tabsMenu = Ext.create('Ext.menu.Menu');
            me.tabPanel.on('destroy', me.tabsMenu.destroy, me.tabsMenu);
        }

        me.generateTabMenuItems();

        var target = Ext.get(e.getTarget());
        var xy = target.getXY();

        //Y param + 24 pixels
        xy[1] += 24;

        me.tabsMenu.showAt(xy);
    },

    // private
    generateTabMenuItems: function() {
        var me = this,
            tabPanel = me.tabPanel,
            curActive = tabPanel.getActiveTab(),
            totalItems = tabPanel.items.getCount(),
            pageSize = me.getPageSize(),
            numSubMenus = Math.floor(totalItems / pageSize),
            remainder = totalItems % pageSize,
            i, curPage, menuItems, x, item, start, index;

        if (totalItems > pageSize) {

            // Loop through all of the items and create submenus in chunks of 10
            for (i = 0; i < numSubMenus; i++) {
                curPage = (i + 1) * pageSize;
                menuItems = [];

                for (x = 0; x < pageSize; x++) {
                    index = x + curPage - pageSize;
                    item = tabPanel.items.get(index);
                    menuItems.push(me.autoGenMenuItem(item));
                }

                me.tabsMenu.add({
                    text: me.getMenuPrefixText() + ' ' + (curPage - pageSize + 1) + ' - ' + curPage,
                    menu: menuItems
                });
            }
            // remaining items
            if (remainder > 0) {
                start = numSubMenus * pageSize;
                menuItems = [];
                for (i = start; i < totalItems; i++) {
                    item = tabPanel.items.get(i);
                    menuItems.push(me.autoGenMenuItem(item));
                }

                me.tabsMenu.add({
                    text: me.menuPrefixText + ' ' + (start + 1) + ' - ' + (start + menuItems.length),
                    menu: menuItems
                });

            }
        }
        else {
            tabPanel.items.each(function(item) {
                if (item.id != curActive.id && !item.hidden) {
                    me.tabsMenu.add(me.autoGenMenuItem(item));
                }
            });
        }
    },

    // private
    autoGenMenuItem: function(item) {
        var maxText = this.getMaxText(),
            text = Ext.util.Format.ellipsis(item.title, maxText);

        return {
            text: text,
            handler: this.showTabFromMenu,
            scope: this,
            disabled: item.disabled,
            tabToShow: item,
            iconCls: item.iconCls
        };
    },

    // private
    showTabFromMenu: function(menuItem) {
        this.tabPanel.setActiveTab(menuItem.tabToShow);
    }
});

/* extjs-ux/content/extjs-ux/ux/BoxSelect.js */

/**
 * @class Ext.ux.form.field.BoxSelect
 * @extends Ext.form.field.ComboBox
 *
 * BoxSelect for ExtJS 4, a combo box improved for multiple value querying, selection and management.
 *
 * A friendlier combo box for multiple selections that creates easily individually
 * removable labels for each selection, as seen on facebook and other sites. Querying
 * and type-ahead support are also improved for multiple selections.
 *
 * Options and usage mostly remain consistent with the {@link Ext.form.field.ComboBox}
 * control. Some default configuration options have changed, but should still
 * work properly if overridden.
 *
 * Inspired by the SuperBoxSelect component for ExtJS 3 (http://technomedia.co.uk/SuperBoxSelect/examples3.html),
 * which in turn was inspired by the BoxSelect component for ExtJS 2 (http://efattal.fr/en/extjs/extuxboxselect/).
 *
 * Various contributions and suggestions made by many members of the ExtJS community which can be seen
 * in the user extension posting: http://www.sencha.com/forum/showthread.php?134751-Ext.ux.form.field.BoxSelect
 *
 * Many thanks go out to all of those who have contributed, this extension would not be
 * possible without your help.
 *
 * @author kvee_iv http://www.sencha.com/forum/member.php?29437-kveeiv
 * @version 1.3.1
 * @requires BoxSelect.css
 * @xtype boxselect
 */
Ext.define('Ext.ux.form.field.BoxSelect', {
    extend:'Ext.form.field.ComboBox',
    alias: ['widget.comboboxselect', 'widget.boxselect'],
    // requires: ['Ext.selection.Model', 'Ext.data.Store'], this was in the orginal code, I removed do to unit tests not liking it. 

    /**
     * @cfg {Boolean} multiSelect
     * If set to <code>true</code>, allows the combo field to hold more than one value at a time, and allows selecting
     * multiple items from the dropdown list. (Defaults to <code>true</code>, the default usage for BoxSelect)
     */
    multiSelect: true,

    /**
	 * @cfg {Boolean} forceSelection
	 * <code>true</code> to restrict the selected value to one of the values in the list,
     * <code>false</code> to allow the user to set arbitrary text into the field (defaults to <code>true</code>, the default usage for BoxSelect)
     */
    forceSelection: true,

    /**
     * @cfg {Boolean} selectOnFocus <code>true</code> to automatically select any existing field text when the field
     * receives input focus (defaults to <code>true</code> for best multi-select usability during querying)
     */
    selectOnFocus: true,

    /**
     * @cfg {Boolean} triggerOnClick <code>true</code> to activate the trigger when clicking in empty space
     * in the field. Note that the subsequent behavior of this is controlled by the field's {@link #triggerAction}.
     * This behavior is similar to that of a basic ComboBox with {@link #editable} <code>false</code>.
     * (defaults to <code>true</code>).
     */
    triggerOnClick: true,

    /**
	 * @cfg {Boolean} createNewOnEnter
	 * When forceSelection is false, new records can be created by the user. These records are not added to the
	 * combo's store. By default, this creation is triggered by typing the configured 'delimiter'. With
	 * createNewOnEnter set to true, this creation can also be triggered by the 'enter' key. This configuration
	 * option has no effect if forceSelection is true. (defaults to <code>false</code>)
	 * <code>true</code> to allow the user to press 'enter' to create a new record
	 * <code>false</code> to only allow the user to type the configured 'delimiter' to create a new record
	 */
    createNewOnEnter: false,

    /**
	 * @cfg {Boolean} createNewOnBlur
	 * Similar to {@link #createNewOnEnter}, createNewOnBlur will create a new record when the field loses focus.
	 * This configuration option has no effect if forceSelection is true. Please note that this behavior is also
	 * affected by the configuration options {@link #autoSelect} and {@link #selectOnTab}. If those are true
	 * and an existing item would have been selected as a result, the partial text the user has entered will
	 * be discarded.
	 * <code>true</code> to create a new record when the field loses focus
	 * <code>false</code> to not create a new record on blur
	 */
    createNewOnBlur: false,

    /**
     * @cfg {Boolean} encodeSubmitValue
     * Controls the formatting of the form submit value of the field. (defaults to <code>false</code>). This
     * is not applicable of {@link #multiSelect} is false.
     * <code>true</code> for the field value to submit as a json encoded array in a single POST variable
     * <code>false</code> for the field to submit as an array of POST variables
     */
    encodeSubmitValue: false,

    /**
	 * @cfg {Boolean} stacked
	 * When stacked is true, each labelled item will fill to the width of the form field
	 * <code>true</code> to have each labelled item fill the width of the form field
	 * <code>false</code> to have each labelled item size to its displayed contents (defaults to <code>false</code>)
	 */
    stacked: false,

    /**
	 * @cfg {Boolean} pinList
	 * When multiSelect is true, the pick list used for the combo will stay open after each selection is made. This
	 * config option has no effect if multiSelect is false.
	 * <code>true</code> to keep the pick list expanded after each multiSelect selection
	 * <code>false</code> to collapse the pick list after each multiSelect selection (defaults to <code>true</code>)
	 */
    pinList: true,

    /**
     * @cfg {Boolean} grow <tt>true</tt> if this field should automatically grow and shrink to its content
     * (defaults to <tt>true</tt>)
     */
    grow: true,

    /**
     * @cfg {Number} growMin The minimum height to allow when <tt>{@link Ext.form.field.Text#grow grow}=true</tt>
     * (defaults to <tt>false</tt>, which allows for natural growth based on selections)
     */
    growMin: false,

    /**
     * @cfg {Number} growMax The maximum height to allow when <tt>{@link Ext.form.field.Text#grow grow}=true</tt>
     * (defaults to <tt>false</tt>, which allows for natural growth based on selections)
     */
    growMax: false,

    //private
    componentLayout: 'boxselectfield',

    /**
	 * Initialize additional settings and enable simultaneous typeAhead and multiSelect support
	 */
    initComponent: function() {
        var me = this,
        typeAhead = me.typeAhead;

        if (typeAhead && !me.editable) {
            Ext.Error.raise('If typeAhead is enabled the combo must be editable: true -- please change one of those settings.');
        }

        Ext.apply(me, {
            typeAhead: false
        });

        me.callParent(arguments);

        me.typeAhead = typeAhead;

        me.selectionModel = new Ext.selection.Model({
            store: me.valueStore,
            mode: 'MULTI',
            onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
                commitFn();
            }
        });

        if (!Ext.isEmpty(me.delimiter) && me.multiSelect) {
            me.delimiterEndingRegexp = new RegExp(String(me.delimiter).replace(/[$%()*+.?\[\\\]{|}]/g, "\\$&") + "$");
        }
    },

    /**
	 * Register events for management controls of labelled items
	 */
    initEvents: function() {
        var me = this;

        me.callParent(arguments);

        if (!me.enableKeyEvents) {
            me.mon(me.inputEl, 'keydown', me.onKeyDown, me);
        }
        me.mon(me.itemList, 'click', me.onItemListClick, me);
        me.mon(me.selectionModel, 'selectionchange', me.applyMultiselectItemMarkup, me);
    },

    /**
	 * Create a store for the records of our current value based on the main store's model
	 */
    bindStore: function(store, initial) {
        var me = this,
        oldStore = me.store;

        if (oldStore) {
            me.mun(oldStore, 'beforeload', me.onBeforeLoad, me);
            if (me.valueStore) {
                me.mun(me.valueStore, 'datachanged', me.applyMultiselectItemMarkup, me);
                me.valueStore = null;
            }
        }

        me.callParent(arguments);

        if (me.store) {
            me.valueStore = new Ext.data.Store({
                model: me.store.model,
                proxy: {
                    type: 'memory'
                }
            });
            me.mon(me.valueStore, 'datachanged', me.applyMultiselectItemMarkup, me);
            me.mon(me.store, 'beforeload', me.onBeforeLoad, me);
        }
    },

    /**
	 * Add refresh tracking to the picker for selection management
	 */
    createPicker: function() {
        var me = this,
        picker = me.callParent(arguments);

        me.mon(picker, {
            'beforerefresh': me.onBeforeListRefresh,
            'show': function(pick) {
                /**
                 * Temporary fix for reapplying maxHeight after shorter list was previously shown
                 */
                var listEl = picker.listEl,
                ch = listEl.getHeight();
                if (ch > picker.maxHeight) {
                    listEl.setHeight(picker.maxHeight);
                }
            },
            scope: me
        });

        return picker;
    },

    /**
	 * Clean up labelled items management controls
	 */
    onDestroy: function() {
        var me = this;

        Ext.destroyMembers(me, 'selectionModel', 'valueStore');

        me.callParent(arguments);
    },

    /**
	 * Overridden to avoid use of placeholder, as our main input field is often empty
	 */
    afterRender: function() {
        var me = this;

        if (Ext.supports.Placeholder && me.inputEl && me.emptyText) {
            delete me.inputEl.dom.placeholder;
        }

        if (me.stacked === true) {
            me.itemList.addCls('x-boxselect-stacked');
        }

        if (me.grow) {
            if (Ext.isNumber(me.growMin) && (me.growMin > 0)) {
                me.itemList.applyStyles('min-height:'+me.growMin+'px');
            }
            if (Ext.isNumber(me.growMax) && (me.growMax > 0)) {
                me.itemList.applyStyles('max-height:'+me.growMax+'px');
            }
        }

        me.applyMultiselectItemMarkup();

        me.callParent(arguments);

    },

    /**
	 * Overridden to search store snapshot instead of data (if available)
	 */
    findRecord: function(field, value) {
        var ds = this.store,
        rec = false,
        idx;

        if (ds.snapshot) {
            idx = ds.snapshot.findIndexBy(function(rec) {
                return rec.get(field) === value;
            });
            rec = (idx !== -1) ? ds.snapshot.getAt(idx) : false;
        } else {
            idx = ds.findExact(field, value);
            rec = (idx !== -1) ? ds.getAt(idx) : false;
        }

        return rec;
    },

    /**
	 * When the picker is refreshing, we should ignore selection changes. Otherwise
	 * the value of our field will be changing just because our view of the choices is.
	 */
    onBeforeLoad: function() {
        this.ignoreSelection++;
    },

    /**
	 * Overridden to map previously selected records to the "new" versions of the records
	 * based on value field, if they are part of the new store load
	 */
    onLoad: function() {
        var me = this,
        valueField = me.valueField,
        valueStore = me.valueStore,
        changed = false;


        if (valueStore) {
            if (!Ext.isEmpty(me.value) && (valueStore.getCount() == 0)) {
                me.setValue(me.value, false, true);
            }

            valueStore.suspendEvents();
            valueStore.each(function(rec) {
                var r = me.findRecord(valueField, rec.get(valueField)),
                i = r ? valueStore.indexOf(rec) : -1;
                if (i >= 0) {
                    valueStore.removeAt(i);
                    valueStore.insert(i, r);
                    changed = true;
                }
            });
            valueStore.resumeEvents();
            if (changed) {
                valueStore.fireEvent('datachanged', valueStore);
            }
        }

        me.callParent(arguments);

        me.ignoreSelection = Ext.Number.constrain(me.ignoreSelection - 1, 0);

        me.alignPicker();
    },

    /**
	 * @private
	 * Used to determine if a record is filtered (for retaining as a multiSelect value)
	 */
    isFilteredRecord: function(record) {
        var me = this,
        store = me.store,
        valueField = me.valueField,
        storeRecord,
        filtered = false;

        storeRecord = store.findExact(valueField, record.get(valueField));

        filtered = ((storeRecord === -1) && (!store.snapshot || (me.findRecord(valueField, record.get(valueField)) !== false)));

        filtered = filtered || (!filtered && (storeRecord === -1) && (me.forceSelection !== true) &&
            (me.valueStore.findExact(valueField, record.get(valueField)) >= 0));

        return filtered;
    },

    /**
	 * Overridden to allow for continued querying with multiSelect selections already made
	 */
    doRawQuery: function() {
        var me = this,
        rawValue = me.inputEl.dom.value;

        if (me.multiSelect) {
            rawValue = rawValue.split(me.delimiter).pop();
        }

        this.doQuery(rawValue, false, true);
    },

    /**
	 * When the picker is refreshing, we should ignore selection changes. Otherwise
	 * the value of our field will be changing just because our view of the choices is.
	 */
    onBeforeListRefresh: function() {
        this.ignoreSelection++;
    },

    /**
	 * When the picker is refreshing, we should ignore selection changes. Otherwise
	 * the value of our field will be changing just because our view of the choices is.
	 */
    onListRefresh: function() {
        this.callParent(arguments);
        this.ignoreSelection = Ext.Number.constrain(this.ignoreSelection - 1, 0);
    },

    /**
	 * Overridden to preserve current labelled items when list is filtered/paged/loaded
	 * and does not include our current value.
	 */
    onListSelectionChange: function(list, selectedRecords) {
        var me = this,
        valueStore = me.valueStore,
        mergedRecords = [],
        i;

        // Only react to selection if it is not called from setValue, and if our list is
        // expanded (ignores changes to the selection model triggered elsewhere)
        if ((me.ignoreSelection <= 0) && me.isExpanded) {
            // Pull forward records that were already selected or are now filtered out of the store
            valueStore.each(function(rec) {
                if (Ext.Array.contains(selectedRecords, rec) || me.isFilteredRecord(rec)) {
                    mergedRecords.push(rec);
                }
            });
            mergedRecords = Ext.Array.merge(mergedRecords, selectedRecords);

            i = Ext.Array.intersect(mergedRecords, valueStore.getRange()).length;
            if ((i != mergedRecords.length) || (i != me.valueStore.getCount())) {
                me.setValue(mergedRecords, false);
                if (!me.multiSelect || !me.pinList) {
                    Ext.defer(me.collapse, 1, me);
                }
                if (valueStore.getCount() > 0) {
                    me.fireEvent('select', me, valueStore.getRange());
                }
            }
            me.inputEl.focus();
            if (!me.pinList) {
                me.inputEl.dom.value = '';
            }
            if (me.selectOnFocus) {
                me.inputEl.dom.select();
            }
        }
    },

    /**
     * Overridden to use valueStore instead of valueModels, for inclusion of filtered records
     */
    syncSelection: function() {
        var me = this,
        picker = me.picker,
        valueField = me.valueField,
        pickStore, selection, selModel;

        if (picker) {
            pickStore = picker.store;

            // From the value, find the Models that are in the store's current data
            selection = [];
            if (me.valueStore) {
                me.valueStore.each(function(rec) {
                    var i = pickStore.findExact(valueField, rec.get(valueField));
                    if (i >= 0) {
                        selection.push(pickStore.getAt(i));
                    }
                });
            }

            // Update the selection to match
            me.ignoreSelection++;
            selModel = picker.getSelectionModel();
            selModel.deselectAll();
            if (selection.length > 0) {
                selModel.select(selection);
            }
            me.ignoreSelection = Ext.Number.constrain(me.ignoreSelection - 1, 0);
        }
    },

    /**
	 * Overridden to align to itemList size instead of inputEl
     */
    alignPicker: function() {
        var me = this,
        picker, isAbove,
        aboveSfx = '-above',
        itemBox = me.itemList.getBox(false, true);

        if (this.isExpanded) {
            picker = me.getPicker();
            var pickerScrollPos = picker.getTargetEl().dom.scrollTop;
            if (me.matchFieldWidth) {
                // Auto the height (it will be constrained by min and max width) unless there are no records to display.
                picker.setSize(itemBox.width, picker.store && picker.store.getCount() ? null : 0);
            }
            if (picker.isFloating()) {
                picker.alignTo(me.itemList, me.pickerAlign, me.pickerOffset);

                // add the {openCls}-above class if the picker was aligned above
                // the field due to hitting the bottom of the viewport
                isAbove = picker.el.getY() < me.inputEl.getY();
                me.bodyEl[isAbove ? 'addCls' : 'removeCls'](me.openCls + aboveSfx);
                picker.el[isAbove ? 'addCls' : 'removeCls'](picker.baseCls + aboveSfx);
            }
        }
    },

    /**
	 * @private
	 * Get the current cursor position in the input field
	 */
    getCursorPosition: function() {
        var cursorPos;
        if (Ext.isIE) {
            cursorPos = document.selection.createRange();
            cursorPos.collapse(true);
            cursorPos.moveStart("character", -this.inputEl.dom.value.length);
            cursorPos = cursorPos.text.length;
        } else {
            cursorPos = this.inputEl.dom.selectionStart;
        }
        return cursorPos;
    },

    /**
	 * @private
	 * Check to see if the input field has selected text
	 */
    hasSelectedText: function() {
        var sel, range;
        if (Ext.isIE) {
            sel = document.selection;
            range = sel.createRange();
            return (range.parentElement() == this.inputEl.dom);
        } else {
            return this.inputEl.dom.selectionStart != this.inputEl.dom.selectionEnd;
        }
    },

    /**
	 * Handles keyDown processing of key-based selection of labelled items
	 */
    onKeyDown: function(e, t) {
        var me = this,
        key = e.getKey(),
        rawValue = me.inputEl.dom.value,
        valueStore = me.valueStore,
        selModel = me.selectionModel,
        stopEvent = false,
        rec, i;

        if (me.readOnly || me.disabled || !me.editable) {
            return;
        }

        // Handle keyboard based navigation of selected labelled items
        if ((valueStore.getCount() > 0) &&
            ((rawValue == '') || ((me.getCursorPosition() === 0) && !me.hasSelectedText()))) {
            if ((key == e.BACKSPACE) || (key == e.DELETE)) {
                if (selModel.getCount() > 0) {
                    me.valueStore.remove(selModel.getSelection());
                } else {
                    me.valueStore.remove(me.valueStore.last());
                }
                me.setValue(me.valueStore.getRange());
                selModel.deselectAll();
                stopEvent = true;
            } else if ((key == e.RIGHT) || (key == e.LEFT)) {
                if ((selModel.getCount() === 0) && (key == e.LEFT)) {
                    selModel.select(valueStore.last());
                    stopEvent = true;
                } else if (selModel.getCount() > 0) {
                    rec = selModel.getLastFocused() || selModel.getLastSelected();
                    if (rec) {
                        i = valueStore.indexOf(rec);
                        if (key == e.RIGHT) {
                            if (i < (valueStore.getCount() - 1)) {
                                selModel.select(i + 1, e.shiftKey);
                                stopEvent = true;
                            } else if (!e.shiftKey) {
                                selModel.deselect(rec);
                                stopEvent = true;
                            }
                        } else if ((key == e.LEFT) && (i > 0)) {
                            selModel.select(i - 1, e.shiftKey);
                            stopEvent = true;
                        }
                    }
                }
            } else if (key == e.A && e.ctrlKey) {
                selModel.selectAll();
                stopEvent = e.A;
            }
            me.inputEl.focus();
        }

        if (stopEvent) {
            me.preventKeyUpEvent = stopEvent;
            e.stopEvent();
            return;
        }

        // Prevent key up processing for enter if it is being handled by the picker
        if (me.isExpanded && (key == e.ENTER) && me.picker.highlightedItem) {
            me.preventKeyUpEvent = true;
        }

        if (me.enableKeyEvents) {
            me.callParent(arguments);
        }

        if (!e.isSpecialKey() && !e.hasModifier()) {
            me.selectionModel.deselectAll();
            me.inputEl.focus();
        }
    },

    /**
	 * Handles auto-selection of labelled items based on this field's delimiter, as well
	 * as the keyUp processing of key-based selection of labelled items.
	 */
    onKeyUp: function(e, t) {
        var me = this,
        rawValue = me.inputEl.dom.value,
        rec;

        if (me.preventKeyUpEvent) {
            e.stopEvent();
            if ((me.preventKeyUpEvent === true) || (e.getKey() === me.preventKeyUpEvent)) {
                delete me.preventKeyUpEvent;
            }
            return;
        }

        if (me.multiSelect && (me.delimiterEndingRegexp && me.delimiterEndingRegexp.test(rawValue)) ||
            ((me.createNewOnEnter === true) && e.getKey() == e.ENTER)) {
            rawValue = rawValue.replace(me.delimiterEndingRegexp, '');
            if (!Ext.isEmpty(rawValue)) {
                rec = me.valueStore.findExact(me.valueField, rawValue);
                if (rec >= 0) {
                    rec = me.valueStore.getAt(rec);
                } else {
                    rec = me.store.findExact(me.valueField, rawValue);
                    if (rec >= 0) {
                        rec = me.store.getAt(rec);
                    } else {
                        rec = false;
                    }
                }
                if (!rec && !me.forceSelection) {
                    rec = {};
                    rec[me.valueField] = rawValue;
                    rec[me.displayField] = rawValue;
                    rec = new me.valueStore.model(rec);
                }
                if (rec) {
                    me.collapse();
                    me.setValue(me.valueStore.getRange().concat(rec));
                    me.inputEl.dom.value = '';
                    me.inputEl.focus();
                }
            }
        }

        me.callParent([e,t]);

        Ext.Function.defer(me.alignPicker, 10, me);
    },

    /**
	 * Overridden to get and set the dom value directly for type-ahead suggestion (bypassing get/setRawValue)
	 */
    onTypeAhead: function() {
        var me = this,
        displayField = me.displayField,
        inputElDom = me.inputEl.dom,
        record = me.store.findRecord(displayField, inputElDom.value),
        boundList = me.getPicker(),
        newValue, len, selStart;

        if (record) {
            newValue = record.get(displayField);
            len = newValue.length;
            selStart = inputElDom.value.length;
            boundList.highlightItem(boundList.getNode(record));
            if (selStart !== 0 && selStart !== len) {
                inputElDom.value = newValue;
                me.selectText(selStart, newValue.length);
            }
        }
    },

    /**
	 * Delegation control for selecting and removing labelled items or triggering list collapse/expansion
	 */
    onItemListClick: function(evt, el, o) {
        var me = this,
        itemEl = evt.getTarget('.x-boxselect-item'),
        closeEl = itemEl ? evt.getTarget('.x-boxselect-item-close') : false;

        if (me.readOnly || me.disabled) {
            return;
        }

        evt.stopPropagation();

        if (itemEl) {
            if (closeEl) {
                me.removeByListItemNode(itemEl);
            } else {
                me.toggleSelectionByListItemNode(itemEl, evt.shiftKey);
            }
            me.inputEl.focus();
        } else if (me.triggerOnClick) {
            me.onTriggerClick();
        }
    },

    /**
	 * Build the markup for the labelled items. Template must be built on demand due to ComboBox initComponent
	 * lifecycle for the creation of on-demand stores (to account for automatic valueField/displayField setting)
	 */
    getMultiSelectItemMarkup: function() {
        var me = this;

        if (!me.multiSelectItemTpl) {
            if (!me.labelTpl) {
                me.labelTpl = Ext.create('Ext.XTemplate',
                    '{[values.' + me.displayField + ']}'
                );
            } else if (Ext.isString(me.labelTpl)) {
                me.labelTpl = Ext.create('Ext.XTemplate', me.labelTpl);
            }

            me.multiSelectItemTpl = [
            '<tpl for=".">',
            '<li class="x-boxselect-item ',
            '<tpl if="this.isSelected(values.'+ me.valueField + ')">',
            ' selected',
            '</tpl>',
            '" qtip="{[typeof values === "string" ? values : values.' + me.displayField + ']}">' ,
            '<div class="x-boxselect-item-text">{[typeof values === "string" ? values : this.getItemLabel(values)]}</div>',
            '<div class="x-tab-close-btn x-boxselect-item-close"></div>' ,
            '</li>' ,
            '</tpl>',
            {
                compile: true,
                disableFormats: true,
                isSelected: function(value) {
                    var i = me.valueStore.findExact(me.valueField, value);
                    if (i >= 0) {
                        return me.selectionModel.isSelected(me.valueStore.getAt(i));
                    }
                },
                getItemLabel: function(values) {
                    return me.getTpl('labelTpl').apply(values);
                }
            }
            ];
        }

        return this.getTpl('multiSelectItemTpl').apply(Ext.Array.pluck(this.valueStore.getRange(), 'data'));
    },

    /**
	 * Update the labelled items rendering
	 */
    applyMultiselectItemMarkup: function() {
        var me = this,
        itemList = me.itemList,
        item;

        if (itemList) {
            while ((item = me.inputElCt.prev()) != null) {
                item.remove();
            }
            me.inputElCt.insertHtml('beforeBegin', me.getMultiSelectItemMarkup());
        }
    },

    /**
	 * Returns the record from valueStore for the labelled item node
	 */
    getRecordByListItemNode: function(itemEl) {
        var me = this,
        itemIdx = 0,
        searchEl = me.itemList.dom.firstChild;

        while (searchEl && searchEl.nextSibling) {
            if (searchEl == itemEl) {
                break;
            }
            itemIdx++;
            searchEl = searchEl.nextSibling;
        }
        itemIdx = (searchEl == itemEl) ? itemIdx : false;

        if (itemIdx === false) {
            return false;
        }

        return me.valueStore.getAt(itemIdx);
    },

    /**
	 * Toggle of labelled item selection by node reference
	 */
    toggleSelectionByListItemNode: function(itemEl, keepExisting) {
        var me = this,
        rec = me.getRecordByListItemNode(itemEl);

        if (rec) {
            if (me.selectionModel.isSelected(rec)) {
                me.selectionModel.deselect(rec);
            } else {
                me.selectionModel.select(rec, keepExisting);
            }
        }
    },

    /**
	 * Removal of labelled item by node reference
	 */
    removeByListItemNode: function(itemEl) {
        var me = this,
        rec = me.getRecordByListItemNode(itemEl);

        if (rec) {
            me.valueStore.remove(rec);
            me.setValue(me.valueStore.getRange());
        }
    },

    /**
	 * Intercept calls to getRawValue to pretend there is no inputEl for rawValue handling,
	 * so that we can use inputEl for just the user input.
	 *
	 * **Note that in general, raw values are the rendered value for the input field,
	 * and therefore should not be used for comboboxes or most programmatic logic.**
	 */
    getRawValue: function() {
        var me = this,
        inputEl = me.inputEl,
        result;
        me.inputEl = false;
        result = me.callParent(arguments);
        me.inputEl = inputEl;
        return result;
    },

    /**
	 * Intercept calls to setRawValue to pretend there is no inputEl for rawValue handling,
	 * so that we can use inputEl for just the user input.
	 *
	 * **Note that in general, raw values are the rendered value for the input field,
	 * and therefore should not be used for comboboxes or most programmatic logic.**
	 */
    setRawValue: function(value) {
        var me = this,
        inputEl = me.inputEl,
        result;

        me.inputEl = false;
        result = me.callParent([value]);
        me.inputEl = inputEl;

        return result;
    },

    /**
	 * Adds a value or values to the current value of the field
	 * @param {mixed} valueMixed The value or values to add to the current value
	 */
    addValue: function(valueMixed) {
        var me = this;
        if (valueMixed) {
            me.setValue(Ext.Array.merge(me.value, Ext.Array.from(valueMixed)));
        }
    },

    /**
	 * Removes a value or values from the current value of the field
	 * @param {mixed} valueMixed The value or values to remove from the current value
	 */
    removeValue: function(valueMixed) {
        var me = this;

        if (valueMixed) {
            me.setValue(Ext.Array.difference(me.value, Ext.Array.from(valueMixed)));
        }
    },

    /**
	 * Intercept calls to setValue to use records from the valueStore when available.
	 * Unknown values (if forceSelection is true) will trigger a call to store.load
	 * once to try to retrieve those records. The list of unknown values will be
	 * submitted as the name of the valueField with values separated by the configured
	 * delimiter. This process will cause setValue to asynchronously process.
	 */
    setValue: function(value, doSelect, skipLoad) {
        var me = this,
        valueStore = me.valueStore,
        valueField = me.valueField,
        record, len, i, valueRecord, h,
        unknownValues = [];

        if (Ext.isEmpty(value)) {
            value = null;
        }
        if (Ext.isString(value) && me.multiSelect) {
            value = value.split(me.delimiter);
        }
        value = Ext.Array.from(value);

        for (i = 0, len = value.length; i < len; i++) {
            record = value[i];
            if (!record || !record.isModel) {
                valueRecord = valueStore.findExact(valueField, record);
                if (valueRecord >= 0) {
                    value[i] = valueStore.getAt(valueRecord);
                } else {
                    valueRecord = me.findRecord(valueField, record);
                    if (!valueRecord) {
                        if (me.forceSelection) {
                            unknownValues.push(record);
                        } else {
                            valueRecord = {};
                            valueRecord[me.valueField] = record;
                            valueRecord[me.displayField] = record;
                            valueRecord = new me.valueStore.model(valueRecord);
                        }
                    }
                    if (valueRecord) {
                        value[i] = valueRecord;
                    }
                }
            }
        }

        if ((skipLoad !== true) && (unknownValues.length > 0) && (me.queryMode === 'remote')) {
            var params = {};
            params[me.valueField] = unknownValues.join(me.delimiter);
            me.store.load({
                params: params,
                callback: function() {
                    me.itemList.unmask();
                    me.setValue(value, doSelect, true);
                    me.autoSize();
                }
            });
            return false;
        }

        /**
		 * For single-select boxes, use the last value
		 */
        if (!me.multiSelect && (value.length > 0)) {
            value = value[value.length - 1];
        }

        me.callParent([value, doSelect]);
    },

    /**
     * Returns the records for the field's current value
     * @return {Array} The records for the field's current value
     */
    getValueRecords: function() {
        return this.valueStore.getRange();
    },

    /**
     * Overridden to optionally allow for submitting the field as a json encoded array.
     */
    getSubmitData: function() {
        var me = this,
        val = me.callParent(arguments);

        if (me.multiSelect && me.encodeSubmitValue && val && val[me.name]) {
            val[me.name] = Ext.encode(val[me.name]);
        }

        return val;
    },

    /**
	 * Overridden to handle creation of new value for unforced selections
	 */
    beforeBlur: function() {
        var me = this;
        me.doQueryTask.cancel();
        me.assertValue();
        me.collapse();
    },

    /**
	 * Overridden to clear the input field if we are auto-setting a value as we blur.
	 */
    mimicBlur: function() {
        var me = this;

        if (me.selectOnTab && me.picker && me.picker.highlightedItem) {
            me.inputEl.dom.value = '';
        }

        me.callParent(arguments);
    },

    /**
	 * Overridden to handle partial-input selections more directly
	 */
    assertValue: function() {
        var me = this,
        rawValue = me.inputEl.dom.value,
        rec = !Ext.isEmpty(rawValue) ? me.findRecordByDisplay(rawValue) : false,
        value = false;

        if (!rec && !me.forceSelection && me.createNewOnBlur && !Ext.isEmpty(rawValue)) {
            value = rawValue;
        } else if (rec) {
            value = rec;
        }

        if (value) {
            me.addValue(value);
        }

        me.inputEl.dom.value = '';

        me.collapse();
    },

    /**
	 * Update the valueStore from the new value and fire change events for UI to respond to
	 */
    checkChange: function() {
        if (!this.suspendCheckChange && !this.isDestroyed) {
            var me = this,
            valueStore = me.valueStore,
            lastValue = me.lastValue,
            valueField = me.valueField,
            newValue = Ext.Array.map(Ext.Array.from(me.value), function(val) {
                if (val.isModel) {
                    return val.get(valueField);
                }
                return val;
            }, this).join(this.delimiter);

            if (!me.isEqual(newValue, lastValue)) {
                valueStore.suspendEvents();
                valueStore.removeAll();
                if (Ext.isArray(me.valueModels)) {
                    valueStore.add(me.valueModels);
                }
                valueStore.resumeEvents();
                valueStore.fireEvent('datachanged', valueStore);

                me.lastValue = newValue;
                me.fireEvent('change', me, newValue, lastValue);
                me.onChange(newValue, lastValue)
            }
        }
    },

    /**
	 * Overridden to use value (selection) instead of raw value and to avoid the use of placeholder
	 */
    applyEmptyText : function() {
        var me = this,
        emptyText = me.emptyText,
        inputEl, isEmpty;

        if (me.rendered && emptyText) {
            isEmpty = Ext.isEmpty(me.value) && !me.hasFocus;
            inputEl = me.inputEl;
            if (isEmpty) {
                inputEl.dom.value = emptyText;
                inputEl.addCls(me.emptyCls);
            } else {
                if (inputEl.dom.value === emptyText) {
                    inputEl.dom.value = '';
                }
                inputEl.removeCls(me.emptyCls);
            }
        }
    },

    /**
	 * Overridden to use inputEl instead of raw value and to avoid the use of placeholder
	 */
    preFocus : function(){
        var me = this,
        inputEl = me.inputEl,
        emptyText = me.emptyText,
        isEmpty;

        if (emptyText && inputEl.dom.value === emptyText) {
            inputEl.dom.value = '';
            isEmpty = true;
            inputEl.removeCls(me.emptyCls);
        }
        if (me.selectOnFocus || isEmpty) {
            inputEl.dom.select();
        }
    },

    /**
	 * Intercept calls to onFocus to add focusCls, because the base field classes assume this should be applied to inputEl
	 */
    onFocus: function() {
        var me = this,
        focusCls = me.focusCls,
        itemList = me.itemList;

        if (focusCls && itemList) {
            itemList.addCls(focusCls);
        }

        me.callParent(arguments);
    },

    /**
	 * Intercept calls to onBlur to remove focusCls, because the base field classes assume this should be applied to inputEl
	 */
    onBlur: function() {
        var me = this,
        focusCls = me.focusCls,
        itemList = me.itemList;

        if (focusCls && itemList) {
            itemList.removeCls(focusCls);
        }

        me.callParent(arguments);
    },

    /**
	 * Intercept calls to renderActiveError to add invalidCls, because the base field classes assume this should be applied to inputEl
	 */
    renderActiveError: function() {
        var me = this,
        invalidCls = me.invalidCls,
        itemList = me.itemList,
        hasError = me.hasActiveError();

        if (invalidCls && itemList) {
            itemList[hasError ? 'addCls' : 'removeCls'](me.invalidCls + '-field');
        }

        me.callParent(arguments);
    },

    /**
	 * Ensure inputEl is sized well for user input using the remaining
     * horizontal space available in the list element
     *
     * Automatically grows the field to accomodate the height of the selections up to the
     * maximum field height allowed.  This only takes effect if <tt>{@link #grow} = true</tt>,
     * and fires the {@link #autosize} event if the height changes.
     */
    autoSize: function() {
        var me = this,
        height;

        if (me.rendered) {
            me.doComponentLayout();
            if (me.grow) {
                height = me.getHeight();
                if (height !== me.lastInputHeight) {
                    me.alignPicker();
                    me.fireEvent('autosize', height);
                    me.lastInputHeight = height;
                }
            }
        }

        return me;
    }

}, function() {
    /**
     * ExtJS 4.0.5 introduced more optimized ways of referencing child elements. As this is
     * currently a subscriber only release, these registrations are performed here for
     * backwards compatibility with the currently available public version 4.0.2a
     */

    var useNewSelectors = !Ext.getVersion('extjs').isLessThan('4.0.5'),
    overrides = {};

    if (useNewSelectors) {
        Ext.apply(overrides, {
            fieldSubTpl: [
            '<div class="x-boxselect">',
            '<ul id="{cmpId}-itemList" class="x-boxselect-list {fieldCls} {typeCls}">',
            '<li id="{cmpId}-inputElCt" class="x-boxselect-input">',
            '<input id="{cmpId}-inputEl" type="{type}" ',
            '<tpl if="name">name="{name}" </tpl>',
            '<tpl if="size">size="{size}" </tpl>',
            '<tpl if="tabIdx">tabIndex="{tabIdx}" </tpl>',
            'class="x-boxselect-input-field" autocomplete="off" />',
            '</li>',
            '</ul>',
            // CHANGE START:
            // fix for the libraries broken code that causes double ids
            '<div id="{cmpId}-triggerWrap-ux-boxselect" class="{triggerWrapCls}" role="presentation">',
            // END CHANGE
            '{triggerEl}',
            '<div class="{clearCls}" role="presentation"></div>',
            '</div>',
            '<div class="{clearCls}" role="presentation"></div>',
            '</div>',
            {
                compiled: true,
                disableFormats: true
            }
            ],
            childEls: ['itemList', 'inputEl', 'inputElCt']
        });
    } else {
        Ext.apply(overrides, {
            fieldSubTpl: [
            '<div class="x-boxselect">',
            '<ul class="x-boxselect-list {fieldCls} {typeCls}">',
            '<li class="x-boxselect-input">',
            '<input id="{id}" type="{type}" ',
            '<tpl if="name">name="{name}" </tpl>',
            '<tpl if="size">size="{size}" </tpl>',
            '<tpl if="tabIdx">tabIndex="{tabIdx}" </tpl>',
            'class="x-boxselect-input-field" autocomplete="off" />',
            '</li>',
            '</ul>',
            '<div class="{triggerWrapCls}" role="presentation">',
            '{triggerEl}',
            '<div class="{clearCls}" role="presentation"></div>',
            '</div>',
            '</div>',
            {
                compiled: true,
                disableFormats: true
            }
            ],
            renderSelectors: {
                itemList: 'ul.x-boxselect-list',
                inputEl: 'input.x-boxselect-input-field',
                inputElCt: 'li.x-boxselect-input'
            }
        });
    }

    Ext.override(this, overrides);
});

/**
 * This is an amalgamation of the TextArea field layout and the Trigger field layout,
 * with overrides to manage the layout of the field on the itemList wrap instead
 * of the inputEl and to grow based on inputEl wrap positioning instead of
 * raw text value.
 */
Ext.define('Ext.ux.layout.component.field.BoxSelectField', {

    /* Begin Definitions */

    alias: ['layout.boxselectfield'],

    extend: 'Ext.layout.component.field.Field',

    /* End Definitions */

    type: 'boxselectfield',

    /**
	 * Overridden to use an encoded value instead of raw value
	 */
    beforeLayout: function(width, height) {
        var me = this,
        owner = me.owner,
        lastValue = this.lastValue,
        value = Ext.encode(owner.value);
        this.lastValue = value;
        return me.callParent(arguments) || (owner.grow && value !== lastValue);
    },

    /**
     * Overridden to use itemList instead of inputEl, and to merge trigger field
     * sizing with text field growability.
     */
    sizeBodyContents: function(width, height) {
        var me = this,
        owner = me.owner,
        triggerWrap = owner.triggerWrap,
        triggerWidth = owner.getTriggerWidth(),
        itemList, inputEl, inputElCt, lastEntry,
        listBox, listWidth, inputWidth;

        // If we or our ancestor is hidden, we can get a triggerWidth calculation
        // of 0.  We don't want to resize in this case.
        if (owner.hideTrigger || owner.readOnly || triggerWidth > 0) {
            itemList = owner.itemList;

            // Decrease the field's width by the width of the triggers. Both the field and the triggerWrap
            // are floated left in CSS so they'll stack up side by side.
            me.setElementSize(itemList, Ext.isNumber(width) ? width - triggerWidth : width, height);

            // Explicitly set the triggerWrap's width, to prevent wrapping
            triggerWrap.setWidth(triggerWidth);

            // Size the input el to take up the maximum amount of remaining list width,
            // or the entirety of list width to cause wrapping if too little space remains.
            inputEl = owner.inputEl;
            inputElCt = owner.inputElCt;
            listBox = itemList.getBox(true, true);
            listWidth = listBox.width;

            if ((owner.grow && owner.growMax && (itemList.dom.scrollHeight > (owner.growMax - 25))) ||
                (owner.isFixedHeight() && (itemList.dom.scrollHeight > itemList.dom.clientHeight))) {
                listWidth = listWidth - Ext.getScrollbarSize().width;
            }
            inputWidth = listWidth - 10;
            lastEntry = inputElCt.dom.previousSibling;
            if (lastEntry) {
                inputWidth = inputWidth - (lastEntry.offsetLeft + Ext.fly(lastEntry).getWidth() + Ext.fly(lastEntry).getPadding('lr'));
            }
            if (inputWidth < 35) {
                inputWidth = listWidth - 10;
            }

            if (inputWidth >= 0) {
                me.setElementSize(inputEl, inputWidth);
                if (owner.hasFocus) {
                    inputElCt.scrollIntoView(itemList);
                }
            }
        }
    }

});
/* xcp_event_lib/content/xcp/event/EventBus.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.event.EventBus", {
    singleton: true,

    /**
     * Publish a message to a channel in the event bus
     * @param channel   name of the channel
     * @param message   message/data to go with the event
     */
    publish: function(channel, message) {
        OpenAjax.hub.publish(channel, message);
    },

    /**
     * Subscribe to a channel in the event bus
     * @param channel   name of the channel
     * @param callback  function to call back when a message is published
     * @param scope     scope to invoke the callback
     * @param subData   subsriber's data
     */
    subscribe: function(channel, callback, scope, subData) {
        return OpenAjax.hub.subscribe(channel, callback, scope, subData);
    },

    /**
     * Unsubscribe to a channel in the event bus
     * @param subscription  subscription
     */
    unsubscribe: function(sub) {
        OpenAjax.hub.unsubscribe(sub);
    }
});
/* xcp_event_lib/content/xcp/event/Publisher.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.event.Publisher", {
    requires: ['xcp.event.EventBus'],

    /**
     * Initilize the mixin for an object or a class
     * @param config    config
     */
    initMixin: function(config) {
        config = config || this.initialConfig;

        var xcpeventpub = (config && config.xcpeventpub) || this.xcpeventpub;
        if (!xcpeventpub) {
            xcpeventpub = [];
        }
        var xcpeventconfig = (config && config.xcpeventconfig) || this.xcpeventconfig;
        var widgetInstanceId = (config && config.xcpId) || "";
        var baseChannelName = widgetInstanceId + ".";
        if (xcpeventconfig) {
            for (var i = 0; i < xcpeventconfig.length; i++) {
                var cfg = xcpeventconfig[i];
                var event = cfg.event;
                var targetEvent = cfg.targetEvent;
                if (!targetEvent) {
                    targetEvent = event;
                }
                //Check if channel name is available for this event;
                var found=false;
                for(var j=0; j<xcpeventpub.length; j++) {
                    if (xcpeventpub[j]['event'] && xcpeventpub[j]['event'] == targetEvent) {
                        found=true;
                        break;
                    }
                }
                if (!found) {
                    var channelName = baseChannelName + targetEvent;
                    var pubEvent = {
                        event:targetEvent,
                        channel:channelName
                    };
                    xcpeventpub.push(pubEvent);
                }
                this.xcpeventpub = xcpeventpub;
                this.relayXcpEvent(cfg.origin, event, targetEvent, cfg.data);
            }
        }
    },

    /**
     * Publish a message to the channel in the event bus
     * @param event         event that triggers the message
     * @param data          data or message to publish
     * @param useconfig     flag to indicate whether it should publish to a channel or the event bus.
     *                      True to publish to a channel. False, otherwise.
     */
    publishXcpEvent: function(event, data, useconfig) {
        if (!useconfig) {
             xcp.event.EventBus.publish(event, data);
        }

        else if (this.xcpeventpub) {
            var published = {};
            if (!this.baseChannelName) {
                var containerXType = "xcp_page";
                var container;
                if (this.getXType && this.getXType() == containerXType) {
                    container = this;
                } else {
                    if (Ext.isFunction(this.getPage) && this.getPage()) {
                        container = this.getPage();
                    } else {
                        container = this.up(containerXType);
                    }
                }
                if (container) {
                    this.baseChannelName = container.id + ".";
                } else {
                    this.baseChannelName = "";
                }
            }
            for(var i=0; i<this.xcpeventpub.length; i++) {
                var e = this.xcpeventpub[i];
                if (e.event == event && e.channel && !published[e.channel]) {
                    var channelName = this.baseChannelName + e.channel;
                    xcp.event.EventBus.publish(channelName, data);
                    published[e.channel] = true;
                }
            }
        }
    },

    /**
     * Relay the internal ExtJS event to the corresponding external event
     * @param origin        ExtJS component that generates the event
     * @param oevent        name of event generated by ExtJS component
     * @param tevent        name of event generated the widget
     * @param data          data to be published
     */
    relayXcpEvent: function(origin, oevent, tevent, data) {
        origin = origin || this;
        var handler = function() {
            var d = data;
            if (Ext.isFunction(d)) {
                d = d.apply(this, Ext.Array.toArray(arguments));
            }
            this.publishXcpEvent(tevent, d, true);
        }
        origin.on(oevent, handler, this);
    }

});

/* xcp_event_lib/content/xcp/event/Subscriber.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.event.Subscriber", {
    requires: ['xcp.event.EventBus'],


    /**
     * Initilize the mixin for an object or a class
     * @param config    config
     */
    initMixin : function(config) {
        config = config || this.initialConfig;
        this.xcpEventSubs = new Ext.util.HashMap();
        // register the bindings
        var xcpeventsub = config && config.xcpeventsub || this.xcpeventsub;
        if (xcpeventsub) {
            for (var i = 0; i < xcpeventsub.length; i++) {
                this.subscribeXcpEvent(xcpeventsub[i]);
            }
        }
        // cleanup
        if (this.isObservable && this.events && this.events["destroy"]) {
            this.on("destroy", function() {
                var count = this.xcpEventSubs.getCount();
                if (count > 0) {
                    var keys = this.xcpEventSubs.getKeys();
                    for (var i=0; i < count; i++) {
                        var key = keys[i];
                        this.unsubscribeXcpEvent(key);
                    }
                }

            }, this);
        }
    },

    /**
     * Subscribe to a channel in the event bus
     * @param e     config containing the channel and handler
     */
    subscribeXcpEvent : function(e) {
        var subKey = e.channel;
        var sub = xcp.event.EventBus.subscribe(subKey, this[e.handler], this);
        this.xcpEventSubs.add(subKey, sub);
    },

    /**
     * Unsubscribe to a channel
     * @param e     config containing the channel
     */
    unsubscribeXcpEvent : function(e) {
        if (e) {
            var subKey = Ext.isString(e) ? e : e.channel;

            var sub = this.xcpEventSubs.get(subKey);
            if (sub !== undefined) {
                this.xcpEventSubs.removeAtKey(subKey);
                xcp.event.EventBus.unsubscribe(sub);
            }
        }
    }
});

/* xcp_event_lib/content/xcp/event/EventManager.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.event.EventManager
 *
 * This class is responsible for initializing the event bus framework.
 */
Ext.define("xcp.event.EventManager", {
    singleton: true,
    requires: ['xcp.event.Publisher', 'xcp.event.EventBus'],

    /**
     * Initialize the event mechanism in the system
     * This function adds publisher and subscriber functionality to Component and Store base class.
     * This allows instances of Component or Store to publish or subscribe to the event bus. 
     */
    init: function() {
        // Add pub/sub functionality to Component as mixins
        //move this logic into ExtjsPatch.js XCPUIC-1331
//        Ext.Component.mixin('xcppublisher', xcp.event.Publisher);
//        Ext.Component.mixin('xcpsubscriber', xcp.event.Subscriber);
//        Ext.override(Ext.Component, {
//            constructor: function() {
//                this.callOverridden(arguments);
//                this.mixins.xcppublisher.initMixin.call(this);
//                this.mixins.xcpsubscriber.initMixin.call(this);
//            }
//        });

        // Add pub/sub functionality to Store as mixins 
        Ext.data.Store.mixin('xcppublisher', xcp.event.Publisher);
        Ext.data.Store.mixin('xcpsubscriber', xcp.event.Subscriber);
        Ext.override(Ext.data.Store, {
            constructor: function() {
                this.callOverridden(arguments);
                this.mixins.xcppublisher.initMixin.call(this);
                this.mixins.xcpsubscriber.initMixin.call(this);
            }
        });
    }
});
/* xcp_event_lib/content/xcp/event/ApplicationEvent.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.event.ApplicationEvent
 *
 * This is an abstract base class for application event data.  It should be subclassed before use.
 * All subclasses must define an applicationEventType
 */
Ext.define("xcp.event.ApplicationEvent", {
    statics: {
        registerEventType: function(name, eventClass){
            this._eventTypes.add(name, eventClass);
        },

        // Utility method to enumerate registered application event types.
        getEventTypes: function() {
            return this._eventTypes.getKeys();
        },

        _eventTypes: new Ext.util.HashMap()
    },
    constructor: function() {
        var cls = Ext.ClassManager.getClass(this);
        if (typeof(cls.prototype.applicationEventType) == 'undefined') {
            Ext.Error.raise('Unregistered application event type: ' + Ext.ClassManager.getName(cls) +
            '.  applicationEventType must be defined on all xcp.event.ApplicationEvent subtypes.')
        }
    }
});

// This class manager post processor watches for class definitions that inherit from
// ApplicationEvent, and registers the event type in a static application event registry.
Ext.ClassManager.registerPostprocessor("applicationEventType", function(name, cls, data){
    xcp.event.ApplicationEvent.registerEventType(data.applicationEventType, cls);
});
Ext.ClassManager.setDefaultPostprocessorPosition("applicationEventType", "last");  // $NON-NLS-L$ 

Ext.define('xcp.event.ContainerChangedEvent', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.container.changed',
    documentId: '',
    statics:{
        CONTAINER_CHANGED_EVENT: 'xcpApp.container.changed',
        NAME: "xcpApp.container.changed"
    }
});

Ext.define('xcp.event.ItemLockedEvent', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.item.locked',
    documentId: '',
    statics:{
        ITEM_LOCKED_EVENT: 'xcpApp.item.locked',
        NAME: 'xcpApp.item.locked'
    }
});

Ext.define('xcp.event.ItemUnlockedEvent', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.item.unlocked',
    documentId: '',
    statics:{
        ITEM_UNLOCKED_EVENT: 'xcpApp.item.unlocked',
        NAME: 'xcpApp.item.unlocked'
    }
});

Ext.define('xcp.event.ItemDeleted', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.item.ItemDeleted',
    statics:{
        ITEM_CONTAINER_CHANGED: 'xcpApp.item.deleted',
        NAME: 'xcpApp.item.deleted'
    }
});

Ext.define('xcp.event.ItemModified', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.item.ItemModified',
    statics:{
        NAME: 'xcpApp.item.modified'
    }
});

Ext.define('xcp.event.SelectorEvent',{
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.selector.selectionDone',
    statics:{
        NAME: 'xcpApp.selector.selectionDone'
    }
});
Ext.define('xcp.event.PageModEvent',{
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.viewer.docModified',
    statics:{
        NAME: 'xcpApp.viewer.docModified'
    }
});

Ext.namespace("xcp.Strings.widget.Viewer");

Ext.apply(xcp.Strings.widget.Viewer, {
    vwrTitle:                 "Viewer",
    loadDocMask:              "Loading document...",
	insertPages:		      "Insert Pages",
	removePages:       	      "Remove Pages",
	reorderPages:             "Reorder Pages",
    movePages:		          "Move Pages",
    extractPages:             "Extract Pages",
    removeKBShortcut:         "Del",
    selectForMoveCtxMenu:     "Select for moving",
    moveBeforeCtxMenu:        "Move before",
    moveAfterCtxMenu:         "Move after",
    moveCancelCtxMenu:        "Clear selection",

    delWinTitle:              "Delete Pages",
    delWinTextFieldLabel:     "Pages to delete",
    delLoadingMask:           "Deleting pages...",
    delConstraintBlank:       "Please specify pages to delete",
    delSuccessMsg:            "Pages deleted",

    extWinTitle:              "Extract Pages",
    extExtractFromLabel:      "Extract from",
    extExtractPagesLabel:     "Extract pages",
    extDelPagesChkBoxLabel:   "Delete extracted pages from current document",
    extFieldSetText:          "The current document will be saved without the extracted pages",
    extNewDocNameLabel:       "Name for new document",
    extConstraintBlank:       "Please specify pages to extract",
    extLoadingMask:           "Extracting pages...",
    extSuccessMsg:            "{0} created",
    extWizardStep1:           "Step 1 of 2",
    extWizardStep2:           "Step 2 of 2",
    extWizardBackButton:      "{0} Back",
    extWizardNextButton:      "Next {0}",
    extWizardFinishButton:    "Finish",
    extWizardCancelButton:    "Cancel",


    reordWinDisplayFieldLabel:"The new page order will be applied upon clicking OK",
    reordLoadingMask:         "Reordering pages...",
    reordSuccessMsg:          "Pages reordered",

    insInsertFromLabel:       "Insert from",
    insInsertPagesLabel:      "Insert pages",
    insBeforeFirstLabel:      "Before first page",
    insAfterPageLabel:        "After page",
    insOfLabel:               "of",
    insFieldSetText:          "The current document will be saved with the new pages",
    insLoadingMask:           "Inserting pages...",
    insSuccessMsg:            "Pages from {0} inserted",

    thumbnailMask:            "Loading thumbnails...",
    winCommentLabel:          "Notes on the new version",
    okButton:                 "OK",
    cancelButton:             "Cancel",
    applyButton:              "Apply",
    txtConstraintInvalidChar: "Please remove invalid characters",
    txtConstraintOverlap:     "Please specify page ranges that do not overlap",
    txtConstraintAllPages:    "Deleting all pages from a document is not permitted",
    txtConstraintInvalidPgNum:"Please specify valid page number",
    thmAltText:               "Cannot display",
    dragText:                 "{0} Page{1} selected",
    exampleText:              "For example {0}",
    versionInformationLabel:  "Version Information",
    currentVersionLabel:      "Current Version",
    newVersionLabel:          "New Version",
    minorVersion:             "{0} (minor change)",
    majorVersion:             "{0} (major change)",
    currentVersion:           "{0} (overwrite current version)",

    viewerNotRendered:        "Viewer panel not rendered correctly",
    blankDoc:                 "No document to display",
    delErr:                   "Deleting pages failed. Please check the logs for the stack trace",
    reordErr:                 "Reordering pages failed. Please check the logs for the stack trace",
    insErr:                   "Inserting pages failed. Please check the logs for the stack trace",
    extErr:                   "Extracting pages failed. Please check the logs for the stack trace",
    pageDeletionServiceUrl:   "Page deletion service URL not specified",
    pageReorderServiceUrl:    "Page reorder service URL not specified",
    pageInsertionServiceUrl:  "Page insertion service URL not specified",
    pageExtractionServiceUrl: "Page extraction service URL not specified",
    loadDocErr:               "Failed to load document. Please check the logs for the stack trace",
    unsupportedFormat:        "There is no viewer associated with this file format: '{0}'",
    errorStr1:                "HTML tag '{0}' is not supported or not installed on this machine.Please click the link for the {1} Document {2}",
    errorStr2:                "HTML tag '{0}' is not supported or not installed on this machine."

});
/* xcp_viewer/content/xcp/widget/Viewer.js */

// xcp_viewer.js
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.Viewer
 * @extends Ext.Panel
 * @param {Object} config Configuration options.
 * @xtype xcp_viewer
 */
Ext.define("xcp.widget.Viewer", {
    extend: "Ext.Panel",
    alias: 'widget.xcp_viewer',
    layout: 'border',
    statics: {
        VWR_PANEL_ID: "_viewerPanel",
        VCONTROL: "_vcontrol",
        COMP_PANEL_ID: "_compositePanel",
        DESIGNTIME_THM_MDC_WIDTH:160,
        DESIGNTIME_THM_WIDTH:120
    },

    constructor: function(config) {
        // XCPIVF-86 - IFrame shims are required when opening modal windows on top of applets or activeX
        Ext.useShims = true;
        var me = this;
        config = config || {};
        if(config.width){
            delete config.width;
        }
        me.runtime = Ext.isDefined(xcp.navigationManager);
        (me.runtime) ? me.runTimeWidget(config) : me.designTimeWidget(config);
        me.config = config;
        me.isDocumentLoaded=false;
        xcp.widget.Viewer.superclass.constructor.apply(this, [config]);
    },

    initComponent: function() {
        var me = this;
        var previousViewer;
        xcp.widget.Viewer.superclass.initComponent.call(me);
        if (me.runtime) {
            me.mask = new Ext.LoadMask(me, {msg: xcp.Strings.widget.Viewer.loadDocMask});
            me.on("afterrender", me.initViewer, me);
            me.on("destroy", function () {
                if (xcp.event && this.config.mdc) {
                    var widgetId = this.widgetId;
                    previousViewer = ivfclient.getViewer(widgetId);
                    if (previousViewer) {
                        previousViewer.cleanup();
                    }
                    var e = xcp.event.EventBus;
                    e.unsubscribe(widgetId + '.enableAll');
                    e.unsubscribe(widgetId + '.disableAll');
                    e.unsubscribe(widgetId + '.reorderPages');
                    e.unsubscribe(widgetId + '.singlePage');
                }
            }, me);
        }
    },

    // Runtime impl of viewer widget
    runTimeWidget:function(config) {
        var me = this;
        me.widgetId = me.getId().replace("-", "_");
        var wid = me.widgetId;

        me.vwrTitle = config.title;
        config.title = xcp.Strings.widget.Viewer.vwrTitle;
        //viewer panel
        var viewerPanel = new Ext.Panel({
            region: 'center',
            id: wid + xcp.widget.Viewer.VWR_PANEL_ID,
            cls:'vwrPanel',
            listeners:{
                resize:function(window, adjWidth, adjHeight, opts) {
                    if (me.provider && me.provider == 'AXViewer') {
                        var toolbar;
                        if (toolbar = Ext.getCmp(wid + xcp.viewer.impl.AXViewer.AXToolbar))
                            toolbar.setWidth(adjWidth);
                    }
                }
            }
        });

        var viewerItems = [viewerPanel];

        var actions = {};
        if (config.mdc) {
            actions = me.createActions();
        }

        var compositeItems = [];
        if (config.mdc && !Ext.is.iOS) {
            var pgModPanel = new xcp.cmp.PageMod({wid: wid, actions:actions});
            compositeItems.push(pgModPanel);
        }

        //Thumbnail Panel
        if (config.thm) {
            var thmPanel = new xcp.cmp.Thumbnail({wid: wid, contentType:config.contentType, actions: actions});
            compositeItems.push(thmPanel);
        }

        if (config.thm) {
            //composite panel
            var compositePanel = new Ext.Panel({
                id:wid + xcp.widget.Viewer.COMP_PANEL_ID,
                region: 'west',
                collapsible:true,
                layout: 'border',
                cls:'compPanel',
                collapsedCls:'compPanelCollapsed',
                items: compositeItems,
                listeners:{
                    beforecollapse:function(p, direction, animate, eOpts) {
                        if (Ext.getCmp(wid + xcp.cmp.Thumbnail.REORD_MODE_ID).isVisible())
                            p.setTitle(xcp.Strings.widget.Viewer.reorderPages);                                           //div not getting rendered.Hence setting the title with value
                        return true;
                    },
                    //XCP default viewer listens to collapse/expand events to resize appropriately
                    collapse:function(p, direction, animate, eOpts) {
                        if (xcp.event)
                            xcp.event.EventBus.publish(wid + '.thm.collapse', null);
                        return true;
                    },
                    expand:function(p, eopts) {
                        if (Ext.getCmp(wid + xcp.cmp.Thumbnail.REORD_MODE_ID).isVisible())
                            p.setTitle("<span style='width:150px;text-align:left;left:55px;position:relative;'>" + xcp.Strings.widget.Viewer.reorderPages + "</span>");     //Align Reorder Pages title at the top thumbnail panel
                        if(xcp.event)
                            xcp.event.EventBus.publish(wid + '.thm.expand', null);
                    },
                    afterrender: function(panel){
                         panel.header.setHeight(36);
                    }
                }
            });

            if (!config.mdc)
                compositePanel.setWidth(150);
            else
                compositePanel.setWidth(200);

            viewerItems.push(compositePanel);
        }

        if (!config.width) {
            delete config.width;
        }
        else {
            var width = config.width;
            if (width != "auto" && typeof width === "string" && width.indexOf("%") < 0 && width.length != 0) {
                config.width = parseInt(width, 10);
            }
        }
        var height;
        if (!(height = config.height))
            height = config.height = 650;
        if (typeof height === "string" && height.indexOf("%") < 0 && height.length != 0) {
            config.height = parseInt(height, 10);
        }
        Ext.apply(config, {
            width: config.width,
            height: config.height,
            padding:3,
            id: wid,
            items:[viewerPanel]});

        if(compositePanel)
            config.items[1] = compositePanel;
    },

    // Viewer initialization after render
    initViewer:function(config) {
        var me = this;
        var wid = me.widgetId;
        if(config.thm)
            Ext.getCmp(wid + xcp.widget.Viewer.COMP_PANEL_ID).setVisible(false);

        xcp.util.IvfUtil.debug("Rendering Viewer widget");
        me.loadDocument();
    },

    // Set through expression
    setObjectId : function(value, prop) {
        if (value && value.length != 0 && !Ext.isArray(value))  {
            this.objectIdModified = true;
            this.config.objectId = value;
            if (this.contentTypeModified) {
                this.loadDocumentFromExpression();
            }
        }

    },

    // Set through expression
    setContentType :function(value, prop) {
        var me = this;
        if (value && value.length != 0 && !Ext.isArray(value))  {
            me.config.contentType = value;
            me.contentTypeModified = true;
            if (me.objectIdModified) {
                this.loadDocumentFromExpression();
            }
        }
    },

    loadDocumentFromExpression: function() {
        if(this.isDocumentLoaded) {
            var viewer = ivfclient.getViewer(this.widgetId);
            if(viewer && viewer.isAnnotationModified())
                viewer.saveAnnotation(this);
            else
                this.loadDocumentCallback();
        } else
            this.loadDocumentCallback();
    },

    loadDocumentCallback: function() {
        this.loadDocument();
        this.contentTypeModified = false;
        this.objectIdModified = false;
    },

    // Fires init service call from widget and loads document in viewer
    loadDocument:function() {
        var me = this,
            config = me.config,
            contentType = config.contentType,
            objId = config.objectId,
            annoEnabled = config.ann,
            editAnno = config.man,
            enablePrint = config.prn,
            dispThumbnail = config.thm,
            modifyContent = config.mdc,
            wid = me.widgetId;
        if(this.isDestroyed){
            return;
        }
        me.allowPageMod = false;
        var viewerPanel = Ext.getCmp(wid + xcp.widget.Viewer.VWR_PANEL_ID);
        //todo: need to deal with local file display where objectID is {null} or empty
        if (contentType == null || objId == null) {
            viewerPanel.update("<table height='100%' width='100%'><tr><td valign='center' align='center'>"+xcp.Strings.widget.Viewer.blankDoc+"</td></tr></table>");
            return;
        }
        if (me.getEl().down('.x-panel-body').mask)                                 //Remove error mask if any before loading current document
            me.getEl().down('.x-panel-body').unmask();

        if (viewerPanel.html && viewerPanel.html.indexOf(xcp.Strings.widget.Viewer.blankDoc) > 0)          //clearing 'No document to display' msg before loading document
            viewerPanel.update("");
        me.getEl().mask('<img src="component/xcp-ivf-widgets/icons/loading_66.gif">');
        var networkLocationId = "";
        if (xcp.UserPreferences)
            networkLocationId = xcp.UserPreferences.get('networkLocation');
        var appPath = xcp.util.IvfUtil.getAppPath(),
            viewerUrl = appPath + "/ivf/initialization?objectId=" + objId + "&ann=" + annoEnabled + "&man=" + editAnno + "&prn=" + enablePrint + "&contentType=" + contentType + "&thm=" + dispThumbnail + "&mdc=" + modifyContent;
        xcp.util.IvfUtil.debug("Initializing viewer");
        Ext.Ajax.request({
            url: viewerUrl,
            timeout : 60000,
            method:"GET",
            params:{
                location:networkLocationId
            },
            scope:this,
            success: function(response, opts) {
                if(me.isDestroyed){
                    return;
                }
                var json = Ext.decode(response.responseText), viewer, previousViewer, isSameProvider = false, reRender = true;

                if (me.provider == json.provider) {
                    isSameProvider = true;
                    viewer = ivfclient.getViewer(wid);
                    viewer.init(json);
                }

                me.config.objectName = json.objectName;
                var title = me.vwrTitle;
                if (title && title.indexOf('<') == 0 && title.indexOf('>') == title.length - 1)       //document_name
                    me.setTitle(me.config.objectName);
                else
                    me.setTitle(title);

                me.allowPageMod = json.allowPageModify;
                me.versionLabel = json.versionLabel;

                if (isSameProvider && viewer.updateDocument(json)) {
                    reRender = false;
                    xcp.util.IvfUtil.debug("Reusing " + json.provider + " viewer for " + json.objectName);
                }
                else {
                    previousViewer = ivfclient.getViewer(wid);
                    if (previousViewer) {
                        previousViewer.cleanup();
                    }
                    viewer = ivfclient.createViewer(wid + xcp.widget.Viewer.VCONTROL, json.provider, json);
                    ivfclient.addViewer(wid, viewer);
                    xcp.util.IvfUtil.debug("Loading document " + json.objectName + " in " + json.provider + " viewer");

                    viewer.enableAnnotation(annoEnabled);
                    var html = viewer.preRender(json);
                    html += viewer.renderControl(json.providerType, json.attributeList, json.parameterList);
                    html += viewer.postRender(json);
                }

                if (!json.allowThumbnail) {                                                                         //hide thumbnail and pagemodification toolbar for viewer which doesn't support interaction
                    if (config.thm)
                        Ext.getCmp(wid + xcp.widget.Viewer.COMP_PANEL_ID).setVisible(false);
                    xcp.util.IvfUtil.debug("Viewer does not support thumbnails.Page modification and Thumbnail panels will be hidden");
                }
                else {
                    if (config.thm) {
                        var thmCmp = Ext.getCmp(wid + xcp.cmp.Thumbnail.THM_PANEL_ID);
                        Ext.getCmp(wid + xcp.cmp.Thumbnail.REORD_MODE_ID).setVisible(false);
                        Ext.getCmp(wid + xcp.widget.Viewer.COMP_PANEL_ID).setVisible(true);
                        thmCmp.supportUrlFallback = json.supportUrlFallback;
                        thmCmp.store.removeAll();
                    }
                    else
                        xcp.event.EventBus.publish(wid + '.disableAll', null);
                }
                if (me.mask)
                    me.unmask();

                me.isDocumentLoaded=true

                /* Tear down and render viewer again if the provider is not same or if the viewer
                 does not implement updateDocument method */
                if (viewerPanel && reRender) {
                    viewerPanel.update(html);
                    me.provider = json.provider;
                    me.isDocumentLoaded=true;
                }
                else if (!viewerPanel)   {
                    me.displayErrorMsg(xcp.Strings.widget.Viewer.viewerNotRendered, response);
                    me.isDocumentLoaded=false;
                }
            },
            failure: function(response, options) {
                if(me.isDestroyed){
                    return;
                }
                if (viewerPanel)
                    viewerPanel.update('');
                var errorMessage, errorCode;
                if(response && response.responseText){
                    errorMessage = Ext.decode(response.responseText);
                    errorCode = errorMessage.code;
                }
                me.provider = 'none';
                if (me.mask){
                    me.unmask();
                }
                var maskMessage = xcp.Strings.widget.Viewer.loadDocErr;
                if(errorCode == "IVF_UNSUPPORTED_FORMAT"){
                    maskMessage = Ext.String.format(xcp.Strings.widget.Viewer.unsupportedFormat,contentType);
                }
                this.getEl().down('.x-panel-body').mask(maskMessage, 'xcp-mask-error');
                me.isDocumentLoaded=false;
            }
        });
    },

    //Loads thumbnail panel with thumbnail images
    loadThumbnails:function(pageCount,isFullyRendered) {
        var me = this;
        var wid = me.widgetId;
        var topBar = Ext.getCmp(wid + xcp.cmp.Thumbnail.REORD_MODE_ID);
        //Enable all pg mod actions
        if (xcp.event && !topBar.isVisible())
            xcp.event.EventBus.publish(wid + '.enableAll', null);

        var networkLocationId = "";
        if (xcp && xcp.UserPreferences)
            networkLocationId = xcp.UserPreferences.get('networkLocation');

        xcp.util.IvfUtil.debug("Loading thumbnails with pageCount " + pageCount);

        if (me.config.thm) {
            var thmCmp = Ext.getCmp(wid + xcp.cmp.Thumbnail.THM_PANEL_ID);
            if (topBar.isVisible()) {
                thmCmp.reordered = false;
                thmCmp.actions.reorder.disableApplyBtn(true);
            }
            thmCmp.store.proxy.extraParams.objectId = me.config.objectId;
            //A hint for the server side to use pagemodification mock data if available.
            thmCmp.store.proxy.extraParams.isfullyRenderedDoc = isFullyRendered;
            //Network location preference for thumbnail rendition
            thmCmp.store.proxy.extraParams.location = networkLocationId;
            //We are refreshing viewer after a page mod op if total is already defined
            thmCmp.confirmViewSize();
            if (thmCmp.store.proxy.extraParams.total) {
                if (!thmCmp.cancelReorder) {
                    thmCmp.store.reordCache.removeAll();                     //after page mod op cache and prefetchData id are cleared
                    thmCmp.store.pageMap.clear();
                }
                thmCmp.store.proxy.extraParams.total = pageCount;
                thmCmp.store.load();
            }
            else {
                thmCmp.store.proxy.extraParams.total = pageCount;
                thmCmp.store.pageSize = xcp.thm.Store.PAGE_SIZE;
                var actualPageSize = pageCount < thmCmp.store.pageSize ? pageCount : thmCmp.store.pageSize;
                thmCmp.store.guaranteeRange(0, actualPageSize - 1);
            }
        }
        if (!me.allowPageMod) {
            xcp.event.EventBus.publish(wid + '.disableAll', null);
            var ddPlugin = thmCmp.view.plugins[0];
            if (ddPlugin.ptype == 'gridviewdragdrop') {
                ddPlugin.dragZone.lock();
            }
            xcp.util.IvfUtil.debug("Document cannot be modified.Page modification will be disabled");
        } else {
            if (pageCount === 1) {   // Disable Remove Pages if doc has only 1 page
                if (xcp.event)
                    xcp.event.EventBus.publish(wid + '.singlePage', null);
                xcp.util.IvfUtil.debug("Single page document.Remove and Reorder pages will be disabled");
            }
        }
    },

    // Instantiates page modification actions
    createActions: function() {
        var wid = this.widgetId;
        var extractAction = new xcp.action.page.ExtractAction({widgetId:wid}),
            insertAction = new xcp.action.page.InsertAction({widgetId:wid}),
            removeAction = new xcp.action.page.RemoveAction({widgetId:wid}),
            reorderAction = new xcp.action.page.ReorderAction({widgetId:wid});
        return {extract:extractAction, insert: insertAction, remove: removeAction, reorder: reorderAction};
    },

    displayErrorMsg: function(msg, response) {
        xcp.Logger.error(response.responseText);
        if (xcp.core.FeedbackManager)
            xcp.core.FeedbackManager.showFeedback(null, "", msg, "systemErrors", false);
    },

    // Designtime impl of viewer widget
    designTimeWidget:function(config) {
        var thmImage = "f_unknown_64.gif";
        var storeCfg = new Ext.data.Store({
            fields:['pgno','img'],
            proxy: {
                type:'memory',
                reader : {
                    type:'json',
                    root:'pages'
                }
            }
        });

        pages = [];
        for (i = 1; i < 5; i++)
            pages.push({'pgno': i, 'img': i+":"+thmImage});
        storeCfg.loadData(pages);

        var btnCfg = {xtype:'button',scale:'large',cls:'x-btn-icon',iconAlign:'top'},
            insertBtn = new Ext.Button(Ext.apply(btnCfg, {icon:"'" + xcp.designer.iconsDir + "/viewer_addpages_24_tool.png'"})),
            removeBtn = new Ext.Button(Ext.apply(btnCfg, {icon:"'" + xcp.designer.iconsDir + "/viewer_deletepages_24_tool.png'"})),
            moveBtn = new Ext.Button(Ext.apply(btnCfg, {icon:"'" + xcp.designer.iconsDir + "/viewer_movepages_24_tool.png'"})),
            extractBtn = new Ext.Button(Ext.apply(btnCfg, {icon:"'" + xcp.designer.iconsDir + "/viewer_extractpages_24_tool.png'"}));

        var hideThm = (!config.thm),
            hidePgMod = (!config.mdc),
            thmWidth = xcp.widget.Viewer.DESIGNTIME_THM_MDC_WIDTH;
        if (hidePgMod)
            thmWidth = xcp.widget.Viewer.DESIGNTIME_THM_WIDTH;
        Ext.apply(config, {
            //width:"auto",
            height:280,
            items: [
                {
                    xtype:'grid',
                    id:config.id+'_thmPanel',
                    cls:'xcp_viewer_thmPanel',
                    hidden:hideThm,
                    region:'west',
                    layout:'fit',
                    width:thmWidth,
                    collapsible:true,
                    listeners:{
                        beforecollapse:function(p, dir, animate, opts) {
                            return false;
                        }
                    },
                    store:storeCfg,
                    bodyStyle:'background:#D7D7D7',
                    viewConfig:{
                        stripeRows:false
                    },
                    hideHeaders:true,
                    scroll:'vertical',
                    columns: [
                        {
                            dataIndex: 'pgno',
                            width:0,
                            hidden:true
                        },
                        {
                            dataIndex: 'img',
                            width:119,
                            align:'left',
                            renderer:function(val) {
                                var pos = val.indexOf(":");
                                var pgNo = val.substring(0,pos);
                                var img = val.substring(pos+1);
                                return "<table width=99 height=50><tr><td width=50 height=50 valign='center' align='center'><img align='center' src='" + xcp.designer.iconsDir + "/" + img + "'/></td></tr><tr><td height=2></td></tr><tr><td style='font-size:10pt' valign='center' align='center'>" + pgNo + "</td></tr><tr><td height=3></td></tr></table>"
                            }}
                    ],
                    dockedItems:[
                        {
                            xtype:'toolbar',
                            dock:'left',
                            hidden:hidePgMod,
                            id:config.id+'_pgModPanel',
                            items:[moveBtn,extractBtn,insertBtn,removeBtn]
                        }
                    ]

                },
                {
                    xtype: 'panel',
                    id:config.id+'_viewerPanel',
                    cls:'xcp_viewer_viewerPanel',
                    region:'center',
                    bodyStyle:'background:white'
                }
            ]
        });
    }
});

/* xcp_viewer/content/xcp/common/ViewerManager.js */

/**
 *ivfclient is a singleton object that manages multiple ViewerObject instances
 */
Ext.define('xcp.common.ViewerManager', {
    singleton:true,
    alternateClassName:'ivfclient',
    constructor:function() {
        this.m_viewerMap = new Ext.util.HashMap();
    },
    addViewer : function(widgetId, viewerObject) {
        this.m_viewerMap.add(widgetId, viewerObject);
    },

    createViewer : function(elementId, providerName, initData) {
        //Instantiate the viewer
        var viewer;
        try
        {
            if(initData.automationLibrary != null && initData.automationLibrary.length > 0)
                viewer = eval("new " + initData.automationLibrary + "('" + elementId + "')");
            else
                viewer = eval("new xcp.viewer.impl." + providerName + "('" + elementId + "')");
        }
        catch(e)
        {
            //Fallback to the base implementation
            viewer = eval("new xcp.viewer.impl.ViewerObject('" + elementId + "')");
        }
        viewer.init(initData);

        return viewer;
    },

    getViewer : function(widgetId) {
        var viewer = this.m_viewerMap.get(widgetId);
        if (viewer)
            return viewer;
        else
            return null;
    }
});
/* xcp_viewer/content/xcp/util/IvfUtil.js */

/**
 Utility class for viewer methods
 */

Ext.define("xcp.util.IvfUtil",{
    singleton: true,
    /**
     * Get Selected Pages in thumbnail panel as a comma separated string
     * @param pageNums  Page numbers array
     */
    selectedPagesStr: function(pageNums) {
        pageNums.sort(function(a, b) {
            return a - b;
        });
        var pageStr = "";
        var n1 = pageNums[0],n2 = pageNums[0];
        for (var i = 1; i < pageNums.length; i++) {
            if (n2 + 1 == pageNums[i])
                n2 = pageNums[i];
            else {
                if (n1 == n2)
                    pageStr += n1 + ",";
                else
                    pageStr += n1 + "-" + n2 + ",";
                n1 = n2 = pageNums[i];
            }
        }
        if (n1 == n2)
            pageStr += n1;
        else
            pageStr += n1 + "-" + n2;
        return pageStr;
    },

    /**
     * Get Selected Page numbers in thumbnail panel as an array
     * @param pageStr  Page numbers string
     */
    getPageNums: function(pageStr) {
        var pageNums = [];
        var pgNo = 0;
        var pages = pageStr.split(",");
        for (i = 0; i < pages.length; i++) {
            pageNums[pgNo] = parseInt(pages[i].split("-")[0]);
            if (n2 = parseInt(pages[i].split("-")[1])) {
                while (pageNums[pgNo] < n2) {
                    pageNums[pgNo + 1] = parseInt(pageNums[pgNo]) + 1;
                    pgNo++;
                }
            }
            pgNo++;
        }
        pageNums.sort(function(a, b) {
            return a - b;
        });
        return pageNums;
    },

    /**
     * Get thumburl for a specific contentType
     * @param contentType ContentType of document
     */
    getThumbUrl: function(contentType) {
        var me = this,
                url = me.geIconPath(),
                knownFmt = false;

        //todo: add more content types here
        var formats = new Array("pdf", "tiff", "ppt8", "ppt12", "jpeg", "gif", "png", "excel8book", "excel12book", "msw8", "msw12");
        for (var i = 0; i < formats.length; i++) {
            if (formats[i] == contentType) {
                knownFmt = true;
                break;
            }
        }
        if (knownFmt)
            url += "f_" + contentType + "_64.gif";
        else
            url += "f_unknown_64.gif";
        return url;
    },

    // Frame icon path as a relative URL
    geIconPath: function() {
        var me = this;
        return me.getAppPath() + "/component/xcp-ivf-widgets/icons/";
    },

    // Obtain relative app path
    getAppPath: function() {
        var appPath = document.location.pathname;
        if (appPath.charAt(appPath.length - 1) == '/') {
            appPath = appPath.substr(0, appPath.length - 1);
        }
        return appPath;
    },

    debug:function(msg){
        xcp.Logger.debug("IVF:",msg);
    }
});
/* xcp_viewer/content/xcp/cmp/PageMod.js */

/**
 * @class xcp.cmp.PageMod
 * @extends Ext.Panel
 * Page Modification component for Viewer widget
 */

Ext.define('xcp.cmp.PageMod', {
    extend: "Ext.Panel",
    alias: 'panel.pagemod',
    statics: {
        PGMOD_PANEL_ID: "_pgModPanel"
    },

    constructor: function(config) {
        config = config || {};
        var me = this;
        var actions = config.actions;
        var wid = config.wid;

        Ext.apply(config, {
                    id: wid + xcp.cmp.PageMod.PGMOD_PANEL_ID,
                    region: 'west',
                    width: 50,
                    cls: 'pgModTbl'
                });

        var reorderBtn = new xcp.cmp.PageModBtn(actions.reorder);
        reorderBtn.setIconCls('pg-move-24');

        var extractBtn = new xcp.cmp.PageModBtn(actions.extract);
        extractBtn.setIconCls('pg-extract-24');

        var insertBtn = new xcp.cmp.PageModBtn(actions.insert);
        insertBtn.setIconCls('pg-insert-24');

        var removeBtn = new xcp.cmp.PageModBtn(actions.remove);
        removeBtn.setIconCls('pg-delete-24');

        config.lbar = [reorderBtn,extractBtn,insertBtn,removeBtn];
        me.callParent([config]);
    }
});

/**
 * @class xcp.cmp.PageModBtn
 * @extends Ext.Button
 * Page Modification button for Page Mod Component
 */
Ext.define('xcp.cmp.PageModBtn', {
    extend: "Ext.Button",
    height: 40,
    width: 49,
    scale:'medium',
    iconAlign: 'bottom',

    constructor: function(actionCfg) {
        this.callParent([actionCfg]);
        this.setText('&nbsp;');
    }
});

/* xcp_viewer/content/xcp/cmp/Thumbnail.js */

/**
 * @class xcp.cmp.Thumbnail
 * @extends Ext.grid.GridPanel
 * Thumbnail component for Viewer widget
 */

Ext.define('xcp.cmp.Thumbnail', {
    extend: "Ext.grid.GridPanel",
    alias: 'panel.thm',
    statics: {
        THM_PANEL_ID: "_thmPanel",
        THM_STORE_ID: "_store",
        REORD_MODE_ID: "_thmModTopBar"
    },

    constructor: function(config) {
        var me = this,
                actions = config.actions,
                thumburl = xcp.util.IvfUtil.getThumbUrl(config.contentType),
                wid = config.wid,
                storeConfig = me.getThmStore(thumburl, wid),
                menuCfg = me.getThmCtxMenu(wid, actions),
                reordermenuCfg = me.getReorderCtxMenu(wid, actions.reorder);
        me.actions = actions;

        // This flag is set when Move is selected from ctx menu
        me.reorderByCtxMenu = false;
        // This flag is set when Ctrl is released
        me.reorderByCtrlUpDown = false;
        //This flag is set when thumbnails are dragged;
        me.reorderByDragDrop = false;
        // This flag is set when any reorder gesture is done in thumbnail panel
        me.reordered = false;
        // This flag is set when reorder is cancelled
        me.cancelReorder = false;
        // This field has reorder cursor css class for IE and other browsers
        me.supportUrlFallback = false;
        if (Ext.isIE)
            me.reordCursor = 'pg-paste-ie';
        else
            me.reordCursor = 'pg-paste';

        Ext.apply(config,
                {
                    id: wid + xcp.cmp.Thumbnail.THM_PANEL_ID,
                    region:'center',
                    hideHeaders: true,
                    forceFit:true,
                    store: storeConfig,
                    autoScroll:true,
                    loadMask:true,
                    scroll:'vertical',
                    cls: 'xcp_viewer',
                    width: 150,
                    bodyStyle:'background:#D7D7D7',
                    verticalScroller:{
                        xtype:'paginggridscroller',
                        leadingBufferZone:0,
                        trailingBufferZone:0
                    },
                    //verticalScrollerType: 'paginggridscroller',
                    invalidateScrollerOnRefresh: false,
                    viewConfig: {
                        loadingText: xcp.Strings.widget.Viewer.thumbnailMask,
                        stripeRows:false,
                        plugins: {
                            ptype: 'gridviewdragdrop',
                            ddGroup: 'thmDD',
                            dragText: xcp.Strings.widget.Viewer.dragText,
                            pluginId:'dragdrop'
                        },
                        listeners:{
                            beforedrop: function(node, data, overModel, dropPosition, dropFunction, options) {
                                //Ext considers selection order, we want the order seen in UI, hence sort.
                                var store = this.store;
                                data.records.sort(function(a, b) {
                                    return (store.indexOf(a) - store.indexOf(b));
                                });
                                me.reordered = true;
                                // Cancel any reorder by ctx menu op if initiated
                                me.reorderByCtxMenu = false;
                                me.reorderByDragDrop = true;
                            },
                            drop: function(node, data, overModel, dropPosition, options) {
                                var thmCmp = this.panel;
                                (thmCmp.view).removeCls(thmCmp.reordCursor);
                                thmCmp.showReorderBar(wid);
                                me.reorderByDragDrop = false;
                            },
                            afterrender: function(view, options) {
                                var ddPlugin;
                                if (ddPlugin = view.getPlugin('dragdrop')) {
                                    ddPlugin.dropZone.dropAllowed = "thm-dd-drop-ok";
                                    ddPlugin.dropZone.dropNotAllowed = "thm-dd-drop-nodrop";
                                }

                                var nav = new Ext.util.KeyNav(view.el, {
                                    "pageUp":function (e) {
                                        e.stopPropagation();
                                        return false;
                                    },
                                    "pageDown":function (e) {
                                        e.stopPropagation();
                                        return false;

                                    },
                                    scope:this
                                });

                                var keyNav = new Ext.util.KeyNav({
                                    target: view,
                                    eventName: 'itemkeydown',
                                    pageUp: function (e) {
                                        e.stopEvent();
                                        if(e.xcpViewerHandled == null){
                                            e.xcpViewerHandled = true;
                                        }
                                        else{
                                            return false;
                                        }
                                        var idx  = me.store.indexOf(me.selModel.lastFocused),
                                            record;
                                        if (idx > 0) {
                                            record = me.store.getAt(idx - 1);
                                            me.selModel.doSelect(record);
                                        }
                                    },
                                    pageDown: function (e) {
                                        e.stopEvent();
                                        if(e.xcpViewerHandled == null){
                                            e.xcpViewerHandled = true;
                                        }
                                        else{
                                            return false;
                                        }
                                        var idx  = me.store.indexOf(me.selModel.lastFocused),
                                            record;
                                        if (idx + 1 < me.store.getCount()) {
                                            record = me.store.getAt(idx + 1);
                                            me.selModel.doSelect(record);
                                        }
                                    },
                                    scope: me
                                });
                            },
                            viewready: function(view){
                                me.confirmViewSize();
                                var vScrollbar = me.verticalScroller;
                                vScrollbar.handleViewScroll = me.handleViewScroll;

                            }

                        },
                        onRowSelect : function(rowIdx) {
                            var me = this,
                                    nodes = me.getSelectedNodes();
                            //XCPIVF-300 If nodes is null, row css does not get set
                            if (nodes[0] == null){
                                if(rowIdx == me.panel.getPageNum() - 1)
                                    me.addRowCls(rowIdx, me.focusedItemCls)
                                else
                                    me.addRowCls(rowIdx, me.selectedItemCls);
                                return;
                            }

                            if(nodes.length>1){
                                for (var i = 0; i < nodes.length; i++)
                                    me.addRowCls(nodes[i], me.selectedItemCls);
                            }

                            if (me.panel.reorderByCtrlUpDown || me.panel.reorderByDragDrop) {
                                rowIdx = me.panel.store.findExact('pgno', me.panel.getPageNum());
                                me.addRowCls(rowIdx, me.focusedItemCls);
                            }
                            else
                                me.addRowCls(rowIdx, me.selectedItemCls);
                        }
                    },
                    selModel: new xcp.thm.SelectionModel({id : wid + '_sel'}),
                    listeners:{
                        select: function(sm, selection) {
                            var pgNum = selection.data.pgno;
                            var ivfclientObj = ivfclient;
                            var viewer = ivfclientObj.getViewer(this.selModel.wid);
                            // Thumb row selected, dont need to change focus
                             me.changeThmFocus = false;

                            //Viewer triggered row selection due to paging event, hence do not try to setPage on viewer again
                            if (me.getPageNum() != pgNum && !me.reorderByCtrlUpDown) {
                                viewer.gotoPage(pgNum);
                            }
                        },
                        itemcontextmenu: function(view, record, item, index, e) {
                            e.preventDefault();

                            var menu;
                            if (!Ext.getCmp(wid).allowPageMod)
                                return;

                            if (Ext.getCmp(wid + xcp.cmp.Thumbnail.REORD_MODE_ID).isVisible()) {
                                // We are in Paste mode
                                menu = new Ext.menu.Menu(reordermenuCfg);

                                //remove "Move Selection Here" menuitems if only 1 thumb is selected
                                if (view.selModel.selected.length > 1 || !view.panel.reorderByCtxMenu) {
                                    var moveMenuItem = menu.items.items[2];
                                    menu.removeAll();
                                    menu.add(moveMenuItem);
                                }
                            }
                            else
                                menu = new Ext.menu.Menu(menuCfg);

                            menu.on("hide", function(menu) {
                                menu.removeAll();
                                menu.destroy();
                            }, menu);
                            if (menu)
                                menu.showAt(e.browserEvent.clientX,e.browserEvent.clientY);
                        },
                        render: function() {
                            this.body.on('keyup',
                                    function(e) {
                                        if (e.getKey() == e.CTRL && me.reorderByCtrlUpDown) {
                                            me.showReorderBar(wid);
                                            me.reorderByCtrlUpDown = false;
                                            me.reordered = true;
                                            // Cancel any reorder by ctx menu op if initiated
                                            me.reorderByCtxMenu = false;
                                        }else if(e.getKey() == 33) {
                                            e.stopEvent();
                                            if(e.xcpViewerHandled == null){
                                                e.xcpViewerHandled = true;
                                            }
                                            else{
                                                return false;
                                            }
                                            var idx  = me.store.indexOf(me.selModel.lastFocused),
                                                record;
                                            if (idx > 0) {
                                                record = me.store.getAt(idx - 1);
                                                me.selModel.doSelect(record);
                                            }

                                            return false;
                                        } else if(e.getKey() == 34) {
                                            e.stopEvent();
                                            if(e.xcpViewerHandled == null){
                                                e.xcpViewerHandled = true;
                                            }
                                            else{
                                                return false;
                                            }
                                            var idx  = me.store.indexOf(me.selModel.lastFocused),
                                                record;
                                            if (idx + 1 < me.store.getCount()) {
                                                record = me.store.getAt(idx + 1);
                                                me.selModel.doSelect(record);
                                            }
                                            return false;
                                        }
                                    }, this);
                        }
                    },
                    columns: [
                        {
                            dataIndex: 'pgno',
                            width:0,
                            hidden:true
                        },
                        {
                            dataIndex: 'url',
                            flex: 1,
                            renderer: function(val) {
                                var pos = val.indexOf(':'),
                                        pageNum = val.substr(0, pos),
                                        pageUrl = val.substr(pos + 1, val.length),
                                width = (me.store.proxy.extraParams.total < 4)?'150px':'130px',
                                thumburl =   Ext.getCmp(wid).thumburl;
                                if(Ext.isIE8)
                                   return "<table width="+width+" height='120px'><tr><td height='5px'></td></tr><tr><td width=100 height=100 valign='center' align='center'><img width=100 height=100 alt='" + xcp.Strings.widget.Viewer.thmAltText + "' src=" + pageUrl + " onError=fallback(this,'"+me.thumburl+"',"+me.supportUrlFallback+")></img></td></tr><tr><td height='2px'></td></tr><tr><td height='7px' align='center' valign='center'>" + pageNum + "</td></tr><tr height='3px'></tr></table>";
                                else
                                return "<table width="+width+" height='120px'><tr><td height='5px'></td></tr><tr><td width=100 height=100 valign='center' align='center'><img alt='" + xcp.Strings.widget.Viewer.thmAltText + "' class='thmimg' src=" + pageUrl + " onError=fallback(this,'"+me.thumburl+"',"+me.supportUrlFallback+")></img></td></tr><tr><td height='2px'></td></tr><tr><td height='7px' align='center' valign='center'>" + pageNum + "</td></tr><tr height='3px'></tr></table>";
                            }
                        }
                    ],
                    dockedItems: [
                        {
                            xtype: 'toolbar',
                            id:wid + xcp.cmp.Thumbnail.REORD_MODE_ID,
                            width:150,
                            height:36,
                            dock: 'top',
                            cls:'thmMod',
                            items: [
                                { xtype: 'button', text: xcp.Strings.widget.Viewer.applyButton, scale:'medium', maxWidth:72, autoWidth:false, disabled:true, cls:'thmModBtn', handler:function() {
                                    this.ownerCt.ownerCt.actions.reorder.showDialog();
                                }},
                                { xtype: 'button', text: xcp.Strings.widget.Viewer.cancelButton, scale:'medium', maxWidth:72, autoWidth:false, cls:'thmModBtn',
                                    handler:function() {
                                        var viewerCmp = Ext.getCmp(wid),
                                            thmCmp = Ext.getCmp(wid + xcp.cmp.Thumbnail.THM_PANEL_ID),
                                            store_cache = thmCmp.store.reordCache;
                                        thmCmp.cancelReorder = true;
                                        //Bring back old order of pages and show the first page
                                        Ext.getCmp(wid + xcp.cmp.Thumbnail.REORD_MODE_ID).setVisible(false);
                                        if (xcp.event)
                                            xcp.event.EventBus.publish(wid + '.enableAll', null);

                                        thmCmp.ownerCt.setTitle('');
                                        (thmCmp.view).removeCls(thmCmp.reordCursor);
                                        thmCmp.reordered = false;
                                        var viewer = ivfclient.getViewer(wid);
                                        if (viewer) {
                                            store_cache.sort(store_cache.sorters[0], 'ASC');
                                            store_cache.reinitializeIndex();                    //internal index of recs in cache are reinitialized
                                            thmCmp.store.removeAll();
                                            thmCmp.store.insert(0, store_cache.getRange(0, xcp.thm.Store.PAGE_SIZE -1));
                                            thmCmp.findAndSelectThumb(thmCmp.selModel, 1);
                                            thmCmp.view.el.dom.scrollTop=0;
                                        }
                                        viewer.gotoPage(1);
                                    }
                                }
                            ]
                        }
                    ]
                });
        me.callParent([config]);
    },

    // Show the Reorder Mode bar if not yet visible
    showReorderBar: function(wid) {
        var reorderAction = this.actions.reorder;
        var topBar = Ext.getCmp(wid + xcp.cmp.Thumbnail.REORD_MODE_ID);
        if (!topBar.isVisible())
            reorderAction.execute();
        else
            reorderAction.disableApplyBtn(false);             //enable Apply btn
    },

    /**
     * Get store for thumbnail grid
     * @param thumburl  Contenttype thumb url
     * @param wid  Viewer widget ID
     */
    getThmStore: function(thumburl, wid) {
        return new xcp.thm.Store({thumburl: thumburl, storeId: wid + xcp.cmp.Thumbnail.THM_STORE_ID});
    },

    /**
     * Get thumbnail context menu
     * @param wid  Viewer widget ID
     * @param actions  Page Mod actions config
     */
    getThmCtxMenu: function(wid, actions) {
        var menuCfg = { id:wid + '_thmCtx',showSeparator: false,
            items: [ actions.reorder, actions.extract, actions.insert,{xtype: 'menuseparator'}, actions.remove ]
        };
        return menuCfg;
    },

    /**
     * Get Reorder context menu
     * @param wid  Viewer widget ID
     * @param reorderAction  Reorder Page Mod action
     */
    getReorderCtxMenu: function(wid, reorderAction) {
        var menuCfg = { id:wid + '_reorderCtx',showSeparator: false,
            items: [
                {
                    text: xcp.Strings.widget.Viewer.moveBeforeCtxMenu,iconCls: 'pg-insertBefore',
                    handler: function() {
                        reorderAction.doReorder('ctxMenu-before');
                    }
                },
                {
                    text: xcp.Strings.widget.Viewer.moveAfterCtxMenu,iconCls: 'pg-insertAfter',
                    handler: function() {
                        reorderAction.doReorder('ctxMenu-after');
                    }
                },
                {
                    text: xcp.Strings.widget.Viewer.selectForMoveCtxMenu,iconCls: 'pg-move',
                    handler: function() {
                        reorderAction.execute(this);
                    }
                },
                {
                    xtype: 'menuseparator'
                },
                {
                    text: xcp.Strings.widget.Viewer.moveCancelCtxMenu,iconCls: 'pg-cancel',
                    handler: function() {
                        reorderAction.cancel();
                    }
                }
            ]
        };
        return menuCfg;
    },

    initializeThumbnail : function(widgetId, pageCount, isFullyRendered)
    {
        //Defaults to fully rendered doc.
        if(isFullyRendered == undefined){
            isFullyRendered = true;
        }

        var vwr = Ext.getCmp(widgetId);
        var me = this;
        if (vwr && vwr.config.thm) {
            me.setPageNum(1);
            //changeThmFocus decides whether to update selection on store load or not
            me.changeThmFocus = true;
            me.thumburl = xcp.util.IvfUtil.getThumbUrl(vwr.config.contentType);
            me.store.proxy.extraParams.thumburl=me.thumburl;
            vwr.loadThumbnails(pageCount,isFullyRendered);
            me.selModel.setSelectionMode('MULTI');
        }
    },

    setThumbnailFocus : function(widgetId, pageNum)
    {
        var me = this;
        var vwr = Ext.getCmp(widgetId);
        if (vwr && !vwr.config.thm || !me.changeThmFocus)
            return;

        var selModel = me.selModel;
        var selItems = selModel.selected.items;
        //var rowHt = xcp.thm.SelectionModel.ROW_HT;
        var rowHt = me.verticalScroller.view.el.dom.scrollHeight/me.store.totalCount;
        if (rowHt == NaN) {
            rowHt = xcp.thm.SelectionModel.ROW_HT;
            if (Ext.isIE)
                rowHt--;
        }
        var currentSel;

        me.setPageNum(pageNum);
        if (me.cancelReorder) {
            me.cancelReorder = false;
            selModel.selectionCache = selModel.selected.clone();
            return;
        }
        if (selItems.length != 0)
            currentSel = selItems[selItems.length - 1];

        var thmCtx = Ext.getCmp(widgetId + '_thmCtx');
        if (thmCtx) thmCtx.destroy();
        /* Below condition ensures that we dont go in a loop. For eg selecting a page in thumbnail panel fires an event to hosted
         * viewer to display that page. The viewer again fires an event asking the thumbnail panel to set focus on that page.
         */

        if (currentSel && currentSel.data.pgno != pageNum) {
            //Dismiss any open context menus before setting focus on thumbnail
            var reorderCtx = Ext.getCmp(widgetId + '_reorderCtx');
            var currentSelIndexInReorderCache = me.store.reordCache.findExact('pgno', currentSel.data.pgno);
            var pageIndexInReorderCache = me.store.reordCache.findExact('pgno', pageNum);
            var scrollRowsBy;

            if (reorderCtx) reorderCtx.destroy();

            if (pageIndexInReorderCache < 0)                                                  //rec not found in cache, hence using pageIndex to compute scrollRowsBy
                scrollRowsBy = pageNum - (currentSelIndexInReorderCache + 1);
            else
                scrollRowsBy = pageIndexInReorderCache - (currentSelIndexInReorderCache + 1);


            // If rows are found in store, select the required thumb. Else scroll rows to fetch data and then select.
            if (me.findAndSelectThumb(selModel, pageNum) < 0) {
                me.scrollByDeltaY(parseInt(scrollRowsBy) * rowHt);
                //After scroll and fetch, record will be selected by store load listener
            }
        }
        else {
            if (!currentSel) {
                // No selection in thm panel
                me.changeThmFocus = true;
                // we need to scroll based on absolute position if current selection is lost due to user moving the thumbnail scrollbar manually
                //me.setScrollTop(parseInt(pageNum - 1) * rowHt);
                me.view.el.dom.scrollTop=parseInt(pageNum - 1) * rowHt;
                //Current sel is lost, select again
                me.findAndSelectThumb(selModel, pageNum);
            }
            else {
                me.changeThmFocus = false;
                return;
            }
        }
        if(typeof selModel.selectionCache != "number")
            selModel.selectionCache = selModel.selected.clone();
    },

    findAndSelectThumb : function(selModel, pageNum)
    {
        var store=this.store;
        var recFound = store.findExact('pgno', pageNum),
                selectRec = store.findRecord('pgno', pageNum, "", false, false, true);
        // Record found and not selected yet
        if (recFound != -1 && !selModel.isSelected(selectRec))
        {
            selModel.select(selectRec);
        }
        return recFound;
    },

     setPageNum : function(num)
    {
        this.pageNum = num;
    },

    getPageNum : function()
    {
        return this.pageNum;
    },

    /**
     * Making sure the view is not unnecessarily repainting itself by taking a small chunk from the page size
     * also fixes issue of not being able to navigate beyond first 7-8 pages
     * @param direction
     */
    handleViewScroll:function (direction) {
        var me = this,
            store = me.store,
            view = me.view,
            viewSize = me.viewSize,
            totalCount = store.getTotalCount(),
            visibleStart = me.getFirstVisibleRowIndex(),
            visibleEnd = me.getLastVisibleRowIndex(),
            requestStart,
            requestEnd;

        // Only process if the total rows is larger than the visible page size
        if (totalCount >= viewSize) {

            var storePageSize = store.pageSize;
            visibleStart++; //actual row count rather than index
            var firstVisiblePageSet = Math.ceil(visibleStart / storePageSize);
            requestStart = ( firstVisiblePageSet - 1 ) * storePageSize;
            //check if last visible is in current page set
            var lastVisiblePageSet = Math.ceil(visibleEnd / storePageSize);
            var pageSetDiff = lastVisiblePageSet - firstVisiblePageSet;
            requestEnd = requestStart + (storePageSize * (pageSetDiff + 1) ) - 1;
            if (requestEnd > totalCount) {
                requestEnd = totalCount;
            }
            if (requestStart !== undefined) {

                // If range is satsfied within the prefetch buffer, then just draw it from the prefetch buffer
                if (store.rangeCached(requestStart, requestEnd)) {
                    me.cancelLoad();
                    var isFirstRowLoaded = false;
                    var isLastRowLoaded = false;
                    var dataPageNumber = -1;
                    Ext.Array.some(store.data.items, function (pageInfo) {
                        dataPageNumber = pageInfo.data.pgno;
                        if (!isFirstRowLoaded) {
                            if (dataPageNumber == requestStart + 1) {
                                isFirstRowLoaded = true;
                            }
                        }
                        if (!isLastRowLoaded) {
                            if (dataPageNumber == requestEnd + 1) {
                                isLastRowLoaded = true;
                            }
                        }
                        return isFirstRowLoaded && isLastRowLoaded;
                    });

                    if (!(isFirstRowLoaded && isLastRowLoaded)) {
                        store.guaranteeRange(requestStart, requestEnd);
                    }
                }

                // Required range is not in the prefetch buffer. Ask the store to prefetch it.
                // We will recieve a guaranteedrange event when that is done.
                else {
                    me.attemptLoad(requestStart, requestEnd);
                }
            }
        }
    },

    confirmViewSize: function() {
        var vScrollbar = this.verticalScroller;
        if (vScrollbar.viewSize == null ) {
            vScrollbar.viewSize = 5;
        }
        if (vScrollbar.viewSize <=10 ) {
            vScrollbar.viewSize = this.store.viewSize = vScrollbar.viewSize == null | vScrollbar.viewSize <= 5 ? (vScrollbar.store.viewSize = 5) : (vScrollbar.store.viewSize = 10);
        }
    }

});
function fallback(source,thumburl,supportUrlFallback){
    if (supportUrlFallback)
        source.src = thumburl;
}

/* xcp_viewer/content/xcp/viewer/impl/ViewerObject.js */

/**
 * Base object for all viewers. Each viewer provider is an instance (derived class) of ViewerObject.
 */
Ext.define('xcp.viewer.impl.ViewerObject', {
    statics:{
        /*****************************************************************************************
         * Event type definitions
         ****************************************************************************************/

        /*
         * The viewer framework fires this event when the viewer control successfully loaded the first page
         * of a document. Components interested in this event must subscribe to this event by calling the
         * <c>addEventHandler</c> method.
         *
         * A good example of why this event should be used is the thumbnail control, after getting notified of this event
         * it can call the <c>getPageCount</c> method to get the actual page count of the document. This information is only
         * available after the viewer control successfully load the first page of the document.
         */

        Event_DocumentOpened : 1,
        /*
         * The viewer framework fires this event after user navigates through pages of the document in display.
         * Components interested in this event must subscribe to this event by calling the <c>addEventHandler</c> method.
         *
         * A good example of how this event can be used is the thumbnail control, after getting notified of this event,
         * it can set current selection on a thumbnail so to keep the thumbnail selection in sync with the page displayed in
         * the viewer control.
         */


        Event_Pagination : 2,
        /*
         * The viewer framework fires this event after the viewer control successfully saves a document and the objectID of
         * which is different from the one before the save happens. This event notifies the subscribers that the objectID
         * of the document currently displayed has changed.
         *
         * There are 2 use cases for this event:
         * 1. Redaction. Some viewers support burning annotation on top of the original document and generating a new version
         *    for the original document. When this happens, the document under display in the viewer control is the redacted
         *    version of the original document, and the objectID is different from the original document. Components around the
         *    viewer control, for example the component/form that displays the document attributes, needs to refresh the content
         *    in order to reflect the objectID change.
         * 2. Upload a local file into the repository. When the local file is displayed in the viewer control, there is not objectID
         *    associated with it. However, after the viewer control uploading the local file to the repository, an objectID is
         *    generated. This event notifies the subscribers the objectID changes.
         */


        Event_RefreshRequired : 3
    },
    constructor:function(config) {
        this.m_elementId = config.elementId;
        this.m_providerName = config.providerName;

        this.m_objectId = null;
        this.m_automationLibrary = null;
        this.m_annotationModified = false;
        this.m_userAnnotationUrl = null;
        this.m_allAnnotationsUrl = null;
        this.m_documentUploadUrl = null;
        this.m_annotationUploadUrl = null;
        this.m_printAuditUrl = null;
        this.m_exportAuditUrl = null;
        this.m_pageDeletionUrl = null;
        this.m_pageReorderUrl = null;
        this.m_pageInsertionUrl = null;
        this.m_pageExtractionUrl = null;
//        this.m_pagemodificationUrl = null;
        this.m_documentFallbackUrls = new Array();
        this.m_annotationFallbackUrls = new Array();

        //The true value of these attributes will depend on the runtime context.
        this.m_documentModifiable = true;
        this.m_annotationModifiable = true;
        //The value of the following attributes depends on the design time settings
        this.m_showAnnotation = true;
    },
    /***************************************************************************************
     *
     * Base object implementations
     * Derived object can use these methods to perform some operations. Derived object can
     * also override these methods if they do not work as you desire.
     *
     **************************************************************************************/
    getWidgetId : function()
    {
        var pos = this.m_elementId.lastIndexOf(xcp.widget.Viewer.VCONTROL);
        var widgetId = this.elementId.substr(0, pos);
        return widgetId;
    },
    getViewerElement : function()
    {
        return document.getElementById(this.m_elementId);
    },
    getProviderName : function ()
    {
        return this.m_providerName;
    },
    isDocumentModifiable : function ()
    {
        return this.m_documentModifiable;
    },
    isAnnotationModifiable : function ()
    {
        return this.m_annotationModifiable;
    },
    enableDocumentModification : function (enable)
    {
        this.m_documentModifiable = enable;
    },
    enableAnnotationModification : function (enable)
    {
        this.m_annotationModifiable = enable;
    },
    isAnnotationEnabled : function()
    {
        return this.m_showAnnotation;
    },
    enableAnnotation : function(enable)
    {
        this.m_showAnnotation = enable;
    },
    isAnnotationModified : function()
    {
        return this.m_annotationModified;
    },
    setAnnotationModified : function(modified)
    {
        this.m_annotationModified = modified;
    },
    getUserAnnotationUrl : function()
    {
        if(this.m_annotationModified)
        {
            var urlCount = this.m_annotationFallbackUrls.length;
            if(urlCount > 0)
                return this.m_annotationFallbackUrls[urlCount-1];
            else
                return this.m_userAnnotationUrl;
        }
        else
        {
            return this.m_userAnnotationUrl;
        }
    },
    setUserAnnotationUrl : function(url)
    {
        this.m_userAnnotationUrl = url;
    },
    getAllUserAnnotationUrl : function()
    {
        return this.m_allAnnotationsUrl;
    },
    init : function (initData)
    {
        this.m_objectId = initData.objectId;
        this.m_automationLibrary = initData.automationLibrary;
        this.m_userAnnotationUrl = initData.userAnnotationUrl;
        this.m_allAnnotationsUrl = initData.allAnnotationsUrl;
        this.m_documentUploadUrl = initData.documentUploadUrl;
        this.m_annotationUploadUrl = initData.annotationUploadUrl;
        this.m_printAuditUrl = initData.printAuditUrl;
        this.m_exportAuditUrl = initData.exportAuditUrl;
        this.m_pageDeletionUrl = initData.pageDeletionUrl;
        this.m_pageReorderUrl = initData.pageReorderUrl;
        this.m_pageInsertionUrl = initData.pageInsertionUrl;
        this.m_pageExtractionUrl = initData.pageExtractionUrl;
//        this.m_pagemodificationUrl = initData.pagemodificationUrl;
        this.m_documentModifiable = initData.allowPageModify;
        this.m_annotationModifiable = initData.allowAnnotate;

        this.m_documentFallbackUrls = [];
        this.m_annotationFallbackUrls = [];

        for (var i = 0; typeof initData.documentFallbackUrls != 'undefined' && initData.documentFallbackUrls != null && i < initData.documentFallbackUrls.length; i++)
            this.m_documentFallbackUrls.push(initData.documentFallbackUrls[i].value);

        for (var i = 0; typeof initData.annotationFallbackUrls != 'undefined' && initData.annotationFallbackUrls != null && i < initData.annotationFallbackUrls.length; i++)
            this.m_annotationFallbackUrls.push(initData.annotationFallbackUrls[i].value);
    },
    renderControl : function(tagName, attrList, paramList)
    {
        var htmlContent = "<" + tagName + " id='" + this.m_elementId + "' height='100%' width='100%'";
        for (var i = 0; i < attrList.length; i++)
        {
            htmlContent += " " + attrList[i].name + "='" + attrList[i].value + "'";
        }
        htmlContent += ">";

        if (paramList)
        {
            for (var i = 0; i < paramList.length; i++)
            {
                htmlContent += "<param name='" + paramList[i].name + "' value=\"" + paramList[i].value + "\" >";
            }
        }
        if (this.m_documentFallbackUrls.length > 0)
            htmlContent += "<div>" + Ext.String.format(xcp.Strings.widget.Viewer.errorStr1, tagName, "<a href='" + this.m_documentFallbackUrls[this.m_documentFallbackUrls.length - 1] + "'>", "</a>") + "</div>";
        else
            htmlContent += "<div>" + Ext.String.format(xcp.Strings.widget.Viewer.errorStr2, tagName) + "</div>";
        htmlContent += "</" + tagName + ">";
        return htmlContent;
    },

    /***************************************************************************************
     * updateDocument is called when a 3rd party viewer currently being shown in the widget, has the ability to show
     * a second document without teardown.
     *
     * Default implementation of updateDocument returns false. If the derived viewer supports updating a document,
     * it has to implement updateDocument and return true.
     **************************************************************************************/

    updateDocument  : function(json)
    {
        this.log("updateDocument method not implemented");
        return false;
    },

    isAnnotationUrl : function(url)
    {
        return (url.indexOf("type=anno") > 0);
    },
    getNextDocumentFallbackUrl : function()
    {
        var nextUrl = null;
        if (this.m_documentFallbackUrls.length > 0)
        {
            nextUrl = this.m_documentFallbackUrls[0];
            this.m_documentFallbackUrls.splice(0, 1);
        }
        return nextUrl;
    },
    getNextAnnotationFallbackUrl : function()
    {
        var nextUrl = null;
        if (this.m_annotationFallbackUrls.length > 0)
        {
            nextUrl = this.m_annotationFallbackUrls[0];
            this.m_userAnnotationUrl = nextUrl;
            this.m_annotationFallbackUrls.splice(0, 1);
        }
        return nextUrl;
    },
    initializeThumbnail : function(pageCount,isFullyRenderedDoc)
    {
        var widgetId = this.getWidgetId();
        var viewerObj = Ext.getCmp(widgetId);
        if(viewerObj && viewerObj.config.thm)
            Ext.getCmp(widgetId + xcp.cmp.Thumbnail.THM_PANEL_ID).initializeThumbnail(widgetId, pageCount,isFullyRenderedDoc);
    },
    setThumbnailFocus : function(pageNum)
    {
        var widgetId = this.getWidgetId();
        var viewerObj = Ext.getCmp(widgetId);
        if (viewerObj && viewerObj.config.thm) {
            var thmCmp = Ext.getCmp(widgetId + xcp.cmp.Thumbnail.THM_PANEL_ID);
            thmCmp.changeThmFocus = true;
            thmCmp.setThumbnailFocus(widgetId, pageNum);
        }
    },
    tryAlternativeDocumentUrl : function()
    {
        this.log("tryAlternativeDocumentUrl method not implemented");
    },
    tryAlternativeAnnotationUrl : function()
    {
        this.log("tryAlternativeAnnotationUrl method not implemented");
    },

    log: function(msg)
    {
        xcp.util.IvfUtil.debug(msg);
    },

    printAuditTrailRequest : function(auditMessage)
    {
    },
    exportAuditTrailRequest : function(auditMessage)
    {
    },
    pageModifictionRequest : function (pageOrder)
    {
    },
    addEventHandler : function(eventType, eventHandler)
    {
    },
    fireEvent : function(eventType, eventData)
    {
    },

    /***************************************************************************************
     *
     * Methods that the derived object may choose to implement.
     * A derived object does not need to implement all these methods. If the debug mode, if
     * an method gets called and it is not implemented by the derived object, a 'method not implemented'
     * alert will show up.
     *
     **************************************************************************************/
    preRender : function (json)
    {
        this.log("preRender method not implemented");
        return "";
    },
    postRender : function (json)
    {
        this.log("postRender method not implemented");
        return "";
    },
    getPageCount : function ()
    {
        this.log("getPageCount method not implemented");
        return 1;
    },
    nextPage : function()
    {
        this.log("nextPage method not implemented");
    },
    prevPage  : function()
    {
        this.log("prevPage method not implemented");
    },
    gotoPage  : function(pageNum)
    {
        this.log("gotoPage method not implemented");
    },
    printDocument  : function()
    {
        this.log("printDocument method not implemented");
    },
    printPage  : function()
    {
        this.log("printPage method not implemented");
    },
    loadLocalFile  : function(filePath, dosExtension)
    {
        this.log("loadLocalFile method not implemented");
    },
    saveDocument  : function()
    {
        this.log("saveDocument method not implemented");
    },
    loadDocumentUrl  : function(docUrl)
    {
        this.log("loadDocumentUrl method not implemented");
    },
    loadAnnotationUrl  : function(annoUrl)
    {
        this.log("loadAnnotations method not implemented");
    },
    saveAnnotation  : function()
    {
        this.log("saveAnnotation method not implemented");
    },
    loadAllAnnotations  : function()
    {
        this.log("loadAllAnnotations method not implemented");
    },
    loadCurrentUserAnnotations  : function()
    {
        this.log("loadCurrentUserAnnotations method not implemented");
    },
    cleanup : function()
    {
        this.log("cleanup method not implemented");
    },

    /*************************************************************************************
     * Event handling methods
     ************************************************************************************/
    handleViewerEvent  : function(eventId, msg)
    {
        this.log("handleViewerEvent method not implemented");
    },

    /*************************************************************************************
     * Private methods
     ************************************************************************************/
    controlRequest : function(objectId) {
    }
});
/* xcp_viewer/content/xcp/thm/DataModel.js */

/**
 * @class xcp.thm.DataModel
 * @extends Ext.data.Model
 * Data Model for thumbnail component
 */
Ext.define('xcp.thm.DataModel', {
    extend: 'Ext.data.Model',
    alias: 'thmdatamodel',
    fields: [
        {name:'pgno',type:'int'},
        {name:'url', type:'string'}
    ]
});
/* xcp_viewer/content/xcp/thm/SelectionModel.js */

/**
 * @class xcp.thm.SelectionModel
 * @extends Ext.selection.RowModel
 * Custom row selection model for thumbnail grid
 */
Ext.define('xcp.thm.SelectionModel', {
    extend: 'Ext.selection.RowModel',
    alias: 'selection.thmselmodel',
    statics: {
        ROW_HT: 122
    },

    constructor: function(config) {
        config = config || {};
        var me = this,
                pos = config.id.indexOf("_sel");
        me.wid = config.id.substr(0, pos);
        //selectionCache keeps track of selected thumbnails in the infinite grid
        me.selectionCache=[];
        me.callParent([config]);
    },

    initKeyNav: function(view) {
        var me = this;
        me.callParent(arguments);
        view.el.on(Ext.EventManager.getKeyEvent(), me.onKeyPress, me);                     //register KeyPress event
    },

    //Handler for keyup in thumbnail grid.
    onKeyUp: function(e, t) {
        var me = this;

        if (e.ctrlKey && me.view.panel.actions.reorder && !me.view.panel.actions.reorder.isDisabled()) {
            me.view.panel.actions.reorder.doReorder('ctrl-up');
            return;
        }

        me.callParent(arguments);
    },

    //Handler for keydown in thumbnail grid.
    onKeyDown: function(e, t) {
        var me = this;

        if (e.ctrlKey && me.view.panel.actions.reorder && !me.view.panel.actions.reorder.isDisabled()) {
            me.view.panel.actions.reorder.doReorder('ctrl-down');
            return;
        }

        me.callParent(arguments);
    },

    // Navigate one record up. This could be a selection or
    // could be simply focusing a record for discontiguous
    // selection. Provides bounds checking.
    onKeyPageUp: function(e) {
        e.stopEvent();
        if(e.xcpViewerHandled == null){
            e.xcpViewerHandled = true;
        }
        else{
            return false;
        }

        var me = this,
            idx  = me.store.indexOf(me.lastFocused),
        record;

        if (idx > 0) {
            // needs to be the filtered count as thats what
            // will be visible.
            record = me.store.getAt(idx - 1);
            if (e.shiftKey && me.lastFocused) {
                if (me.isSelected(me.lastFocused) && me.isSelected(record)) {
                    me.doDeselect(me.lastFocused, true);
                    me.setLastFocused(record);
                } else if (!me.isSelected(me.lastFocused)) {
                    me.doSelect(me.lastFocused, true);
                    me.doSelect(record, true);
                } else {
                    me.doSelect(record, true);
                }
            } else if (e.ctrlKey) {
                me.setLastFocused(record);
            } else {
                me.doSelect(record);
                //view.focusRow(idx - 1);
            }
        }
        // There was no lastFocused record, and the user has pressed up
        // Ignore??
        //else if (this.selected.getCount() == 0) {
        //
        //    this.doSelect(record);
        //    //view.focusRow(idx - 1);
        //}
    },

    // Navigate one record down. This could be a selection or
    // could be simply focusing a record for discontiguous
    // selection. Provides bounds checking.
    onKeyPageDown: function(e) {
        e.stopEvent();
        if(e.xcpViewerHandled == null){
            e.xcpViewerHandled = true;
        }
        else{
            return false;
        }

        var me = this,
            idx  = me.store.indexOf(me.lastFocused),
        record;

        // needs to be the filtered count as thats what
        // will be visible.
        if (idx + 1 < me.store.getCount()) {
            record = me.store.getAt(idx + 1);
            if (me.selected.getCount() === 0) {
                if (!e.ctrlKey) {
                    me.doSelect(record);
                } else {
                    me.setLastFocused(record);
                }
                //view.focusRow(idx + 1);
            } else if (e.shiftKey && me.lastFocused) {
                if (me.isSelected(me.lastFocused) && me.isSelected(record)) {
                    me.doDeselect(me.lastFocused, true);
                    me.setLastFocused(record);
                } else if (!me.isSelected(me.lastFocused)) {
                    me.doSelect(me.lastFocused, true);
                    me.doSelect(record, true);
                } else {
                    me.doSelect(record, true);
                }
            } else if (e.ctrlKey) {
                me.setLastFocused(record);
            } else {
                me.doSelect(record);
                //view.focusRow(idx + 1);
            }
        }
    },



    //Handler for mousedown in thumbnail grid.
    onRowMouseDown: function(view, record, item, index, e) {
        var me = this;
        // Do not allow deselect if only 1 row is selected
        if (/*me.selected.length == 1 &&*/ e.ctrlKey && me.selected.items[me.selected.length-1].data.pgno == record.data.pgno || (e.button === 2 && me.isSelected(index))) {
            return;
        }
        else {
            view.el.focus();
            me.selectWithEvent(record, e);
        }
    },

    //Handler for keypress in thumbnail grid.
    onKeyPress: function(e, t) {
        var me = this;
        var remAction = me.view.panel.actions.remove;
        if (e.getKey() === e.DELETE && remAction && !remAction.isDisabled()) {
            remAction.execute(remAction.widgetId);
        }
        else if (e.getKey() === e.ESC) {
            var reorderAction = me.view.panel.actions.reorder;
            reorderAction.cancel();
        }
    },

    // Clear Selections override to workaround Sencha bug
    clearSelections: function() {
        var me = this;
        me.deselectAll();
        me.lastSelected = null;
        me.setLastFocused(null);
    },

    // Override to remember previous selection on grid and show them selected during scroll back
    refresh: function(){
        var me = this,
            toBeSelected = [],
            oldSelections = me.selectionCache,
            len = oldSelections.length,
            selection,
            change,
            i = 0,
            lastFocused = this.getLastFocused();

        for (; i < len; i++) {
            selection = oldSelections.items[i];
            if (me.store.findExact('pgno', selection.data.pgno) != -1) {
                toBeSelected.push(selection);
            }
        }
        if (me.selected.getCount() != toBeSelected.length) {
            change = true;
        }
        me.clearSelections();
        if (me.store.indexOf(lastFocused) !== -1) {
            this.setLastFocused(lastFocused, true);
        }
        if (toBeSelected.length) {
            me.doSelect(toBeSelected, false, true);
        }
        me.maybeFireSelectionChange(change);
    },

    onSelectChange: function(record, isSelected, suppressEvent) {
        //XCPIVF-300 rowIdx might become -ve after a reorder cancel
        if(this.store.indexOf(record) < 0)
            record = this.store.findRecord('pgno', record.data.pgno, "", false, false, true);

         this.callParent(arguments);
    },

    // Override selectWithEvent to keep selectionCache in sync
     selectWithEvent: function(record, e) {
         var me = this;
         me.callParent(arguments);
         me.selectionCache = me.selected.clone();
     }
});
/* xcp_viewer/content/xcp/thm/ReorderCache.js */

/**
 * @class xcp.thm.ReorderCache
 * @extends Ext.data.ArrayStore
 * Intermediate cache in thumbnail grid Store for reorder persistence
 */
Ext.define('xcp.thm.ReorderCache',{
    extend: 'Ext.data.ArrayStore',
    alias: 'reordCache.thmstore',

    constructor: function(config) {
        config = config || {};
        config.storeId = 'store_cache',
        config.fields = [{'name':'pgno'},{'name':'url'}],
        config.sorters = [{
                sorterFn: function(a,b){
                    var a_pgno = a.data.pgno,
                        b_pgno = b.data.pgno;
                    if(a_pgno.toString().indexOf('dummy')!=-1 || b_pgno.toString().indexOf('dummy')!=-1)
                       return 0;
                    if(a_pgno < b_pgno)
                      return -1;
                    else
                      return 1;
                }
            }];
        this.callParent([config]);
    },

    //first record in the cache should have internal index 0
    reorderIndex : function(org_Index,selRecords){
        var me= this;
        var firstRec = me.data.items[0];
        if (selRecords[0].index == 0) {                           //rec moved to first position
            selRecords[0].index = firstRec.index;
            firstRec.index = 0;
        } else if (firstRec.index != 0) {                         //first record moved to some other position
            me.data.items[org_Index].index = firstRec.index;
            firstRec.index = 0;
        }
    },

    //reinitialize index in original order when reorder is are cancelled
    reinitializeIndex : function() {
        var me = this;
        for (var i = 0; i < me.data.items.length; i++)
            me.data.items[i].index = i;
    },

    //returns records from cache for corresponding records in store
    getCacheRecords : function(storeRecords) {
        var me=this,
            cacheRecords = [];
        for (i = 0; i < storeRecords.length; i++) {
            cacheRecords[i] = me.findRecord('pgno', storeRecords[i].data.pgno, "", false, false, true);
        }
        return cacheRecords;
    }

});

/* xcp_viewer/content/xcp/thm/Store.js */

/**
 * @class xcp.thm.Store
 * @extends Ext.data.Store
 * Data Store for thumbnail grid
 */
Ext.define('xcp.thm.Store', {
    extend: 'Ext.data.Store',
    alias: 'store.thmstore',
	statics :{
        PAGE_SIZE :5
    },

    constructor: function(config) {
        var me = this;
        config = config || {};
        config.buffered = true;
        config.purgePageCount = 0;
        config.pageSize = xcp.thm.Store.PAGE_SIZE;
        config.leadingBufferZone = 0;
        config.trailingBufferZone = 0;
        config.proxy = {
            model: "xcp.thm.DataModel",
            type:"ajax",
            url: "ivf/thumbnails",
            extraParams: {
                thumburl:config.thumburl
            },
            reader: {
                root: "pages",
                totalProperty: 'total'
            }
        };

        config.reordCache = new xcp.thm.ReorderCache({});
        me.callParent([config]);
    },
    listeners: {
        load: function() {
            var me = this;
            var pos = me.storeId.indexOf(xcp.cmp.Thumbnail.THM_STORE_ID);
            var widgetId = me.storeId.substr(0, pos);
            var thmCmp = Ext.getCmp(widgetId + xcp.cmp.Thumbnail.THM_PANEL_ID);
            if(thmCmp == null){
                return;
            }
            var selModel = thmCmp.selModel;

            thmCmp.getEl().unmask();
            thmCmp.confirmViewSize();
            //Make sure when we cancel reorder, 1st thumb gets selected
            if(thmCmp.cancelReorder){
                thmCmp.setPageNum(1);
                thmCmp.changeThmFocus = true;
            }

            if(me.reordCache.data.items.length==0){                                         //when the cache n prefetchData are cleared after page mod op, initial 50 rec are copied from store
                var rec = me.getRange(0,xcp.thm.Store.PAGE_SIZE -1);
                me.reordCache.insert(0,rec);
            }

             /*When we do Insert Pages action, store will be cleared and reloaded for the new doc.
            Hence we cache pg no to show the thumb as selected after refresh  */
            if (typeof selModel.selectionCache == 'number') {
                thmCmp.setThumbnailFocus(widgetId, selModel.selectionCache);
                return;
            }

            thmCmp.getView().focus();

            var toSelect = thmCmp.getPageNum(),
                    selected = selModel.selected;
            //Sometimes in IE, even if 1st row is selected, css is not set
            if (selected.length > 0 && selected.items[selected.items.length-1].data.pgno == toSelect) {
                if (toSelect == 1) {
                    var view = thmCmp.view;
                    view.addRowCls(0, view.selectedItemCls);
                }
                return;
            }

             if(thmCmp.changeThmFocus)
            {
                thmCmp.changeThmFocus = false;
                thmCmp.findAndSelectThumb(selModel, toSelect);
                selModel.selectionCache = selModel.selected.clone();
            }
        }
    },

    insertRecords : function(storeIndex, storeRecs, cacheIndex, cacheRecs) {
        this.insert(storeIndex, storeRecs);
        this.reordCache.insert(cacheIndex, cacheRecs);
    },

    removeRecords : function(storeRecs, cacheRecs) {
        this.remove(storeRecs);
        this.reordCache.remove(cacheRecs);
    }
});

/* xcp_viewer/content/xcp/util/ExtjsPatch.js */

xcp.thm.Store.override({
    cachePage: function(records, page) {
        var me = this;

        if (!Ext.isDefined(me.totalCount)) {
            me.totalCount = records.length;
            me.fireEvent('totalcountchange', me.totalCount);
        }


        var start = (page-1)*xcp.thm.Store.PAGE_SIZE;
        var cache_len = me.reordCache.data.items.length;
        if (start > cache_len) {
            for (i = cache_len; i < start; i++) {                                             //insert dummy records
                var pg = 'dummy' + i;
                me.reordCache.insert(i, {'pgno':pg,'url':''});
            }
        }
        else {
            if (me.reordCache.data.items[start + 1]) {                                        //remove inserted dummy records to replace with fetched records at the position
                var rec = me.reordCache.getRange(start, start + xcp.thm.Store.PAGE_SIZE - 1);
                me.reordCache.remove(rec);
            }
        }
        me.reordCache.insert(start, records);                                                 //insert into reorder cache.

        me.pageMap.addPage(page, records);
        xcp.util.IvfUtil.debug("Records ranging from " + start+" - "+(start + xcp.thm.Store.PAGE_SIZE - 1)+" inserted into prefetchData and reorderCache");
    },
    onGuaranteedRange: function(options) {
        var me = this,
            totalCount = me.getTotalCount(),
            start = options.prefetchStart,
            end = ((totalCount - 1) < options.prefetchEnd) ? totalCount - 1 : options.prefetchEnd,
            range;

        end = Math.max(0, end);

        if (start > end) {
            Ext.log({
                level: 'warn',
                msg: 'Start (' + start + ') was greater than end (' + end +
                    ') for the range of records requested (' + start + '-' +
                    options.prefetchEnd + ')' + (this.storeId ? ' from store "' + this.storeId + '"' : '')
            });
        }

        //range = me.pageMap.getRange(start, end);
        range = me.reordCache.getRange(start, end);

        me.fireEvent('guaranteedrange', range, start, end);
        if (options.cb) {
            options.cb.call(options.scope || me, range, start, end);
        }

        this.fireEvent('load');
    },
    guaranteeRange: function(start, end, cb, scope) {
        var me=this,
        pos = me.storeId.indexOf(xcp.cmp.Thumbnail.THM_STORE_ID),
        widgetId = me.storeId.substr(0, pos),
        thmCmp = Ext.getCmp(widgetId + xcp.cmp.Thumbnail.THM_PANEL_ID);

        var msk = thmCmp.getEl().mask('<img src="component/xcp-ivf-widgets/icons/loading_66.gif">');
        msk.dom.nextSibling.style.left =  (parseInt(msk.dom.nextSibling.style.left)-13)+"px";                           //Align the img to center
        this.callParent(arguments);
    }
});

Ext.grid.ViewDropZone.override({
    handleNodeDrop : function(data, record, position) {
        var view = this.view,
            store = view.getStore(),
            storeIndex, records, i, len, cacheIndex, firstSelRecIndexInReordCache, recsInReordCache= [];

        recsInReordCache = store.reordCache.getCacheRecords(data.records);
        firstSelRecIndexInReordCache = store.reordCache.indexOf(recsInReordCache[0]);

        if (data.copy) {
            records = data.records;
            data.records = [];
            for (i = 0,len = records.length; i < len; i++) {
                data.records.push(records[i].copy(records[i].getId()));
            }
        } else {

            data.view.store.remove(data.records, data.view === view);
            data.view.store.reordCache.remove(recsInReordCache,data.view===view);
        }

        storeIndex = store.indexOf(record);
        cacheIndex = store.reordCache.findExact('pgno',record.data.pgno);

        if (position != 'before') {
            storeIndex++;
            cacheIndex++;
        }
        store.insertRecords(storeIndex, data.records, cacheIndex, recsInReordCache);

        store.reordCache.reorderIndex(firstSelRecIndexInReordCache, recsInReordCache);

        view.getSelectionModel().select(data.records);
    }

});
Ext.grid.PagingScroller.override({
    onViewResize: function(view, width, height) {
        var me = this,
            newViewSize;
        var rowHeight = me.rowHeight;
        if (view.ownerCt && view.ownerCt.id.indexOf(xcp.cmp.Thumbnail.THM_PANEL_ID) != -1) {
            rowHeight = 122;
        }
        newViewSize = Math.ceil(height / rowHeight) + me.trailingBufferZone + (me.numFromEdge * 2) + me.leadingBufferZone;
        if (newViewSize > me.viewSize) {
            me.viewSize = me.store.viewSize = newViewSize;
            me.handleViewScroll(me.lastScrollDirection || 1);
        }
    }
});
Ext.layout.boxOverflow.Menu.override({
    beforeMenuShow: function(menu) {
        var me = this,
            index;
        me.callOverridden(arguments);
        if (me.layout && me.layout.owner && (index=me.layout.owner.id.indexOf(xcp.viewer.impl.AXViewer.ImageToolbar_ID)) != -1) {
            var parentToolbarId = me.layout.owner.id;
            var widgetId = parentToolbarId.substring(0, index);
            var viewer = ivfclient.getViewer(widgetId);
            var items = menu.items.items;
            var i;
            for (i = 0; i < items.length; i++)
                if (items[i].getXType() == 'tbtext')
                    items[i].setText(viewer.getPageCount());
        }
    }
});
Ext.dd.DragDropManager.isOverTarget= function(pt, oTarget, intersect){
        // use cache if available
        var loc = this.locationCache[oTarget.id],
            dc, pos, el, curRegion, overlap;
        if (!loc || !this.useCache) {
            loc = this.getLocation(oTarget);
            this.locationCache[oTarget.id] = loc;

        }

        if (!loc) {
            return false;
        }

    //This fix is required only for firefox. Also checking the component which can be either thumbnail-grid-body or gridview
    if (Ext.firefoxVersion && (oTarget.id.indexOf(xcp.cmp.Thumbnail.THM_PANEL_ID)!=-1 || (Ext.getCmp(oTarget.id).ownerCt && Ext.getCmp(oTarget.id).ownerCt.id.indexOf(xcp.cmp.Thumbnail.THM_PANEL_ID)!=-1)))
        pt.y = Ext.getBody().getScroll().top + pt.y;

    oTarget.cursorIsOver = loc.contains( pt );

        // DragDrop is using this as a sanity check for the initial mousedown
        // in this case we are done.  In POINT mode, if the drag obj has no
        // contraints, we are also done. Otherwise we need to evaluate the
        // location of the target as related to the actual location of the
        // dragged element.
        dc = this.dragCurrent;
        if (!dc || !dc.getTargetCoord ||
                (!intersect && !dc.constrainX && !dc.constrainY)) {
            return oTarget.cursorIsOver;
        }

        oTarget.overlap = null;

        // Get the current location of the drag element, this is the
        // location of the mouse event less the delta that represents
        // where the original mousedown happened on the element.  We
        // need to consider constraints and ticks as well.
        pos = dc.getTargetCoord(pt.x, pt.y);

        el = dc.getDragEl();
        curRegion = new Ext.util.Region(pos.y,
                                               pos.x + el.offsetWidth,
                                               pos.y + el.offsetHeight,
                                               pos.x );

        overlap = curRegion.intersect(loc);

        if (overlap) {
            oTarget.overlap = overlap;
            return (intersect) ? true : oTarget.cursorIsOver;
        } else {
            return false;
        }
};
Ext.view.DropZone.override({
    positionIndicator: function(node, data, e) {
        if (data.view&& data.view.ownerCt && data.view.ownerCt.id.indexOf(xcp.cmp.Thumbnail.THM_PANEL_ID) != -1) {
            var me = this,
                view = me.view,
                pos = me.getPosition(e, node),
                overRecord = view.getRecord(node),
                draggingRecords = data.records,
                indicatorY;

            if (!Ext.Array.contains(draggingRecords, overRecord) && (
                pos == 'before' && !me.containsRecordAtOffset(draggingRecords, overRecord, -1) ||
                    pos == 'after' && !me.containsRecordAtOffset(draggingRecords, overRecord, 1)
                )) {
                me.valid = true;

                if (me.overRecord != overRecord || me.currentPosition != pos) {

                    indicatorY = Ext.fly(node).getY() - view.el.getY() - 1;
                    if (pos == 'after') {
                        indicatorY += Ext.fly(node).getHeight();
                    }
                    if (Ext.firefoxVersion || Ext.isIE)
                        indicatorY = indicatorY - Ext.getBody().getScroll().top;
                    me.getIndicator().setWidth(Ext.fly(view.el).getWidth()).showAt(0, indicatorY);

                    // Cache the overRecord and the 'before' or 'after' indicator.
                    me.overRecord = overRecord;
                    me.currentPosition = pos;
                }
            } else {
                me.invalidateDrop();
            }
        }
        else {
            this.callOverridden(arguments);
        }
    }
});
/* xcp_viewer/content/xcp/action/page/BaseAction.js */

/**
 * @class xcp.action.page.BaseAction
 * @extends Ext.Action
 * Base Action implementation for all Page Modification Actions
 */
Ext.define("xcp.action.page.BaseAction",{
    extend: "Ext.Action",

    constructor: function(config) {
        var me = this;
        me.widgetId = config.widgetId;
        me.subscribeEvts(me.widgetId);
        Ext.apply(config, {handler: me.execute, disabled:true});
        me.callParent([config]);
    },

    /**
     * Handler for BaseAction
     */
    execute: function() {

    },

    /**
     * Subscribe to events for enabling/disabling actions
     * @param widgetId  Viewer Widget ID
     */
    subscribeEvts: function (widgetId) {
        if (xcp.event) {
            var e = xcp.event.EventBus;

            e.subscribe(widgetId + '.enableAll', this.enableMe, this, null);
            e.subscribe(widgetId + '.disableAll', this.disableMe, this, null);

            if (!(this instanceof xcp.action.page.ReorderAction))
                e.subscribe(widgetId + '.reorderPages', this.disableMe, this, null);

            if ((this instanceof xcp.action.page.RemoveAction) || (this instanceof xcp.action.page.ReorderAction))
                e.subscribe(widgetId + '.singlePage', this.disableMe, this, null);
        }
    },

    /**
     * Disable Action
     * @param evt  Event that triggered state change
     */
    disableMe: function(evt) {
        this.disable();
    },

    /**
     * Enable Action
     * @param evt  Event that triggered state change
     */
    enableMe: function(evt) {
        this.enable();
    },

    /**
     * Version Information FieldSet displayed in confirmation dialog
     */
    getVersionInformationFieldSet: function(label,widthIncr) {
        var viewerCmp = Ext.getCmp(this.widgetId),
                wid = this.widgetId,
                currentVersion = viewerCmp.versionLabel,
                minorVersion,
                majorVersion;

        var width = 400,
            textAreaWidth = 375;
        if (widthIncr != undefined){
            width+=  widthIncr;
            textAreaWidth +=widthIncr;
        }
        if(currentVersion.indexOf(',')!=-1)
        currentVersion = currentVersion.substring(0,currentVersion.indexOf(','));
        minorVersion = Math.floor(parseInt(currentVersion)) + "." + (parseInt(currentVersion.substring(currentVersion.indexOf('.') + 1)) + 1);
        majorVersion = (Math.floor(parseInt(currentVersion)) + 1).toFixed(1);

        var versionInfoField = {
            xtype:'fieldset',
            id:wid+'versFieldSet',
            width:width,
            title:xcp.Strings.widget.Viewer.versionInformationLabel,
            cls:'fieldSetStyle',
            layout:'anchor',
            items:[
                {xtype:'displayfield',fieldLabel:'',hideEmptyLabel:true,value:label,hidden:(label==""||label==undefined)},
                {xtype:'displayfield',fieldLabel:xcp.Strings.widget.Viewer.currentVersionLabel,labelSeparator:" :",labelWidth:110,value:currentVersion,cls:'alignField'},
                version = new Ext.form.RadioGroup({fieldLabel:xcp.Strings.widget.Viewer.newVersionLabel,labelSeparator:" :",labelWidth:110,columns:1,
                    items:[
                        {boxLabel:Ext.String.format(xcp.Strings.widget.Viewer.minorVersion, minorVersion),name:'versGrp',inputValue:1,checked:true},
                        {boxLabel:Ext.String.format(xcp.Strings.widget.Viewer.majorVersion, majorVersion),name:'versGrp',inputValue:2},
                        {boxLabel:Ext.String.format(xcp.Strings.widget.Viewer.currentVersion, currentVersion),name:'versGrp',inputValue:0}
                    ]
                }),
                {xtype: 'displayfield',fieldLabel: xcp.Strings.widget.Viewer.winCommentLabel,labelSeparator:" :",labelWidth:textAreaWidth},
                {xtype:'tbspacer',width:20},    
                comment = new Ext.form.field.TextArea(
                {
                    xtype: 'textareafield',
                    width: textAreaWidth,
                    height:95
                })
            ]
        }
        return versionInfoField;
    },

    validate:function(pageStr, widgetId) {
        //invalid charaters
        var validChars = "0123456789-, ";
        for (i = 0; i < pageStr.length; i++)
            if (!(validChars.indexOf(pageStr.charAt(i)) >= 0)) {
                return xcp.Strings.widget.Viewer.txtConstraintInvalidChar;

            }

        var viewer = ivfclient.getViewer(widgetId),
            totalPages;
        if (viewer) {
            totalPages = viewer.getPageCount();
        }

        //overlapping of pages
        var pageNums = xcp.util.IvfUtil.getPageNums(pageStr);
        for (i = 0; i < pageNums.length; i++) {
            if(pageNums[i]>totalPages)
                return xcp.Strings.widget.Viewer.txtConstraintInvalidPgNum;
            if (pageNums[i] == pageNums[i + 1]) {
                return xcp.Strings.widget.Viewer.txtConstraintOverlap;
            }
        }

        var extractDelCnd = true;               //in the case ExtractAction, only if checkbox is selected, we need to validate for deleting all pages.Variable extractDelCnd is set to true for all other actions.
        if (this instanceof xcp.action.page.ExtractAction)
            extractDelCnd = Ext.getCmp(widgetId + 'extDelChkbox').getValue();

        //deleting all pages
        if ((totalPages == 1 || pageStr == "1-" + totalPages || pageStr == "-" + totalPages || pageStr == "1-") && extractDelCnd) {
            return xcp.Strings.widget.Viewer.txtConstraintAllPages;
        }

        if (extractDelCnd)
            if (pageNums.length == totalPages) {
                for (i = 0; i < pageNums.length - 1; i++)
                    if (pageNums[i] + 1 != pageNums[i + 1]) {
                        return 'valid';
                    }
                return xcp.Strings.widget.Viewer.txtConstraintAllPages;
            }

        return 'valid';
    }

});

/* xcp_viewer/content/xcp/action/page/ExtractAction.js */

// ExtractAction.js

/**
 * @class xcp.action.page.ExtractAction
 * @extends xcp.action.page.BaseAction
 * Action implementation for extracting pages from a document in xCP Viewer.
 */
Ext.define("xcp.action.page.ExtractAction",{
    extend: "xcp.action.page.BaseAction",
    alias: "action.extractpgs",

    constructor: function(config) {
        Ext.apply(config, {iconCls: 'pg-extract', tooltip:xcp.Strings.widget.Viewer.extractPages, text: xcp.Strings.widget.Viewer.extractPages});
        this.callParent([config]);
    },

    /**
     * Handler for ExtractAction
     */
    execute: function() {
        xcp.util.IvfUtil.debug("Extract pages action invoked");
        var me = this;
        var wid;
        if (me.widgetId)
            wid = me.widgetId;
        else
            wid = me.baseAction.widgetId;

        var thmCmp = Ext.getCmp(wid + "_thmPanel"),
            viewerCmp = Ext.getCmp(wid),
            thisAction = thmCmp.actions.extract,
            pageStr = "";

        if (thmCmp) {
            var selModel = thmCmp.selModel;
            var pageNums = [],
                selectedPages = (selModel.selected.items.length > 0 ) ? selModel.selected.items : selModel.selectionCache.items;
            for (i = 0; i < selectedPages.length; i++)
                pageNums[i] = selectedPages[i].data.pgno;
            pageStr = xcp.util.IvfUtil.selectedPagesStr(pageNums);
        }


        var stepsCfg = thisAction.getStepsCfg(wid, pageStr),
            btnCfg = thisAction.getBtnCfg(wid);

        var win = Ext.create('Ext.Window', {
            title: xcp.Strings.widget.Viewer.extWinTitle,
            iconCls:'ext_win',
            id:wid + "_extractWizard",
            width: 475,
            height: 510,
            layout: 'card',
            cls:'ext_win-body',
            bodyStyle: 'padding:5px',
            constrain:true,
            modal: true,
            resizable:false,
            defaults: {
                // applied to each contained panel
                border: false
            },
            buttons: btnCfg,
            // the panels within the layout
            items: stepsCfg
        });
        win.show();
        if (Ext.isIE)
          win.el.shim.dom.style.top = win.el.dom.style.top;
    },

    getStepsCfg: function(wid, pageStr) {
        Ext.apply(Ext.form.field.VTypes, {
            whitespace: function(val, field) {
                if (val == "" || (/^\s*$/).test(val))
                    return false;
                else
                    return true;
            }});


        var versionInformationField = (this.baseAction) ? this.baseAction.getVersionInformationFieldSet(xcp.Strings.widget.Viewer.extFieldSetText, 40) : this.getVersionInformationFieldSet(xcp.Strings.widget.Viewer.extFieldSetText, 40),
            versionFieldSet;

        var stepsCfg = [
            {
                id: wid + '_ext_step1',
                xtype:'panel',
                layout:'vbox',
                items:[
                    {xtype:'tbspacer',height:15},
                    {xtype:'displayfield',fieldLabel:xcp.Strings.widget.Viewer.extExtractFromLabel,labelSeparator:" :",labelWidth:140,value:Ext.getCmp(wid).config.objectName,hideEmptyLabel:false},
                    {xtype:'textfield',id:wid + 'extTxtField',fieldLabel:xcp.Strings.widget.Viewer.extExtractPagesLabel,labelSeparator:" :",labelWidth:140,width:430,value:pageStr,
                        regex:/^[0-9, -]*$/,
                        regexText:xcp.Strings.widget.Viewer.txtConstraintInvalidChar,
                        msgTarget:'under',
                        allowBlank:false,
                        blankText:xcp.Strings.widget.Viewer.extConstraintBlank,
                        vtype:'whitespace',
                        vtypeText:xcp.Strings.widget.Viewer.extConstraintBlank,
                        listeners:
                        {
                            errorChange:function(field,error,eOpts) {
                                var win = field.ownerCt.ownerCt,
                                    winHt = win.getHeight(),
                                    errorMsgHt =20;
                                error.length > 0 ? win.setHeight(winHt + errorMsgHt) : win.setHeight(winHt - errorMsgHt);
                                if (nextBtn)
                                    nextBtn.setDisabled(error.length>0);                          //disable next button when there is a validation error
                            }
                        }
                    },
                    {xtype:'displayfield',hideEmptyLabel:false,labelWidth:140,value:Ext.String.format(xcp.Strings.widget.Viewer.exampleText, "1,5,12-20"),disabled:true},
                    {xtype:'checkbox',id:wid + 'extDelChkbox',value:'false',boxLabel:xcp.Strings.widget.Viewer.extDelPagesChkBoxLabel, hideEmptyLabel:false,labelWidth:140,
                        handler:function(el, checked) {
                            if (checked) {
                                if (!Ext.getCmp(wid + 'versFieldSet'))
                                    Ext.getCmp(wid + '_ext_step1').add(versionInformationField);
                                else
                                    versionFieldSet.setVisible(true);
                            }
                            else {
                                (versionFieldSet = Ext.getCmp(wid + 'versFieldSet')).setVisible(false);
                                if (nextBtn && nextBtn.isDisabled() && Ext.getCmp(wid + 'extTxtField').activeError.indexOf(xcp.Strings.widget.Viewer.txtConstraintAllPages)!=-1) {
                                    nextBtn.setDisabled(false);
                                    Ext.getCmp(wid + 'extTxtField').clearInvalid();
                                }
                            }
                        }
                    }
                ],
                dockedItems:[
                    {
                        xtype:'toolbar',
                        type:'top',
                        height:20,
                        items:[
                            {xtype:'displayfield',value:xcp.Strings.widget.Viewer.extWizardStep1}
                        ]
                    }
                ]
            },
            {
                id: wid + '_ext_step2',
                xtype:'panel',
                layout:'vbox',
                items:[
                    {xtype:'tbspacer',height:15},
                    {xtype:'textfield',id:'newDocName',fieldLabel:xcp.Strings.widget.Viewer.extNewDocNameLabel,labelSeparator:" :",labelWidth:180,width:430,
                        listeners:
                        {
                            change:function(field, e) {
                                if (finishBtn)
                                    finishBtn.setDisabled(e == "" || (/^\s*$/).test(e) ? true : false);
                            }
                        }
                    }
                ],
                dockedItems:[
                    {
                        xtype:'toolbar',
                        type:'top',
                        height:20,
                        items:[
                            {xtype:'displayfield',value:xcp.Strings.widget.Viewer.extWizardStep2}
                        ]
                    }
                ]

            }
        ]
        return stepsCfg;
    },

    getBtnCfg: function(wid) {
        var viewerCmp = Ext.getCmp(wid),
            thmCmp = Ext.getCmp(wid + "_thmPanel"),
            thisAction = thmCmp.actions.extract;

        var parentCmp = viewerCmp.ownerCt,
            columnvbox = 'xcp_columnvbox';
        if ((parentCmp.id).indexOf(columnvbox) != -1)
            parentCmp = parentCmp.ownerCt;

        var objId = viewerCmp.config.objectId;

        var navigate = function(panel, direction) {
            var layout = panel.getLayout();
            layout[direction]();
            if (Ext.isIE)
                panel.el.shim.dom.style.top = panel.el.dom.style.top;
            Ext.getCmp(wid + 'ext_move_prev').setVisible(layout.getPrev());
            Ext.getCmp(wid + 'ext_move_next').setVisible(layout.getNext());
            Ext.getCmp(wid + 'ext_finish').setVisible(!layout.getNext())
        };

        var btnCfg = [
            '->', // greedy spacer so that the buttons are aligned to each side,
            {
                id:wid + 'ext_move_prev',
                text: Ext.String.format(xcp.Strings.widget.Viewer.extWizardBackButton, "<"),
                handler: function(btn) {
                    navigate(btn.up("panel"), "prev");
                },
                hidden: true
            },
            nextBtn = new Ext.button.Button({
                id: wid + 'ext_move_next',
                text: Ext.String.format(xcp.Strings.widget.Viewer.extWizardNextButton, ">"),
                handler: function(btn) {
                    var extTxtField = Ext.getCmp(wid + "extTxtField");
                    var pages = extTxtField.getValue();
                    if ((err = thisAction.validate(pages, wid)) != 'valid') {
                        extTxtField.markInvalid(err);
                        btn.setDisabled(true);
                        return;
                    }
                    navigate(btn.up("panel"), "next");
                }
            }),
            finishBtn = new Ext.button.Button({
                id: wid + 'ext_finish',
                text: xcp.Strings.widget.Viewer.extWizardFinishButton,
                disabled: true,
                handler: function(btn) {

                    var win = Ext.getCmp(wid + "_extractWizard"),
                        extTxtField = Ext.getCmp(wid + 'extTxtField'),
                        pageStr = extTxtField.getValue();

                    if (pageStr.indexOf('-') == 0)
                        pageStr = "1" + pageStr;

                    var viewer = ivfclient.getViewer(wid),
                        totalPages;
                    if (viewer) {
                        totalPages = viewer.getPageCount();
                    }

                    var removePages = Ext.getCmp(wid + 'extDelChkbox').getValue(),
                        newDocName = Ext.getCmp('newDocName').getValue();

                    if(viewer.m_pageExtractionUrl.length > 0)
                    {
                        var mask = new Ext.LoadMask(parentCmp, {msg:xcp.Strings.widget.Viewer.extLoadingMask});
                        mask.show();
                        xcp.util.IvfUtil.debug("Server call to extract pages " + pageStr + " from the document");
                        Ext.Ajax.request({
                            url:viewer.m_pageExtractionUrl,
                            timeout:300000,
                            method:'POST',
                            params:{pages:pageStr,pageCount:totalPages,removePages:removePages,versionOptions:version.lastValue.versGrp},
                            jsonData:{"attributes":[
                                {"name":"object_name","values":[newDocName]}
                            ],"objectType":"","targetFolder":"","versionComments":comment.getValue()},
                            scope:this,
                            success:function(response, opts) {
                                xcp.util.IvfUtil.debug("Pages extracted successfully");
                                if (removePages) {
                                    var objIds = Ext.decode(response.responseText).split(","),
                                        newObjectId = objIds[1];
                                    xcp.util.IvfUtil.debug("Reloading the document after deleting the extracted pages");
                                    if (xcp.event) {
                                        if (version.lastValue.versGrp == 1 || version.lastValue.versGrp == 2) {
                                            xcp.event.EventBus.publish(xcp.event.PageModEvent.NAME, newObjectId);                       //PageModEvent event refreshes the document view page
                                        }
                                        xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, viewerCmp.config.objectId);             //itemModified  event refreshes the ResultList
                                    }
                                    viewerCmp.config.objectId = newObjectId;
                                    viewerCmp.loadDocument();
                                }
                                else{
                                    if (xcp.event)
                                        xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, viewerCmp.config.objectId);
                                }
                                mask.hide();
                                xcp.core.FeedbackManager.showFeedback(null, "", Ext.String.format(xcp.Strings.widget.Viewer.extSuccessMsg, newDocName), "notifications");
                            },
                            failure:function(response, options) {
                                mask.hide();
                                viewerCmp.displayErrorMsg(xcp.Strings.widget.Viewer.extErr, response);
                            }
                        });


                        win.close();
                    }
                    else xcp.core.FeedbackManager.showFeedback(null, "", xcp.Strings.widget.Viewer.pageExtractionServiceUrl, "systemErrors", false);
                },
                hidden: true
            }),
            {
                text: xcp.Strings.widget.Viewer.extWizardCancelButton,
                handler: function(btn) {
                    var win = Ext.getCmp(wid + "_extractWizard");
                    win.close();
                }
            }
        ]
        return btnCfg;
    }

});

/* xcp_viewer/content/xcp/action/page/InsertAction.js */

// InsertAction.js

/**
 * @class xcp.action.page.InsertAction
 * @extends xcp.action.page.BaseAction
 * Action for inserting pages into a document in xCP Viewer.
 */
Ext.define("xcp.action.page.InsertAction", {
    extend: "xcp.action.page.BaseAction",
    alias: "action.insertpgs",

    constructor: function(config) {
        Ext.apply(config, {iconCls: 'pg-insert', tooltip:xcp.Strings.widget.Viewer.insertPages, text: xcp.Strings.widget.Viewer.insertPages});
        this.callParent([config]);
    },

    /**
     * Handler for InsertAction
     */
    execute: function() {
        xcp.util.IvfUtil.debug("Insert pages action invoked");
        var me = this;
        var wid;
        if (me.widgetId)
            wid = me.widgetId;
        else
            wid = me.baseAction.widgetId;

        var thmCmp = Ext.getCmp(wid + xcp.cmp.Thumbnail.THM_PANEL_ID);
        var thisAction = thmCmp.actions.insert;
        var viewerCmp = Ext.getCmp(wid);

        var selModel = thmCmp.selModel;
        var selRecords = (selModel.selected.length > 0) ? selModel.selected : selModel.selectionCache;
        var ary = [];
        for (var i = 0, len = selRecords.length; i < len; i++) {
            ary.push(selRecords.items[i]);
        }
        selRecords = ary;
        //Sort records and get the last pgno after which we will insert the new pgs
        if (selRecords.length > 1) {
            selRecords.sort(function(a, b) {
                return (a.data.pgno - b.data.pgno);
            });
        }
        var pagenum = selRecords[selRecords.length - 1].data.pgno;

        var items = thisAction.getItemsCfg(viewerCmp, wid, pagenum);
        var btns = thisAction.getBtnsCfg(viewerCmp, thmCmp, wid, pagenum);

        if (!win) {
            var win = new Ext.Window({
                id:wid + "_insertDialog",
                title: xcp.Strings.widget.Viewer.insertPages,
                iconCls:'ins_win',
                width: 475,
                height: 468,
                layout:{
                    type:'vbox',
                    padding:'12'
                },
                constrain:true,
                modal: true,
                resizable: false,
                items : items,
                buttons : btns
            });
        }
        win.show();
        var selectorWidget = Ext.getCmp('sel_wid');
        selectorWidget.el.dom.style.top =  (parseInt(selectorWidget.el.dom.style.top)-5) +"px";                         //vertically align selector widget
        if (Ext.isIE)
          win.el.shim.dom.style.top = win.el.dom.style.top;                                                             //In IE, shim was not getting set properly

    },

    getItemsCfg: function(viewerCmp, widgetId, insertAt) {
        var viewer = ivfclient.getViewer(widgetId),
            totalPages;
        if (viewer) {
            totalPages = viewer.getPageCount();
        }
        var versionInformationField = (this.baseAction) ? this.baseAction.getVersionInformationFieldSet(xcp.Strings.widget.Viewer.insFieldSetText,20) : this.getVersionInformationFieldSet(xcp.Strings.widget.Viewer.insFieldSetText,40);
        var spacer = { xtype:'tbspacer',width:8};
        var itemsCfg = [
            {   xtype:'fieldcontainer',
                width:400,
                frame:false,
                defaultType: 'displayfield',
                layout:'hbox',
                items:[{value:xcp.Strings.widget.Viewer.insInsertFromLabel+" :"},
                       { xtype:'tbspacer',width:55},
                       {
                           xtype:'xcp_selector',id:'sel_wid',bodyStyle:{top:'-5px'},
                           wizardConfig:{modal:true},
                           fromRepository:true,actionFlowId:"xcp_selector_content",
                           displayField : "object_name",objectType:"xcp_dm_document",
                           extraParams : {"contenttype":viewerCmp.config.contentType},
                           listeners:
                           {
                               change:function(field, value, oldValue) {
                                   if (okBtn)
                                       okBtn.setDisabled( !( value != null && value != "" ) );
                               }
                           }
                       }
                ]
            },
            {
                xtype:'radiofield',
                fieldLabel:xcp.Strings.widget.Viewer.insInsertPagesLabel,
                labelSeparator:" :",
                boxLabel:xcp.Strings.widget.Viewer.insBeforeFirstLabel,
                labelWidth:110,
                name:'insGrp',
                inputValue:0,
                id:'radio_insBefore'
            },
            {
                xtype: 'fieldcontainer',
                width:400,
                frame:false,
                defaultType: 'displayfield',
                layout: 'hbox',
                items: [
                    {
                        xtype:'tbspacer',
                        width:115
                    },
                    {   xtype:'radiofield',
                        name      : 'insGrp',
                        checked : true,
                        inputValue: 1,
                        id        : 'radio_insAfter'
                    },
                    {xtype:'tbspacer',width:5},
                    {value: xcp.Strings.widget.Viewer.insAfterPageLabel,id : 'afterpg'},
                    spacer,
                    {
                        xtype     : 'textfield',
                        id        : 'insAtTxtField',
                        width:30,
                        value     : insertAt,
                        regex:/^[0-9]*$/,
                        regexText:xcp.Strings.widget.Viewer.txtConstraintInvalidChar,
                        listeners:
                        {
                            change:function(field, e) {
                                if (okBtn)
                                    okBtn.setDisabled(false);
                            }
                        }
                    },
                    spacer,
                    {value:xcp.Strings.widget.Viewer.insOfLabel,id: 'of'},
                    spacer,
                    {value:totalPages}
                ]
            },

            versionInformationField
        ];
        return itemsCfg;
    },

    getBtnsCfg: function(viewerCmp, thmCmp, widgetId, pageIndex) {
        var me=this,
            viewer = ivfclient.getViewer(widgetId),
            totalPages;
        if (viewer) {
            totalPages = viewer.getPageCount();
        }
        var parentCmp = viewerCmp.ownerCt,
            columnvbox = 'xcp_columnvbox';
        if ((parentCmp.id).indexOf(columnvbox) != -1)
            parentCmp = parentCmp.ownerCt;
        var objId = viewerCmp.config.objectId;

        btnCfg = [
            okBtn = new Ext.button.Button(
                {text: xcp.Strings.widget.Viewer.okButton,
                    handler:function() {
                        var win = Ext.getCmp(widgetId + "_insertDialog"),
                            selectorWidget =  Ext.getCmp('sel_wid'),
                            srcObjID = selectorWidget.getValue(),
                            srcObjectName =  selectorWidget.selectedRecord.data.object_name,
                            insertAt;
                        if (Ext.getCmp('radio_insBefore').getValue() == true)
                            insertAt = 0;
                        else {
                            var insertAtField = Ext.getCmp('insAtTxtField');
                            insertAt = insertAtField.getValue();
                            if (!me.validate(insertAt, totalPages)) {
                                insertAtField.markInvalid(xcp.Strings.widget.Viewer.txtConstraintInvalidPgNum);
                                okBtn.setDisabled(true);
                                return;
                            }
                        }
                        if(viewer.m_pageInsertionUrl.length > 0)
                        {
                            var mask = new Ext.LoadMask(parentCmp, {msg:xcp.Strings.widget.Viewer.insLoadingMask});
                            mask.show();
                            var insertPagesUrl = viewer.m_pageInsertionUrl + "&pageCount=" + totalPages + "&pageIndex=" + insertAt + "&srcObjectId="+srcObjID+ "&versionOptions="+version.lastValue.versGrp + "&comments=" + comment.getValue();
                            xcp.util.IvfUtil.debug("Server call to insert pages from the document");
                            Ext.Ajax.request({
                                url:insertPagesUrl,
                                timeout:300000,
                                scope:this,
                                success:function(response, opts) {
                                    xcp.util.IvfUtil.debug("Pages inserted successfully");
                                    var newObjectId = Ext.decode(response.responseText);
                                    mask.hide();
                                    xcp.util.IvfUtil.debug("Reloading the document with changes");
                                    if (xcp.event) {
                                        if (version.lastValue.versGrp == 1 || version.lastValue.versGrp == 2) {
                                            xcp.event.EventBus.publish(xcp.event.PageModEvent.NAME, newObjectId);                   //PageModEvent event refreshes the document view page
                                        }
                                        xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, viewerCmp.config.objectId);         //itemModified  event refreshes the ResultList
                                    }
                                    thmCmp.selModel.selectionCache = pageIndex;
                                    viewerCmp.config.objectId = newObjectId;
                                    viewerCmp.loadDocument();
                                    xcp.core.FeedbackManager.showFeedback(null, "", Ext.String.format(xcp.Strings.widget.Viewer.insSuccessMsg,srcObjectName), "notifications");
                                },
                                failure:function(response, options) {
                                    mask.hide();
                                    viewerCmp.displayErrorMsg(xcp.Strings.widget.Viewer.insErr, response);
                                }
                            });
                            win.close();
                        }
                        else xcp.core.FeedbackManager.showFeedback(null, "", xcp.Strings.widget.Viewer.pageInsertionServiceUrl, "systemErrors", false);
                    },
                    disabled: true
                }),
            {xtype: 'button',text: xcp.Strings.widget.Viewer.cancelButton,
                handler:function() {
                    var win = Ext.getCmp(widgetId + "_insertDialog");
                    win.close();
                    if (thmCmp)
                        thmCmp.getView().focus();
                }}];
        return btnCfg;
    },

    validate: function(pageIndex, totalPages) {
        var validChars = "0123456789";
        for (i = 0; i < pageIndex.length; i++)
            if (!(validChars.indexOf(pageIndex.charAt(i)) >= 0)) {
                return false;
            }
        if (parseInt(pageIndex) > parseInt(totalPages))
            return false;
        return true;
    }

});

/* xcp_viewer/content/xcp/action/page/RemoveAction.js */

// RemoveAction.js

/**
 * @class xcp.action.page.RemoveAction
 * @extends xcp.action.page.BaseAction
 * Action implementation for removing pages from a document in xCP Viewer.
 */
Ext.define("xcp.action.page.RemoveAction",{
    extend: "xcp.action.page.BaseAction",
    alias: "action.removepgs",

    constructor: function(config) {
        Ext.apply(config, {iconCls: 'pg-delete', tooltip:xcp.Strings.widget.Viewer.removePages, text: xcp.Strings.widget.Viewer.removePages + "<span style='margin-left: 30px'>" + xcp.Strings.widget.Viewer.removeKBShortcut + "</span>"});
        this.callParent([config]);
    },

    /**
     * Handler for RemoveAction
     */
    execute: function(wId) {
        xcp.util.IvfUtil.debug("Remove pages action invoked");
        var me = this;
        var widgetId;
        if (me.baseAction)
            widgetId = me.baseAction.widgetId;
        else
            widgetId = wId;

        var thmCmp = Ext.getCmp(widgetId + xcp.cmp.Thumbnail.THM_PANEL_ID),
                pageStr = "",
                viewerCmp = Ext.getCmp(widgetId);

        var thisAction = thmCmp.actions.remove;
        if (thmCmp) {
            var selModel = thmCmp.selModel;
            var pageNums = [],
                selectedPages = (selModel.selected.items.length > 0 ) ? selModel.selected.items : selModel.selectionCache.items;
            for (i = 0; i < selectedPages.length; i++)
                pageNums[i] = selectedPages[i].data.pgno;
            pageStr = xcp.util.IvfUtil.selectedPagesStr(pageNums);
        }

        var itemsCfg = thisAction.getItemsCfg(pageStr),
            btnCfg = thisAction.getBtnCfg(widgetId,pageStr);

        if (!win) {
            var win = new Ext.Window({
                        id:widgetId+"_removeDialog",
                        title: xcp.Strings.widget.Viewer.delWinTitle,
                        iconCls:'del_win',
                        width: 435,
                        height: 408,
                        layout:{
                            type:'vbox',
                            padding:'12'
                        },
                        constrain:true,
                        modal: true,
                        resizable: false,
                        items : itemsCfg,
                        buttons : btnCfg
                    });
        }
        win.show();
        if (Ext.isIE)
          win.el.shim.dom.style.top = win.el.dom.style.top;

    },

    getItemsCfg : function(pageStr) {
        Ext.apply(Ext.form.field.VTypes, {
            whitespace: function(val, field) {
                if (val == "" || (/^\s*$/).test(val))
                    return false;
                else
                    return true;
        }});

        var me=this;
        var versionInformationField = (me.baseAction) ? me.baseAction.getVersionInformationFieldSet() : me.getVersionInformationFieldSet();
        var itemsCfg = [
            {xtype: 'textfield',id:'delWinTxtField',fieldLabel: xcp.Strings.widget.Viewer.delWinTextFieldLabel,labelAlign:'left',labelWidth:120,labelSeparator:" :",width:395,value:pageStr,
                regex:/^[0-9, -]*$/,
                regexText:xcp.Strings.widget.Viewer.txtConstraintInvalidChar,
                msgTarget:'under',
                allowBlank:false,
                blankText:xcp.Strings.widget.Viewer.delConstraintBlank,
                vtype:'whitespace',
                vtypeText:xcp.Strings.widget.Viewer.delConstraintBlank,
                listeners:
                {
                    errorChange:function(field,error,eOpts) {
                        var win = field.ownerCt,
                            winHt = win.getHeight(),
                            errorMsgHt =20;
                        error.length > 0 ? win.setHeight(winHt + errorMsgHt) : win.setHeight(winHt - errorMsgHt);
                        if (okBtn)
                            okBtn.setDisabled(error.length>0);                          //disable ok button when there is a validation error
                    }
                }
            },
            {xtype:'displayfield',hideEmptyLabel:false,labelWidth:120,value:Ext.String.format(xcp.Strings.widget.Viewer.exampleText, "1,5,12-20"),disabled:true},
            versionInformationField
        ]
        return itemsCfg;
    },

    getBtnCfg : function(widgetId,pageStr) {
        var viewerCmp = Ext.getCmp(widgetId),
            thmCmp = Ext.getCmp(widgetId+xcp.cmp.Thumbnail.THM_PANEL_ID),
            thisAction = thmCmp.actions.remove;

        var parentCmp = viewerCmp.ownerCt,
                columnvbox = 'xcp_columnvbox';
        if ((parentCmp.id).indexOf(columnvbox) != -1)
            parentCmp = parentCmp.ownerCt;
        var objId = viewerCmp.config.objectId;

        var btnCfg = [
            okBtn = new Ext.button.Button(
                {text: xcp.Strings.widget.Viewer.okButton,
                    disabled:(pageStr == "" || pageStr == "undefined") ? true : false,
                    handler:function() {
                        var win = Ext.getCmp(widgetId+"_removeDialog"),
                            delTxtField = Ext.getCmp('delWinTxtField'),
                            pageStr = delTxtField.getValue();
                        if ((err = thisAction.validate(pageStr, widgetId)) != 'valid') {
                            delTxtField.markInvalid(err);
                            okBtn.setDisabled(true);
                            return;
                        }
                        if (pageStr.indexOf('-') == 0)
                            pageStr = "1" + pageStr;

                        var viewer = ivfclient.getViewer(widgetId),
                            totalPages;
                        if (viewer) {
                            totalPages = viewer.getPageCount();
                        }

                        if(viewer.m_pageDeletionUrl.length > 0)
                        {
                            var mask = new Ext.LoadMask(parentCmp, {msg:xcp.Strings.widget.Viewer.delLoadingMask});
		                    mask.show();
                            var delPagesUrl = viewer.m_pageDeletionUrl + "&pages=" + pageStr + "&pageCount=" + totalPages + "&versionOptions=" + version.lastValue.versGrp + "&comment=" + comment.getValue();
                            xcp.util.IvfUtil.debug("Server call to delete pages " + pageStr + " from the document");
                            Ext.Ajax.request({
                                url:delPagesUrl,
                                timeout:300000,
                                scope:this,
                                success:function(response, opts) {
                                    xcp.util.IvfUtil.debug("Pages deleted successfully");
                                    var newObjectId = Ext.decode(response.responseText);
                                    mask.hide();
                                    xcp.util.IvfUtil.debug("Reloading the document with changes");
                                    if (xcp.event) {
                                        if (version.lastValue.versGrp == 1 || version.lastValue.versGrp == 2) {
                                            xcp.event.EventBus.publish(xcp.event.PageModEvent.NAME, newObjectId);                   //PageModEvent event refreshes the document view page
                                        }
                                        xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, viewerCmp.config.objectId);         //itemModified  event refreshes the ResultList
                                    }
                                    viewerCmp.config.objectId = newObjectId;
                                    viewerCmp.loadDocument();
                                    xcp.core.FeedbackManager.showFeedback(null, "", xcp.Strings.widget.Viewer.delSuccessMsg, "notifications");
                                },
                                failure:function(response, options) {
                                    mask.hide();
                                    viewerCmp.displayErrorMsg(xcp.Strings.widget.Viewer.delErr, response);
                                }
                            });
                            win.close();
                        }
                        else xcp.core.FeedbackManager.showFeedback(null, "", xcp.Strings.widget.Viewer.pageDeletionServiceUrl, "systemErrors", false);
                    }}),
            {xtype: 'button',text: xcp.Strings.widget.Viewer.cancelButton,
                handler:function() {
                    var win = Ext.getCmp(widgetId+"_removeDialog");
                    win.close();
                    if (thmCmp)
                        thmCmp.getView().focus();
                }}]
        return btnCfg;
    }

});

/* xcp_viewer/content/xcp/action/page/ReorderAction.js */

// ReorderAction.js

/**
 * @class xcp.action.page.ReorderAction
 * @extends xcp.action.page.BaseAction
 * Action implementation for reordering pages within a document in xCP Viewer.
 */
Ext.define("xcp.action.page.ReorderAction",{
    extend: "xcp.action.page.BaseAction",
    alias: "action.reorderpgs",

    constructor: function(config) {
        Ext.apply(config, {iconCls: 'pg-move', tooltip:xcp.Strings.widget.Viewer.reorderPages, text:xcp.Strings.widget.Viewer.movePages});
        this.callParent([config]);
    },

   /**
     * Handler for ReorderAction
     */
   execute: function(ctrl) {
       xcp.util.IvfUtil.debug("Reorder pages action invoked");
       var me = this;
       var wid;
       if (me.widgetId)
           wid = me.widgetId;
       else
           wid = me.baseAction.widgetId;

       var thmCmp = Ext.getCmp(wid + xcp.cmp.Thumbnail.THM_PANEL_ID);
       if(xcp.event)
       xcp.event.EventBus.publish(wid + '.reorderPages', null);

       //Action was called by Right click context menu
       thmCmp.reorderByCtxMenu = (ctrl && ctrl.getXType() == 'menuitem') ? true : false;
       var thisAction = thmCmp.actions.reorder;

       if (thmCmp.reorderByCtxMenu) {
           (thmCmp.view).addCls(thmCmp.reordCursor);
           // Remember records to be moved
           thisAction.selRecords = thmCmp.selModel.getSelection();
       }

       var topBar = Ext.getCmp(wid + xcp.cmp.Thumbnail.REORD_MODE_ID);
       if (!topBar.isVisible()){
           topBar.setVisible(true);
            xcp.util.IvfUtil.debug("Thumbnail panel is in reorder mode");
       }

       // Disable Apply btn if no reorder is made
       topBar.items.items[0].setDisabled(!thmCmp.reordered);
       thmCmp.ownerCt.setTitle("<span style='width:150px;text-align:left;left:55px;position:relative;'>"+xcp.Strings.widget.Viewer.reorderPages+"</span>");
   },

    //Show Reorder Confirmation dialog
    showDialog: function() {
        var me = this;
        var widgetId = me.widgetId;
        var thmCmp = Ext.getCmp(widgetId + xcp.cmp.Thumbnail.THM_PANEL_ID);
        var viewerCmp = Ext.getCmp(widgetId);
        var viewer = ivfclient.getViewer(widgetId);

        var parentCmp = viewerCmp.ownerCt,
                objId = viewerCmp.config.objectId;

        if ((parentCmp.id).indexOf('xcp_columnvbox') != -1)
            parentCmp = parentCmp.ownerCt;

        var itemsCfg = [
            {xtype: 'displayfield',value: xcp.Strings.widget.Viewer.reordWinDisplayFieldLabel},
            {xtype: 'tbspacer', height:10},
            me.getVersionInformationFieldSet()
        ],
            btnCfg = [
                    okBtn = new Ext.button.Button({text: xcp.Strings.widget.Viewer.okButton,
                                handler:function() {
                                    if(viewer.m_pageReorderUrl.length > 0)
                                    {
                                        var mask = new Ext.LoadMask(parentCmp, {msg:xcp.Strings.widget.Viewer.reordLoadingMask});
                                        mask.show();
                                        var pgNums = getReorderedPgNums();
                                        xcp.util.IvfUtil.debug("Server call to reorder pages in the order:"+pgNums);
                                        Ext.Ajax.request({
                                                    url:viewer.m_pageReorderUrl,
                                                    timeout:300000,
                                                    method:'POST',
                                                    params:{pages:pgNums,versionOptions:version.lastValue.versGrp,comment:comment.getValue()},
                                                    scope:this,
                                                    success:function(response, opts) {
                                                        xcp.util.IvfUtil.debug("Pages reordered successfully");
                                                        var newObjectId = Ext.decode(response.responseText);
                                                        mask.hide();
                                                        Ext.getCmp(widgetId + xcp.cmp.Thumbnail.REORD_MODE_ID).setVisible(false);
                                                        thmCmp.ownerCt.setTitle('');
                                                        xcp.util.IvfUtil.debug("Reloading the document with changes");
                                                        if (xcp.event) {
                                                            if (version.lastValue.versGrp == 1 || version.lastValue.versGrp == 2) {
                                                                xcp.event.EventBus.publish(xcp.event.PageModEvent.NAME, newObjectId);                   //PageModEvent event refreshes the document view page
                                                            }
                                                            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, viewerCmp.config.objectId);         //itemModified  event refreshes the ResultList
                                                        }
                                                        viewerCmp.config.objectId = newObjectId;
                                                        viewerCmp.loadDocument();
                                                        xcp.core.FeedbackManager.showFeedback(null, "", xcp.Strings.widget.Viewer.reordSuccessMsg, "notifications");
                                                    },
                                                    failure:function(response, options) {
                                                        mask.hide();
                                                        viewerCmp.displayErrorMsg(xcp.Strings.widget.Viewer.reordErr, response);
                                                    }
                                                });
                                        win.close();
                                    }
                                    else xcp.core.FeedbackManager.showFeedback(null, "", xcp.Strings.widget.Viewer.pageReorderServiceUrl, "systemErrors", false);
                                }}),
                    {xtype: 'button',text: xcp.Strings.widget.Viewer.cancelButton,
                        handler:function() {
                            win.close();
                            thmCmp.getView().focus();
                        }}
                ];

        var win = new Ext.Window({
            id:widgetId + "_reordDialog",
            title: xcp.Strings.widget.Viewer.reorderPages,
            iconCls:'reord_win',
            width: 435,
            height: 393,
            layout:{
                type:'vbox',
                padding:'12'
            },
            constrain:true,
            modal: true,
            resizable: false,
            items : itemsCfg,
            buttons : btnCfg
        });

        win.show();
        if (Ext.isIE)
          win.el.shim.dom.style.top = win.el.dom.style.top;

        //returns reordered page numbers from reorder cache
        function getReorderedPgNums() {
            var storeData = thmCmp.store.reordCache.data.items,
                pgno,
                len,
                pgNos = "",
                totalPages = thmCmp.store.proxy.extraParams.total;
            i = 0;
            if ((len = storeData.length) > totalPages)
                len = totalPages;
            for (i = 0; i < len - 1; i++) {
                pgno = storeData[i].data.pgno.toString();
                if (pgno.indexOf('dummy') != -1)                                  //if dummy rec is found, set orginial page number
                    pgNos += ((i + 1) + ",");
                else
                    pgNos += (pgno + ",");
            }
            pgno = storeData[i].data.pgno.toString();
            pgNos += (pgno.indexOf('dummy') != -1) ? (i + 1) : pgno;
            if (len < totalPages){                                               //entire range of page numbers of the doc need to be sent to the reorder service.
                pgNos += ",";                                                    //if the pages were not fetched into store, set pgNos with original page number
                for (i = len + 1; i < totalPages; i++)
                    pgNos += i + ",";
                pgNos += totalPages;
            }
            return pgNos;
        }
    },

    // Method which initiates reorders of thumbnails
    doReorder: function(gesture) {
        var thmCmp = Ext.getCmp(this.widgetId + xcp.cmp.Thumbnail.THM_PANEL_ID);
        var store = thmCmp.store;
        var selRecords = thmCmp.selModel.getSelection();
        var selRecordsInReordCache = [];
        var index,
                firstSelRecIndexInReordCache;

        if (gesture == 'ctxMenu-after' || gesture == 'ctxMenu-before') {
            // Use the records we already selected for Move
            selRecords = this.selRecords;
        }

        selRecords.sort(function(a, b) {
            return (store.reordCache.findExact('pgno', a.data.pgno) - store.reordCache.findExact('pgno', b.data.pgno));
        });

        selRecordsInReordCache = store.reordCache.getCacheRecords(selRecords);
        firstSelRecIndexInReordCache = store.reordCache.indexOf(selRecordsInReordCache[0]);

        if (gesture == 'ctxMenu-after' || gesture == 'ctxMenu-before') {
            // Use the records we already selected for Move
            var rowAtInsertionPt = thmCmp.selModel.selected.items[0];
            index = store.indexOf(rowAtInsertionPt);

            // Insertion row should be different than the rows selected for Move
            for (var i = 0; i < selRecords.length; i++) {
                if (store.indexOf(selRecords[i]) == index)
                    return;
            }
            this.doReorderByCtxMenu(gesture, thmCmp, selRecords, selRecordsInReordCache);
        }
        else
            this.doReorderByCtrlUpDown(gesture, thmCmp, selRecords, selRecordsInReordCache);


        store.reordCache.reorderIndex(firstSelRecIndexInReordCache, selRecordsInReordCache);                           //reorder the internal index of first rec if the index is not 0.
        (thmCmp.view).removeCls(thmCmp.reordCursor);
        thmCmp.reordered = true;
    },

    // Method which reorders thumbnails by Insert before/after
    doReorderByCtxMenu: function(gesture, thmCmp, selRecords, selRecordsInReordCache) {
        var storeIndex, storeInsertionIndex, cacheIndex, cacheInsertionIndex;
        var store = thmCmp.store;
        var rec =  thmCmp.selModel.selected.items[0];

        store.removeRecords(selRecords, selRecordsInReordCache);
        //Recompute index after removing rows
        storeIndex = store.indexOf(rec);
        cacheIndex = store.reordCache.findExact('pgno', rec.data.pgno);
        storeInsertionIndex = (gesture == 'ctxMenu-after') ? (storeIndex + 1) : storeIndex;
        cacheInsertionIndex = (gesture == 'ctxMenu-after') ? (cacheIndex + 1) : cacheIndex;
        store.insertRecords(storeInsertionIndex, selRecords, cacheInsertionIndex, selRecordsInReordCache);

        thmCmp.selModel.select(selRecords);
        thmCmp.selModel.selectionCache = thmCmp.selModel.selected.clone();
        thmCmp.reorderByCtxMenu = false;
        this.disableApplyBtn(false);
    },

    // Method which reorders thumbnails by Ctrl Up/Down
    doReorderByCtrlUpDown: function (gesture, thmCmp, selRecords, selRecordsInReordCache)
    {
        var storeIndex, storeInsertionIndex, cacheIndex, cacheInsertionIndex;
        var store = thmCmp.store;
        if (gesture == 'ctrl-up') {
            storeIndex = store.indexOf(selRecords[0]);
            //cannot move above the first record
            if (storeIndex == 0)
                return;
            storeInsertionIndex = storeIndex - 1;
            cacheIndex = store.reordCache.indexOf (selRecordsInReordCache[0]);
            cacheInsertionIndex = cacheIndex - 1;
        }
        else {
            storeIndex = store.indexOf(selRecords[selRecords.length - 1]);
            //cannot move beyond the last record
            if (storeIndex == store.proxy.extraParams.total - 1)
                return;
            storeInsertionIndex = (storeIndex - selRecords.length) + 2;
            cacheIndex = store.reordCache.indexOf(selRecordsInReordCache[selRecordsInReordCache.length - 1]);
            cacheInsertionIndex = (cacheIndex - selRecordsInReordCache.length) + 2;
        }

        store.removeRecords(selRecords, selRecordsInReordCache);
        store.insertRecords(storeInsertionIndex, selRecords, cacheInsertionIndex, selRecordsInReordCache);

        thmCmp.reorderByCtrlUpDown = true;
        thmCmp.selModel.select(selRecords);
        thmCmp.getView().focus();
        // Cancel any reorder by ctx menu op if initiated
        thmCmp.reorderByCtxMenu = false;

    },

    // Cancel the Reorder By Context Menu op
    cancel: function() {
        var thmCmp = Ext.getCmp(this.widgetId + xcp.cmp.Thumbnail.THM_PANEL_ID);
        (thmCmp.view).removeCls(thmCmp.reordCursor);
        thmCmp.reorderByCtxMenu = false;
    },

    /* Enable/Disable Apply btn in Reorder Mode 'Top Bar'
     * disable: true - Enable
     * disable: false - Disable
     */
    disableApplyBtn: function(disable)
    {
        var topBar = Ext.getCmp(this.widgetId + xcp.cmp.Thumbnail.REORD_MODE_ID);
        topBar.items.items[0].setDisabled(disable);
    }
});

/* ivf_acrobatreader_lib/content/xcp/viewer/impl/AcrobatReader.js */

Ext.define('xcp.viewer.impl.AcrobatReader', {
    extend: 'xcp.viewer.impl.ViewerObject',
    constructor:function(elementId) {
        var config = {};
        this.elementId = config.elementId = elementId;
        config.providerName = "AcrobatReader";
        this.callParent([config]);
    }
});Ext.namespace("xcp.Strings.viewer.impl.AXViewer");

Ext.apply(xcp.Strings.viewer.impl.AXViewer, {
    importDocumentLabel : "Display local file",
    uploadLocalFileLabel : "Upload local file",
    exportDocumentLabel : "Export document",
    printDocumentLabel : "Print document",
    printPageLabel : "Print page",
    pageCountSeparatorLabel :"/",
    prevPageLabel   :"Previous page",
    goToPageLabel   :"Go to page",
    nextPageLabel   :"Next Page",
    fitToWidthLabel :"Fit to width",
    fitToHeightLabel:"Fit to height",
    zoomInLabel     :"Zoom in",
    zoomOutLabel    :"Zoom out",
    rotateLeftLabel :"Rotate left",
    rotateRightLabel:"Rotate right",
    annotationDisplayOptions:"Annotation display options",
    currentUserAnnotations:"Show Mine",
    allUserAnnotations:"Show All",
    hideAnnotations:"Show None",
    annoSelectLabel:"Select",
    annoTextLabel:"Text",
    annoNoteLabel:"Note",
    annoHighlightLabel: "Highlight",
    annoLineLabel: "Straight",
    annoFreehandLabel: "Freehand",
    annoArrowLabel: "Arrow",
    annoRectangleLabel: "Rectangle",
    annoRoundedRectangleLabel: "Rounded",
    annoOvalLabel: "Oval",
    annoPolygonLabel: "Polygon",
    annoPolylineLabel: "Polyline",
    annoRubberstampsLabel: "Rubber stamps",
    annoEraserLabel: "Eraser",
    annoNoFillLabel: "No Fill",
    annoLineWidthLabel: "Line width",
    annoColorLabel: "Color",
    annoBackgroundColorLabel: "Background color",
    annoSelectAllLabel: "Select all",
    annoDeleteLabel: "Delete",
    annoUndoLabel: "Undo",
    annoSaveLabel:"Save",
    annoLineMenuLabel: "Lines",
    annoShapesMenuLabel:"Shapes",
    lineWidthPickerDialogTitle: "Line Width Picker",
    colorPickerDialogTitle: "Color Picker",
    printAuditTrailAjaxError: "Failed to generate audit trail entry for print",
    exportAuditTrailAjaxError: "Failed to generate audit trail entry for export",
    unsavedAnnoTitle: "Save modified annotations?",
    saveAnnoMsg: "You are navigating away from a document that has unsaved annotations. Would you like to save your changes?",
    saveAnnoBtn: "Save",
    noSaveAnnoBtn: "Don't save"
})

/* ivf_axviewer_lib/content/xcp/viewer/impl/AXViewer.js */

Ext.define('xcp.viewer.impl.AXViewer', {
    extend: 'xcp.viewer.impl.ViewerObject',
    statics:{
        Event_ControlInitialized : 1,
        Event_URLFailed : 2,
        Event_PrintJobSubmitted : 3,
        Event_DocumentExported : 4,
        Event_Pagination : 5,
        Event_AnnoNotification : 6,
        AnnoModified: 1,
        AnnoTool_Select : -1,
        AnnoTool_Note : 0,
        AnnoTool_Text : 1,
        AnnoTool_Highlight : 2,
        AnnoTool_Freehand : 3,
        AnnoTool_Line : 4,
        AnnoTool_Arrow : 5,
        AnnoTool_Rectangle : 6,
        AnnoTool_RoundedRectangle : 7,
        AnnoTool_Polygon : 8,
        AnnoTool_Oval : 9,
        AnnoTool_Polyline : 10,
        AnnoTool_Rubberstamp : 11,
        AnnoTool_Eraser : 12,
        AnnoToolbar_ID:"_AXAnnoToolbar",
        ImageToolbar_ID:"_AXImgToolbar",
        AXToolbar:"_AXToolbar"
    },
    constructor:function(elementId) {
        var config = {};
        this.m_thumbnailInitialized = false;
        this.elementId = config.elementId = elementId;
        config.providerName = "AXViewer";
        this.callParent([config]);
    },
    preRender : function(json) {
        var html = "";
        var isIE = (navigator.appVersion.indexOf("MSIE") != -1);
        var isWindows = (navigator.appVersion.toLowerCase().indexOf("win") != -1);
        var isOpera = (navigator.userAgent.indexOf("Opera") != -1);
        var widgetId = this.getWidgetId();

        var enable = isIE && isWindows && !isOpera;
        
        var extToolbarHandler = widgetId+"AXInitEvt";

        if (enable) {
            html += "<div id='" + widgetId + "_AXToolbar'>";
            html += "\<img id='" + widgetId + "_img' src='" + Ext.BLANK_IMAGE_URL + "' height='0' width='0' onload='" + extToolbarHandler + "()'/>";
            html += "</div>";
        }

        html += "<div id='" + widgetId + "_AXView' style='width:100%; height:90%'>";
        if(enable)
        {
            var viewerId = this.m_elementId;
            html += renderScripts(widgetId, viewerId);
        }
        return html;

        function renderScripts(widgetId, viewerId)
        {
            var scripts = "";

            scripts += "<script type='text/javascript' for='" + viewerId + "' event='OnPageCountChanged(pageCount)'>";
            scripts += "ivfclient.getViewer('"+widgetId+"').handleViewerEvent(xcp.viewer.impl.AXViewer.Event_ControlInitialized, pageCount);";
            scripts += "<\/script>";

            scripts += "<script type='text/javascript' for='" + viewerId + "' event='OnURLError(url, errorCode, componentType)'>";
            scripts += "ivfclient.getViewer('" + widgetId + "').handleViewerEvent(xcp.viewer.impl.AXViewer.Event_URLFailed, url);";
            scripts += "<\/script>";

            scripts += "<script type='text/javascript' for='" + viewerId + "' event='OnPrinted(min, max)'>";
            scripts += "var eventData = min + ',' + max;";
            scripts += "ivfclient.getViewer('" + widgetId + "').handleViewerEvent(xcp.viewer.impl.AXViewer.Event_PrintJobSubmitted, eventData);";
            scripts += "<\/script>";

            scripts += "<script type='text/javascript' for='" + viewerId + "' event='OnExported(url, errorCode, componentType)'>";
            scripts += "ivfclient.getViewer('" + widgetId + "').handleViewerEvent(xcp.viewer.impl.AXViewer.Event_DocumentExported, url);";
            scripts += "<\/script>";

            scripts += "<script type='text/javascript' for='" + viewerId + "' event='OnAnnoNotification(notifyCode)'>";
            scripts += "ivfclient.getViewer('" + widgetId + "').handleViewerEvent(xcp.viewer.impl.AXViewer.Event_AnnoNotification, notifyCode);";
            scripts += "<\/script>";

            return scripts;
        }
    },
    postRender : function(json)
    {
        var widgetId = this.getWidgetId(),
            me = this;

        var scrollEvts = [
                { widgetId:'combobox',
                    widgetEvents: [{
                        eventName: 'expand',
                        evtHandlerFn: function(evtArgs, html, opts) {
                            var comp = opts;
                            if(comp) {
                                if (comp.collapse && typeof comp.collapse === 'function')
                                    comp.collapse();
                            }
                        }
                    }, { eventName: 'collapse',
                        evtHandlerFn: null
                    }]
                },
                { widgetId:'button, splitbutton',
                    widgetEvents: [{
                        eventName: 'show',
                        evtHandlerFn: function(evtArgs, html, opts) {
                            var comp = opts;
                            if(comp) {
                                if(comp.hide && typeof comp.hide === 'function')
                                    comp.hide();
                            }
                        }
                    }, {eventName: 'hide',
                        evtHandlerFn: null
                    }]
                }];

        var extToolbarHandler = widgetId + "AXInitEvt";
        window[extToolbarHandler] = function() {
            Ext.get(widgetId + '_img').remove();
            var panel = new Ext.panel.Panel({
                renderTo:widgetId + xcp.viewer.impl.AXViewer.AXToolbar,
                id:widgetId + xcp.viewer.impl.AXViewer.AXToolbar,
                width:'100%',
                height:72,
                cls:'toolbarBg',
                dockedItems:[
                    {
                        xtype:'toolbar',
                        plugins: [{
                            ptype: 'toolbarscroll',
                            widgetScrollHandlers: scrollEvts
                        }],
                        dock:'top',
                        layout:{
                            overflowHandler:'Menu'
                        },
                        height:36,
                        id:widgetId+xcp.viewer.impl.AXViewer.ImageToolbar_ID,
                        enableOverflow:true,
                        items:me.imageToolbar(widgetId, json.displayAnnotations, json.format)
                    }
                ],
                tbar:{id:widgetId+xcp.viewer.impl.AXViewer.AnnoToolbar_ID,enableOverflow:true,layout:{overflowHandler:'Menu'},height:36,
                    items:me.annotationToolbar(widgetId, json.displayAnnotations, json.allowAnnotate),
                    plugins: [{
                        ptype: 'toolbarscroll',
                        widgetScrollHandlers: scrollEvts
                    }]}
            });

            if (!json.displayAnnotations) {
                Ext.getCmp(widgetId + xcp.viewer.impl.AXViewer.AnnoToolbar_ID).setVisible(false);
                //Ext.getCmp(widgetId + widgetId + xcp.viewer.impl.AXViewer.AXToolbar).setHeight(26);
            }

        }

        return "";
    },
    imageToolbar: function(widgetId,showAnnotations,imgFormat)
    {
        var me=this;

        // XCPIVF-575
        // AX Viewer uses Adobe viewer to display PDF document, so not all AX toolbar
        // controls are enabled since they are handled by Adobe viewer. The actions
        // handled by the native PDF viewer include: Zoom in\out, Fit height\width,
        // Rotate Left\Right, so we need to determine the format being displayed by
        // the viewer here to enable\disable these buttons.
        //
        //The same is true for Office formats such as msw, excel and ppt
        var controllableFmt = me.isControllableFormat(imgFormat);

        var imageTools = [
            {xtype:'button',id:widgetId + "_ImportDocument",cls:"AxAlwaysEnabled",iconCls:'ax-toolbar-button importDocIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.importDocumentLabel,align:'br-tr'},handler:function() {
                me.axviewerImportDocument(widgetId);
            }},
            {xtype:'tbspacer',width:5,cls:"AxAlwaysEnabled"},
            {xtype:'button',id:widgetId + "_ExportDocument",cls:"AxAlwaysEnabled",iconCls:'ax-toolbar-button exportDocIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.exportDocumentLabel,align:'br-tr'},handler:function() {
                me.axviewerExportDocument(widgetId);
            }},
            {xtype:'tbspacer',width:5,cls:"AxAlwaysEnabled"},
            {xtype:'button',id:widgetId + "_PrintDocument",cls:"AxAlwaysEnabled",iconCls:'ax-toolbar-button printDocIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.printDocumentLabel,align:'br-tr'},handler:function() {
                me.axviewerPrintDocument(widgetId);
            }},
            {xtype:'tbspacer',width:5,cls:"AxAlwaysEnabled"},
            {xtype:'button',id:widgetId + "_PrintPage",cls:"AxAlwaysEnabled",iconCls:'ax-toolbar-button printPageIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.printPageLabel,align:'br-tr'},handler:function() {
                me.axviewerPrintPage(widgetId);
            }},
            {xtype: 'tbseparator',hidden:!controllableFmt},
            {xtype:'button',id:widgetId + "_PrevPage",iconCls:'ax-toolbar-button prevPageIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.prevPageLabel,align:'br-tr'},disabled:true,hidden:!controllableFmt,handler:function() {
                me.axviewerPrevPage(widgetId);
            }},
            {xtype: 'tbspacer',hidden:!controllableFmt,width:2},
            {xtype:'textfield',id:widgetId + "_GotoPage",tooltip:{text:xcp.Strings.viewer.impl.AXViewer.goToPageLabel,align:'br-tr'},hidden:!controllableFmt,hideLabel:true,width:30,allowBlank:false,labelAlign:"center",
                listeners:{
                    specialKey:function(field, e) {
                        if (e.getKey() == e.ENTER)
                            me.axviewerGotoPage(field, widgetId)
                    }
                }
            },
            {xtype: 'tbspacer',hidden:!controllableFmt,width:3},
            {xtype:'displayfield',hidden:!controllableFmt,hidelabel:true,value:"  " + xcp.Strings.viewer.impl.AXViewer.pageCountSeparatorLabel + " "},
            {xtype:'tbtext',hidden:!controllableFmt,hideLabel:true,id:widgetId + "_PageCount",text:"",width:30,cls:'pgCountFont'},
            {xtype:'button',id:widgetId + "_NextPage",iconCls:'ax-toolbar-button nextPageIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.nextPageLabel,align:'br-tr'},hidden:!controllableFmt,handler:function() {
                me.axviewerNextPage(widgetId);
            }},
            {xtype: 'tbseparator',hidden:!controllableFmt},
            {xtype:'button',id:widgetId + "_ZoomOut",iconCls:'ax-toolbar-button zoomOutIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.zoomOutLabel,align:'br-tr'},hidden:!controllableFmt,handler:function() {
                me.axviewerZoomout(widgetId);
            }},
            {xtype:'tbspacer',width:3,hidden:!controllableFmt},
            {xtype:'button',id:widgetId + "_ZoomIn",iconCls:'ax-toolbar-button zoomInIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.zoomInLabel,align:'br-tr'},hidden:!controllableFmt,handler:function() {
                me.axviewerZoomin(widgetId);
            }},
            {xtype:'tbspacer',width:3,hidden:!controllableFmt},
            {xtype:'button',id:widgetId + "_FitHeight",iconCls:'ax-toolbar-button fitHeightIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.fitToHeightLabel,align:'br-tr'},hidden:!controllableFmt,handler:function() {
                me.axviewerFitHeight(widgetId);
            }},
            {xtype:'tbspacer',width:3,hidden:!controllableFmt},
            {xtype:'button',id:widgetId + "_FitWidth",iconCls:'ax-toolbar-button fitWidthIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.fitToWidthLabel,align:'br-tr'},hidden:!controllableFmt,handler:function() {
                me.axviewerFitWidth(widgetId);
            }},
            {xtype:'tbspacer',width:3,hidden:!controllableFmt},
            {xtype:'button',id:widgetId + "_RotateLeft",iconCls:'ax-toolbar-button rotateLeftIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.rotateLeftLabel,align:'br-tr'},hidden:!controllableFmt,handler:function() {
                me.axviewerRotate90Left(widgetId);
            }},
            {xtype:'tbspacer',width:3,hidden:!controllableFmt},
            {xtype:'button',id:widgetId + "_RotateRight",iconCls:'ax-toolbar-button rotateRightIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.rotateRightLabel,align:'br-tr'},hidden:!controllableFmt,handler:function() {
                me.axviewerRotate90Right(widgetId);
            }},
            {xtype: 'tbseparator',hidden:!controllableFmt},
            {xtype:'combobox',id:widgetId + "_ShowAnnotations",tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annotationDisplayOptions,align:'br-tr'},hidden:!controllableFmt,
                store:new Ext.data.SimpleStore({
                    fields:['name','value'],
                    data:me.getAnnoDDItems(showAnnotations)
                }),
                displayField:'name',
                valueField:'value',
                editable:false,
                value:showAnnotations?'1':'0',
                listeners:{
                    select:function(combo, value) {
                        me.axviewerShowAnnotations(widgetId, this.value);
                    }
                }
            }
        ]

        return imageTools;
    },
    getAnnoDDItems:function(showAnnotations){
            var items = [];
            if (showAnnotations) {
                items.push([xcp.Strings.viewer.impl.AXViewer.currentUserAnnotations,'1']);
                items.push([xcp.Strings.viewer.impl.AXViewer.allUserAnnotations,'2']);
            }
            items.push([xcp.Strings.viewer.impl.AXViewer.hideAnnotations,'0']);
            return items;
    },
    annotationToolbar: function(widgetId,showAnnotations,allowAnnotate)
    {
        var me = this,
            annotationTools = [],
            disableTools = !allowAnnotate;

        annotationTools = [
            {xtype:'button',id:widgetId + "_AnnoSelect",iconCls:'ax-toolbar-button annoPointerIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoSelectLabel,align:'br-tr'},disabled:disableTools,handler:function() {
                me.axviewerAnnotationTool(widgetId, this, xcp.viewer.impl.AXViewer.AnnoTool_Select)
            }},
            {xtype:'tbspacer',width:5},
            {xtype:'button',id:widgetId + "_AnnoSelectAll",iconCls:'ax-toolbar-button annoSelectAllIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoSelectAllLabel,align:'br-tr'},disabled:disableTools,handler:function() {
                me.axviewerAnnotationSelectAll(widgetId)
            }},
            {xtype: 'tbseparator'},
            {xtype:'button',id:widgetId + "_AnnoNote",iconCls:'ax-toolbar-button annoNoteIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoNoteLabel,align:'br-tr'},disabled:disableTools,handler:function() {
                me.axviewerAnnotationTool(widgetId, this, xcp.viewer.impl.AXViewer.AnnoTool_Note)
            }},
            {xtype:'tbspacer',width:5},
            {xtype:'button',id:widgetId + "_AnnoText",iconCls:'ax-toolbar-button annoTextIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoTextLabel,align:'br-tr'},disabled:disableTools,handler:function() {
                me.axviewerAnnotationTool(widgetId, this, xcp.viewer.impl.AXViewer.AnnoTool_Text)
            }},
            {xtype:'tbspacer',width:5},
            {xtype:'button',id:widgetId + "_AnnoHighlight",iconCls:'ax-toolbar-button annoHighlightIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoHighlightLabel,align:'br-tr'},disabled:disableTools,handler:function() {
                me.axviewerAnnotationTool(widgetId, this, xcp.viewer.impl.AXViewer.AnnoTool_Highlight)
            }},
            {xtype:'tbspacer',width:5},
            {xtype:'button',id:widgetId + "_AnnoRubberstamps",iconCls:'ax-toolbar-button annoRubberStampIcon',height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoRubberstampsLabel,align:'br-tr'},disabled:disableTools,handler:function() {
                me.axviewerAnnotationRubberstamps(widgetId, this, xcp.viewer.impl.AXViewer.AnnoTool_Rubberstamp)
            }},
            {xtype: 'tbseparator'},
            {xtype:'button',id:widgetId + "lineMenu",iconCls:'ax-toolbar-button annoLineIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoLineMenuLabel,align:'br-tr'},
                menu:{plain:true,
                    items:[
                        {text:xcp.Strings.viewer.impl.AXViewer.annoLineLabel,iconCls:'ax-toolbar-button annoLineIcon',id:widgetId + "_AnnoLine",toolId:xcp.viewer.impl.AXViewer.AnnoTool_Line,tooltip:xcp.Strings.viewer.impl.AXViewer.annoLineLabel},
                        {text:xcp.Strings.viewer.impl.AXViewer.annoArrowLabel,iconCls:'ax-toolbar-button annoArrowIcon',id:widgetId + "_AnnoArrow",toolId:xcp.viewer.impl.AXViewer.AnnoTool_Arrow,tooltip:xcp.Strings.viewer.impl.AXViewer.annoArrowLabel},
                        {text:xcp.Strings.viewer.impl.AXViewer.annoFreehandLabel,iconCls:'ax-toolbar-button annoFreehandIcon',id:widgetId + "_AnnoFreehand",toolId:xcp.viewer.impl.AXViewer.AnnoTool_Freehand,tooltip:xcp.Strings.viewer.impl.AXViewer.annoFreehandLabel},
                        {text:xcp.Strings.viewer.impl.AXViewer.annoPolylineLabel,iconCls:'ax-toolbar-button annoPolylineIcon',id:widgetId + "_AnnoPolyline",toolId:xcp.viewer.impl.AXViewer.AnnoTool_Polyline,tooltip:xcp.Strings.viewer.impl.AXViewer.annoPolylineLabel}
                    ],
                    listeners:{
                        click:function(menu, item, opts) {
                            var lineMenuBtn = Ext.getCmp(widgetId + "lineMenu");
                            lineMenuBtn.setIconCls(item.iconCls);
                            menu.hide();
                            me.axviewerAnnotationTool(widgetId, lineMenuBtn, item.toolId);
                        }
                    }}
            },
            {xtype:'button',id:widgetId + "shapesMenu",iconCls:'ax-toolbar-button annoRectangleIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoShapesMenuLabel,align:'br-tr'},
                menu:{plain:true,
                    items:[
                        {text:xcp.Strings.viewer.impl.AXViewer.annoRectangleLabel,iconCls:'ax-toolbar-button annoRectangleIcon',id:widgetId + "_AnnoRectangle",toolId:xcp.viewer.impl.AXViewer.AnnoTool_Rectangle,tooltip:xcp.Strings.viewer.impl.AXViewer.annoRectangleLabel},
                        {text:xcp.Strings.viewer.impl.AXViewer.annoRoundedRectangleLabel,iconCls:'ax-toolbar-button annoRoundedRectangleIcon',id:widgetId + "_AnnoRoundedRectangle",toolId:xcp.viewer.impl.AXViewer.AnnoTool_RoundedRectangle,tooltip:xcp.Strings.viewer.impl.AXViewer.annoRoundedRectangleLabel},
                        {text:xcp.Strings.viewer.impl.AXViewer.annoOvalLabel,iconCls:'ax-toolbar-button annoOvalIcon',id:widgetId + "_AnnoOval",toolId:xcp.viewer.impl.AXViewer.AnnoTool_Oval,tooltip:xcp.Strings.viewer.impl.AXViewer.annoOvalLabel},
                        {text:xcp.Strings.viewer.impl.AXViewer.annoPolygonLabel,iconCls:'ax-toolbar-button annoPolygonIcon',id:widgetId + "_AnnoPolygon",toolId:xcp.viewer.impl.AXViewer.AnnoTool_Polygon,tooltip:xcp.Strings.viewer.impl.AXViewer.annoPolygonLabel}
                    ],
                    listeners:{
                        click:function(menu, item, opts) {
                            var shapesMenuBtn = Ext.getCmp(widgetId + "shapesMenu");
                            shapesMenuBtn.setIconCls(item.iconCls);
                            menu.hide();
                            me.axviewerAnnotationTool(widgetId, shapesMenuBtn, item.toolId);
                        }
                    }}
            },
            {xtype:'button',id:widgetId + "_AnnoLineWidth",iconCls:'ax-toolbar-button annoLineWidthIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoLineWidthLabel,align:'br-tr'},
                menu:{plain:true,
                    items:[
                        {text:'1 px',itemId:'1'},
                        {text:'2 px',itemId:'2'},
                        {text:'3 px',itemId:'3'},
                        {text:'5 px',itemId:'5',cls:'x-menu-item-active'},
                        {text:'9 px',itemId:'9'},
                        {text:'14 px',itemId:'14'}
                    ],
                    listeners:{
                        beforeShow:function(menu, opts) {
                            if (menu.selLineSize != undefined)
                                menu.getComponent(menu.selLineSize).addCls('x-menu-item-active');
                            menu.clearSel = true;
                        },
                        click:function(menu, item, opts) {
                            menu.selLineSize = item.itemId;
                            me.axviewerAnnotationLineWidth(widgetId, item.itemId);
                            menu.hide();
                        },
                        mouseover:function(menu, t, opts) {
                            if (menu.clearSel && menu.selLineSize)
                                menu.getComponent(menu.selLineSize).removeCls('x-menu-item-active');
                            menu.clearSel = false;
                        }
                    }}
            },
            {xtype:'button',id:widgetId + "_AnnoColor",iconCls:'ax-toolbar-button annoColorIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoColorLabel,align:'br-tr'},
                menu:{plain:true,items:[Ext.create('Ext.ColorPalette', {
                    value:'FF0000',
                    listeners:{
                        select: function(field, color, opts) {
                            field.ownerCt.hide();
                            me.axviewerAnnotationColor(widgetId, color);
                        }}
                })]}
            },
            {xtype:'button',id:widgetId + "_AnnoBackgroundColor",iconCls:'ax-toolbar-button annoColorBGIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoBackgroundColorLabel,align:'br-tr'},
                menu:{plain:true,items:[Ext.create('Ext.ColorPalette', {
                    value:'FFFF00',
                    listeners:{
                        select: function(field, color, opts) {
                            field.ownerCt.hide();
                            me.axviewerAnnotationBackgroundColor(widgetId, color);
                        }}
                })]}
            },
            {xtype:'button',id:widgetId + "_AnnoNoFill",iconCls:'ax-toolbar-button annoNoFillIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoNoFillLabel,align:'br-tr'},handler:function() {
                me.axviewerAnnotationNoFill(widgetId, this)
            }},
            {xtype: 'tbseparator'},
            {xtype:'button',id:widgetId + "_AnnoEraser",iconCls:'ax-toolbar-button annoEraserIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoEraserLabel,align:'br-tr'},handler:function() {
                me.axviewerAnnotationTool(widgetId, this, xcp.viewer.impl.AXViewer.AnnoTool_Eraser)
            }},
            {xtype:'tbspacer',width:5},
            {xtype:'button',id:widgetId + "_AnnoDelete",iconCls:'ax-toolbar-button annoDeleteIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoDeleteLabel,align:'br-tr'},handler:function() {
                me.axviewerAnnotationDelete(widgetId)
            }},
            {xtype:'tbspacer',width:5},
            {xtype:'button',id:widgetId + "_AnnoUndo",iconCls:'ax-toolbar-button annoUndoIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoUndoLabel,align:'br-tr'},handler:function() {
                me.axviewerAnnotationUndo(widgetId)
            }},
            {xtype:'tbspacer',width:5},
            {xtype:'button',id:widgetId + "_AnnoSave",iconCls:'ax-toolbar-button annoSaveIcon',disabled:disableTools,height:36,tooltip:{text:xcp.Strings.viewer.impl.AXViewer.annoSaveLabel,align:'br-tr'},handler:function() {
                me.axviewerAnnoSave(widgetId)
            }}
        ]
        return annotationTools;
    },
    // Override updateDocument and return true.
    updateDocument  : function(json) {

        var widgetId = this.getWidgetId(),
            showAnnoCombo = Ext.getCmp(widgetId + "_ShowAnnotations"),
            annoToolbar = Ext.getCmp(widgetId + xcp.viewer.impl.AXViewer.AnnoToolbar_ID);

        //Set control visibility based on the format type we are displaying
        //because some toolbar buttons are enabled\disabled based on the type
        //(some disabled for PDF, DOC, etc.)
        this.setControlsStateForFormat(json.format);

        //Set the annotation toolbar based on whether the format
        //of the file support it (if the anno toolbar has been created
        //because in regular view mode it will not have been, but
        //in viewer control reuse it should have been.)
        if(annoToolbar) {
            showAnnoCombo.store.loadData(this.getAnnoDDItems(json.displayAnnotations));
            annoToolbar.setVisible(json.displayAnnotations);
            if (json.displayAnnotations) {
                showAnnoCombo.setValue('1');
                this.disableAnnotationTools(widgetId, !json.allowAnnotate);
            } else {
                showAnnoCombo.setValue('0');
            }
        }

        this.m_thumbnailInitialized = false;

        var params = json.parameterList, docUrl, annoUrl;
        for (var i = 0; i < params.length; i++) {
            if (params[i].name == "AnnotationURL") {
                annoUrl = params[i].value;
            }
            else if (params[i].name == "ImageURL") {
                docUrl = params[i].value;
            }
        }

        var viewer = this.getViewerElement();

        if(json.displayAnnotations)
            this.clearViewerAnnos(viewer, json.allAnnotationsUrl);

        //update new doc and annotations
        try {
            viewer.Display(docUrl, annoUrl);
        }
        catch(e) {
            xcp.util.IvfUtil.debug("Error updating document: "+e);
            return false;
        }

        return true;
    },
    getPageCount : function()
    {
        var pageCount = 1;
        var viewer = this.getViewerElement();
        if(viewer)
            pageCount = viewer.pageCount;
        return pageCount;
    },
    nextPage : function() {
        var viewer = this.getViewerElement();
        if (viewer && viewer.currentPage < viewer.pageCount - 1)
        {
            viewer.currentPage++;
        }

        this.setPaginationControlsState(viewer.currentPage, viewer.pageCount);
    },
    prevPage : function() {
        var viewer = this.getViewerElement();
        if (viewer && viewer.currentPage > 0)
        {
            viewer.currentPage--;
        }

        this.setPaginationControlsState(viewer.currentPage, viewer.pageCount);
    },
    gotoPage : function(pageIndex) {
        //pageIndex is 1-based
        var viewer = this.getViewerElement();
        if (viewer) {
            //pageIndex is 1-based
            if (pageIndex > 0 && pageIndex <= viewer.pageCount) {
                viewer.currentPage = pageIndex - 1; //AXViewer currentPage is 0-based

                //Update the Goto Page input field
                var widgetId = this.getWidgetId();
                var pageField = Ext.getCmp(widgetId + "_GotoPage");
                if (pageField)
                    pageField.setValue(pageIndex);
                ivfclient.getViewer(widgetId).handleViewerEvent(xcp.viewer.impl.AXViewer.Event_Pagination, pageIndex);

                this.setPaginationControlsState(viewer.currentPage, viewer.pageCount);
            }
        }
    },
    handleViewerEvent : function(eventId, eventData) {

        var widgetId = this.getWidgetId(),
            vwr = Ext.getCmp(widgetId);

        if (eventId == xcp.viewer.impl.AXViewer.Event_ControlInitialized)
        {
             xcp.util.IvfUtil.debug("Event_ControlInitialized event intercepted with eventData: "+eventData);
            if(this.m_thumbnailInitialized == false && eventData != null && eventData > 0)
            {
                this.fireEvent(xcp.viewer.impl.ViewerObject.Event_DocumentOpened, "");
                Ext.getCmp(widgetId+"_GotoPage").setValue(1);
                var pageCountField = Ext.getCmp(widgetId + "_PageCount");
                pageCountField.setText(eventData);

                var viewerObj = ivfclient.getViewer(widgetId);
                if (viewerObj) {
                    var viewer = viewerObj.getViewerElement();
                    if (viewer) {
                        viewer.AnnoFill = true
                        viewer.AnnoLineWidth=5;
                    }
                }

                this.initializeThumbnail(eventData);

                this.m_thumbnailInitialized = true;

                this.initializePagingHotKeys(widgetId);
            }
        }
        else if (eventId == xcp.viewer.impl.AXViewer.Event_URLFailed)
        {
            xcp.util.IvfUtil.debug("Event_URLFailed event intercepted");
            var viewer = this.getViewerElement();
            if(viewer)
            {
                var annoUrl;
                if(this.isAnnotationUrl(eventData))
                {
                    annoUrl = this.getNextAnnotationFallbackUrl();
                    if(annoUrl != null && annoUrl.length > 0)
                    {
                        xcp.util.IvfUtil.debug("Request for annotation content failed. Loading annotations with fallback url "+annoUrl);
                        viewer.AddAnnotationFile(annoUrl, true);
                    }
                    else
                    {
                        xcp.Logger.error("Annotation fallback url is null");
                    }
                }
                else
                {
                    var docUrl = this.getNextDocumentFallbackUrl();
                    if(docUrl != null && docUrl.length > 0)
                    {
                        xcp.util.IvfUtil.debug("Request for document content failed. Loading document with fallback url "+docUrl);
                        viewer.LoadImage(docUrl);
                    }
                    else
                    {
                        xcp.Logger.error("Document fallback url is null");
                    }
                }
            }
        }
        else if (eventId == xcp.viewer.impl.AXViewer.Event_Pagination)
        {
            xcp.util.IvfUtil.debug("Event_Pagination event intercepted");
            this.setThumbnailFocus(eventData);
        }
        else if (eventId == xcp.viewer.impl.AXViewer.Event_PrintJobSubmitted)
        {
            xcp.util.IvfUtil.debug("Event_PrintJobSubmitted event intercepted");
            if(this.m_printAuditUrl != null && this.m_printAuditUrl.length > 0)
            {
                xcp.util.IvfUtil.debug("Ready to call print audit trail service: " + this.m_printAuditUrl);
                var ajaxUrl = this.m_printAuditUrl;
                Ext.Ajax.request({
                    url: ajaxUrl,
                    scope:this,
                    success: function(response, options) {
                        xcp.util.IvfUtil.debug("Print audit trail request submitted!");
                    },
                    failure: function(response, options) {
                        xcp.Logger.error(response.responseText);
                        if(xcp.core.FeedbackManager)
                            xcp.core.FeedbackManager.showFeedback(null, "", xcp.Strings.viewer.impl.AXViewer.printAuditTrailAjaxError, "systemErrors", false);
                    }
                });
            }
        }
        else if (eventId == xcp.viewer.impl.AXViewer.Event_DocumentExported)
        {
            xcp.util.IvfUtil.debug("Event_DocumentExported event intercepted");
            if(this.m_exportAuditUrl != null && this.m_exportAuditUrl.length > 0)
            {
                xcp.util.IvfUtil.debug("Ready to call export audit trail service: " + this.m_exportAuditUrl);
                var ajaxUrl = this.m_exportAuditUrl;
                Ext.Ajax.request({
                    url: ajaxUrl,
                    scope:this,
                    success: function(response, options) {
                        xcp.util.IvfUtil.debug("Export audit trail request submitted!");
                    },
                    failure: function(response, options) {
                        xcp.Logger.error(response.responseText);
                        if(xcp.core.FeedbackManager)
                            xcp.core.FeedbackManager.showFeedback(null, "", xcp.Strings.viewer.impl.AXViewer.exportAuditTrailAjaxError, "systemErrors", false);
                    }
                });
            }
        }
        else if (eventId == xcp.viewer.impl.AXViewer.Event_AnnoNotification)
        {
            xcp.util.IvfUtil.debug("Event_AnnoNotification event intercepted");
            if(eventData!=null&&eventData==xcp.viewer.impl.AXViewer.AnnoModified) {
                var viewerObj = ivfclient.getViewer(widgetId);
                if(viewerObj)
                    viewerObj.setAnnotationModified(true);
            }
        }

    },
    axviewerImportDocument:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                viewer.ImportFromLocal();
                viewer.AddAnnotationFile("", true);

                Ext.getCmp(widgetId+xcp.widget.Viewer.COMP_PANEL_ID).setVisible(false);
                this.disableAnnotationTools(widgetId,true);
                Ext.getCmp(widgetId+"_ShowAnnotations").setValue('0');

                var pageCount = viewer.pageCount;
                var pageCountField = Ext.getCmp(widgetId + "_PageCount");
                pageCountField.setText(pageCount);
                viewerObj.initializeThumbnail(pageCount);
            }
        }
    },
    axviewerExportDocument:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                viewer.SaveAs();
            }
        }
    },
    axviewerUploadLocalFile:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                //todo: get file name from the viewer control
                var localFilename = "";
                var uploadUrl = viewerObj.m_documentUploadUrl;
                if (uploadUrl != null && uploadUrl.length > 0)
                    viewer.UploadCurrentImageFile(uploadUrl, localFilename);
            }
        }
    },
    axviewerPrintDocument:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                viewer.Print(true);
            }
        }
    },
    axviewerPrintPage:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                var pageToPrint = viewer.currentPage + 1;
                viewer.Print(false, pageToPrint, pageToPrint);
            }
        }
    },
    axviewerPrevPage:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        viewerObj.prevPage(widgetId)
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                var pageIndex = viewer.currentPage + 1;
                viewerObj.handleViewerEvent(xcp.viewer.impl.AXViewer.Event_Pagination, pageIndex);

                //Update the Goto Page input field
                var pageField = Ext.getCmp(widgetId + "_GotoPage");
                if (pageField)
                    pageField.setValue(pageIndex);
            }
        }
    },
    axviewerGotoPage:function(inputField, widgetId) {
        var pageIndex = parseInt(inputField.getValue());
        var pageCount = parseInt(Ext.getCmp(widgetId + "_PageCount").el.dom.innerHTML);
        var viewer = ivfclient.getViewer(widgetId);
        if (pageIndex > 0 && pageIndex <= pageCount) {
            viewer.gotoPage(pageIndex);
        } else {    //invalid input
            //Update the Goto Page input field with current, valid page
            var widgetId = this.getWidgetId();
            var pageField = Ext.getCmp(widgetId + "_GotoPage");
            if (pageField) {
                var pageNum = viewer.getViewerElement().currentPage+1;
                pageField.setValue(pageNum);
            }
        }
    },
    axviewerNextPage:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        viewerObj.nextPage(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                var pageIndex = viewer.currentPage + 1;
                viewerObj.handleViewerEvent(xcp.viewer.impl.AXViewer.Event_Pagination, pageIndex);

                //Update the Goto Page input field
                var pageField = Ext.getCmp(widgetId + "_GotoPage");
                if (pageField)
                    pageField.setValue(pageIndex);
            }
        }
    },
    axviewerZoomin:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
                viewer.ZoomRatio = 2 * viewer.ZoomRatio;
        }
    },
    axviewerZoomout:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer && viewer.ZoomRatio >= 2) {
                viewer.ZoomRatio = viewer.ZoomRatio / 2;
            }
        }
    },
    axviewerRotate90Left:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                viewer.Orientation -= 90;
                if (viewer.Orientation < 0)
                    viewer.Orientation += 360;
            }
        }
    },
    axviewerRotate90Right:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                viewer.Orientation += 90;
                if (viewer.Orientation >= 360)
                    viewer.Orientation = (viewer.Orientation % 360);
            }
        }
    },
    axviewerFitHeight:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
                viewer.ZoomRatio = -2;
        }
    },
    axviewerFitWidth:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
                viewer.ZoomRatio = -1;
        }
    },
    axviewerShowAnnotations:function(widgetId, option) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                viewer.ShowAnnoUser = parseInt(option);
            }
        }
    },
    setAnnotationToolSelected:function(toolElem, selectedState)
    {
        if (toolElem == null)
            return;
        if (selectedState)
            toolElem.addCls('x-btn-default-medium-pressed');
        else
            toolElem.removeCls('x-btn-default-medium-pressed');
    },
    axviewerAnnotationTool:function(widgetId, toolElem, toolId)
    {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
        {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
            {
                viewer.AnnoCreateTool = toolId;
                if(viewer.m_selectedAnnoTool != null)
                    this.setAnnotationToolSelected(viewer.m_selectedAnnoTool, false);
                //Selected the this tool
                this.setAnnotationToolSelected(toolElem, true);

                viewer.m_selectedAnnoTool = toolElem;
            }
        }
    },
    axviewerAnnotationRubberstamps:function(widgetId, toolElem, toolId)
    {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
        {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
            {
                viewer.AnnoCreateTool = toolId;

                viewer.RubberStampsURL = "component/xcp-ivf-provider-axviewer/ivf_axviewer_lib/lib/axviewer/rubberstamps.xml";
                viewer.SelectRubberStamp("", -1);

                //Deselect the current tool
                if (viewer.m_selectedAnnoTool != null)
                    this.setAnnotationToolSelected(viewer.m_selectedAnnoTool, false);
                //Selected the this tool
                this.setAnnotationToolSelected(toolElem, true);
                viewer.m_selectedAnnoTool = toolElem;
            }
        }
    },
    axviewerAnnotationNoFill:function(widgetId, toolElem)
    {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
        {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
            {
                viewer.AnnoFill = !viewer.AnnoFill;
                if (viewer.AnnoFill)
                    toolElem.removeCls('x-btn-default-medium-pressed');
                else
                    toolElem.addCls('x-btn-default-medium-pressed');
            }
        }
    },
    axviewerAnnotationLineWidth:function(widgetId,lineWidth)
    {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
        {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
            {
                viewer.AnnoLineWidth = parseInt(lineWidth);
            }
        }
    },
    axviewerAnnotationColor:function(widgetId,color)
    {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
        {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
            {
                var r = color.substring(0,2);
                var g = color.substring(2,4);
                var b = color.substring(4,6);
                viewer.AnnoForeColor = parseInt(b + g + r, 16);
            }
        }
    },
    axviewerAnnotationBackgroundColor:function(widgetId,color)
    {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
        {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
            {
                var r = color.substring(0,2);
                var g = color.substring(2,4);
                var b = color.substring(4,6);
                viewer.AnnoBackColor = parseInt(b + g + r, 16);
            }
        }
    },
    axviewerAnnotationSelectAll:function(widgetId)
    {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
        {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
            {
                viewer.AnnoSelectAll(true);
            }
        }
    },
    axviewerAnnotationDelete:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                viewer.DeleteSelectedAnno();
            }
        }
    },
    axviewerAnnotationUndo:function(widgetId) {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj) {
            var viewer = viewerObj.getViewerElement();
            if (viewer) {
                var annoShowValue = Ext.getCmp(widgetId + "_ShowAnnotations").getValue();
                viewer.ShowAnnoUser = parseInt(annoShowValue);

                if (annoShowValue == "1") {
                    var annoUrl = viewerObj.getUserAnnotationUrl();
                    viewer.AddAnnotationFile(annoUrl, true);
                }
                else if (annoShowValue == "2") {
                    var annoUrl = viewerObj.getAllUserAnnotationUrl();
                    viewer.AddAnnotationFile(annoUrl, true);
                }
            }
        }
    },
    axviewerAnnoSave:function(widgetId)
    {
        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
        {
            var viewer = viewerObj.getViewerElement();
            if (viewer)
            {
                viewer.UploadAnnotationFile(viewerObj.m_annotationUploadUrl);
                viewerObj.setAnnotationModified(false);
            }
        }
    },
    /*  Enable/Disable annotation toolbar
     *  disbale: true - disable
     *  disbale: false - enable
     */
    disableAnnotationTools:function(widgetId,disable){
        var items = Ext.getCmp(widgetId+xcp.viewer.impl.AXViewer.AnnoToolbar_ID).items.items;
        for(i=0;i<items.length;i++)
           items[i].setDisabled(disable);

    },
    /*  Display/hide the specified control
     *  id - the id of the widget to display\hide
     *  display - boolean indicating whether to display
     *  the control or not.
     */
    displayAXViewerControl:function(id, display) {
        var ctrl = Ext.getCmp(id);
        if(ctrl)
            ctrl.setVisible(display);
    },
    /*  Disable/enable the specified control
     *  id - the id of the widget to disable\enable
     *  disable - boolean indicating whether to disable
     *  the control or not.
     */
    disableAXViewerControl:function(id, disable) {
        var ctrl = Ext.getCmp(id);
        if(ctrl)
            ctrl.setDisabled(disable);
    },
   /*
    *   Sets the pagination controls based on the
    *   current page displayed and document page count
    *   currPage - integer indicating the current page displayed
    *   in the viewer
    *   pageCount - integer indicating the number of pages which
    *   the document contains
    */
    setPaginationControlsState:function(currPage, pageCount) {
        var me = this;
        var widgetId = me.getWidgetId();
        if(widgetId) {
            if(currPage===0) {
                me.disableAXViewerControl(widgetId + "_PrevPage", true);
                me.disableAXViewerControl(widgetId + "_NextPage", false);
            } else if(currPage>=(pageCount-1)) {
                me.disableAXViewerControl(widgetId + "_PrevPage", false);
                me.disableAXViewerControl(widgetId + "_NextPage", true);
            } else {
                me.disableAXViewerControl(widgetId + "_PrevPage", false);
                me.disableAXViewerControl(widgetId + "_NextPage", false);
            }
        }
    },
    /***
     * This is a helper method which displays toolbar controls
     * based on the format of the content we are displaying
     * @param format
     */
    setControlsStateForFormat:function(format) {

        var controllableFmt = this.isControllableFormat(format);
        var widgetId = this.getWidgetId();
        var axToolbar = Ext.getCmp(widgetId+xcp.viewer.impl.AXViewer.ImageToolbar_ID);

        if(axToolbar){
            var ctrls = axToolbar.query("*:not([cls='AxAlwaysEnabled'])");
            if(ctrls) {
                for(var i=0;i<ctrls.length;i++)
                    this.displayAXViewerControl(ctrls[i].getId(), controllableFmt);
            }
        }
    },
    /***
     * Helper method used to determine whether or not the format of the document
     * being displayed is "controllable" or not. By "controllable" we mean the ability
     * to zoom in\out, rotate, fit to width, etc.
     * @param format
     * @return {Boolean}
     */
    isControllableFormat: function(format) {

        if(Ext.isEmpty(format) == false) {

            var fmt = format.toLowerCase();

            //In the future we can move this to
            //a configurable file
            if(fmt.indexOf("pdf") != -1)
                return false;
            else if(fmt.indexOf("msw") != -1)
                return false;
            else if(fmt.indexOf("excel") != -1)
                return false;
            else if(fmt.indexOf("ppt") != -1)
                return false;
        }

        //We'll assume that it is a format that we have more control over
        //such as TIFF, BMP, JPEG, etc.
        return true;
    },
    setContentTypeControlsState:function(isPDF) {
        var me = this;
        var widgetId = me.getWidgetId();
        var axToolbar = Ext.getCmp(widgetId+xcp.viewer.impl.AXViewer.ImageToolbar_ID);

        if(axToolbar){
            var ctrls = axToolbar.query("*:not([cls='AxAlwaysEnabled'])");
            if(ctrls) {
                for(i=0;i<ctrls.length;i++)
                    me.displayAXViewerControl(ctrls[i].getId(), !isPDF);
            }
        }
    },
    /***
     * Helper method used to initialize hot keys for paging within
     * the document displayed within the viewer
     * @param widgetId
     */
    initializePagingHotKeys:function (widgetId) {
        var viewer = Ext.getCmp(widgetId);
        var viewerElem = document.getElementById(widgetId + "_AXView");

        var map = new Ext.util.KeyMap({
            target: viewerElem,
            binding: [{
                key: Ext.EventObject.UP,
                fn: function(e) {
                    this.axviewerPrevPage(widgetId);
                },
                scope: this
            },{
                key: Ext.EventObject.DOWN,
                fn: function(e) {
                    this.axviewerNextPage(widgetId);
                },
                scope: this
            }]
        });
    },

    saveAnnotation: function() {
        var me = this;
        var widget = arguments[0];

        var winObj = Ext.create('Ext.window.Window',{
            width:300,
            height:200,
            maximizable:false,
            modal:true,
            title:xcp.Strings.viewer.impl.AXViewer.unsavedAnnoTitle,
            cls: Ext.baseCSSPrefix + 'message-box',
            layout: {
                type: 'vbox',
                align: 'stretch'
            },
            items:[{
                xtype:'label',
                text:xcp.Strings.viewer.impl.AXViewer.saveAnnoMsg,
                border:false
            }],
            buttons: [{
                text: xcp.Strings.viewer.impl.AXViewer.saveAnnoBtn,
                handler: function(){
                    me.confirmSaveModifiedAnnos('yes', winObj, widget);
                }
            }, {
                text: xcp.Strings.viewer.impl.AXViewer.noSaveAnnoBtn,
                handler: function(){
                    me.confirmSaveModifiedAnnos('no', winObj, widget);
                }
            }]
        }).show();
    },

    confirmSaveModifiedAnnos: function(btn, win, widget) {
        var widgetId = this.getWidgetId();

        if (btn == 'yes')
            this.axviewerAnnoSave(widgetId);

        var viewerObj = ivfclient.getViewer(widgetId);
        if (viewerObj)
            viewerObj.setAnnotationModified(false);

        win.close();
        widget.loadDocumentCallback();
    },
    clearViewerAnnos:function(viewer, allUsersUrl) {
        if(viewer) {
            viewer.OtherUsersAnnotationURL = allUsersUrl;
            viewer.AddAnnotationFile("", true);
            viewer.ClearImage();
        }
    }
});

/* ivf_browser_lib/content/xcp/viewer/impl/Browser.js */

Ext.define('xcp.viewer.impl.Browser', {
    extend: 'xcp.viewer.impl.ViewerObject',
    constructor:function(elementId) {
        var config = {};
        this.elementId = config.elementId = elementId;
        config.providerName = "Browser";
        this.callParent([config]);
    },

    // Override updateDocument and return true.
    updateDocument  : function(json) {
        var docUrl = null;
        var attrs = json.attributeList;
        try {
            var viewer = this.getViewerElement();
            for (var i = 0; i < attrs.length; i++) {
                if (attrs[i].name == "src")
                    docUrl = attrs[i].value;
            }
            if (viewer != null && docUrl != null)
                viewer.src = docUrl;
        }
        catch(e) {
            alert(e);
            return false;
        }
        return true;

    }
});Ext.namespace("RM.Strings.Viewer.DocumentViewer");

Ext.apply(RM.Strings.Viewer.DocumentViewer, {
    viewerSearchLabel:"Search",
    viewerCommentsLabel:"Comments",
    defaultPagesLabel:"/ 0",
    fitHeightLabel:"Fit to Height",
    fitWidthLabel:"Fit to Width",
    fitWindowLabel:"Fit to Window",
    commentLabel:"Comment",
    choosePrompt:"Choose ...",
    commentShowLabel:"Show: ",
    addCommentLabel:"Add Comment",
    ok:"Ok",
    cancel:"Cancel",
    close:"Close",
    edit:"Edit",
    editComment:"Edit Comment",
    replyComment:"Reply to {0} on {1}",
    reply:"Reply",
    post:"Post",
    addCommentTitle:"Add comment marker",
    addCommentHeader:"Comment for this marker",
    nextPageLabel:"Next Page",
    previousPageLabel:"Previous Page",
    showAllLabel:"Show All",
    showMineLabel:"Show Mine",
    showNoneLabel:"Show None",
    commentHoverPrompt:"Click marker to view more, edit, or reply.",
    deleteLabel:"Delete",
    deleteConfirmHeader:"Delete Comment",
    deleteConfirmMsg:"Are you sure you want to delete the comment?",
    deleteReplyConfirmMsg:"Deleting this comment will also delete its replies. \nAre you sure you want to do this?",
    deleteThreadConfirmMsg:"Deleting this comment will also delete its replies and the comment marker. \nAre you sure you want to do this?",
    errorLabel:"Error",
    commentDelError:"Unable to delete the comment.",
    commentThreadTitle:"Comment ",
    creationDateFormat:"M j Y, g:i a",
    commentHeaderFormat:"{0} on {1}",
    commentReplyCountLabel:"Reply",
    commentRepliesCountLabel:"Replies",
    commentingNotAllowed:"Commenting not allowed",
    loadingPagesMsg:"Preparing content...",
    zoomOut:"Zoom Out",
    zoomIn:"Zoom In",
    rotateLeft:"Rotate left",
    rotateRight:"Rotate right",
    searchError:"Searching is disabled on this document.",
    searchOccurrence:"{0} occurrence",
    searchOccurrences:"{0} occurrences",
    previousOccurrence:"Previous occurrence",
    nextOccurrence:"Next occurrence",
    search:"Search",
    printPreview:"Your document will print as it appears below.",
    print:"Print",
    printConstraintInvalidChar:"Please remove invalid characters",
    printConstraintBlank:"Please specify pages to print",
    printConstraintOverlap:"Please specify page ranges that do not overlap",
    printAllAlertMsg:"This document contains a large number of pages. For the best printing performance, please:",
    printRangeAlertMsg:"The specified range contains a large number of pages. For the best printing performance, please:",
    printDownloadInstMsg:"Download the document",
    printDocInsMsg:"Print the downloaded document",
    printPgInsMsg:"Print pages from the downloaded document",
    printValidPgNum:"Please specify valid page number",
    printCurrent:"Current Page",
    printAll:"All",
    printSpecific:"Specific Pages",
    printAuditTrailAjaxError:"Failed to generate audit trail entry for print",
    printWinTitle:"Pages to print",
    pages:"Pages",
    printAuditExtraInfo:"Please note this log indicates the user clicked on the Print button in the viewer application. User could have clicked OK or Cancel in the OS print dialog that followed.",
    commentPageInfo:"Comment {0}, page {1}", //eg. Comment 1, page 22
    printWithComments:"Include comments",
    loadingIndex:"Loading index...",
    notPageLoadingError:"Content not yet available. Please try again. ",
    acsError:"Content server unavailable.",
    loadingSearchHits:"Searching...",
    commentSaveError:"Unable to save the comment."
});

/* ivf_contentviewer_lib/content/xcp/viewer/impl/ContentViewer.js */

/**
 * Viewer framework client implementation for default viewer: Document viewer.
 * The name of the object must be exactly the same as the name of the viewer provider.
 */
Ext.define('xcp.viewer.impl.ContentViewer', {
    extend: 'xcp.viewer.impl.ViewerObject',
    statics:{
        Event_DocumentOpened : "currentDocumentChanged",
        Event_CurrentPageChanged : "currentPageChanged",
        Event_PrintSubmitted : "currentDocumentPrinted"
    },
    constructor: function(elementId) {
        var config = {};
        this.elementId = config.elementId = elementId;
        config.providerName = "DocumentViewer";
        this.callParent([config]);
    },
    preRender : function(json) {
        var html = "";
        var widgetId = this.getWidgetId();
        var viewerId = this.m_elementId;
        //loadScript('component/xcp-ivf-widgets/xcp_ckeditor_lib/lib/ckeditor/ckeditor.js', null);
        return html;

        function loadScript(url, callback) {

            var script = document.createElement("script")
            script.type = "text/javascript";

            if (script.readyState) {  //IE
                script.onreadystatechange = function() {
                    if (script.readyState == "loaded" ||
                        script.readyState == "complete") {
                        script.onreadystatechange = null;
                        //callback();
                    }
                };
            } else {  //Others
                script.onload = function() {
                    //callback();
                };
            }

            script.src = url;
            document.getElementsByTagName("head")[0].appendChild(script);
        }
    },
    renderControl : function(tagName, attrList, paramList) {
        var viewerId = this.m_elementId;
        var widgetId = this.getWidgetId();
        var imageHandlerFunction = this.m_elementId + "_initializerEvent";

        var firstPageUrl = Ext.BLANK_IMAGE_URL;
        var htmlContent;

        htmlContent = "<" + tagName + " id='" + viewerId + "' width='100%' style='position: absolute; width: 100%; height: 100%'> ";
        htmlContent += "\<img id='" + viewerId + "_img' src= '" + firstPageUrl + "' height='0' width='0' onload='" + imageHandlerFunction + "()'/>";
        htmlContent += "</" + tagName + ">";

        if (paramList) {
            var paramName, paramValue;
            var eventHandlerName;
            var ivfclientObj = ivfclient;

            for (var i = 0; i < paramList.length; i++) {
                paramName = paramList[i].name;
                paramValue = paramList[i].value;
                if (paramName == 'documentInfo') {
                    documentInfo = eval('(' + paramValue + ')');
                    this.pageCount = documentInfo.pageCount;
                    this.isFullyRenderedDoc = documentInfo.rendered;
                    this.assetClass =  documentInfo.assetClass;
                    this.documentInfo = documentInfo;
                }
                if (paramName == 'language') {
                    this.locale = paramValue;
                }
                if (paramName == 'documentPagesServiceUrl') {
                    this.documentPageServiceUrl = paramValue;
                }
                if (paramName == 'documentPagesChunkSize') {
                    this.documentPagesChunkSize = parseInt(paramValue);
                }
                if (paramName == 'searchInfoUrl'){
                    this.textualMetaDataUrl = paramValue;
                }
                if (paramName == 'searchUrl'){
                    this.searchContentUrl = paramValue;
                }
                if (paramName == 'isCommentingAllowed'){
                    this.isCommentingAllowed = (paramValue === 'true');
                }
                if (paramName == 'isServerSideSearch'){
                    this.isServerSideSearch = (paramValue === 'true');
                }
                if (paramName == 'docURL'){
                    this.documentUrl = paramValue;
                }
                if (paramName == 'eventhandler') {
                    this.eventHandlerName = viewerId + "_" + paramValue;
                    paramValue = this.eventHandlerName;
                    window[this.eventHandlerName] = function(eventId, msg) {
                        //ivfclient.handleViewerEvent(widgetId,  eventId, msg);
                        ivfclientObj.getViewer(widgetId).handleViewerEvent(eventId, msg);
                    };
                }
            }
        }
        return htmlContent;
    },
    postRender : function(json) {
        var imageHandlerFunction = this.m_elementId + "_initializerEvent";

        var me = this;
        var deleteCommentUrl = "";
        //Construct delete url only if the user has create comment permission.
        if (json.annotationUploadUrl) {
            deleteCommentUrl = json.annotationUploadUrl + "&deleteComment=true";
        }
        window[imageHandlerFunction] = function() {
            var loadIndicatorImage = Ext.get(me.m_elementId + "_img");
            if(loadIndicatorImage == null){
                return;
            }
            loadIndicatorImage.remove();
            //Set format info in documentInfo object
            me.documentInfo.format = json.format;
            me.documentViewer = new RM.view.DocumentViewer({
                enableRemotePagesFetch:true,
                documentUrl: me.documentUrl,
                assetClass: me.assetClass,
                documentPagesUrl: me.documentPageServiceUrl,
                pageChunkSize: me.documentPagesChunkSize,
                isFullyRenderedDoc: me.isFullyRenderedDoc,
                userLoginInfo: xcp.currentUser,
                textualMetaDataUrl: me.textualMetaDataUrl,
                isCommentingAllowed:me.isCommentingAllowed,
                searchUrl: me.searchContentUrl,
                isServerSideSearch: me.isServerSideSearch,
                saveCommentsUrl: json.annotationUploadUrl,
                deleteCommentUrl: deleteCommentUrl,
                allCommentsUrl:json.allAnnotationsUrl,
                userCommentsUrl:json.userAnnotationUrl
            });

            me.documentViewer.setCommunicationFunction(window[me.eventHandlerName]);
            me.documentViewer.setLocale(me.locale);
            me.documentViewer.setRenderContainer(me.m_elementId);
            me.documentViewer.setDocument(me.documentInfo);
            me.documentViewer.setWidgetId(me.getWidgetId());
        }
        return "";
    },
    getPageCount : function() {
        return this.pageCount;
    },
    printDocument : function() {
    },
    printPage : function() {
    },
    handleViewerEvent : function(eventId, eventData) {
        if (eventId == xcp.viewer.impl.ContentViewer.Event_DocumentOpened) {
            //Notify the event subscribers that the document has successfully opened
            this.fireEvent(xcp.viewer.impl.ViewerObject.Event_DocumentOpened, "");
            var totalPageCount = eventData.pageCount;
            var isFullyRendered = eventData.isFullyRendered;
            this.initializeThumbnail(totalPageCount,isFullyRendered);
        }
        else if (eventId == xcp.viewer.impl.ContentViewer.Event_CurrentPageChanged) {
            var pageNum = eventData;
            this.setThumbnailFocus(pageNum);
        }
        else if (eventId == xcp.viewer.impl.ContentViewer.Event_PrintSubmitted) {
            xcp.util.IvfUtil.debug("Event_PrintJobSubmitted event intercepted");
            if(this.m_printAuditUrl != null && this.m_printAuditUrl.length > 0)
            {
                xcp.util.IvfUtil.debug("Ready to call print audit trail service: " + this.m_printAuditUrl);
                var ajaxUrl = this.m_printAuditUrl;
                if(eventData){
                    ajaxUrl += ("&v1=page "+eventData);
                }
                Ext.Ajax.request({
                    url: ajaxUrl,
                    scope:this,
                    success: function(response, options) {
                        xcp.util.IvfUtil.debug("Print audit trail request submitted!");
                    },
                    failure: function(response, options) {
                        xcp.Logger.error(response.responseText);
                        if(xcp.core.FeedbackManager)
                            xcp.core.FeedbackManager.showFeedback(null, "", RM.Strings.Viewer.DocumentViewer.printAuditTrailAjaxError, "systemErrors", false);
                    }
                });
            }
        }
    },

    setThumbnailCtrlPage: function(widgetId, pageNum) {
        this.setThumbnailFocus(pageNum);
    },

    nextPage : function() {
        if (this.documentViewer)
            this.documentViewer.navigateToNextPage();
    },
    prevPage : function() {
        if (this.documentViewer)
            this.documentViewer.navigateToPreviousPage();
    },
    gotoPage : function(pageNum) {
        if (this.documentViewer)
            this.documentViewer.setCurrentPage(pageNum);
    },
    loadCurrentUserAnnotations : function() {

    },
    loadAllAnnotations : function() {
    },

    updateDocument  : function(json){
        if (this.documentViewer)
            this.documentViewer.destroyViewer();
        return false;
    },
    cleanup: function() {
        if (this.documentViewer)
            this.documentViewer.destroyViewer();
    }
});
/* ivf_contentviewer_lib/content/xcp/viewer/pkg/document-viewer-all.js */

Ext.define("RM.Logger", {
    extend:"Ext.util.Observable",
    singleton:true,
    useExtLogging:false,
    level:5,
    clazes:[],
    DEBUG:'debug',
    INFO:'info',
    LOG:'log',
    ERROR:'error',
    WARN:'warn',


    //Call this function from console to activate viewer internal logging
    enable:function () {
        this.useExtLogging = true;
        return "Enabled Viewer logging";
    },

    //Call this function from console to deactivate viewer internal logging
    disable:function () {
        this.useExtLogging = false;
        return "Disabled Viewer logging"
    },

    setLevel:function (levelName) {
        this.level = this.getLogLevel(levelName)
        return "Log level changed to : " + levelName;
    },

    getLogLevel:function (levelName) {
        switch (levelName) {
            case this.DEBUG:
                return 5;
            case this.INFO:
                return 4;
            case this.LOG:
                return 3;
            case this.WARN:
                return 2;
            case this.ERROR:
                return 1;
        }
        return 5;
    },

    setClass:function (claz) {
        this.clazes.push(claz);
        return "Logging classes: " + this.clazes.join(",");
    },

    removeClass:function (claz) {
        Ext.Array.remove(this.clazes, claz);
        return "Logging classes: " + this.clazes.join(",");
    },


    doExtLogging:function (level, msg, options) {
        if (!options) {
            options = {level:level};
        }
        else {
            Ext.apply(options, {level:level});
        }
        this.extLogger(options, msg);
    },

    setClassPrefix:function (claz, method, msg) {
        claz = claz || "";
        method = method || "";
        return claz + "." + method + " -> " + msg;
    },

    setViewerPrefix:function (claz, method) {
        claz = claz || "";
        method = method || "";
        return "Viewer: " + claz + "." + method;
    },

    log:function (claz, method, msg, options) {
        var level = this.LOG;
        if (this.useExtLogging) {
            this.doFilteredLogging(claz, level, method, msg, options);
        }
        else {
            if (xcp.Logger) {
                xcp.Logger.log(this.setViewerPrefix(claz, method), msg);
            }
        }
    },
    debug:function (claz, method, msg, options) {
        var level = this.DEBUG;
        if (this.useExtLogging) {
            this.doFilteredLogging(claz, level, method, msg, options);
        }
        else {
            if (xcp.Logger) {
                xcp.Logger.debug(this.setViewerPrefix(claz, method), msg);
            }
        }
    },
    info:function (claz, method, msg, options) {
        var level = this.INFO;
        if (this.useExtLogging) {
            this.doFilteredLogging(claz, level, method, msg, options);
        }
        else {
            if (xcp.Logger) {
                this.setClassPrefix(claz, method)
                xcp.Logger.info(this.setViewerPrefix(claz, method), msg);
            }
        }
    },
    warn:function (claz, method, msg, options) {
        var level = this.WARN;
        if (this.useExtLogging) {
            this.doFilteredLogging(claz, level, method, msg, options);
        }
        else {
            if (xcp.Logger) {
                xcp.Logger.warn(this.setViewerPrefix(claz, method), msg);
            }
        }
    },
    error:function (claz, method, msg, options) {
        var level = this.ERROR;
        if (this.useExtLogging) {
            this.doFilteredLogging(claz, level, method, msg, options);
        }
        else {
            if (xcp.Logger) {
                xcp.Logger.error(this.setViewerPrefix(claz, method), msg);
            }
        }
    },
    doFilteredLogging:function (claz, levelName, method, msg, options) {
        if ((this.clazes.length == 0 || Ext.Array.contains(this.clazes, claz) )
            && (this.level >= this.getLogLevel(levelName))) {
            this.doExtLogging(levelName, this.setClassPrefix(claz, method, msg), options);
        }
    },

    // Ext logger.Copied the logger form the ext 4.0.1
    // Using it for more logging capabilities. Kept it as hidden for
    // engineering use
    count:0,
    counters:{ error:0, warn:0, info:0, log:0 },
    out:[],
    max:250,
    extLogger:function (message) {
        var options, dump,
            con = Ext.global.console,
            level = 'log',
            indent = this.indent || 0,
            stack;

        this.indent = indent;

        if (!Ext.isString(message)) {
            options = message;
            message = options.msg || '';
            level = options.level || level;
            dump = options.dump;
            stack = options.stack;

            if (options.indent) {
                ++this.indent;
            } else if (options.outdent) {
                this.indent = indent = Math.max(indent - 1, 0);
            }

            if (dump && !(con && con.dir)) {
                message += this.dumpObject(dump);
                dump = null;
            }
        }

        if (arguments.length > 1) {
            message += Array.prototype.slice.call(arguments, 1).join('');
        }

        message = indent ? this.repeat('   ', indent) + message : message;
        // w/o console, all messages are equal, so munge the level into the message:
        if (level != 'log') {
            message = '[' + level.charAt(0).toUpperCase() + '] ' + message;
        }

        // Not obvious, but 'console' comes and goes when Firebug is turned on/off, so
        // an early test may fail either direction if Firebug is toggled.
        //
        if (con) { // if (Firebug-like console)
            if (con[level]) {
                con[level](message);
            } else {
                con.log(message);
            }

            if (dump) {
                con.dir(dump);
            }

            if (stack && con.trace) {
                // Firebug's console.error() includes a trace already...
                if (!con.firebug || level != 'error') {
                    con.trace();
                }
            }
        } else {
            if (Ext.isOpera) {
                opera.postError(message);
            } else {
                var out = this.out,
                    max = this.max;

                if (out.length >= max) {
                    // this formula allows out.max to change (via debugger), where the
                    // more obvious "max/4" would not quite be the same
                    Ext.Array.erase(out, 0, out.length - 3 * Math.floor(max / 4)); // keep newest 75%
                }

                out.push(message);
            }
        }

        // Mostly informational, but the Ext.Error notifier uses them:
        ++this.count;
        ++this.counters[level];
    },
    dumpObject:function (object) {
        var member, members = [];

        // Cannot use Ext.encode since it can recurse endlessly (if we're lucky)
        // ...and the data could be prettier!
        Ext.Object.each(object, function (name, value) {
            if (typeof(value) === "function") {
                return;
            }

            if (!Ext.isDefined(value) || value === null ||
                Ext.isDate(value) ||
                Ext.isString(value) || (typeof(value) == "number") ||
                Ext.isBoolean(value)) {
                member = Ext.encode(value);
            } else if (Ext.isArray(value)) {
                member = '[ ]';
            } else if (Ext.isObject(value)) {
                member = '{ }';
            } else {
                member = 'undefined';
            }
            members.push(Ext.encode(name) + ': ' + member);
        });

        if (members.length) {
            return ' \nData: {\n  ' + members.join(',\n  ') + '\n}';
        }
        return '';
    },

    repeat:function (pattern, count, sep) {
        for (var buf = [], i = count; i--;) {
            buf.push(pattern);
        }
        return buf.join(sep || '');
    }
});
/**
 * User: michad
 * Date: 8/8/11
 * Time: 3:27 PM
 */

Ext.namespace("RM");
RM.richEditorHelper = function() {

    return {
        isEmptyText:function (editorHtml) {
            if(editorHtml == null || editorHtml.length == 0){
                return true;
            }

            if(editorHtml.length == 1 && editorHtml.charCodeAt(0) == 8203){
                return true;
            }

            var currentText = editorHtml;
            currentText = currentText.replace("&nbsp;", "");
            currentText = currentText.replace("<br>", "");

            if(currentText.length == 0){
                return true;
            }

            return false;
        },

        getEditorValue:function (richEditor) {
            var editorValue = richEditor.getValue();
            editorValue = Ext.util.Format.trim(richEditor.getValue());
            if(editorValue.charCodeAt(0) == 8203) { //Unicode Character 'ZERO WIDTH SPACE'
                editorValue = editorValue.slice(1);
            }

            return editorValue;
        },

        init: function(){

        },

        ckEditorConfig : {
            removePlugins : 'elementspath,scayt',
            toolbar:[
                ['Bold','Italic','Underline','Strike', 'BGColor'],
                ['Cut','Copy','Paste','-','Undo','Redo','-'],
                ['BulletedList','NumberedList','-','Outdent','Indent'],
                ['Table', 'Link', 'HorizontalRule','SpecialChar']
            ],
            resize_enabled : false,
            toolbarCanCollapse : false,
            contentsCss : 'component/xcp-core/ckeditor/lib/ckeditor/skins/xcp/formats.css',
            toolbarStartupExpanded : true,
            baseFloatZIndex: 20000,
            language: ((xcp && xcp.ckeditorlanguage) ? xcp.ckeditorlanguage : undefined),
            skin: 'xcp'
        },

        isCkEditorInitialized: false
    };

}();
/**
 * User: Deepak Michael
 * Date: 10/25/11
 * Time: 6:39 PM
 */

Ext.namespace('xcp.event');
/*// ----------------- TEMP

*//**
 * @class xcp.event.ApplicationEvent
 *
 * This is an abstract base class for application event data.  It should be subclassed before use.
 * All subclasses must define an applicationEventType
 *//*
Ext.define("xcp.event.ApplicationEvent", {
    statics: {
        registerEventType: function(name, eventClass){
            this._eventTypes.add(name, eventClass);
        },

        // Utility method to enumerate registered application event types.
        getEventTypes: function() {
            return this._eventTypes.getKeys();
        },

        _eventTypes: new Ext.util.HashMap()
    },
    constructor: function() {
        var cls = Ext.ClassManager.getClass(this);
        if (typeof(cls.prototype.applicationEventType) == 'undefined') {
            Ext.Error.raise('Unregistered application event type: ' + Ext.ClassManager.getName(cls) +
            '.  applicationEventType must be defined on all xcp.event.ApplicationEvent subtypes.')
        }
    }
});

// This class manager post processor watches for class definitions that inherit from
// ApplicationEvent, and registers the event type in a static application event registry.
Ext.ClassManager.registerPostprocessor("applicationEventType", function(name, cls, data){
    xcp.event.ApplicationEvent.registerEventType(data.applicationEventType, cls);
});
Ext.ClassManager.setDefaultPostprocessorPosition("applicationEventType", "last");*/

// ----------------- TEMP END

Ext.define('RM.event.CommentViewedEvent', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.comment.thread.viewed',
    commentId: '',
    documentId: '',
    statics:{
        COMMENT_VIEWED_EVENT: 'xcpApp.comment.thread.viewed'
    }
});

Ext.define('RM.event.CommentCreatedEvent', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.comment.created',
    commentId: '',
    documentId: '',
    statics:{
        COMMENT_ADD_EVENT: 'xcpApp.comment.created'
    }
});

Ext.define('RM.event.CommentUpdatedEvent', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.comment.updated',
    commentId: '',
    documentId: '',
    statics:{
        COMMENT_UPDATE_EVENT: 'xcpApp.comment.updated'
    }
});

Ext.define('RM.event.CommentDeletedEvent', {
    extend: 'xcp.event.ApplicationEvent',
    applicationEventType: 'xcpApp.comment.deleted',
    commentId: '',
    documentId: '',
    statics:{
        COMMENT_DELETE_EVENT: 'xcpApp.comment.deleted'
    }
});


/**
 * User: michad
 * Date: 9/6/11
 * Time: 4:01 PM
 */
Ext.define('Ext.ux.CKeditor', {
    extend:'Ext.form.field.TextArea',
    alias:'widget.ckeditor',
    initComponent: function() {
        this.callParent(arguments);
        RM.Logger.info("CKeditor", "initComponent", "Register for afterrender to init CK editor");
        this.on('afterrender', this.initializeCkEditor , this);

        var ckEditor = this.getCKeditorInstance();
        this.registerCkEditorInstanceReady(ckEditor,this.onCkEditorInitialize);

    },

    getCKeditorInstance: function (){
        return CKEDITOR;
    },

    initializeCkEditor: function() {
        Ext.apply(this.CKConfig, {
            height:this.getHeight()
        });
        var ckEditor = this.getCKeditorInstance();
        this.editor = this.instantiateCkEditor(ckEditor,this.inputEl.id, this.CKConfig);
        this.editorId = this.editor.id;
        RM.Logger.log("CKeditor", "initializeCkEditor", "Instantiated CK editor id:" + this.editorId);
    },

    instantiateCkEditor: function(ckEditor,target,config){
        return ckEditor.replace(target, config);
    },

    registerCkEditorInstanceReady: function (ckEditor, handler) {
        RM.Logger.info("CKeditor", "registerCkEditorInstanceReady", "Register CK editor for instance ready event");
        var me = this;
        ckEditor.on('instanceReady', function(ev) {
            // Ends self closing tags the HTML4 way, like <br>.
            handler.call(me,ev);
        });
    },

    onRender :function(ct, position) {
        if (!this.el) {
            this.defaultAutoCreate = {
                tag: 'textarea',
                autocomplete :'off'
            };
        }
        this.callParent(arguments)
    },

    setValue :function(value) {
        this.callParent(arguments);
        if (this.editor) {
            RM.Logger.debug("CKeditor", "setValue", "Value:"+value);
            this.editor.setData(value);
        }
    },

    getValue :function() {
        if (this.editor) {
            var value = this.editor.getData();
            RM.Logger.debug("CKeditor", "getValue", "Value:" + value);
            return value;
        } else {
            return ''
        }
    },

    onCkEditorInitialize: function(e) {
        RM.Logger.log("CKeditor", "onCkEditorInitialize", "CK Editor Initialized");
        this.fireEvent('editorInitialized');
        RM.richEditorHelper.isCkEditorInitialized = true;
        this.resizeCkEditor(e);
    },

    resizeCkEditor: function(e) {
        if (RM.richEditorHelper.isCkEditorInitialized) {
            var o = Ext.ComponentQuery.query('ckeditor[editorId="' + e.editor.id + '"]');
            comp = o[0];
            var editorWidth = comp.getWidth() - 10;
            if (Ext.isIE) {
                editorWidth = comp.getWidth() - 25;
            }
            var editorHeight = comp.getHeight();
            e.editor.resize(editorWidth, editorHeight);
            RM.Logger.debug("CKeditor", "resizeCkEditor", "Ck editor resized with width:"+editorWidth+" height:"+ editorHeight);
            /*comp.on('resize', function(c, adjWidth, adjHeight) {
                c.editor.resize(adjWidth, adjHeight)
            });*/
        }
    }

});
/**
 * User: michad
 * Date: 7/15/11
 * Time: 12:27 PM
 */

Ext.define('RM.view.CommentMarker', {
    extend:'Ext.container.Container',
    autoHeight: true,
    autoWidth: true,
    shadow: false,
    alias: 'widget.rmCommentMarker',
    cls:'rmCommentMarker',
    layout: {
        type: 'hbox',
        pack: 'start',
        align: 'stretch'
    },

    statics: {
        getColorStyleRgb:function (commentColor) {
            var commentColorHex = "000000";
            if (commentColor != null) {
                commentColorHex = (commentColor.charAt(0) == "#") ? commentColor.substring(1, 7) : commentColor
            }
            var markerBackgroundRgb = RM.view.CommentMarker.hex2rgb(parseInt("0x" + commentColorHex));
            var commentColorRgb = "rgba(" + markerBackgroundRgb.R + "," + markerBackgroundRgb.G + "," + markerBackgroundRgb.B + "," + " 0.5)";
            return {commentColorHex:commentColorHex, commentColorRgb:commentColorRgb};
        },

        getIEStyleFilter: function (commentColor) {
            var colorWithAlpha = commentColor.replace("#", "#7f");
            return "progid:DXImageTransform.Microsoft.gradient(startColorstr="+colorWithAlpha+",endColorstr="+colorWithAlpha+")";
        },

        hex2rgb:function (hex){
            var r = (hex & 0xff0000) >> 16;
            var g = (hex & 0x00ff00) >> 8;
            var b = hex & 0x0000ff ;
            return {R:r, G:g, B:b};
        }
    },

    listeners: {
        afterrender: function() {
            if(Ext.isIE && this.el) {
                this.el.dom.style.filter = RM.view.CommentMarker.getIEStyleFilter(this.comment.commentColor);
            }
            var me = this;
            if(me.el){
                me.el.addListener('mouseover', me.mouseOverListener, me);

                me.el.addListener('click', function(event, target) {
                    RM.Logger.debug("CommentMarker", "click", " Clicked");
                    me.fireEvent('commentClicked', me.comment);
                });
            }
        },
        containermouseover: function() {
            this.registerQuickTip(this);
        }
    },
    config: {
        comment:{creatorName: ''},
        circleRadius: 8,
        targetDiv: ''
    },

    mouseOverListener: function(event, target){
        RM.Logger.debug("CommentMarker", "mouseOverListener", "Mouse over on comment marker");
        this.el.removeListener('mouseover', this.mouseOverListener, this);
        this.registerQuickTip(this, event);
    },

    initComponent:function() {
        this.addEvents('commentClicked');
        this.enableBubble('commentClicked');
        var circleRadius = 8;
        var targetDiv = this;
        // create circle and text element
        this.markerImage = this.createMarkerImage(this.circleRadius, this.targetDiv, this.comment);
        this.textElement = this.createNumberMarker(this.targetDiv, this.circleRadius, this.comment);
        //add as items to this component
        this.items = [ this.markerImage, this.textElement ];
        //positioning will be done for this whole component
        var __ret = RM.view.CommentMarker.getColorStyleRgb(this.comment.commentColor);
        var commentColorHex = __ret.commentColorHex;
        var commentColorRgb = __ret.commentColorRgb;
        if (!Ext.isIE) {
            this.style = {
                backgroundColor:commentColorRgb//comment.commentColor
            };
        }
        this.callParent(arguments);
        RM.Logger.debug("CommentMarker", "initComponent", "Created comment marker with color" + commentColorHex);

    },

    createMarkerImage:function (circleRadius, targetDiv, comment) {
        var me = this;
        var markerImage = new Ext.Component({
            width: circleRadius * 2, height: circleRadius * 2,
            padding: 0,
            cls: 'viewer-comment-ovr',
            draggable: false,
            constrain: true ,
            listeners: {
                scope: me,
                mouseover: function() {
                    me.registerQuickTip(me);
                }
            }
        });
        return markerImage;
    },

    createNumberMarker:function (targetDiv, circleRadius, comment) {
        var me = this;
        var markerNumber = {
            xtype: 'label',
            cls:'rmCommentNumber',
            text: this.comment.commentNumber,
            style: 'font-size:'+(circleRadius * 2)+'px',
            listeners:{
                afterrender: function() {
                    var numberMarginValue = me.getLeftRightMarginTotal(".rmCommentNumber");
                    var imageMarginValue = me.getLeftRightMarginTotal(".viewer-comment-ovr");
                    me.setWidth ( me.markerImage.width  + Ext.getCmp(this.id).getWidth() + numberMarginValue + imageMarginValue );
                }
            }
        };

        return markerNumber;
    },

    getLeftRightMarginTotal: function(componentStyleName) {
        var marginValue = 5;//default margin value
        var componentStyleRule = Ext.util.CSS.getRule(componentStyleName);
        if(!componentStyleRule){
            return marginValue;
        }
        var componentStyle = componentStyleRule.style;
        if(!Ext.isIE){
            marginValue = parseInt(componentStyle.getPropertyValue('margin-left').replace("px",""))
                + parseInt(componentStyle.getPropertyValue('margin-right').replace("px",""));
        }
        else{
            marginValue = parseInt(componentStyle.marginLeft.replace("px",""))
                + parseInt(componentStyle.marginRight.replace("px",""));
        }
        return marginValue;
    },

    getPreviewContent:function (previewContent) {
        var plainContent = Ext.util.Format.stripTags(previewContent);

        if (plainContent.length > 0) {
            previewContent = plainContent.replace(/&nbsp;/g, " ");
        }

        var previewPlain = Ext.String.ellipsis(previewContent, 250);
        RM.Logger.info("CommentMarker", "getPreviewContent", "Preview text"+ previewPlain);
        return previewPlain;
    },

    registerQuickTip: function(markerImage, event) {
        var comment = this.comment;
        var date = new Date(comment.creationDate)
        var previewContent = comment.commentContent;
        var previewPlain = this.getPreviewContent(comment.commentContent);
        var formattedCreationDate = Ext.Date.format(date, RM.Strings.Viewer.DocumentViewer.creationDateFormat);
        var commentHeaderText = Ext.String.format(RM.Strings.Viewer.DocumentViewer.commentHeaderFormat,
            comment.creatorName, formattedCreationDate);

        var tip = Ext.create('Ext.tip.ToolTip', {
            target: markerImage.id,
            cls: 'rmCommentHoverPanel',
            autoHide: true,
            shadow: false,
            dismissDelay: 0,
            preventHeader: true,
            items: [
                { xtype: 'component', cls:'rmHoverTopBar', html: commentHeaderText, cols: 32 },
                { xtype: 'component', cls: 'rmCommentPreviewSeparator' },
                { xtype: 'component', html: previewPlain, cls: 'rmCommentPreviewContent', grow: true, cols: 32 },
                { xtype: 'component', cls: 'rmCommentPreviewLowerSeparator' },
                { xtype: 'label', text: RM.Strings.Viewer.DocumentViewer.commentHoverPrompt, cls: 'rmHoverBottomBar' }
            ]
        });
        RM.Logger.debug("CommentMarker", "registerQuickTip", "Registered quick tip for marker:" + markerImage.id);
        var tipOffsetX = tip.getMouseOffset()[0];
        var tipOffsetY = tip.getMouseOffset()[1];
        if(event.browserEvent.pageX) {
            tip.showAt([event.browserEvent.pageX + tipOffsetX, event.browserEvent.pageY + tipOffsetY]);
        }
        else{
            tip.showAt([event.browserEvent.clientX + tipOffsetX, event.browserEvent.clientY + tipOffsetY]);
        }

        this.tip = tip;
    },

    applyComment: function(comment) {
        this.comment = comment;
        if(this.tip){
            this.tip.removeAll();
            this.tip.destroy();
            if(this.tip.ownerCt){
                this.tip.ownerCt.remove(this.tip, true);
            }
            delete this.tip;
        }
        this.el.addListener('mouseover', this.mouseOverListener, this);
        return comment;
    }
});

/**
 * User: michad
 * Date: 8/10/11
 * Time: 12:29 PM
 */
Ext.define('RM.view.CommentView', {
    extend:'Ext.panel.Panel',
    cls:'rmCommentlist-content-view',
    layout:'fit',
    preventHeader:false,
    collapsible:false,
    config:{
        comment:{},
        parentCommentId:'',
        commentAreaId:'',
        currentUser:'',
        canEditComment:false
    },

    statics:{
        getCommentMetadata:function (comment) {
            var formattedCreationDate = Ext.Date.format(new Date(comment.creationDate),
                RM.Strings.Viewer.DocumentViewer.creationDateFormat);
            return Ext.String.format(RM.Strings.Viewer.DocumentViewer.commentHeaderFormat,
                comment.creatorName, formattedCreationDate);
        }
    },

    initComponent:function () {
        var me = this;
        var comment = me.comment;
        me.addEvents('editCancelled');

        me.contentArea = { xtype:'component', html:comment.commentContent, cls:'rmCommentlist-content', shrinkWrap:true};
        me.items = [
            me.contentArea
        ];

        me.commentToolbar = Ext.create('RM.view.CommentToolbar', {
            ui:'footer',
            dock:'bottom',
            comment:comment,
            commentAreaId:me.commentAreaId,
            parentCommentId:me.parentCommentId,
            currentUser:me.currentUser,
            canEditComment:me.canEditComment
        });
        me.relayEvents(me.commentToolbar, [
            "editCommentEvent",
            "replyToCommentEvent",
            "deleteCommentEvent"
        ]);
        if (this.comment.replies > 0) {   //Have a collapsible header to show reply count
            me.commentHeader = this.createCommentHeader(comment);
            me.tbar = me.commentHeader;
        }
        me.bbar = me.commentToolbar;
        me.callParent(arguments);

        if (this.comment.replies == 0) {  //This is just a leaf element, No need for header panel
            me.setTitle(RM.view.CommentView.getCommentMetadata(comment));
        }
    },

    createReplyCountHtml:function () {
        var replyText = RM.Strings.Viewer.DocumentViewer.commentReplyCountLabel;
        if (this.comment.replies > 1) replyText = RM.Strings.Viewer.DocumentViewer.commentRepliesCountLabel;

        var replyFormat = '<span class="rmComment-reply-count">{0}&nbsp;{1}</span>';
        var replyCount = Ext.String.format(replyFormat, this.comment.replies, replyText);
        var hasUnreadReplies = this.comment.unreadReplies > 0;
        if (hasUnreadReplies) {
            replyFormat = '<span class="rmComment-reply-count">{0} (<span class="rmComment-unread-count">{1}</span>)&nbsp;&nbsp;{2}</span>';
            replyCount = Ext.String.format(replyFormat, this.comment.replies, this.comment.unreadReplies, replyText);
        }
        return replyCount;
    },

    createCommentHeader:function (comment) {
        var replyCountLabels = [];
        var headBarCollapsed = true;
        var replyCount = "";
        if (this.comment.replies > 0) {
            replyCount = this.createReplyCountHtml();
            headBarCollapsed = !this.collapsed;
        }
        replyCountLabels.push({ xtype:'component', itemId:"replyCount", html:replyCount, cls:"rmHeaderReplyCount"});
        return Ext.create('Ext.Toolbar',
            {   dock:'top',
                ui:'header',
                isHeader:true,
                items:{ xtype:'panel', itemId:"headerView", title:RM.view.CommentView.getCommentMetadata(comment),
                    items:replyCountLabels, cls:'rmViewerCommentHeader', collapsed:headBarCollapsed, animCollapse:false}
            });
    },

    updateReplyCountLabels:function () {
        if (this.commentHeader) {  //No header means no replies
            var replyCountBar = this.commentHeader.getComponent('headerView');
            var replyCountLabel = replyCountBar.getComponent("replyCount");
            var replyCount = "";
            if (this.comment.replies > 0) {
                replyCountLabel.update(this.createReplyCountHtml());
            }
            else {
                replyCountLabel.update("");//There is no replies.. dont show count.
            }
        }
    },

    listeners:{
        afterrender:function () {
            var me = this;
            var height;
            Ext.each(me.items.items, function (item) {
                height = item.getHeight();
                item.el.setStyle("width", "auto");
//                item.el.setStyle("height", height + "px");
            });

            //EXTJS 41 b bug for html component height
            Ext.defer(function () {
                me.doComponentLayout();
            }, 250, this);

        }
    },

    applyComment:function (comment) {
        this.contentArea.html = comment.commentContent;
        return comment;
    },

    disableToolbar:function (disable) {
        this.commentToolbar.isToolbarActive(!disable);
    },

    updateReplyCount:function (countChangedEventData) {
        if (!Ext.Array.contains(countChangedEventData.parents, this.comment))
            return;

        this.updateReplyCountLabels();
        this.commentToolbar.updateReplyCountLabels();
    },

    minimizeView:function () {
        if (this.commentHeader) {
            var headView = this.commentHeader.getComponent('headerView');
            if (headView.collapsed) {
                headView.toggleCollapse();
                headView.doComponentLayout();
            }
        }
        if (!this.collapsed) {
            //Do collapse
            // this.title = this.getCommentMetadata(this.comment);
            this.toggleCollapse();
        }
    },

    maximizeView:function () {
        if (this.commentHeader) {
            var headView = this.commentHeader.getComponent('headerView');
            if (!headView.collapsed) {
                headView.toggleCollapse();
            }
        }
        if (this.collapsed) {
            //Do expand
            this.toggleCollapse();
        }
    }

});
/**
 * User: michad
 * Date: 8/3/11
 * Time: 11:35 AM
 */

Ext.define('RM.view.CommentThread', {
    extend:'Ext.Window',
    title:RM.Strings.Viewer.DocumentViewer.commentThreadTitle,
    constrain:true,
    renderTo:"",
    modal:true,
    minWidth:420,
    iconCls:'viewer-add-comment',
    cls:'rmViewerCommentThread',
    autoScroll:false,
    alias:'widget.rmViewerCommentThread',
    layout:'border',
    colTemplate:{
        commentBody:"<tr><td>{3}</td></tr>  <tr><td class='collapserIconCls'>{5}</td><td>{0}<table cellspacing='0' cellpadding='0' border='0' style='width:90%'><tr>{4}</tr><tr>{1}</tr></table>{2}</td></tr>"
    },
    commentContentPrefix:"cArea",
    commentViewNodeSuffix:"cView",
    expanderCls:Ext.baseCSSPrefix + 'tree-rm-expander',
    maximizedViewCls:'rm-comment-view-maximized',
    minimizedViewCls:'rm-comment-view-minimized',
    config:{
        parentComment:{},
        currentUser:{},
        commentList:[],
        commentThread:[],
        newCommentId:"newCommentThreadCommentId",
        canEditComment:false,
        replyComment:{
            creatorName:"",
            commentId:"",
            commentTitle:"",
            leaf:true
        }
    },

    initComponent:function () {
        var me = this;
        me.addEvents('commentThreadCommentEdit', 'commentThreadCommentAdd');
        me.commentAreaList = [];
        me.itemsToCleanup = [];
        me.prepareStore(me.commentThread);

        me.title = RM.Strings.Viewer.DocumentViewer.commentThreadTitle + me.parentComment.commentNumber;

        me.commentTree = Ext.create('Ext.tree.Panel', {
            cls:'rmViewerCommentTree',
            region:"center",
            store:me.commentThreadStore,
            rootVisible:false,
            hideHeaders:true,
            autoScroll:true,
            multiSelect:false,
            viewConfig:{
                trackOver:false,
                stripeRows:false,
                toggleOnDblClick:false,
                listeners:{
                    scope:me,
                    viewready:function () {
                        me.assignCommentControls();
                    }
                }
            },
            columns:[
                {dataIndex:'commentContent', scope:me, sortable:false, renderer:me.renderComment, flex:1}
            ]
        });
        //Adding listener after tree has been loaded with current set
        me.commentTree.on('itemappend', me.onCommentNodeAdded, me);
        me.commentTree.on('itemremove', me.onCommentNodeRemoved, me);

        me.commentTree.getView().store.on('expand', me.onNodeExpanded, me);
        me.commentTree.getView().store.on('collapse', me.onNodeCollapsed, me);
        me.commentTree.getView().on('beforeitemclick', me.onViewItemClick, me);

        me.on('editorActiveEvent', me.checkEnableCollapse, me);

        me.bbar = Ext.create('Ext.Toolbar', {
            ui:'footer',
            dock:'bottom',
            items:[
                {xtype:'component', flex:1},
                {xtype:'button', cls:'rmCommentThreadCloseButton', text:RM.Strings.Viewer.DocumentViewer.close, scope:me, handler:me.closeHandler}
            ]
        });

        me.commentBar = Ext.create('Ext.panel.Panel', {
            cls:"rmCommentHeader", //set style at runtime?
            preventHeader:true,
            html:"<div id=" + me.id + "header" + "container" + "> </div>",
            region:"north"
        });

        me.items = [me.commentBar, me.commentTree];
        me.commentBar.setHeight(0);
        me.callParent();
    },

    assignCommentControls:function (replyParentNode) {
        var me = this;
        var currentComment;
        var currentCommentId;
        var currentUser = me.currentUser;
        var commentNode;
        Ext.each(me.commentAreaList, function (commentAreaInfo) {
            currentComment = commentAreaInfo.comment;
            currentCommentId = currentComment.commentId;
            var existingComponent = me.getCommentNodeView(currentCommentId);
            var commentArea;
            var commentView;

            commentArea = Ext.get(me.getCommentContentAreaId(currentComment));
            if (commentArea.dom.childNodes.length > 0) {
                commentArea.dom.removeChild(commentArea.dom.firstChild);
            }
            me.cleanUpCommentView(existingComponent, me);

            var isMinimized = false;
            commentNode = this.commentThreadStore.getNodeById(currentComment.commentId);
            if (commentNode && !(commentNode.isLeaf() && commentNode.isExpanded()) || commentNode.data.expanded == false) {
                if (commentNode.maximized != null && commentNode.maximized == false) {
                    isMinimized = true;
                }
            }

            commentView = Ext.create('RM.view.CommentView', {
                id:me.commentViewNodeSuffix + me.id + currentCommentId,
                comment:currentComment,
                currentUser:me.currentUser,
                parentCommentId:me.parentComment.commentId,
                commentAreaId:commentAreaInfo.commentAreaId,
                collapsed:isMinimized,
                canEditComment:this.canEditComment,
                renderTo:me.getCommentContentAreaId(currentComment)

            });
            me.on('editorActiveEvent', commentView.disableToolbar, commentView);
            me.on('replyCountChanged', commentView.updateReplyCount, commentView);

            me.itemsToCleanup.push(commentView.id);
            commentView.el.setStyle("width", "auto");
            commentView.on('editCommentEvent', me.editCommentHandler, me);
            commentView.on('replyToCommentEvent', me.commentReplyHandler, me);
            commentView.on('deleteCommentEvent', me.commentDeleteHandler, me);
            commentView.on('expand', me.commentExpandHandler, me);

            if (replyParentNode) {
                commentView.disableToolbar(replyParentNode.data.commentId == currentCommentId);
            } else {
                commentView.disableToolbar(me.isEditorActive);
            }
        }, this, !Ext.isIE);
        me.commentAreaList = [];
    },

    cleanUpCommentView:function (existingComponent, commentThread) {
        if (existingComponent) {
            commentThread.un('editorActiveEvent', existingComponent.disableToolbar, existingComponent);
            commentThread.un('replyCountChanged', existingComponent.updateReplyCount, existingComponent);
            existingComponent.un('editCommentEvent', commentThread.editCommentHandler, commentThread);
            existingComponent.un('replyToCommentEvent', commentThread.commentReplyHandler, commentThread);
            existingComponent.un('deleteCommentEvent', commentThread.commentDeleteHandler, commentThread);
            existingComponent.un('expand', commentThread.commentExpandHandler, commentThread);


            existingComponent.destroy();
        }
    },

    renderComment:function (value, metaData, record, rowIndex, colIdx, store, view) {
        var commentThreadBuffer = [];
        commentThreadBuffer.push("<table cellspacing='0' cellpadding='0' border='0' style='width:100%'");

        var format = Ext.String.format;
        var commentInfo = record;
        var comment = commentInfo.data;

        if (comment.unread) {
            commentThreadBuffer.push("class='rmComment-unread'");
        }
        else {
            commentThreadBuffer.push("class='rmComment-read'");
        }

        var commentAreaId = this.getCommentContentAreaId(comment);

        var replyToLevel = commentInfo.getDepth();
        var imgText = '<input type="image" src="{1}" class="{0}" ';
        imgText = this.createImageTag(record, replyToLevel, imgText);
        if (replyToLevel > 0)
            imgText = imgText + ' style="margin-left:' + (15 * (replyToLevel - 1)) + 'px;" ';
        imgText += '/>';

        var padding = "<div class='rmCommentlist-comment' id='" + commentAreaId + "' style='";
        padding = padding + "'>";
        var endpadding = "</div>";

        this.commentAreaList.push({"comment":comment, "commentAreaId":commentAreaId});

        var divider;
        var commentBody = "";

        divider = ((replyToLevel == 0) && (rowIndex > 0)) ? "<div class='rmCommentlist-horizontal-rule'/>" : "";
        commentBody = format(this.colTemplate.commentBody, padding,
            "", endpadding, divider, "", imgText);
        commentThreadBuffer.push(commentBody);
        commentThreadBuffer.push("</table>");
        return  commentThreadBuffer.join("");

    },

    createImageTag:function (record, depth, imgText) {
        var treePrefix = Ext.baseCSSPrefix + 'tree-';
        var collapseIconCls = 'rm-tree-';
        var expanderCls = treePrefix + 'rm-expander';
        format = Ext.String.format;
        if (record.getDepth() > 1) {
            //Not the Root
            if (record.isLeaf() || (record.isLoaded() && !record.hasChildNodes())) {
                if ((record.maximized == null || record.maximized == true) && record.data.expanded == true) {
                    imgText = (format(imgText, (this.maximizedViewCls), Ext.BLANK_IMAGE_URL));
                    record.maximized = true;
                }
                else {
                    imgText = (format(imgText, (this.minimizedViewCls), Ext.BLANK_IMAGE_URL));
                    record.maximized = record.data.expanded = false;
                }
            } else {
                imgText = (format(imgText, (collapseIconCls + 'plus ' + expanderCls), Ext.BLANK_IMAGE_URL));
                record.maximized = record.data.expanded;
            }
        } else {
            imgText = (format(imgText, (collapseIconCls + 'empty'), Ext.BLANK_IMAGE_URL));
        }
        return imgText;
    },

    prepareStore:function (rootNode) {
        var store = Ext.create('Ext.data.TreeStore', {
            model:'RM.model.Comment',
            root:{
                expanded:true,
                children:[
                    rootNode
                ]
            }
        });
        this.commentThreadStore = store;
    },

    getCommentContentAreaId:function (comment) {
        return this.commentContentPrefix + comment.commentId;
    },

    closeHandler:function (btn) {
        //send out an event with collapsed nodes information and size of dialog for the current comment
        var collapsedNodeFilter = new Ext.util.Filter({
            filterFn:function (item) {
                if (item.maximized != null)
                    return !item.maximized;
                else
                    return false;
            }
        });

        //a new MixedCollection with the applied filter
        var collapsedNodes = Ext.Array.filter(this.commentThreadStore.tree.flatten(), collapsedNodeFilter.filterFn);

        this.fireEvent("commentThreadWindowClose", this.parentComment, collapsedNodes, this.getHeight(), this.getWidth());
        this[this.closeAction]();
        //destroy any components hanging around
        var existingComponent;
        Ext.each(me.itemsToCleanup, function (commentAreaCmp) {
            existingComponent = Ext.getCmp(commentAreaCmp);
            if (!existingComponent) {
                return;
            }
            if (existingComponent instanceof RM.view.CommentView) {
                this.cleanUpCommentView(existingComponent, this);
            }
            else {
                existingComponent.destroy();
            }
        });
    },

    cleanUpCachedEditor:function () {
        if (this.currentEditor != null) {
            this.currentEditor.destroy();
        }
    },

    getCommentEditor:function (comment) {
        var me = this;
        me.cleanUpCachedEditor();

        var parentCommentNode = this.commentThreadStore.getNodeById(comment.parentId);
        if (parentCommentNode) var parentComment = parentCommentNode.data;
        me.currentEditor = Ext.create('RM.view.InLineCommentEditor', {
            comment:comment,
            parentComment:parentComment,
            replyCommentId:me.config.newCommentId,
            editorHeaderArea:me.id + "header" + "container",
            editorMaxHeight:me.commentTree.getView().getHeight() - 120, //removing the toolbar's height (not rendered as yet)
            layout:'fit'
        });
        me.relayEvents(me.currentEditor, ['commentSaveRequest']);
        return me.currentEditor;
    },

    isRootComment:function (commentId) {
        return this.parentComment.commentId == commentId;
    },

    onCommentNodeAdded:function (replyParentNode, newCommentNode) {
        var commentAreaId = this.getCommentContentAreaId(newCommentNode.data);
        var me = this;

        var delayTask = new Ext.util.DelayedTask(function () {
            me.assignCommentControls(replyParentNode);
            if (newCommentNode.data.commentId == me.config.newCommentId) {
                me.editCommentHandler(newCommentNode.data, commentAreaId);
            }

            //me.commentTree.doLayout();
            me.getCommentNodeView(newCommentNode.data.commentId).el.scrollIntoView(me.commentTree.getView().el);
        });
        delayTask.delay(250);
    },

    onCommentNodeRemoved:function (replyParentNode, newCommentNode) {
        var commentAreaId = this.getCommentContentAreaId(newCommentNode.data);
        var me = this;

        var delayTask = new Ext.util.DelayedTask(function () {
            me.assignCommentControls();
            /*if (me.commentTree && me.commentTree.view && me.commentTree.view.el && me.commentTree.view.el.dom) {
             me.commentTree.determineScrollbars();
             }*/
            me.commentTree.selModel.select(newCommentNode);
            me.getCommentNodeView(newCommentNode.data.commentId).el.scrollIntoView(me.commentTree.getView().el);
        });
        delayTask.delay(250);
    },

    onNodeCollapsed:function (collapsedNode) {
        collapsedNode.maximized = false;
        this.assignCommentControls();
        this.minimizeComment(collapsedNode.data.commentId);
        //this.commentTree.updateLayout();
        //this.commentTree.invalidateScroller();
    },

    onNodeExpanded:function (expandedNode) {
        expandedNode.maximized = true;
        this.assignCommentControls();
        this.maximizeComment(expandedNode.data.commentId);
        //this.commentTree.updateLayout();
        //this.commentTree.invalidateScroller();
    },

    minimizeComment:function (commentId) {
        this.getCommentNodeView(commentId).minimizeView();
    },

    maximizeComment:function (commentId) {
        this.getCommentNodeView(commentId).maximizeView();
    },

    onViewItemClick:function (view, record, item, index, e) {
        if (record == null || this.isBeingEdited(record)) {
            return false;
        }
        if (e.getTarget("." + this.expanderCls, item)) {
            view.toggle(record);
            //the event to the collapse/expand takes care of the rest
            return false;
        }
        //if it's a click on a maximized icon - minimize the view and change the icon to minimized
        var maximizedIcon = e.getTarget("." + this.maximizedViewCls, item);
        var minimizedIcon;
        var viewComponent = this.getCommentNodeView(record.data.commentId);
        if (maximizedIcon) {
            viewComponent.minimizeView();
            Ext.Element.get(maximizedIcon).replaceCls(this.maximizedViewCls, this.minimizedViewCls);
            record.maximized = false;
        }
        else {
            minimizedIcon = e.getTarget("." + this.minimizedViewCls, item);
            //double check
            if (minimizedIcon) {
                viewComponent.maximizeView();
                Ext.Element.get(minimizedIcon).replaceCls(this.minimizedViewCls, this.maximizedViewCls);
                record.maximized = true;
            }
        }
        //this.commentTree.updateLayout();
        //this.commentTree.invalidateScroller();
    },

    getCommentNodeView:function (commentId) {
        if (commentId) {
            return Ext.getCmp(this.commentViewNodeSuffix + this.id + commentId);
        }
    },

    /**
     * returns true if a comment or one of the comments in it's reply heirarchy is being edited
     * @param comment
     */
    isBeingEdited:function (commentInfo) {
        var comment = commentInfo.data;
        var result = false;
        if (!this.isEditorActive) {
            return result; // no need to proceed further with the check
        }
        //Edit is active - a comment is being edited - who is it
        var checkCommentId = comment.commentId;
        //is it me
        if (this.currentEditor.comment.commentId == checkCommentId) {
            result = true;
        }
        //is it a reply to me
        if (this.currentEditor.comment.parentId == checkCommentId) {
            result = true;
        }
        //recursively through all children's children
        if (result == false) {
            result = this.isChildBeingEdited(commentInfo, this.currentEditor.comment.commentId, false);
        }
        return result;
    },

    isChildBeingEdited:function (commentInfo, commentBeingEdited, foundChildEdit) {
        var me = this;
        if (commentInfo.childNodes != null) {
            Ext.Array.some(commentInfo.childNodes, function (currentChildCommentNode) {
                if (currentChildCommentNode.data.commentId == commentBeingEdited) {
                    foundChildEdit = true;
                }
                else {
                    //check it's children
                    if (currentChildCommentNode) {
                        foundChildEdit = me.isChildBeingEdited(currentChildCommentNode, commentBeingEdited, foundChildEdit);
                    }
                }
                return foundChildEdit;
            });
        }
        return foundChildEdit
    },

    enableCollapseIcon:function (commentId, enable, invisible) {
        var commentArea = Ext.get(this.commentContentPrefix + commentId);
        var collapseIconCls = 'rm-tree-plus';
        if (commentArea == null) {
            //it's the top node
            return;
        }
        //get collapse icon from display area
        var commentRow = commentArea.up("tr");
        var collapseIcon = commentRow.down("." + this.maximizedViewCls, true);
        if (!collapseIcon) {
            collapseIcon = commentRow.down("." + collapseIconCls, true);
        }
        if (collapseIcon) {
            collapseIcon.disabled = !enable;
            if (invisible) {
                collapseIcon.hidden = true;
            }
            else {
                collapseIcon.hidden = false;
            }
        }
    },

    checkEnableCollapse:function (isEditorActive) {
        if (isEditorActive) {
            //this.currentEditor.doComponentLayout(this.getCommentNodeWidth( this.currentEditor.comment ) - 2);
            //find the current comment being edited
            var commentInEdit = this.currentEditor.comment.commentId;
            //disable this comment's collapse
            //get display area for comment
            this.enableCollapseIcon(commentInEdit, false, true);
            //disable any parent comment in tree hierarchy
            this.enableParentComments(parentId, false);
        }
        else {
            var commentInEdit = this.currentEditor.comment.commentId;
            this.enableCollapseIcon(commentInEdit, true);
            //var commentView = this.getCommentNodeView(commentInEdit);
            //enable parent in hierarchy
            var parentId = this.currentEditor.comment.replyTo;
            this.enableParentComments(parentId, true);
        }
    },

    enableParentComments:function (parentId, enable) {
        var parentNode;
        while (parentId != null && parentId != "") {
            this.enableCollapseIcon(parentId, enable);
            parentNode = this.commentThreadStore.getNodeById(parentId);
            if (parentNode && parentNode.data) {
                parentId = parentNode.data.replyTo;
            }
            else {
                parentId = null;
            }
        }
    },

    commentReplyHandler:function (comment, commentAreaId) {
        var replyComment = Ext.clone(this.config.replyComment);
        replyComment.replyTo = comment.commentId;
        replyComment.creationDate = (new Date()).getTime();
        replyComment.commentId = this.config.newCommentId;
        replyComment.leaf = true;
        replyComment.expanded = true;

        if (comment.children == null) {
            comment.children = [];
        }
        comment.expanded = true;
        comment.leaf = false;

        var parentNode = this.commentThreadStore.getNodeById(comment.commentId);
        parentNode.appendChild(replyComment);
    },

    commentDeleteHandler:function (commentToDelete, commentAreaId) {
        this.fireEvent('requestCommentDelete', this, commentToDelete, commentAreaId);
        this.threadWaitMode();
    },

    commentExpandHandler:function () {
        //this.commentTree.updateLayout();
        //this.commentTree.invalidateScroller();
    },

    threadWaitMode:function () {
        this.commentTree.disable();
        this.el.setStyle("cursor", "wait");
    },

    editCommentHandler:function (comment, commentAreaId) {
        var me = this;
        this.getCommentEditor(comment);
        me.currentEditArea = commentAreaId;
        me.currentEditor.on('editCancelled', me.editCompleted, me);
        me.currentEditor.on('commentSaved', me.onCommentSaved, me);
        me.currentEditor.on('editorResize', me.onEditorResize, this);
        me.replaceCommentArea(commentAreaId, me.currentEditor, comment);
    },

    replaceCommentArea:function (commentAreaId, currentEditor, comment) {
        this.viewComponentArea = Ext.get(commentAreaId).down('div'); // the div of the displayed comment view component
        this.viewComponentAreaHeight = Ext.get(commentAreaId).getHeight();  // total height taken up by view component now

        /*currentEditor.setWidth("100%");
         if (currentEditor.height < this.viewComponentAreaHeight) {
         currentEditor.setHeight("100%");
         }*/
        currentEditor.render(commentAreaId, 0);
        if (!RM.richEditorHelper.isCkEditorInitialized && currentEditor.richEditor) {
            currentEditor.richEditor.on('editorInitialized', this.resizeCommentBar, this);
        }
        this.commentBar.setHeight(Ext.get(this.id + "header" + "container").getHeight());

        //this.viewComponentArea.setHeight(0);
        this.viewComponentArea.dom.style.display = "none";
        this.fireEvent('editorActiveEvent', true);
        this.isEditorActive = true;
        Ext.get(commentAreaId).setHeight(currentEditor.getHeight());//this.viewComponentAreaHeight);
        this.scrollCommentIntoDisplay(commentAreaId);
    },

    scrollCommentIntoDisplay:function (commentAreaId) {
        var me = this;
        var delayTask = new Ext.util.DelayedTask(function () {
            if (Ext.get(commentAreaId)) {
                //me.commentTree.determineScrollbars();
                Ext.get(commentAreaId).scrollIntoView(me.commentTree.getView().el);
            }
        });
        delayTask.delay(250);
    },

    resizeCommentBar:function () {
        if (this.currentEditor && this.currentEditor.richEditor) {
            this.currentEditor.richEditor.un('editorInitialized', this.resizeCommentBar);
        }
        var toolbarArea = Ext.get(this.id + "header" + "container");
        if (toolbarArea) {
            this.commentBar.setHeight(Ext.get(this.id + "header" + "container").getHeight());
        }
        //this.commentTree.doLayout();
        //this.getCommentNodeView(this.currentEditor.comment.commentId).el.scrollIntoView(this.commentTree.getView().el);
        this.setWindowScrollToEditor(this.currentEditor);
    },

    editCompleted:function (comment) {
        if (comment.commentId == this.config.newCommentId) {
            //this was a new comment - ie. a reply
            //remove the editor node and ask view to assign any controls(comment views) if required (if the comment was saved and not cancelled)
            this.removeTempNode(comment);
            this.assignCommentControls();
        }
        else {
            //this is an edit of an existing comment
            var commentArea = Ext.get(this.currentEditArea);//the area taken up by the enveloping div into which the editor was painted
            if (commentArea.dom.childNodes.length > 1) {
                commentArea.dom.removeChild(commentArea.dom.firstChild);
            }
            this.viewComponentArea.setHeight(this.viewComponentAreaHeight);//this.viewComponentArea.getHeight());
            this.viewComponentArea.setVisible(true);
            this.getCommentNodeView(comment.commentId).doComponentLayout();
            commentArea.setHeight("100%");
        }

        this.fireEvent('editorActiveEvent', false);
        this.isEditorActive = false;
        this.commentBar.setHeight(0);
        //this.commentTree.determineScrollbars();
        this.getCommentNodeView(comment.commentId).el.scrollIntoView(this.commentTree.getView().el);
    },

    removeTempNode:function (comment) {
        var parentNode = this.commentThreadStore.getNodeById(comment.replyTo);
        if (parentNode.childNodes.length == 1) {
            parentNode.collapseChildren();
            parentNode.data.leaf = true;
            parentNode.data.expanded = true;
        }
        var childNode = this.commentThreadStore.getNodeById(comment.commentId);

        parentNode.removeChild(childNode);
    },

    onCommentSaved:function (oldComment, newComment) {
        //this.commentTree.selModel.selNode.reload();
        this.editCompleted(oldComment);
        if (newComment.commentId != this.config.newCommentId) {

            if (oldComment.commentId != this.config.newCommentId) {
                oldComment.commentContent = newComment.commentContent;
                this.commentAreaList.push({"comment":oldComment, "commentAreaId":this.getCommentContentAreaId(newComment)});
                this.fireEvent('commentThreadCommentEdit', oldComment);
            } else {
                var parentNode = this.commentThreadStore.getNodeById(newComment.replyTo);
                if (parentNode.childNodes.length == 0) {
                    parentNode.expand();
                    parentNode.data.leaf = false;
                    parentNode.data.expanded = true;
                }
                newComment.expanded = true;
                newComment.leaf = newComment.loaded = true;
                parentNode.appendChild(newComment);
                this.fireEvent('commentThreadCommentAdd', newComment, newComment.replyTo);

                //Update all the reply count labels
                this.addReplyToCounts(newComment)
            }
        }
        this.assignCommentControls();
    },

    addReplyToCounts:function (replyComment) {
        var parentComments = this.getParentComments(replyComment);
        //Increment reply count for each parent
        Ext.each(parentComments, function (comment) {
            comment.replies++;
        });
        var countChangedEventData = { parents:parentComments, isReply:true, replyId:replyComment.commentId};
        this.fireEvent('replyCountChanged', countChangedEventData);
    },

    deleteRepliesFromCounts:function (deleteComment) {
        var parentComments = this.getParentComments(deleteComment);
        //Decrement reply count for each parent
        Ext.each(parentComments, function (comment) {
            comment.replies -= (deleteComment.replies + 1);
            comment.unreadReplies -= deleteComment.unreadReplies;
        });
        var countChangedEventData = { parents:parentComments };
        this.fireEvent('replyCountChanged', countChangedEventData);
    },

    getParentComments:function (comment) {
        var parentIds = [];
        var immediateParent = comment;
        while (true) {
            if (this.isRootComment(immediateParent.commentId))
                break;
            var parentNode = this.commentThreadStore.getNodeById(immediateParent.replyTo);
            if (parentNode)
                immediateParent = parentNode.data;
            else
                break;
            parentIds.push(immediateParent)
        }
        return parentIds
    },

    onCommentDeleted:function (commentToDelete, commentAreaId, isDeleteSuccessful) {
        if (isDeleteSuccessful) {
            if (commentToDelete.commentId == this.parentComment.commentId) {
                this.closeHandler();
                return;
            }
            else {
                var parentNode = this.commentThreadStore.getNodeById(commentToDelete.replyTo);
                if (parentNode.childNodes.length == 1) {
                    //parentNode.collapse();
                    parentNode.data.leaf = true;
                    parentNode.data.expanded = true;
                }
                this.deleteRepliesFromCounts(commentToDelete);
                parentNode.removeChild(this.commentThreadStore.getNodeById(commentToDelete.commentId));
            }
        }

        this.commentTree.enable();
        this.el.setStyle("cursor", "default");
    },

    listeners:{
        resize:function (window) {
            if (window.isEditorActive == true) {
                window.currentEditor.richEditor.resizeCkEditor(window.currentEditor.richEditor);
                if (window.commentBar.getHeight() != Ext.get(window.id + "header" + "container").getHeight() && !Ext.isIE) {
                    //window.commentBar.doComponentLayout(Ext.get(window.id + "header" + "container").getWidth(), Ext.get(window.id + "header" + "container").getHeight());
                    window.commentBar.setHeight(Ext.get(window.id + "header" + "container").getHeight());
                    window.commentBar.setWidth(Ext.get(window.id + "header" + "container").getWidth());
                }
            }
        }
    },

    getCommentNodeWidth:function (comment) {
        var commentArea = Ext.get(this.getCommentContentAreaId(comment));
        var nodeMargin = commentArea.getMargin("lr");
        var treePadding = this.commentTree.getView().el.getPadding("lr");
        var treeWidth = this.commentTree.getView().getWidth();
        var width = treeWidth - treePadding - nodeMargin;
        return width;
    },

    setWindowScrollToEditor:function (editor) {

        Ext.defer(function () {
            //this.commentTree.getView().resetScrollers(); Ext JS 4b
            //var verticalScroller = this.commentTree.getVerticalScroller();
            //if (verticalScroller) {
            var viewEl = this.commentTree.getView().getEl();
            editor.postBtn.getEl().scrollIntoView(viewEl);
            /*var scrollTop = viewEl.getScroll().top;
             verticalScroller.setScrollTop(scrollTop);*/
            //}
        }, 250, this);
    },

    onEditorResize:function (editor) {
        this.setWindowScrollToEditor(editor);
    }
});

/**
 * User: michad
 * Date: 8/8/11
 * Time: 2:41 PM
 */
Ext.define('RM.view.InLineCommentEditor', {
    extend: 'Ext.panel.Panel',
    cls:'rmCommentItemEditor',
    minWidth: 400,
    editorMaxHeight: 175,
    alias: 'widget.rmCommentEditor',
    preventHeader: false,
    config: {
        comment: {},
        parentComment:{},
        replyCommentId: '',
        editorHeaderArea: ''
    },

    initComponent:function() {
        var me = this;

        me.addEvents('editCancelled', 'commentSaveRequest');

        if (this.isNewReplyComment()) {
            var replyHeaderContainer = this.createReplyHeader(this.parentComment);
            this.replyHeader = replyHeaderContainer.getComponent("replyHeader");
            this.tbar = replyHeaderContainer;
        }
        else{
            this.title = this.createEditHeader();
        }
        var editorConfig = {};
        Ext.apply(editorConfig, RM.richEditorHelper.ckEditorConfig);
        editorConfig.sharedSpaces = {
            top: me.editorHeaderArea
        };
        editorConfig.extraPlugins = 'autogrow';
        editorConfig.autoGrow_maxHeight = me.editorMaxHeight;
        editorConfig.autoGrow_minHeight = 70;
        editorConfig.autoGrow_bottomSpace = 0;
        me.richEditor = Ext.create('widget.ckeditor',{
            cls:'rmCommentHtmlEditor',
            CKConfig: editorConfig
        });

        me.richEditor.setValue(me.comment.commentContent);
        me.richEditor.on('editorInitialized', me.subscribeToEditoResize, me);

        me.items = me.richEditor;

        var postBtn = Ext.create('Ext.button.Button', {
            text    : RM.Strings.Viewer.DocumentViewer.post,
            cls:'rmRichHtmlOkButton',
            disabled: false,
            scope   : me,
            handler : me.postHandler
        });

        me.postBtn = postBtn;

        me.bbar = Ext.create('Ext.Toolbar', {
            ui: 'footer',
            dock: 'bottom',
            items: [
                postBtn,
                {xtype: 'button', cls:'rmRichHtmlCancelButton', text : RM.Strings.Viewer.DocumentViewer.cancel, scope:me, handler: me.cancelHandler},
                {xtype: 'component', flex: 1}
            ]
        });
        me.callParent();
    },

    createEditHeader:function () {
        var formattedCreationDate = this.formatCommentDate(this.comment);
        return Ext.String.format(RM.Strings.Viewer.DocumentViewer.commentHeaderFormat,
            this.comment.creatorName, formattedCreationDate);
    },

    listeners: {
        afterrender:function() {
            if(this.replyHeader){
                var previewPlain = this.getPreviewContent(this.parentComment.commentContent);
                var tip = Ext.create('Ext.tip.ToolTip', {
                    target: this.replyHeader.id,
                    cls: 'rmReplyHoverPanel',
                    autoHide: true,
                    dismissDelay: 0,
                    preventHeader: true,
                    items: [
                        { xtype: 'component', html: previewPlain, cls: 'rmCommentPreviewContent', grow: true, cols: 32 }
                    ]});
            }
        }
    },

    getPreviewContent:function (previewContent) {
        var plainContent = Ext.util.Format.stripTags(previewContent);

        if (plainContent.length > 0) {
            previewContent = plainContent.replace(/&nbsp;/g, " ");
        }

        var previewPlain = Ext.String.ellipsis(previewContent, 250);
        return previewPlain;
    },

    formatCommentDate:function (comment) {
        return Ext.Date.format(new Date(comment.creationDate),
            RM.Strings.Viewer.DocumentViewer.creationDateFormat);
    },

    createReplyHeader: function(parentComment) {
        var displayDate = this.formatCommentDate(parentComment);
        var replyHeading = Ext.String.format(RM.Strings.Viewer.DocumentViewer.replyComment, this.parentComment.creatorName, displayDate);
        return Ext.create('Ext.Toolbar',
            {   dock: 'top',
                ui:'header',
                isHeader: true,
                items: [
                    { xtype: 'component', itemId: "replyHeader", html:replyHeading, cls: 'rmComment-reply-count'}
                ]
            });
    },


    subscribeToEditoResize: function(event) {
        var me = this;
        this.richEditor.editor.on('resize', function() {
            //REDRAW
            me.doLayout();
            me.fireEvent('editorResize', me);
        });
    },

    doComponentLayout: function(width, resizeEditor) {
        if (resizeEditor) {
            this.richEditor.setWidth(width);
            if (this.richEditor.editor != null) {
                this.richEditor.resizeCkEditor(this.richEditor);
            }
        }
        //this.richEditor.doComponentLayout();
        this.callParent(arguments);
    },

    postHandler: function(btn) {
        //console.log("Editor value: " + this.richEditor.getValue() );
        if (this.isCommentContentModified()) {
            this.comment.commentContent = RM.richEditorHelper.getEditorValue(this.richEditor);
            this.fireEvent('commentSaveRequest', this.comment, this.isNewReplyComment(), this);
        }
    },

    cancelHandler: function (btn) {
        this.fireEvent('editCancelled', this.comment);
    },

    validateInputText: function(editor, html) {
        var newValue = html;
        if (newValue.trim != undefined) {
            newValue = newValue.trim();
        }
        if (RM.richEditorHelper.isEmptyText(html) || !this.isCommentContentModified(html)) {
            this.postBtn.disable();
        }
        else {
            this.postBtn.enable();
        }
    },

    applyComment: function(comment) {
        return comment;
    },

    isCommentContentModified: function(html) {
        var result = true;
        var commentContent = this.comment.commentContent;
        var editorContent;
        if (html) {
            editorContent = html;
        }
        else {
            editorContent = RM.richEditorHelper.getEditorValue(this.richEditor);
        }
        if (commentContent == null && RM.richEditorHelper.isEmptyText(this.richEditor)) {
            result = false;
        }
        else {
            result = this.richEditor.editor.checkDirty();
        }
        return result;
    },

    isNewReplyComment: function() {
        return (this.comment.commentId == this.replyCommentId);
    },

    onCommentSaved: function(comment) {
        this.fireEvent('commentSaved', this.comment, comment);
    },

    onCommentSaveFail: function() {

    }


});
/**
 * User: michad
 * Date: 8/5/11
 * Time: 4:24 PM
 */
Ext.define("RM.view.CommentToolbar", {
    extend:"Ext.Toolbar",
    config:{
        comment:{},
        currentUser:'',
        commentAreaId:'',
        parentCommentId:'',
        isToolbarActive:true,
        canEditComment:false
    },

    initComponent:function () {
        this.addEvents('editCommentEvent', 'replyToCommentEvent', 'deleteCommentEvent');
        this.items = this.generateToolBarRegion();
        this.callParent();
    },

    deleteHandler:function () {
        var me = this;
        var confirmationMessage;
        if (me.comment.commentId == me.parentCommentId) {
            confirmationMessage = Ext.util.Format.nl2br(RM.Strings.Viewer.DocumentViewer.deleteThreadConfirmMsg);
        }
        else {
            confirmationMessage = Ext.util.Format.nl2br(RM.Strings.Viewer.DocumentViewer.deleteReplyConfirmMsg);
        }
        this.deleteConfirmation(confirmationMessage);
    },

    deleteConfirmation:function (confirmationMessage) {
        var me = this;
        Ext.Msg.confirm(
            RM.Strings.Viewer.DocumentViewer.deleteConfirmHeader,
            confirmationMessage,
            function (btn) {
                if (btn == 'yes')
                    me.deleteConfirmationHandler();
            });
    },

    deleteConfirmationHandler:function () {
        this.fireEvent('deleteCommentEvent', this.comment, this.commentAreaId);
    },

    editHandler:function () {
        this.fireEvent('editCommentEvent', this.comment, this.commentAreaId);
    },

    replyHandler:function () {
        //tree add child ? or add to store ?

        this.fireEvent('replyToCommentEvent', this.comment, this.commentAreaId);
    },

    generateToolBarRegion:function () {
        var toolBarComponents = [];
        if (this.canEditComment) {
            toolBarComponents = toolBarComponents.concat(this.addAllUserOptions());
            if (this.comment.creatorName == this.currentUser) {
                toolBarComponents = toolBarComponents.concat(this.addCurrentUserOptions());
            }
        }
        return toolBarComponents;
    },

    addCurrentUserOptions:function () {
        var me = this;
        var userOptions = [];

        me.editBtn = Ext.create('Ext.button.Button', {
            text:RM.Strings.Viewer.DocumentViewer.edit,
            cls:"x-btn-text-icon rmCommentEditButton",
            iconCls:"edit-comment",
            disabled:false,
            scope:me,
            handler:me.editHandler
        });
        me.deleteBtn = Ext.create('Ext.button.Button', {
            text:RM.Strings.Viewer.DocumentViewer.deleteLabel,
            cls:"x-btn-text-icon rmCommentDeleteButton",
            iconCls:"delete-comment",
            disabled:false,
            scope:me,
            handler:me.deleteHandler
        });

        userOptions.push(me.editBtn, me.deleteBtn);

        return userOptions;
    },

    addAllUserOptions:function () {
        var me = this;
        var userOptions = [];

        me.replyBtn = Ext.create('Ext.button.Button', {
            text:RM.Strings.Viewer.DocumentViewer.reply,
            cls:"x-btn-text-icon rmCommentReplyButton",
            iconCls:"reply-comment",
            disabled:false,
            scope:me,
            handler:me.replyHandler
        });

        var replyCount = "";
        if (this.comment.replies > 0) {
            replyCount = this.createReplyCountHtml();
        }

        userOptions.push({ xtype:'component', itemId:"replyCount", html:replyCount});
        userOptions.push({xtype:'tbfill'});
        /*userOptions.push({xtype: 'component', cls: 'reply-comment'});*/
        userOptions.push(me.replyBtn);

        return userOptions;
    },

    updateReplyCountLabels:function () {
        var replyCountLabel = this.getComponent("replyCount");
        var replyCount = "";
        if (this.comment.replies > 0) {
            replyCountLabel.update(this.createReplyCountHtml());
        }
        else {
            replyCountLabel.update("");//There is no replies.. dont show count.
        }
    },


    createReplyCountHtml:function () {
        var replyText = RM.Strings.Viewer.DocumentViewer.commentReplyCountLabel;
        if (this.comment.replies > 1) replyText = RM.Strings.Viewer.DocumentViewer.commentRepliesCountLabel;

        var replyFormat = '<span class="rmComment-reply-count">{0}&nbsp;{1}</span>';
        var replyCount = Ext.String.format(replyFormat, this.comment.replies, replyText);
        var hasUnreadReplies = this.comment.unreadReplies > 0;
        if (hasUnreadReplies) {
            replyFormat = '<span class="rmComment-reply-count">{0} (<span class="rmComment-unread-count">{1}</span>)&nbsp;&nbsp;{2}</span>';
            replyCount = Ext.String.format(replyFormat, this.comment.replies, this.comment.unreadReplies, replyText);
        }
        return replyCount;
    },

    isToolbarActive:function (active) {
        if (active) {
            this.enableToolbarControls();
        } else {
            this.disableToolbarControls();
        }
    },

    disableToolbarControls:function () {
        if (this.replyBtn) this.replyBtn.disable();
        if (this.editBtn) this.editBtn.disable();
        if (this.deleteBtn) this.deleteBtn.disable();
    },

    enableToolbarControls:function () {
        if (this.replyBtn) this.replyBtn.enable();
        if (this.editBtn) this.editBtn.enable();
        if (this.deleteBtn) this.deleteBtn.enable();
    }

});
Ext.define("RM.view.SearchMenu", {
    extend:"Ext.menu.Menu",
    allowOtherMenus:true,
    afterrender:function (ct) {
        var me = this;
        me.callParent(ct);
    },
    show:function () {
        this.callParent(arguments);
        if (this.keyNav) {
            this.keyNav.disable();
        }
        this.isSearchMenuTarget = false;
        var me = this;
        Ext.getDoc().on('mousedown', me.onMenuMouseDown, me, {
            // On IE we have issues with the menu stealing focus at certain points
            // during the head, so give it a short buffer
            buffer:Ext.isIE ? 10 : undefined
        });

    },
    hide:function (closeSearch) {
        var me = this;
        if (closeSearch) {
            me.callParent();
        }
        else {
            //if the hide was called from an auto hide from other than clicking the menu (like a scroll), then hide and show to reposition
            this.hide(true);
            if (this.delayedShowTask == null) {
                this.delayedShowTask = new Ext.util.DelayedTask(this.delayedShow, this);
            }
            this.delayedShowTask.delay(1000);
        }
    },
    delayedShow:function () {
        if (this.isSearchMenuTarget && this.isSearchMenuTarget == true) {
            //don't show it if the source of the hide event was a click on the menu item itself
            this.isSearchMenuTarget = false;
        }
        else {
            if(this.ownerButton)
                this.ownerButton.menu.showBy(this.ownerButton.el, this.ownerButton.menuAlign, ((!Ext.isStrict && Ext.isIE) || Ext.isIE6) ? [-2, -2] : undefined);
        }
    },
    // private
    onMenuMouseDown:function (e) {
        if (e.getTarget('.rmViewerSearchIcon')) {
            this.isSearchMenuTarget = true;
        }
    },
    unregister:function (comp) {
        Ext.getDoc().un('mousedown', this.onMenuMouseDown, this);
    }
});

Ext.define('RM.view.SearchBox',
    {
        extend:'Ext.form.field.Trigger',
        trigger1Cls:Ext.baseCSSPrefix + 'viewer-form-clear-trigger',
        trigger2Cls:Ext.baseCSSPrefix + 'viewer-form-search-trigger',
        emptyText:RM.Strings.Viewer.DocumentViewer.search,
        bubbleEvents:["clearSearch", "search", "showNextOccurrence"],

        afterRender:function () {
            this.callParent();
            var cancelBtn = new Ext.dom.Element(this.triggerEl.item(0).dom.parentElement);
            cancelBtn.setDisplayed('none');
            this.doComponentLayout();
        },

        hideClearButton:function () {
            this.setValue("");
            var cancelBtn = new Ext.dom.Element(this.triggerEl.item(0).dom.parentElement);
            cancelBtn.setDisplayed('none');
            this.doComponentLayout();
        },

        showClearButton:function () {
            var cancelBtn = new Ext.dom.Element(this.triggerEl.item(0).dom.parentElement);
            cancelBtn.setDisplayed('block');
            this.doComponentLayout();
        },

        onTrigger1Click:function () {
            this.hideClearButton();
            this.fireEvent("clearSearch");
        },

        onTrigger2Click:function () {
            this.search();
        },

        listeners:{
            specialkey:function (field, e) {
                if (e.getKey() == e.ENTER) {
                    var searchString = this.getValue();
                    if (searchString && this.prevSearch == searchString) {
                        this.fireEvent("showNextOccurrence");
                    } else {
                        this.search();
                    }
                }
            }
        },

        search:function () {
            var searchString = this.getValue();
            if (searchString) {
                this.fireEvent("search", searchString);
                this.showClearButton();
                this.prevSearch = searchString;
            }
            else {
                this.onTrigger1Click();//Clear search;
            }

        }
    }
);


Ext.define("RM.view.SearchControls", {
    extend:"Ext.container.Container",
    alias:'widget.searchcontrols',
    bubbleEvents:["showPrevOccurrence", "showNextOccurrence"],
    cls:"rmViewerSearchControls",
    layout:{
        type:'vbox'
    },
    config:{
        isServerSideSearch:false
    },
    initComponent:function () {
        var me = this;
        this.addListener("clearSearch", this.hideSearchResultCount);
        var isSearchBoxDisabled = !this.isServerSideSearch;
        this.searchBox = Ext.create("RM.view.SearchBox", {
            cls:"rmViewerSearchBox",
            disabled:isSearchBoxDisabled
        });
        var searchToolbar = this.searchToolbar = Ext.create('Ext.container.Container', {
            layout:{
                type:'hbox'
            },
            items:[
                this.searchBox,
                { xtype:'button',
                    itemId:'previousSearchButton',
                    cls:'rmViewerPreviousSearchButton',
                    iconCls:"rmviewer-toolbar-button viewer-prev-page-enabled",
                    tooltip:RM.Strings.Viewer.DocumentViewer.previousOccurrence,
                    disabled:true,
                    handler:function () {
                        me.fireEvent("showPrevOccurrence")
                    }

                },
                { xtype:'button',
                    itemId:'nextSearchButton',
                    cls:'rmViewerNextSearchButton',
                    iconCls:"rmviewer-toolbar-button viewer-next-page-enabled",
                    disabled:true,
                    tooltip:RM.Strings.Viewer.DocumentViewer.nextOccurrence,
                    handler:function () {
                        me.fireEvent("showNextOccurrence")
                    }
                }
            ]

        });

        this.items = [searchToolbar];
        this.callParent();

    },


    getSearchOccurrenceLabel:function (count) {
        if (count > 1)
            return Ext.String.format(RM.Strings.Viewer.DocumentViewer.searchOccurrences, count);
        else
            return Ext.String.format(RM.Strings.Viewer.DocumentViewer.searchOccurrence, count);
    },

    showSearchResultCount:function (count) {
        var searchOccurrences = this.getSearchOccurrenceLabel(count);
        if (!this.resultsCountLabel) {
            this.resultsCountLabel = Ext.create("Ext.form.Label", { text:searchOccurrences, cls:"rmViewerHitCount" });
            this.add(this.resultsCountLabel);
            this.doComponentLayout();
        }
        else {
            this.resultsCountLabel.setText(searchOccurrences);
        }
    },

    showSearchingLabel:function () {
        var searchingLabel = RM.Strings.Viewer.DocumentViewer.loadingSearchHits;
        if (!this.resultsCountLabel) {
            this.resultsCountLabel = Ext.create("Ext.form.Label", { text:searchingLabel, cls:"rmViewerHitCount" });
            this.add(this.resultsCountLabel);
            this.doComponentLayout();
        }
        else {
            this.resultsCountLabel.setText(searchingLabel);
        }
    },

    hideSearchResultCount:function () {
        if (this.resultsCountLabel) {
            this.remove(this.resultsCountLabel);
            delete this.resultsCountLabel;
            this.doComponentLayout();
        }
    },

    setSearchNavPrevBtnState:function (enable) {
        var searchToolbar = this.searchToolbar;
        var nextBtn = searchToolbar.getComponent("previousSearchButton");
        nextBtn.setDisabled(!enable)
    },

    setSearchNavNextBtnState:function (enable) {
        var searchToolbar = this.searchToolbar;
        var prevBtn = searchToolbar.getComponent("nextSearchButton");
        prevBtn.setDisabled(!enable);
    },

    focusSearchBox:function () {
        this.searchBox.focus(true, 100);
    },

    notifySearchXmlLoading:function () {
        this.searchBox.emptyText = RM.Strings.Viewer.DocumentViewer.loadingIndex;
    },

    notifySearchXmlLoadCompletion:function () {
        this.searchBox.emptyText = RM.Strings.Viewer.DocumentViewer.search;
        //Hack to make sure empty text is updated
        this.searchBox.setValue(this.searchBox.getValue());
        if (Ext.isIE) this.searchBox.setValue("");
        this.searchBox.enable(true);
    }
});

Ext.define('RM.controller.SearchController', {
    extend:'Ext.util.Observable',
    textualMetaDataXML:{},
    searchHits:[],
    currentSelectedHitIndex:0,
    highLightIndex:new Ext.util.HashMap(),
    statics:{
        COMMA_REPLACEMENT:"%2C"
    },

    initViewerDomQueryPseudoSelector:function () {
        var me = this;
        Ext.DomQuery.pseudos.viewerSearch = function (textNodes, searchString) {
            var results = [], resultIndex = -1;
            searchString = searchString.replace(RM.controller.SearchController.COMMA_REPLACEMENT, ",");
            var searchTokens = me.getTokens(searchString);
            var searchTokensLength = searchTokens.length - 1;
            var result = null;
            var curSearchIndex = 0;

            for (var nodeIndex = 0, textNode; textNode = textNodes[nodeIndex]; nodeIndex++) {
                var text = (textNode.textContent || textNode.innerText || textNode.text).toLowerCase();
                var textTokens = me.getTokens(text);
                for (var textTokenIndex = 0; textTokenIndex < textTokens.length; textTokenIndex++) {
                    if (textTokens[textTokenIndex].indexOf(searchTokens[curSearchIndex]) != -1) {
                        var tokenHit = me.createHitObject(textNode, textTokens[textTokenIndex], textTokenIndex);
                        if (!result) result = [tokenHit];
                        else result.push(tokenHit);
                        if (searchTokensLength == curSearchIndex) {   //Search success
                            results[++resultIndex] = result;
                            curSearchIndex = 0;
                            result = null;
                        } else {
                            curSearchIndex++;
                        }
                    } else {
                        if (curSearchIndex != 0) {
                            textTokenIndex--;// Redo the loop with current search Index starting from zero
                        }
                        result = null;
                        curSearchIndex = 0;
                    }
                }
            }
            return results;
        };
    },


    initialize:function (viewer, pageView, viewerToolbar) {
        this.documentViewer = viewer;
        this.pageView = pageView;
        this.viewerControlBar = viewerToolbar;
        this.initViewerDomQueryPseudoSelector();
        this.textualMetaDataXMLRequested = false;
        viewer.addListener('resetToNewDocument', this.resetToNewDocument, this);
        viewerToolbar.addListener('searchControlInit', this.initSearch, this);
        viewerToolbar.addListener('search', this.searchAndHighlight, this);
        viewerToolbar.addListener('showPrevOccurrence', this.navigateToPrevSearchHit, this);
        viewerToolbar.addListener('showNextOccurrence', this.navigateToNextSearchHit, this);
        viewerToolbar.addListener('clearSearch', this.clearSearch, this);
        pageView.addListener('repositionSearchHighlights', this.repositionSearchHighlights, this);
        RM.Logger.log("SearchController", "initialize", "Initialized id:" + this.id);
    },

    cleanup:function () {
        this.textualMetaDataXML = null;
    },

    initSearch:function () {
        if (!this.isServerSideSearch()) {
            this.loadTextualMetaDataXML();
        }
    },

    loadTextualMetaDataXML:function () {
        //If it already requested just return
        if (this.textualMetaDataXMLRequested) {
            return;
        }
        else {
            this.textualMetaDataXMLRequested = true;
        }
        var documentId = this.documentViewer.document.objectId;
        var textualMetaDataXMLUrls = this.documentViewer.getTextualMetaDataUrl().split(",");
        var ACS_URL = textualMetaDataXMLUrls[0];
        var fallbackURL = textualMetaDataXMLUrls[1];
        var me = this;

        this.notifySearchXmlLoading();

        if (!Ext.isIE) { //Try loading directly from ACS
            Ext.Ajax.request({
                url:ACS_URL,
                timeout:200000,
                cors:true,
                method:"GET",
                success:function (response) {
                    me.textualMetaDataXML = response.responseXML;
                    Ext.DomQuery.selectNode('t', me.textualMetaDataXML);
                    me.notifySearchXmlLoadCompletion();
                    RM.Logger.log("SearchController", "loadTextualMetaDataXML", "XML Loaded successfully");
                },
                failure:function () {
                    if (fallbackURL != null) {
                        RM.Logger.log("SearchController", "tryFallbackURL", "Failed to load ACS url.Trying fallback URL");
                        me.tryFallbackURL(fallbackURL, documentId, me);
                    }
                }
            });
        }
        else{  //No CORS support for IE as of now because of EXTJSIV-5799.
            me.tryFallbackURL(fallbackURL, documentId, me);
        }

    },

    tryFallbackURL:function (fallbackURL, documentId, me) {
        Ext.Ajax.request({
            url:fallbackURL,
            timeout:36000,
            method:"GET",
            params:{
                objectId:documentId
            },
            success:function (response) {
                me.textualMetaDataXML = response.responseXML;
                Ext.DomQuery.selectNode('t', me.textualMetaDataXML);
                me.notifySearchXmlLoadCompletion();
                RM.Logger.log("SearchController", "loadTextualMetaDataXML", "XML Loaded successfully");
            },
            failure:function () {
                if (xcp && xcp.core && xcp.core.FeedbackManager) {
                    xcp.core.FeedbackManager.showFeedback(null, "", RM.Strings.Viewer.DocumentViewer.searchError, "systemErrors");
                    me.disableSearch();
                    RM.Logger.error("SearchController", "loadTextualMetaDataXML", " Failed to load xml");
                }
                me.notifySearchXmlLoadCompletion();
            }
        });

    },

    notifySearchXmlLoading:function () {
        this.viewerControlBar.notifySearchXmlLoading();
    },

    notifySearchXmlLoadCompletion:function () {
        this.viewerControlBar.notifySearchXmlLoadCompletion();
    },

    disableSearch:function () {
        this.viewerControlBar.disableSearchBtn();
    },

    clearSearch:function () {
        this.searchHits = [];
        this.clearSearchHighlights(true);
    },

    highlightCurrentHit:function (doNavigation) {
        doNavigation = doNavigation || false;
        if (this.searchHits.length == 0) {
            return; //No results to highlight
        }
        var currentHitObj = this.searchHits[this.currentSelectedHitIndex];
        var currentSelectedHitId = this.getSearchHitId(currentHitObj);
        var currentHitPageNumber = currentHitObj[0].pageNumber;
        var hitTargetYPos = currentHitObj[0].targetYPos;
        var hitTargetXPos = currentHitObj[0].targetXPos;
        var highLightIndex = this.highLightIndex;
        var currentHitEls = highLightIndex.get(currentSelectedHitId);
        if (currentHitEls) {
            Ext.Array.forEach(currentHitEls, function (hitFragmentEl) {
                if (!hitFragmentEl.hasCls("rmDocumentViewer-selected-highlight")) {
                    hitFragmentEl.addCls("rmDocumentViewer-selected-highlight");
                }
            });
        }
        if (doNavigation && hitTargetYPos) {
            this.pageView.showSelectedSearchHighlight(currentHitPageNumber, hitTargetXPos, hitTargetYPos);
        }
        else if (doNavigation) {  //Case where the highlight is in next page set
            this.pageView.navigateToPage(currentHitPageNumber);
        }
    },

    navigateToNextSearchHit:function () {
        var totalHits = this.searchHits.length;
        if (this.currentSelectedHitIndex >= totalHits - 1) {
            return; //Currently at last hit
        }
        var lastSelectedHitIndex = this.currentSelectedHitIndex;
        var currentSelectedHitIndex = this.incrementSelectedHitIndex();
        var currentHitObj = this.searchHits[currentSelectedHitIndex];
        var highLightIndex = this.highLightIndex;
        if (lastSelectedHitIndex != -1) {
            var lastSelectedHitId = this.getSearchHitId(this.searchHits[lastSelectedHitIndex]);
            var previousHitEl = highLightIndex.get(lastSelectedHitId);
            if (previousHitEl) {
                Ext.Array.forEach(previousHitEl, function (hitFragment) {
                    hitFragment.removeCls("rmDocumentViewer-selected-highlight");
                });
                RM.Logger.debug("SearchController", "navigateToNextSearchHit", "Clearing previous hit" + lastSelectedHitId);
            }
            else {
                RM.Logger.debug("SearchController", "navigateToNextSearchHit", "Previous hit is not there in the UI" + lastSelectedHitId);
            }
        }

        this.highlightCurrentHit(true);
    },

    navigateToPrevSearchHit:function () {
        var totalHits = this.searchHits.length;
        if (this.currentSelectedHitIndex <= 0) {
            return; //Currently at first hit
        }
        var lastSelectedHitIndex = this.currentSelectedHitIndex;
        var currentSelectedHitIndex = this.decrementSelectedHitIndex();
        var currentHitObj = this.searchHits[currentSelectedHitIndex];
        var highLightIndex = this.highLightIndex;
        if (lastSelectedHitIndex != -1) {
            var lastSelectedHitId = this.getSearchHitId(this.searchHits[lastSelectedHitIndex]);
            var previousHitEl = highLightIndex.get(lastSelectedHitId);
            if (previousHitEl) {
                Ext.Array.forEach(previousHitEl, function (hitFragment) {
                    hitFragment.removeCls("rmDocumentViewer-selected-highlight");
                });
                RM.Logger.debug("SearchController", "navigateToNextSearchHit", "Clearing previous hit" + lastSelectedHitId);
            }
            else {
                RM.Logger.debug("SearchController", "navigateToNextSearchHit", "Previous hit is not there in the UI" + lastSelectedHitId);
            }
        }

        this.highlightCurrentHit(true);
    },

    setCurrentSelectedHitIndex:function (index) {
        this.currentSelectedHitIndex = index;
        this.setNavigationControls();
        return index;
    },

    incrementSelectedHitIndex:function () {
        return this.setCurrentSelectedHitIndex(++this.currentSelectedHitIndex);
    },

    decrementSelectedHitIndex:function () {
        return this.setCurrentSelectedHitIndex(--this.currentSelectedHitIndex);
    },

    setNavigationControls:function () {
        var totalHits = this.searchHits.length;
        var index = this.currentSelectedHitIndex;
        if (index >= totalHits - 1) {
            this.viewerControlBar.setSearchNavNextBtnState(false);
        }
        else {
            this.viewerControlBar.setSearchNavNextBtnState(true);
        }

        if (index == 0) {
            this.viewerControlBar.setSearchNavPrevBtnState(false);
        }
        else {
            this.viewerControlBar.setSearchNavPrevBtnState(true);
        }
    },

    escapeSearchString:function (token) {
        return Ext.String.escape(token);
    },

    getTokens:function (Term) {
        var tokens = [];
        Ext.Array.forEach(Term.split(/\s+/), function (token) {
            if (!Ext.isEmpty(token)) {
                tokens.push(this.escapeSearchString(token.toLowerCase()));
            }
        }, this);

        return tokens;
    },

    search:function (searchString) {
        RM.Logger.info("SearchController", "search", " Searching xml for:" + searchString);
        searchString = Ext.String.escape(searchString);
        //DomQuery don't support selector with comma.if "t:viewerSearch(car,mouse)" is given
        //it will raise a invalid expression error.To workaround, it encodes the comma
        //in the search string and decode it back in the pesudo selector.
        searchString = searchString.replace(",", RM.controller.SearchController.COMMA_REPLACEMENT);
        return Ext.DomQuery.select("t:viewerSearch(" + searchString + ")", this.textualMetaDataXML);
    },

    searchAndHighlight:function (searchString) {
        if (this.isServerSideSearch()) {
            this.doServerSideSearch(searchString, this.highlightSearchHits);
        }
        else {
            var searchHitList = this.search(searchString);
            this.highlightSearchHits(searchHitList);
        }
    },

    doServerSideSearch:function (searchString, successFunction) {
        this.viewerControlBar.notifySearchingOnServer();
        RM.Logger.info("SearchController", "doServerSideSearch", " Performing server search for words:  " + searchString);
        Ext.Ajax.request({
            url:this.documentViewer.searchUrl,
            method:"GET",
            scope:this,
            params:{ objectId:this.documentViewer.document.objectId,
                term:searchString
            },
            success:function (response) {
                var json = Ext.decode(response.responseText);
                var searchHitList = json.searchHitList;
                successFunction.call(this, searchHitList);
            },
            failure:function (error) {
                this.viewerControlBar.notifySearchingComplete();
                if (xcp && xcp.core && xcp.core.FeedbackManager)
                    xcp.core.FeedbackManager.showFeedback(null, "", response.responseText, "systemErrors");
            }
        });

    },

    isServerSideSearch:function () {
        return (this.documentViewer.isServerSideSearch == true && this.documentViewer.searchUrl != null);
    },

    highlightSearchHits:function (searchHitList) {
        var searchResults = this.processResults(searchHitList);
        this.searchHits = searchResults;
        this.clearHighlightSelection();
        this.viewerControlBar.setSearchCount(this.searchHits.length);
        this.highlightAllSearchHits();
        this.setNavigationControls();
        this.highlightCurrentHit(true);
    },

    processResults:function (searchHits) {
        var processedSearchHits = [];
        for (var searchHitIndex = 0; searchHitIndex < searchHits.length; searchHitIndex++) {
            var searchHit = searchHits[searchHitIndex];
            var processedSearchHit = [];
            var currentSearchHitFragment = null;
            for (var i = 0; i < searchHit.length; i++) {
                var hitFragment = searchHit[i];
                if (!currentSearchHitFragment) {
                    currentSearchHitFragment = {};
                    Ext.apply(currentSearchHitFragment, hitFragment);
                    processedSearchHit.push(currentSearchHitFragment)
                }
                else {
                    if (currentSearchHitFragment.yPos == hitFragment.yPos) {
                        if(currentSearchHitFragment.xPos <= hitFragment.xPos )  { //LTR languages
                            currentSearchHitFragment.width = ((parseInt(hitFragment.xPos) - parseInt(currentSearchHitFragment.xPos) ) + parseInt(hitFragment.width));
                        }else{ //RTL languages
                            currentSearchHitFragment.width = (parseInt(currentSearchHitFragment.xPos) - (parseInt(hitFragment.xPos) ) + parseInt(currentSearchHitFragment.width));
                            currentSearchHitFragment.xPos = hitFragment.xPos;
                        }
                    }
                    else {
                        currentSearchHitFragment = {};
                        Ext.apply(currentSearchHitFragment, hitFragment);
                        processedSearchHit.push(currentSearchHitFragment)
                    }
                }
            }
            processedSearchHits.push(processedSearchHit);
        }
        return  processedSearchHits;
    },

    repositionSearchHighlights:function () {
        this.highlightAllSearchHits();
    },

    isSearchTermSimilar:function (nodeText, searchTerm) {
        return  nodeText.indexOf(searchTerm) > -1
    },

    createHitObject:function (hit, text, hitPosition) {
        var p = hit.attributes.getNamedItem("p").value.split(",");
        var height = hit.attributes.getNamedItem("h").value;
        var yPos = hit.attributes.getNamedItem("y").value;
        //Height adjustment for pdf with wrong height values.
        if (height < 0) {
            yPos = yPos - (Math.abs(height) * 2);
        }
        return {
            height:Math.abs(height),
            width:parseInt(p[hitPosition * 2 + 1]),
            xPos:parseInt(p[hitPosition * 2]),
            yPos:yPos,
            text:text,
            pageNumber:hit.parentNode.attributes.getNamedItem("n").value,
            pageHeight:hit.parentNode.attributes.getNamedItem("h").value,
            pageWidth:hit.parentNode.attributes.getNamedItem("w").value};
    },

    resetToNewDocument:function () {
        RM.Logger.info("SearchController", "resetToNewDocument", "Resetting to new document");
        this.textualMetaDataXML = {};
    },

    highlightAllSearchHits:function () {
        //Clear all search hits
        this.clearSearchHighlights();
        Ext.Array.forEach(this.searchHits, function (item, index) {
            this.highlightSearchHit(item, index);
        }, this);

        this.highlightCurrentHit();
    },

    clearHighlightSelection:function () {
        this.setCurrentSelectedHitIndex(0);
    },

    clearSearchHighlights:function (clearSelection) {
        this.highLightIndex.each(function (key, highlights) {
            Ext.Array.forEach(highlights, function (highlight) {
                highlight.remove();
            });
        });
        clearSelection = clearSelection || false;
        this.highLightIndex.clear();
        if (clearSelection) {
            this.clearHighlightSelection();
        }
    },

    createAndPositionHighLight:function (hit) {
        var targetDiv = Ext.get(this.pageView.getUniquePageDivID(hit.pageNumber));
        if (!targetDiv) {
            //log here
            RM.Logger.debug("SearchController", "highlightSearchHit", "Page not in view.No need to highlight page:" + hit.pageNumber);
            return;
        }

        var image = targetDiv.down("img");
        var circleRadius = 8;

        var targetOffsetTop = image.dom.offsetTop;
        var targetOffsetLeft = image.dom.offsetLeft;

        var targetXPos = hit.xPos;
        var targetYPos = hit.yPos;
        var imageWidth = image.dom.width;
        var imageHeight = image.dom.height;
        RM.Logger.debug("SearchController", "highlightSearchHit", "SearchHit.xyPos : " + hit.xPos + ", " + hit.yPos);

        var xRatio = imageWidth / hit.pageWidth;
        var yRatio = imageHeight / hit.pageHeight;
        targetXPos = targetXPos * xRatio;
        targetYPos = targetYPos * yRatio;
        RM.Logger.debug("SearchController", "highlightSearchHit", "targetXYPos (in ratio) : " + targetXPos + ", " + targetYPos);

        var rotatedAngle = this.pageView.getEarlierRotateAngle(hit.pageNumber);
        var hitWidth = hit.width * xRatio;
        var heightAdjustmentForPDFBox = 2;
        var hitHeight = hit.height * yRatio + heightAdjustmentForPDFBox;

        var xMidpoint, yMidpoint, xyRotated, offsetRotated;
        if (rotatedAngle > 0) {
            xMidpoint = imageWidth / 2;
            yMidpoint = imageHeight / 2;
            xyRotated = RM.controller.CommentController.rotatedXY(targetXPos, targetYPos, xMidpoint, yMidpoint, rotatedAngle);
            targetXPos = xyRotated[0];
            targetYPos = xyRotated[1];
            if (Ext.isIE) {
                if (image.dom.style.left != "") {
                    RM.Logger.debug("SearchController", "highlightSearchHit", "IE image correction : targetXPos += image.dom.style.left : " + targetXPos + " += " + image.dom.style.left);
                    RM.Logger.debug("SearchController", "highlightSearchHit", "IE image correction : targetYPos += image.dom.style.left : " + targetYPos + " += " + image.dom.style.left);
                    targetXPos += -parseInt(image.dom.style.left.replace("px", ""));
                    targetYPos += parseInt(image.dom.style.left.replace("px", ""));
                }
                else if (rotatedAngle == 90 || rotatedAngle == 270) {
                    var toMoveDeltaX, toMoveDeltaY;
                    toMoveDeltaX = -((image.dom.width - image.dom.height) / 2  );
                    toMoveDeltaY = -((image.dom.height - image.dom.width) / 2 );
                    targetOffsetLeft += toMoveDeltaX;
                    targetOffsetTop += toMoveDeltaY;
                    RM.Logger.debug("SearchController", "highlightSearchHit", "IE image correction : targetOffsetLeft += toMoveDeltaX : " + targetOffsetLeft + " += " + toMoveDeltaX);
                    RM.Logger.debug("SearchController", "highlightSearchHit", "IE image correction : targetOffsetTop += toMoveDeltaY : " + targetOffsetTop + " += " + toMoveDeltaY);
                }
            }
            RM.Logger.debug("SearchController", "highlightSearchHit", "targetXYPos (rotated) : " + targetXPos + ", " + targetYPos);
        }

        var rotatedXY = this.adjustRotatedXY(rotatedAngle, hitWidth, hitHeight, targetXPos, targetYPos);
        targetXPos = rotatedXY.xPos;
        targetYPos = rotatedXY.yPos;

        if (rotatedAngle == 90 || rotatedAngle == 270) {
            hitWidth = hit.height * yRatio;
            hitHeight = hit.width * xRatio;
        }

        RM.Logger.debug("SearchController", "highlightSearchHit", "targetOffsetLeft + targetXPos - circleRadius : " + targetOffsetLeft + " + " + targetXPos + " - " + circleRadius);
        RM.Logger.debug("SearchController", "highlightSearchHit", "targetOffsetTop + targetYPos - circleRadius  : " + targetOffsetTop + " + " + targetYPos + " - " + circleRadius);
        var circleXPos = (targetOffsetLeft + targetXPos );
        var circleYPos = (targetOffsetTop + targetYPos );
        RM.Logger.debug("SearchController", "highlightSearchHit", "circleXPos : " + circleXPos + " and circleYPos : " + circleYPos);
        var highlightElem = this.createHighlightElement(Math.abs(hitHeight), Math.abs(hitWidth), circleXPos, circleYPos, targetDiv);
        this.saveHitTargetYPos(hit, targetXPos, targetYPos); //Save hit targetXPos and targetYPos
        return highlightElem;
    },

    saveHitTargetYPos:function (hit, targetXPos, targetYPos) {
        hit.targetXPos = targetXPos;
        hit.targetYPos = targetYPos;
    },

    adjustRotatedXY:function (rotatedAngle, hitWidth, hitHeight, targetXPos, targetYPos) {
        switch (rotatedAngle) {
            case 90:
            {
                return {xPos:(targetXPos - hitHeight), yPos:targetYPos};
            }
            case 180:
            {
                return {xPos:(targetXPos - hitWidth), yPos:(targetYPos - hitHeight)}
            }
            case 270:
            {
                return {xPos:targetXPos, yPos:(targetYPos - hitWidth)}
            }
            default :
            {
                return {xPos:targetXPos, yPos:targetYPos }
            }
        }
    },

    highlightSearchHit:function (hit, index) {
        if (Ext.isArray(hit)) {  //Phrase query
            Ext.Array.forEach(hit, function (hitToken) { //Multiple token in a single hit

                var highlightElem = this.createAndPositionHighLight(hitToken);
                this.trackHighlightElements(this.getSearchHitId(hit[0]), highlightElem);
            }, this);
        }
        else { //Single Query
            var highlightElem = this.createAndPositionHighLight(hit);
            this.trackHighlightElements(this.getSearchHitId(hit[0]), highlightElem);
        }
    },

    createHighlightElement:function (hitHeight, hitWidth, circleXPos, circleYPos, targetDiv) {
        var spec = {
            tag:'div',
            cls:'rmDocumentViewer-search-highlight',
            style:"left: " + circleXPos + "px; top:" + circleYPos + "px; height:" + hitHeight + "px; width:" + hitWidth + "px"

        };
        return Ext.core.DomHelper.append(targetDiv, spec, true);
    },

    trackHighlightElements:function (id, highlightElem) {
        if (highlightElem) {
            var highLights = this.highLightIndex.get(id);
            if (highLights) {
                highLights.push(highlightElem);
            }
            else {
                this.highLightIndex.add(id, [highlightElem]);
            }
        }
    },

    getSearchHitId:function (hit) {
        var hitFragment = hit;//if not an array
        if (Ext.isArray(hit)) {
            hitFragment = hit[0];
        }
        //Take the first hit fragment and create id
        return "id-" + hitFragment.pageNumber + hitFragment.xPos + hitFragment.yPos;
    }
});
/**
 * Created by IntelliJ IDEA.
 * User: michad
 * Date: 3/14/12
 * Time: 8:25 PM
 */

Ext.define('RM.controller.PrintController', {
    extend:'Ext.util.Observable',

    statics:{
        /**
         * Get Selected Page numbers in thumbnail panel as an array
         * @param pageStr  Page numbers string
         */
        getPageNums:function (pageStr) {
            var pageNums = [];
            var pgNo = 0;
            var pages = pageStr.split(",");
            for (var i = 0; i < pages.length; i++) {
                pageNums[pgNo] = parseInt(pages[i].split("-")[0]);
                if (n2 = parseInt(pages[i].split("-")[1])) {
                    while (pageNums[pgNo] < n2) {
                        pageNums[pgNo + 1] = parseInt(pageNums[pgNo]) + 1;
                        pgNo++;
                    }
                }
                pgNo++;
            }
            pageNums.sort(function (a, b) {
                return a - b;
            });
            return pageNums;
        },
        printHtml:"<html><head><title>{3}</title><script type='text/javascript'>{0}</script><style type='text/css'>{1}</style></head><body>{2}</body></html>",
        printTemplate:"<div id='{0}' class='rm-preview-page-box' style='text-align: center; width:100%;'><img class='rm-page-image' onload='positionMarker(this)' src='{1}' pageNumber='{2}'>{3}</div>",
        nonPrintArea:"<div class='non-printable'><div class='left-element rm-print-preview-text'>{0}</div><div class='right-element'>{3}<input type='button' class='rm-btn-default-small' onclick='printPagesContainer()' value='{1}'><input type='button' class='rm-btn-default-small' onclick='window.close()' value='{2}'></div></div>",
        checkCommentPrint:"<label class='rm-print-preview-text rm-comment-check-print'><input type='checkbox' onclick='handleCommentCheck(this);'>{0}</label>",
        commentMarkerTemplate:"<div class='rm-preview-page-box-item rm-preview-marker' style='{0}; top: 0px; left: 0px; -webkit-print-color-adjust: exact;' {2} {3}><div class='viewer-comment-ovr' style='padding: 0px; width: 10px; height: 10px; left: 1px; top: 1px; margin: 0px; float:left;'></div><label class='rmCommentNumber' style='font-size: 10px; left: 13px; top: 1px; margin: 0px; '>{1}</label></div>",
        javascriptText:"function printPagesContainer(){window.document.close();window.focus();window.print();window.opener.onDocumentPrinted('{0}', '{1}', '{2}'); /*window.close()*/;} \n {3} \n {4} \n {5} \n {6}",
        getElementsJs:"function getElements(){document.getElementsByClassName = function(className){var a = [];var re = new RegExp('(^| )'+className+'( |$)');var els = document.getElementsByTagName('*'); for(i=0;i<els.length; i++)if(re.test(els[i].className)){a.push(els[i]);} return a;};}",
        ieBrowserVersionJs:"function getIEBrowserVersion() { var version = 999; if (navigator.appVersion.indexOf('MSIE') != -1) version = parseFloat(navigator.appVersion.split('MSIE')[1]); return version;}" ,
        commentPositionJs:"function positionMarker(image) { var bodyWidth = document.body.offsetWidth; \n if(bodyWidth == 0){ \n bodyWidth = 767;} \n var deltaX = (bodyWidth - image.width)/2;  \n if(!document.getElementsByClassName){getElements();} var markers = document.getElementsByClassName('rm-preview-marker'); \n for (var i=0, im=markers.length; im>i; i++) { var marker = markers[i]; var oldX = marker.getAttribute('primex'), oldY = marker.getAttribute('primey'),oldPageHt = marker.getAttribute('primepageht'), oldPageWd = marker.getAttribute('primepagewd'); var newX = (oldX * (image.width/oldPageWd)); var newY= (oldY * (image.height/oldPageHt)); var suffix = '' ; if(getIEBrowserVersion()==10){ suffix = 'px';} marker.style.left = ((newX + deltaX) - (marker.style.width/2))+suffix; marker.style.top = (newY - (marker.style.height/2))+suffix; marker.style.display = 'none'; }}",
        commentCheckJs:"function handleCommentCheck(cb) { var markers = document.getElementsByClassName('rm-preview-marker'); for (var i=0, im=markers.length; im>i; i++) { var marker = markers[i];	if(cb.checked){ marker.style.display = '';} else { marker.style.display = 'none'; } } \n var printSections = document.getElementsByClassName('rm-print-comment-section'); if(printSections.length >0) { \n var printSection = printSections[0];	\n if(cb.checked){ printSection.style.display = '';} else { \n printSection.style.display = 'none'; } } }",
        styleArea:"@media print{.non-printable {display: none; height: 0px; }} .non-printable{z-index:100; height: 30px; padding: 2px 5px 2px 5px; background-color: #E4F3FF;} .left-element{float:left;width:49%;margin-top: 4px;} .right-element{float:right;width:49%;text-align:right;} {0}"
    },

    initialize:function (viewer, pageView, viewerToolbar) {
        this.documentViewer = viewer;
        this.pageView = pageView;
        this.viewerControlBar = viewerToolbar;
        viewer.addListener('interactionFunctionSet', this.setCommunicationFunction, this);
        viewerToolbar.addListener('printCurrentPage', this.printCurrentPage, this);
        viewerToolbar.addListener('printPages', this.printPages, this);
        RM.Logger.log("PrintController", "initialize", "Initialized id:" + this.id);
        var me = this;
        window["onDocumentPrinted"] = function (objectId, pages, viewerId) {
            if (me.documentViewer.document.objectId == objectId && me.documentViewer.id == viewerId) {
                me.onDocumentPrintSubmitted(objectId, pages);
            }
        }
    },

    cleanup:function () {
        this.commentDisplayHtml = null;
    },

    setCommunicationFunction:function (docViewer, commFunction) {
        this.communicationFunction = commFunction;
    },

    printCurrentPage:function () {
        var currentPage = this.viewerControlBar.currentPage;
        var targetDiv = Ext.get(this.pageView.getUniquePageDivID(this.viewerControlBar.currentPage));

        if (targetDiv == undefined) {
            //log here
            RM.Logger.debug("PrintController", "printCurrentPage", "invalid page number received to print :" + currentPage);
            return;
        }

        var image = targetDiv.down("img");
        var pageList = {"documentPages":[
            {"pageNumber":currentPage, "contentUrl":image.dom.src}
        ]};
        this.commentDisplayHtml = null;
        this.commentDisplayHtml = this.loadCommentThreadStores(currentPage + "");
        this.onPagesReceived(pageList, currentPage + "");
    },

    printPages:function (pages) {
        this.commentDisplayHtml = null;
        this.fetchPageUrls(pages, this.documentViewer.documentPagesUrl);
        this.commentDisplayHtml = this.loadCommentThreadStores(pages);

    },

    loadCommentThreadStores:function (pageString) {
        var pageArray = RM.controller.PrintController.getPageNums(pageString);
        var pageComments = this.getCommentsOnPages(pageArray);

        if (pageComments.length <= 0) {
            return "";
        }
        var commentTreeStore = this.createCommentThreadStore(pageComments);
        var commentDisplayHtmlBuffer = [];
        commentDisplayHtmlBuffer.push("<div class='rm-print-comment-section rm-print-preview-text' style='display: none;'>");
        commentDisplayHtmlBuffer.push("<div class='rm-comment-section-title'>" + RM.Strings.Viewer.DocumentViewer.viewerCommentsLabel + "</div>");
        this.getAllCommentHtml(pageComments, commentDisplayHtmlBuffer, commentTreeStore);
        commentDisplayHtmlBuffer.push("</div>");
        return  commentDisplayHtmlBuffer.join("");
    },

    createCommentThreadStore:function (pageComments) {
        var commentThreadList = [];
        var commentController = this.documentViewer.commentController;
        Ext.each(pageComments, function (comment) {
            commentThreadList.push(commentController.getCommentsInReply(Ext.clone(comment), null));
        });

        return Ext.create('Ext.data.TreeStore', {
            model:'RM.model.Comment',
            root:{
                expanded:true,
                children:commentThreadList
            }
        });
    },

    getAllCommentHtml:function (pageComments, commentDisplayHtmlBuffer, commentTreeStore) {
        var me = this;
        var commentController = this.documentViewer.commentController;
        var commentThread;
        Ext.each(pageComments, function (comment) {
            me.getCommentHtml(commentDisplayHtmlBuffer, comment, commentTreeStore);
            commentThread = commentController.getCommentsInReply(Ext.clone(comment));
            if (commentThread.children && commentThread.children.length > 0) {
                me.getAllCommentHtml(commentThread.children, commentDisplayHtmlBuffer, commentTreeStore);
            }
        });
    },

    getCommentHtml:function (commentDisplayHtmlBuffer, comment, commentTreeStore) {
        var commentNode = commentTreeStore.getNodeById(comment.commentId);
        var depth = commentNode.getDepth();
        commentDisplayHtmlBuffer.push("<div class='rm-print-comment' style='margin-left:" + (15 * (depth - 1)) + "px;'>");
        if (depth == 1) {
            commentDisplayHtmlBuffer.push("<hr/>");
        }
        commentDisplayHtmlBuffer.push("<div class='rmHeaderReplyCount'> " + RM.view.CommentView.getCommentMetadata(comment) + " </div>");
        var commentPageInfo;
        if (comment.commentNumber != null && !isNaN(parseFloat(comment.commentNumber)) && comment.commentNumber > 0) {
            commentPageInfo = Ext.String.format(RM.Strings.Viewer.DocumentViewer.commentPageInfo, comment.commentNumber, comment.pageNumber);
            commentDisplayHtmlBuffer.push("<div class='rmHeaderReplyCount'> " + commentPageInfo + " </div>");
        }
        commentDisplayHtmlBuffer.push("<div class='rmViewerCommentTree rm-print-comment-content'" + comment.commentContent + "</div>");
        commentDisplayHtmlBuffer.push("</div>");
    },

    getCommentsOnPages:function (pageArray) {
        var commentThreadList = [];
        var printPagesComments = [];
        var commentController = this.documentViewer.commentController;

        var allComments = commentController.commentList;
        if (!allComments && allComments.length <= 0) {
            return printPagesComments;
        }

        var currentComment;
        Ext.each(allComments, function (commentInfo) {
            currentComment = commentInfo.comment;
            if (Ext.Array.contains(pageArray, currentComment.pageNumber)) {
                printPagesComments.push(currentComment);
            }
        });
        /*Ext.each(printPagesComments, function(comment) {
         commentThreadList.push( commentController.getCommentsInReply(Ext.clone(comment), null) );
         });*/

        return printPagesComments;
    },

    fetchPageUrls:function (pages, url) {
        var me = this;
        var networkLocationId = "";
        if (xcp && xcp.UserPreferences)
            networkLocationId = xcp.UserPreferences.get('networkLocation');
        Ext.Ajax.request({
            url:url,
            scope:this,
            method:"GET",
            params:{
                objectId:this.documentViewer.document.objectId,
                start:0,
                limit:0,
                pages:pages,
                format:this.documentViewer.document.format,
                isFullyRenderedDoc:this.documentViewer.isFullyRenderedDoc,
                totalPages:this.documentViewer.document.pageCount,
                location:networkLocationId
            },
            success:function (response) {
                var pagesResponseList = Ext.decode(response.responseText);
                me.onPagesReceived(pagesResponseList, pages);
            },
            failure:function (response, request) {
                if (xcp && xcp.core && xcp.core.FeedbackManager)
                    xcp.core.FeedbackManager.showFeedback(null, "", response.responseText, "systemErrors");
            }
        });
    },

    onPagesReceived:function (pagesList, pageNumbers) {
        var printPreview = window.open('', RM.Strings.Viewer.DocumentViewer.print, 'scrollbars=1,location=no,width=800,height=800');
        printPreview.document.title = RM.Strings.Viewer.DocumentViewer.print;

        var format = Ext.String.format;
        var printImageHtml = "";
        var printMarkersHtml = "";
        //comments
        var pageArray = RM.controller.PrintController.getPageNums(pageNumbers);
        var pageComments = this.getCommentsOnPages(pageArray);
        var backgroundStyle;
        Ext.each(pagesList.documentPages, function (pageInfo) {
            printMarkersHtml = "", backgroundStyle = "";
            Ext.each(pageComments, function (comment) {
                if (comment.pageNumber == pageInfo.pageNumber) {
                    if (Ext.isIE) {
                        backgroundStyle = "filter:" + RM.view.CommentMarker.getIEStyleFilter(comment.commentColor);
                    }
                    else {
                        backgroundStyle = " background-color:" + RM.view.CommentMarker.getColorStyleRgb(comment.commentColor).commentColorRgb;
                    }
                    printMarkersHtml += format(RM.controller.PrintController.commentMarkerTemplate, backgroundStyle, comment.commentNumber,
                        "primeX=" + comment.xPos + " primeY=" + comment.yPos, "primePageHt=" + comment.pageHeight + " primePageWd=" + comment.pageWidth);
                }
            });
            printImageHtml += format(RM.controller.PrintController.printTemplate, pageInfo.pageNumber, pageInfo.contentUrl, pageInfo.pageNumber, printMarkersHtml);
        }, this);

        /*var printMarkersHtml = "", backgroundStyle;
         Ext.each(pageComments, function (comment) {
         printMarkersHtml += format(RM.controller.PrintController.commentMarkerTemplate, backgroundStyle,
         comment.commentNumber, "primeX="+comment.xPos + " primeY="+ comment.yPos, "primePageHt="+comment.pageHeight + " primePageWd="+comment.pageWidth );
         });*/


        var styleText = "";

        styleText = this.loadStyleText(styleText);
        var styleArea = format(RM.controller.PrintController.styleArea, styleText);
        var checkCommentPrint = format(RM.controller.PrintController.checkCommentPrint, RM.Strings.Viewer.DocumentViewer.printWithComments);
        var nonPrintArea = format(RM.controller.PrintController.nonPrintArea, RM.Strings.Viewer.DocumentViewer.printPreview, RM.Strings.Viewer.DocumentViewer.print, RM.Strings.Viewer.DocumentViewer.close, checkCommentPrint);
        var printHtml = nonPrintArea + printImageHtml + this.commentDisplayHtml;
        var javascriptText = format(RM.controller.PrintController.javascriptText, (this.documentViewer.pageView.documentId), pageNumbers, this.documentViewer.id, RM.controller.PrintController.getElementsJs, RM.controller.PrintController.ieBrowserVersionJs,RM.controller.PrintController.commentPositionJs, RM.controller.PrintController.commentCheckJs);
        printHtml = format(RM.controller.PrintController.printHtml, javascriptText, styleArea, printHtml, RM.Strings.Viewer.DocumentViewer.print);
        printPreview.document.write(printHtml);

        printPreview.focus();
    },

    loadStyleText:function (styleText) {
        styleText = this.appendStyleInfo(".rm-btn-default-small", styleText);
        styleText = this.appendStyleInfo(".rm-btn-default-small:hover", styleText);
        styleText = this.appendStyleInfo(".rm-print-preview-text", styleText);
        styleText = this.appendStyleInfo(".rmViewerCommentTree", styleText);
        styleText = this.appendStyleInfo(".rmHeaderReplyCount", styleText);
        styleText = this.appendStyleInfo(".viewer-comment-ovr", styleText);
        styleText = this.appendStyleInfo(".rm-preview-page-box", styleText);
        styleText = this.appendStyleInfo(".rm-preview-page-box-item", styleText);
        styleText = this.appendStyleInfo(".rm-preview-marker", styleText);
        styleText = this.appendStyleInfo(".rm-comment-check-print", styleText);
        return styleText;
    },

    appendStyleInfo:function (selector, styleText) {
        var selectorStyle = Ext.util.CSS.getRule(selector);
        var textStyleText;
        if (selectorStyle) {
            if(Ext.isIE8)
              textStyleText = selectorStyle.selectorText+"{"+selectorStyle.style.cssText+"}";
            else
              textStyleText = selectorStyle.cssText;
            styleText = styleText + " " + textStyleText;
        }
        return styleText;
    },

    onDocumentPrintSubmitted:function (objectId, pages) {
        if (this.communicationFunction) {
            RM.Logger.debug("ViewerController", "onCurrentDocumentPrinted", "communication call : " + pages);
            this.communicationFunction.call(this, "currentDocumentPrinted", pages + "&v2=" + RM.Strings.Viewer.DocumentViewer.printAuditExtraInfo);
        }
        else {
            RM.Logger.debug("ViewerController", "onCurrentDocumentPrinted", "logged :" + pages);
        }
    }

});

Ext.define('RM.controller.CommentController', {
    extend:'Ext.util.Observable',

    statics:{
        rotatedXY:function rotate(x, y, xm, ym, a) {
            var cos = Math.cos,
                sin = Math.sin,

                a = a * Math.PI / 180, // Convert to radians because that's what
            // JavaScript likes

            // Subtract midpoints, so that midpoint is translated to origin
            // and add it in the end again
                xr = (x - xm) * cos(a) - (y - ym) * sin(a) + xm,
                yr = (x - xm) * sin(a) + (y - ym) * cos(a) + ym;

            RM.Logger.log("CommentController", "rotate", "Rotated by xr:" + xr + " yr:" + yr);
            return [xr, yr];
        }
    },

    initialize:function (viewer, pageView, viewerToolbar) {
        viewer.addListener('resetToNewDocument', this.resetToNewDocument, this);
        this.getDocumentViewer = function () {
            return viewer
        };

        pageView.addListener('repositionMarkers', this.repositionCommentMarkers, this);
        pageView.addListener('pagesReceived', this.onDocPagesResponse, this);
        pageView.addListener('commentAdded', this.onNewCommentSaved, this);
        pageView.addListener('commentAddRequested', this.onCommentRequested, this);
        pageView.addListener('commentAddFailed', this.onCommentAddFailure, this);
        pageView.addListener('commentClicked', this.onCommentClicked, this);
        pageView.addListener('commentThreadCommentEdit', this.onEditInThread, this);
        pageView.addListener('commentThreadCommentAdd', this.onAddInThread, this);
        pageView.addListener('requestCommentDelete', this.onDeleteRequestFromThread, this);
        pageView.addListener('commentThreadWindowClose', this.onCommentThreadViewClose, this);
        pageView.addListener('commentSaveRequest', this.onCommentSaveRequest, this);

        this.getPageView = function () {
            return pageView
        };

        viewerToolbar.addListener('enableCommentMode', this.onEnableCommentMode, this);
        viewerToolbar.addListener('showAllComments', this.onShowAllCommentsRequest, this);
        viewerToolbar.addListener('showMyComments', this.onShowMyCommentsRequest, this);
        viewerToolbar.addListener('hideComments', this.onHideCommentsRequest, this);
        this.getControlBar = function () {
            return viewerToolbar
        };

        this.subscribeToExternalEvents();
        this.registeredNavigationComplete = false;
    },

    cleanup:function () {
        this.commentList = [];
    },

    subscribeToExternalEvents:function () {
        if (xcp && xcp.event) {
            var eventBus = xcp.event.EventBus;
            if (eventBus) {
                eventBus.subscribe(RM.event.CommentViewedEvent.COMMENT_VIEWED_EVENT, this.onCommentViewedExternal, this, null);
                eventBus.subscribe(RM.event.CommentCreatedEvent.COMMENT_ADD_EVENT, this.onCommentsModifiedExternal, this, null);
                eventBus.subscribe(RM.event.CommentUpdatedEvent.COMMENT_UPDATE_EVENT, this.onCommentsModifiedExternal, this, null);
                eventBus.subscribe(RM.event.CommentDeletedEvent.COMMENT_DELETE_EVENT, this.onCommentsModifiedExternal, this, null);
                RM.Logger.debug("CommentController", "subscribeToExternalEvents", "Subscribed to external events");
            }
        }
    },

    onEnableCommentMode:function () {
        this.getPageView().enableCommentMode();
    },

    onNewCommentSaved:function (comment) {
        this.onCommentAdded(comment);
        RM.Logger.log("CommentController", "onNewCommentSaved", "Comment saved", {dump:comment});
        if (!this.getControlBar().isCurrentUserMarkerSetVisible()) {
            var hasDisplayOptionChanged = this.getControlBar().changeCommentDisplayToMine();
            if (hasDisplayOptionChanged) {
                this.onShowMyCommentsRequest();
            }
        }
        this.publishAddedEvent(comment);
        this.invalidateCache();
    },

    onCommentAdded:function (comment, currentDisplayedPages) {
        var pageView = this.getPageView();
        pageView.showDefaultCursor();
        var circleRadius = 8;
        var commentMarker;
        if (currentDisplayedPages == null) {
            currentDisplayedPages = pageView.getCurrentVisiblePages();
        }
        var currentCommentPage = comment.pageNumber;

        if (this.getPageView().currentPage == currentCommentPage || currentDisplayedPages.length > 1) {
            RM.Logger.info("CommentController", "onCommentAdded", "");
            var targetDiv = Ext.get(this.getPageView().getUniquePageDivID(comment.pageNumber));
            commentMarker = this.createCommentMarkerII(comment, circleRadius, targetDiv);

            this.positionCommentMarker(comment, commentMarker, targetDiv);
            this.registerContextMenu(commentMarker, comment);
        }

        this.addCommentToList(comment, commentMarker);
    },

    onCommentAddFailure:function (response) {
        this.showDefaultCursor();
    },

    onCommentRequested:function (commentDataObj) {
        this.showWaitMode();
        var pageView = this.getPageView();
        Ext.Ajax.request({
            url:pageView.saveCommentsUrl,
            scope:this,
            params:{
                commentData:Ext.encode(commentDataObj)
            },
            success:function (response) {
                RM.Logger.log("RichHtmlWindow", "okHandler-success", "Saved comment", {dump:response});
                this.onNewCommentSaved(Ext.decode(response.responseText));
            },
            failure:function (response, request) {
                this.onCommentAddFailure(response);
                RM.Logger.log("RichHtmlWindow", "okHandler-failure", "Commenting failed", {dump:response});
                if (xcp.core.FeedbackManager)
                    xcp.core.FeedbackManager.showFeedback(null, "", response.responseText, "systemErrors", false);
            }
        });
    },

    showDefaultCursor:function () {
        this.getPageView().showDefaultCursor();
    },

    showWaitMode:function () {
        this.getPageView().showWaitMode();
    },

    createContextMenus:function (currentUser) {
        var me = this;
        if (me.contextMenu)
            return me.contextMenu;

        me.contextMenu = Ext.create('Ext.menu.Menu', {
            cls:"rmCommentContextMenu",
            config:{
                comment:{}
            },
            listeners:{
                show:function () {
                    Ext.Array.each(me.contextMenu.items.items, function (menuItem) {
                        if (menuItem.disableMenu) {
                            menuItem.disableMenu();
                        }
                    })
                }
            },
            items:[
                {
                    text:RM.Strings.Viewer.DocumentViewer.deleteLabel,
                    cls:"rmDeleteContextMenu",
                    listeners:{
                        beforerender:function () {
                            this.disableMenu();
                        },
                        click:function () {
                            Ext.Msg.confirm(
                                RM.Strings.Viewer.DocumentViewer.deleteConfirmHeader,
                                RM.Strings.Viewer.DocumentViewer.deleteThreadConfirmMsg,
                                function (btn) {
                                    if (btn == 'yes')
                                        me.deleteComment(me.contextMenu.comment);
                                });
                        }
                    },
                    disableMenu:function () {
                        //Disable/Enable the delete option based on the current user.
                        if (me.contextMenu.comment.creatorName != currentUser || !me.isCommentDelPermitted())
                            this.disable();
                        else {
                            this.enable();
                        }
                    }
                }
            ]
        });
        return me.contextMenu;
    },

    registerContextMenu:function (markerImage, comment) {
        me = this;
        var currentUser = me.getDocumentViewer().getUserLoginInfo().currentUser;
        var markerEl = markerImage.getEl();
        var contextMenu = this.createContextMenus(currentUser);

        //Listen to the context menu event
        if (markerEl) markerEl.on('contextmenu', function (e) {
            e.preventDefault();
            contextMenu.comment = comment;
            contextMenu.showBy(markerImage);
        });
    },

    deleteComment:function (comment, callback) {
        RM.Logger.log("CommentController", "deleteComment", "Deleting comment id:" + comment.id);
        me = this;
        this.showWaitMode();
        Ext.Ajax.request({
            url:this.getDocumentViewer().getDeleteCommentUrl(),
            scope:this,
            params:{
                commentData:Ext.encode(comment)
            },
            success:function (response) {
                this.onDeleteSuccess(comment);
                Ext.callback(callback, this, [true]);
            },
            failure:function (response, request) {
                RM.Logger.info("CommentController", "onDeleteSuccess", "Comment delete failed" + comment.id);
                this.onDeleteFailure(callback, response);
            }
        });
    },

    onDeleteSuccess:function (comment, callback) {
        RM.Logger.info("CommentController", "onDeleteSuccess", "Comment deleted id:" + comment.id, {indent:1});
        this.removeCommentMarker(comment);
        this.clearItemsInThread(comment);
        this.repositionCommentMarkers();
        this.showDefaultCursor();
        this.publishDeletedEvent(comment)
        Ext.callback(callback, this, [true]);
        RM.Logger.info("CommentController", "onDeleteSuccess", "Comment post delete operations" + comment.id, {outdent:1});

    },

    onDeleteFailure:function (callback, response) {
        if (xcp.core.FeedbackManager) {
            //Check the response because it could be a standard html error
            var msg = RM.Strings.Viewer.DocumentViewer.commentDelError;
            if (response.responseText.indexOf("<") == -1) {
                var info = Ext.decode(response.responseText);
                if (info && !Ext.isEmpty(info.detailedMessage))
                    msg = info.detailedMessage;
            }

            xcp.core.FeedbackManager.showFeedback(null, RM.Strings.Viewer.DocumentViewer.commentDelError, msg, "systemErrors");
        }
        this.showDefaultCursor();
        Ext.callback(callback, this, [false]);
    },

    clearItemsInThread:function (comment, directReplies) {
        RM.Logger.debug("CommentController", "clearItemsInThread", "Clearing comments in thread");
        var me = this;
        var commentThread;
        var commentReplies;
        if (directReplies == null) {
            commentThread = me.getCommentsInReply(comment);
            commentReplies = commentThread.children;
        }
        else {
            commentReplies = directReplies;
        }
        Ext.each(commentReplies, function (commentInThread) {
            me.removeCommentMarker(commentInThread);
            me.clearItemsInThread(commentInThread, commentInThread.children);
        });
    },

    removeCommentMarker:function (comment) {
        if (comment == null) return;
        var me = this;
        Ext.Array.some(me.commentList, function (commentInfo) {
            var commentRemoved = false;
            if (commentInfo.comment.commentId == comment.commentId) {
                me.destroyCachedMarkers(commentInfo);
                RM.Logger.log("CommentController", "removeCommentMarker", "Removing comment from list : " + comment.commentNumber);
                Ext.Array.remove(me.commentList, commentInfo);
                commentRemoved = true;
            }
            return commentRemoved;
        });
        this.invalidateCache();
    },

    createCommentMarkerII:function (comment, circleRadius, targetDiv) {
        RM.Logger.debug("CommentController", "createCommentMarkerII", "Comment id:" + comment.id + " targetDiv:" + targetDiv);
        if (comment == undefined)    return;

        var pageView = this.getPageView();
        var commentMarker = new RM.view.CommentMarker({
            circleRadius:5,
            targetDiv:targetDiv,
            comment:comment,
            floating:true,
            constrain:true,
            autoSize:true,
            renderTo:targetDiv,
            getBubbleTarget:function () {
                return pageView;
            }
        });
        return commentMarker;
    },

    positionCommentMarker:function (comment, commentMarker, targetDiv) {
        //var pageView = this.getDocumentViewer().down("rmDocumentPageViewer");
        if (targetDiv == undefined) {
            targetDiv = Ext.get(this.getPageView().getUniquePageDivID(comment.pageNumber));
        }

        if (targetDiv == undefined) {
            //log here
            RM.Logger.debug("CommentController", "positionCommentMarker", "invalid comment marker received for current set at :" + comment.pageNumber);
            return;
        }

        var image = targetDiv.down("img");

        var circleRadius = 8;

        var targetOffsetTop = image.dom.offsetTop;
        var targetOffsetLeft = image.dom.offsetLeft;

        var pagesYOffSet = 0;
        var targetXPos = comment.xPos;
        var targetYPos = comment.yPos;
        var imageWidth = image.dom.width;
        var imageHeight = image.dom.height;
        RM.Logger.debug("CommentController", "positionCommentMarker", "comment.xyPos : " + comment.xPos + ", " + comment.yPos);

        var xRatio = imageWidth / comment.pageWidth;
        var yRatio = imageHeight / comment.pageHeight;
        targetXPos = targetXPos * xRatio;
        targetYPos = targetYPos * yRatio;
        RM.Logger.debug("CommentController", "positionCommentMarker", "targetXYPos (in ratio) : " + targetXPos + ", " + targetYPos);

        var rotatedAngle = this.getPageView().getEarlierRotateAngle(comment.pageNumber);
        var xMidpoint, yMidpoint, xyRotated, offsetRotated;
        if (rotatedAngle > 0) {
            xMidpoint = imageWidth / 2;
            yMidpoint = imageHeight / 2;
            xyRotated = RM.controller.CommentController.rotatedXY(targetXPos, targetYPos, xMidpoint, yMidpoint, rotatedAngle);
            targetXPos = xyRotated[0];
            targetYPos = xyRotated[1];
            if (Ext.isIE) {
                if (image.dom.style.left != "") {
                    RM.Logger.debug("CommentController", "positionCommentMarker", "IE image correction : targetXPos += image.dom.style.left : " + targetXPos + " += " + image.dom.style.left);
                    RM.Logger.debug("CommentController", "positionCommentMarker", "IE image correction : targetYPos += image.dom.style.left : " + targetYPos + " += " + image.dom.style.left);
                    targetXPos += -parseInt(image.dom.style.left.replace("px", ""));
                    targetYPos += parseInt(image.dom.style.left.replace("px", ""));
                }
                else if (rotatedAngle == 90 || rotatedAngle == 270) {
                    var toMoveDeltaX, toMoveDeltaY;
                    toMoveDeltaX = -((image.dom.width - image.dom.height) / 2  );
                    toMoveDeltaY = -((image.dom.height - image.dom.width) / 2 );
                    targetOffsetLeft += toMoveDeltaX;
                    targetOffsetTop += toMoveDeltaY;
                    RM.Logger.debug("CommentController", "positionCommentMarker", "IE image correction : targetOffsetLeft += toMoveDeltaX : " + targetOffsetLeft + " += " + toMoveDeltaX);
                    RM.Logger.debug("CommentController", "positionCommentMarker", "IE image correction : targetOffsetTop += toMoveDeltaY : " + targetOffsetTop + " += " + toMoveDeltaY);
                }
            }
            RM.Logger.debug("CommentController", "positionCommentMarker", "targetXYPos (rotated) : " + targetXPos + ", " + targetYPos);
        }

        RM.Logger.debug("CommentController", "positionCommentMarker", "targetOffsetLeft + targetXPos - circleRadius : " + targetOffsetLeft + " + " + targetXPos + " - " + circleRadius);
        RM.Logger.debug("CommentController", "positionCommentMarker", "targetOffsetTop + targetYPos - circleRadius : " + targetOffsetTop + " + " + targetYPos + " - " + circleRadius);
        var circleXPos = parseInt(targetOffsetLeft + targetXPos - circleRadius);
        var circleYPos = parseInt(targetOffsetTop + targetYPos - circleRadius);
        RM.Logger.debug("CommentController", "positionCommentMarker", "circleXPos : " + circleXPos + " and circleYPos : " + circleYPos);

        commentMarker.setPosition(circleXPos, circleYPos);
    },

    addCommentToList:function (comment, commentMarker) {
        if (this.commentList == undefined) {
            this.commentList = [];
        }
        /*else{
         this.removeCommentMarker(comment);
         }*/
        RM.Logger.debug("CommentController", "addCommentToList", "Adding comment to list : " + comment.commentNumber);
        this.commentList.push({"comment":comment, "commentMarker":commentMarker   });
    },

    repositionCommentMarkers:function () {
        var me = this;
        if (!me.commentList) return;
        var pageView = me.getPageView();
        var currentPageDisplayed = pageView.currentPage;
        var currentDisplayedPages = pageView.getCurrentVisiblePages();
        var currentComment;
        var currentCommentMarker;
        var currentCommentPage;

        var commentsToRemove = [];
        Ext.each(Ext.Array.clone(me.commentList), function (commentInfo) {
            currentComment = commentInfo.comment;
            currentCommentMarker = commentInfo.commentMarker;
            currentCommentPage = currentComment.pageNumber;
            if (currentCommentPage == currentPageDisplayed || currentDisplayedPages.length > 1 ||
                (currentDisplayedPages.length == 1 && currentCommentPage - currentPageDisplayed < 8 && currentCommentPage - currentPageDisplayed > -8)) { //to make sure this is positioned away incase an earlier zoom had it on the current page
                if (!(currentCommentMarker == null || Ext.get(currentCommentMarker.id) == undefined)) {
                    RM.Logger.debug("CommentController", "repositionCommentMarkers", "Repositioning" + currentCommentMarker.id);
                    //marker is created and available
                    //so position it
                    RM.Logger.debug("CommentController", "repositionCommentMarkers",
                        "repositioning markers at " + commentInfo.comment.pageNumber + " and comment number " + currentComment.commentNumber);
                    me.positionCommentMarker(currentComment, currentCommentMarker);
                } else {
                    RM.Logger.debug("CommentController", "repositionCommentMarkers", "reInitializing marker at " + commentInfo.comment.pageNumber + " and comment number " + currentComment.commentNumber);
                    //marker is not present
                    var targetDiv = Ext.get(pageView.getUniquePageDivID(currentComment.pageNumber));
                    if (targetDiv != undefined) {
                        //me.removeCommentMarker(commentInfo.comment);
                        commentsToRemove.push(commentInfo);
                        me.onCommentAdded(currentComment, currentDisplayedPages);
                    }
                    else {
                        RM.Logger.debug("CommentController", "repositionCommentMarkers", "target is unavailable ... the grid has hot swapped it to render only those required");
                    }
                }
            }
            RM.Logger.debug("CommentController", "repositionCommentMarkers", "repositioning : skipping at " + commentInfo.comment.pageNumber + " and comment number " + commentInfo.comment.commentNumber);
        });

        Ext.each(commentsToRemove, function (commentInfoToDelete) {
            Ext.Array.remove(me.commentList, commentInfoToDelete);
            me.destroyCachedMarkers(commentInfoToDelete);
        });
    },

    destroyCachedMarkers:function (commentInfo) {
        if (commentInfo.commentMarker != undefined) {
            RM.Logger.info("CommentController", "destroyCachedMarkers", "Comment Info:" + commentInfo.comment.id);
            commentInfo.commentMarker.destroy();
        }
    },

    requestComments:function (url, processOnlyCurrentUser) {
        var me = this;
        Ext.Ajax.request({
            url:url,
            scope:this,
            success:function (response) {
                RM.Logger.info("CommentController", "requestComments", " got comments from server");
                var commentResponseList = Ext.decode(response.responseText);
                me.commentsCache = commentResponseList;
                me.processCommentsResponse(commentResponseList, processOnlyCurrentUser);
                me.markCommentsAsRead();
            },
            failure:function (response, request) {
                me.getDocumentViewer().fireEvent('commentRequestComplete');
                if (xcp && xcp.core && xcp.core.FeedbackManager)
                    xcp.core.FeedbackManager.showFeedback(null, "", response.responseText, "systemErrors");
            }
        });
    },

    processCommentsResponse:function (commentResponseList, processOnlyCurrentUser) {
        var userLoginName = this.getDocumentViewer().userLoginInfo.userLoginName;
        var me = this;
        RM.Logger.info("CommentController", "processCommentsResponse", " Processing only user comment: " + processOnlyCurrentUser);
        Ext.each(commentResponseList, function (commentInfo) {
            if (!processOnlyCurrentUser) {
                me.onCommentAdded(commentInfo);
            }
            else if (commentInfo.creatorName == userLoginName) {
                me.onCommentAdded(commentInfo);
            }
        });
        this.getDocumentViewer().fireEvent('commentRequestComplete');
    },

    markCommentsAsRead:function () {
        RM.Logger.info("CommentController", "markCommentsAsRead", " marking comments as read");
        var markAsReadUrl = this.getPageView().saveCommentsUrl;
        //  Mark all comments as read
        Ext.Ajax.request({
            url:markAsReadUrl,
            scope:this,
            params:{
                markAsRead:true
            }});
    },

    onCommentSaveRequest:function (comment, isNewReply, editor) {
        var me = this;
        var pageView = me.getPageView();
        var commentInfo = new RM.model.Comment().cloneFrom(comment);
        if (isNewReply) {
            commentInfo.commentId = "";
        }
        Ext.Ajax.request({
            url:pageView.saveCommentsUrl,
            scope:this,
            params:{
                commentData:Ext.encode(commentInfo)
            },
            success:function (response) {
                var replyComment = Ext.decode(response.responseText);
                editor.onCommentSaved(replyComment);
                me.publishUpdatedEvent(replyComment);
                /*this.onCommentAdded( commentDataObj );*/
                /*Ext.MessageBox.hide();*/
            },
            failure:function (response, request) {
                editor.onCommentSaveFail();
                if (xcp.core.FeedbackManager) {
                    //Check the response because it could be a standard html error
                    var msg = RM.Strings.Viewer.DocumentViewer.commentSaveError;
                    if (response.responseText.indexOf("<") == -1) {
                        var info = Ext.decode(response.responseText);
                        if (info && !Ext.isEmpty(info.detailedMessage))
                            msg = info.detailedMessage;
                    }

                    xcp.core.FeedbackManager.showFeedback(null, RM.Strings.Viewer.DocumentViewer.commentSaveError, msg, "systemErrors");
                }
            }
        });

    },

    onDocPagesResponse:function () {
        if (this.areCommentsRequested == null || this.areCommentsRequested == false) {
            var me = this;
            this.requestComments(this.getDocumentViewer().allCommentsUrl);
            this.areCommentsRequested = true;
        }
        this.repositionCommentMarkers();
    },

    onShowAllCommentsRequest:function () {
        this.clearCurrentMarkers();
        if (!this.commentsCache) {
            this.requestComments(this.getDocumentViewer().allCommentsUrl)
        }
        else {
            this.processCommentsResponse(this.commentsCache);
        }
    },

    onShowMyCommentsRequest:function () {
        this.clearCurrentMarkers();
        if (!this.commentsCache) {
            this.requestComments(this.getDocumentViewer().allCommentsUrl, true)
        }
        else {
            this.processCommentsResponse(this.commentsCache, true);
        }
    },

    clearCurrentMarkers:function () {
        var me = this;
        //TODO use a filter here instead
        Ext.each(me.commentList, function (commentInfo) {
            me.destroyCachedMarkers(commentInfo);
        });
        me.commentList = [];
        return me;
    },

    onHideCommentsRequest:function () {
        var me = this.clearCurrentMarkers();
        me.repositionCommentMarkers();
    },


    isCommentDelPermitted:function () {
        return this.getDocumentViewer().getDeleteCommentUrl();

    },

    canEditComment:function () {
        var commentPermit = this.getDocumentViewer().hasCommentingPermission();
        var isAllowedCommenting = this.getDocumentViewer().isCommentingAllowed;
        return commentPermit && isAllowedCommenting;
    },

    onCommentClicked:function (comment) {
        //console.log(comment.commentNumber);
        var me = this;

        var collapsedNodes, windowHeight, windowWidth;
        var currentUser = this.getDocumentViewer().getUserLoginInfo().currentUser;
        var canEditComment = this.canEditComment();

        var viewerSessionInfo = this.getViewerSessionStore().getById(currentUser);
        var commentSessionInfo;
        if (viewerSessionInfo != null) {
            commentSessionInfo = viewerSessionInfo.userCommentsInfo().getById(comment.commentId);
            if (commentSessionInfo) {
                collapsedNodes = commentSessionInfo.get('collapsedNodes');
                windowHeight = commentSessionInfo.get('windowHeight');
                windowWidth = commentSessionInfo.get('windowWidth');
            }
        }
        if (windowHeight == null || windowWidth == null) {
            var __ret = this.getCommentThreadStyleInfo();
            windowHeight = __ret.windowHeight;
            windowWidth = __ret.windowWidth;
        }

        var commentThread = [];
        commentThread = this.getCommentsInReply(Ext.clone(comment), collapsedNodes);

        var commentThreadView = Ext.create('RM.view.CommentThread', {
            parentComment:comment,
            commentList:me.commentList,
            commentThread:commentThread,
            width:windowWidth,
            height:windowHeight,
            canEditComment:canEditComment,
            currentUser:me.getDocumentViewer().getUserLoginInfo().currentUser
        });
        this.getPageView().relayEvents(commentThreadView, ['commentThreadCommentEdit', 'commentThreadCommentAdd', 'requestCommentDelete', 'commentThreadWindowClose', 'commentSaveRequest' ]);
        commentThreadView.show();

        if (xcp.event && xcp.event.EventBus) {
            var commentViewedEvent = new RM.event.CommentViewedEvent();
            commentViewedEvent.commentId = comment.commentId;
            commentViewedEvent.documentId = this.getDocumentViewer().document.objectId;
            xcp.event.EventBus.publish(RM.event.CommentViewedEvent.COMMENT_VIEWED_EVENT, commentViewedEvent);
        }
    },

    getCommentThreadStyleInfo:function () {
        var commentWindowStyleRule;
        if (!this.commentWindowStyle) {
            commentWindowStyleRule = Ext.util.CSS.getRule('.rmViewerCommentThread');
            if (!commentWindowStyleRule) {
                //this is for the unit testing scenario where CSS rules are never loaded
                return {windowHeight:350, windowWidth:490};
            }
            this.commentWindowStyle = commentWindowStyleRule.style;
        }
        if (!Ext.isIE) {
            windowHeight = parseInt(this.commentWindowStyle.getPropertyValue('height').replace("px", ""));
            windowWidth = parseInt(this.commentWindowStyle.getPropertyValue('width').replace("px", ""));
        }
        else {
            windowHeight = parseInt(this.commentWindowStyle.height.replace("px", ""));
            windowWidth = parseInt(this.commentWindowStyle.width.replace("px", ""));
        }
        return {windowHeight:windowHeight, windowWidth:windowWidth};
    },

    getCommentsInReply:function (comment, nodesCollapsedByUser) {
        var currentComment;
        var me = this;
        comment.children = [];
        comment.replies = 0;
        comment.unreadReplies = 0;
        Ext.each(me.commentList, function (commentInfo) {
            currentComment = commentInfo.comment;
            if (currentComment.replyTo == comment.commentId) {
                comment.children.push(currentComment);
                if (currentComment.unread) comment.unreadReplies++;
                comment.replies++;
                me.getCommentsInReply(currentComment, nodesCollapsedByUser);

                comment.replies = comment.replies + currentComment.replies;
                comment.unreadReplies = comment.unreadReplies + currentComment.unreadReplies;
            }
        });

        comment.leaf = comment.children.length <= 0;
        var collapsedComment;
        if (nodesCollapsedByUser) {
            collapsedComment = this.getCommentFromList(comment.commentId, nodesCollapsedByUser);
        }
        comment.expanded = (collapsedComment == null);
        comment.loaded = comment.leaf;
        return comment;
    },

    getCommentFromList:function (commentId, commentModelList) {
        var documentComment;
        Ext.Array.some(commentModelList, function (commentModelObj) {
            if (commentId == commentModelObj.get('commentId')) {
                documentComment = commentModelObj;
                return true;
            }
        });
        return documentComment;
    },

    onEditInThread:function (editedComment) {
        var currentComment;
        Ext.each(this.commentList, function (commentInfo) {
            currentComment = commentInfo.comment;
            if (editedComment.commentId == currentComment.commentId) {
                currentComment.commentContent = editedComment.commentContent;
                if (commentInfo.commentMarker) {
                    commentInfo.commentMarker.setComment(editedComment);
                }
                return true;
            }
        });
        this.invalidateCache();
    },

    invalidateCache:function () {
        var currentComments = [];
        for (var i = 0; i < this.commentList.length; i++) {
            var commentInfo = this.commentList[i];
            currentComments.push(commentInfo.comment);
        }
        this.commentsCache = currentComments;
    },

    onAddInThread:function (newComment, parentCommentId) {
        this.addCommentToList(newComment);
        this.invalidateCache();
    },

    onDeleteRequestFromThread:function (threadComponent, commentToDelete, commentAreaId) {

        var onThreadItemDeleted = function (isCommentDeleted) {
            threadComponent.onCommentDeleted(commentToDelete, commentAreaId, isCommentDeleted);
        };
        this.deleteComment(commentToDelete, onThreadItemDeleted);
    },

    onCommentViewedExternal:function (eventName, eventData) {
        if (eventData.eventSource == this.getDocumentViewer().id ||
            eventData.documentId != this.getDocumentViewer().document.objectId) {
            return;
        }

        //get comment object from comment Id
        var documentComment, currentComment;
        Ext.Array.some(this.commentList, function (commentInfo) {
            currentComment = commentInfo.comment;
            if (eventData.commentId == currentComment.commentId) {
                documentComment = currentComment;
                return true;
            }
        });

        //navigate to page of the comment if not already on the page
        if (documentComment && documentComment.pageNumber && !isNaN(documentComment.pageNumber) &&
            documentComment.pageNumber != this.getPageView().currentPage) {
            this.getPageView().navigateToPage(documentComment.pageNumber);
            RM.Logger.info("CommentController", "onCommentViewedExternal", "Navigate to page which contain the comment - page:" + documentComment.pageNumber);
        }
    },

    onCommentsModifiedExternal:function (eventName, eventData) {
        if (eventData.eventSource == this.getDocumentViewer().id ||
            eventData.documentId != this.getDocumentViewer().document.objectId) {
            return;
        }
        this.getControlBar().refreshDocumentComments();
        RM.Logger.info("CommentController", "onCommentsModifiedExternal", "Refreshing comments");
    },

    updateAnnotationEventInfo:function (commentAddedEvent, comment) {
        commentAddedEvent.annotationId = comment.commentId;
        commentAddedEvent.documentId = this.getDocumentViewer().document.objectId;
        commentAddedEvent.eventSource = this.getDocumentViewer().id;
    },
    isCommentsWidgetEventDefined:function () {
        return xcp.widget && xcp.widget.comments && xcp.widget.comments.event;
    },
    publishAddedEvent:function (comment) {
        if (xcp.event && xcp.event.EventBus
            && this.isCommentsWidgetEventDefined() && xcp.widget.comments.event.AnnotationCreatedEvent) {
            var commentCreatedEvent = new xcp.widget.comments.event.AnnotationCreatedEvent();
            this.updateAnnotationEventInfo(commentCreatedEvent, comment);
            xcp.event.EventBus.publish(xcp.widget.comments.event.AnnotationCreatedEvent.ANNOTATION_CREATE_EVENT, commentCreatedEvent);
            RM.Logger.info("CommentController", "publishAddedEvent", "Published comment added event to event bus");
        }
    },

    publishDeletedEvent:function (comment) {
        if (xcp.event && xcp.event.EventBus
            && this.isCommentsWidgetEventDefined() && xcp.widget.comments.event.AnnotationDeletedEvent) {
            var commentDeletedEvent = new xcp.widget.comments.event.AnnotationDeletedEvent();
            this.updateAnnotationEventInfo(commentDeletedEvent, comment);
            xcp.event.EventBus.publish(xcp.widget.comments.event.AnnotationDeletedEvent.ANNOTATION_DELETE_EVENT, commentDeletedEvent);
            RM.Logger.info("CommentController", "publishDeletedEvent", "Published comment deleted event to event bus");
        }
    },

    publishUpdatedEvent:function (comment) {
        if (xcp.event && xcp.event.EventBus
            && this.isCommentsWidgetEventDefined() && xcp.widget.comments.event.AnnotationUpdatedEvent) {
            var commentUpdatedEvent = new xcp.widget.comments.event.AnnotationUpdatedEvent();
            this.updateAnnotationEventInfo(commentUpdatedEvent, comment);
            xcp.event.EventBus.publish(xcp.widget.comments.event.AnnotationUpdatedEvent.ANNOTATION_UPDATE_EVENT, commentUpdatedEvent);
            RM.Logger.info("CommentController", "publishUpdatedEvent", "Published comment updated event to event bus");
        }
    },

    onCommentThreadViewClose:function (parentComment, collapsedNodes, windowHeight, windowWidth) {
        this.storeUserCommentInfo(parentComment, windowHeight, windowWidth, collapsedNodes);
    },


    storeUserCommentInfo:function (parentComment, windowHeight, windowWidth, collapsedNodes) {
        var currentUser = this.getDocumentViewer().getUserLoginInfo().currentUser;
        //check if already persisted - if so then update
        var viewerSessionInfo = this.getViewerSessionStore().getById(currentUser);
        if (viewerSessionInfo == null) {
            viewerSessionInfo = Ext.create('RM.model.ViewerSessionInfo');
            viewerSessionInfo.set('userId', currentUser);
        }
        //check if there is info present for the comment already
        var commentSessionInfo = viewerSessionInfo.userCommentsInfo().getById(parentComment.commentId);
        if (commentSessionInfo == null) {
            commentSessionInfo = Ext.create('RM.model.CommentSessionInfo');
            commentSessionInfo.set('commentId', parentComment.commentId);
        }

        commentSessionInfo.set('windowHeight', windowHeight);
        commentSessionInfo.set('windowWidth', windowWidth);
        commentSessionInfo.set('collapsedNodes', collapsedNodes);
        viewerSessionInfo.userCommentsInfo().add(commentSessionInfo);
        this.getViewerSessionStore().add(viewerSessionInfo);
        RM.Logger.debug("CommentController", "onCommentThreadViewClose", "Saved user comment info - userId: " + currentUser +
            "commentId" + parentComment.commentId + "windowHeight" + windowHeight + "windowWidth" + windowHeight);
    },

    getViewerSessionStore:function () {
        var store = Ext.data.StoreManager.lookup('rmViewerSessionStore');
        if (store == null) {
            try {
                store = new Ext.data.Store({
                    id:'rmViewerSessionStore',
                    model:'RM.model.ViewerSessionInfo',
                    proxy:{
                        type:'sessionstorage',
                        id:'RM.proxy.viewerSessionProxy'
                    }
                });
            } catch (e) {
                store = new Ext.data.Store({
                    id:'rmViewerSessionStore',
                    model:'RM.model.ViewerSessionInfo',
                    proxy:{
                        type:'memory',
                        id:'RM.proxy.viewerSessionProxy'
                    }
                })
            }
        }

        return store;
    },

    resetToNewDocument:function () {
        RM.Logger.info("CommentController", "resetToNewDocument", "Resetting to new document");
        this.registeredNavigationComplete = false;
        this.commentList = [];
        this.areCommentsRequested = false;
    }

});

Ext.define('RM.controller.ViewerController', {
    extend:'Ext.util.Observable',

    statics:{
        getIERotationAngle:function (angle) {
            var ieAngleEquivalent;
            switch (angle) {
                case 0 :
                    ieAngleEquivalent = 0;
                    break;
                case 90 :
                    ieAngleEquivalent = 1;
                    break;
                case 180 :
                    ieAngleEquivalent = 2;
                    break;
                case 270 :
                    ieAngleEquivalent = 3;
                    break;
                default :
                    ieAngleEquivalent = 0;
                    break;
            }
            RM.Logger.debug("ViewerController", "getIERotationAngle", "Value:" + ieAngleEquivalent);
            return ieAngleEquivalent;
        }
    },

    initialize:function (viewer, pageView, viewerToolbar) {
        viewer.addListener('currentDocumentChanged', this.onDocumentSetModified, this);
        viewer.addListener('navigateToPageRequest', this.navigateToPage, this);
        viewer.addListener('localeChanged', this.onLocaleChanged, this);
        viewer.addListener('navigateToNextPageRequest', this.navigateToNextPage, this);
        viewer.addListener('navigateToPrevPageRequest', this.navigateToPrevPage, this);
        viewer.addListener('interactionFunctionSet', this.setCommunicationFunction, this);
        viewer.addListener('viewerRendered', this.viewerRendered, this);
        this.documentViewer = viewer;
        this.viewerToolbar = viewerToolbar;
        this.pageView = pageView;

        pageView.addListener('fitToWidth', this.fitPageToWidth, this);
        pageView.addListener('currentPageChanged', this.onCurrentPageChanged, this);
        pageView.addListener('zoomLevelChanged', this.viewChanged, this);
        pageView.addListener('totalPageCountUpdated', this.totalPageCountUpdated, this);
        pageView.addListener('isImageDocument', this.initImageDocument, this);
        pageView.addListener('fatalError', this.showFatalError, this);

        viewerToolbar.addListener('fitToWidth', this.fitPageToWidth, this);
        viewerToolbar.addListener('fitToHeight', this.fitPageToHeight, this);
        viewerToolbar.addListener('navigateToPage', this.navigateToPage, this);
        viewerToolbar.addListener('zoomLevelChanged', this.zoomLevelChanged, this);
        viewerToolbar.addListener('rotatePage', this.rotatePage, this);

        this.pageView = pageView;
    },

    initImageDocument:function () {
        this.viewerToolbar.changeToImageDocumentView();
    },

    showFatalError:function (errorReason) {
        if (errorReason == "pageLoading") {
            this.documentViewer.el.mask(RM.Strings.Viewer.DocumentViewer.notPageLoadingError, 'xcp-mask-error');
        }
        else if (errorReason == "acsError") {
            this.documentViewer.el.mask(RM.Strings.Viewer.DocumentViewer.acsError, 'xcp-mask-error');
        }

    },

    cleanup:function () {
        this.pageView.cleanup()
        this.pageView.deleteStyleSheetCreated();
    },

    viewerRendered:function () {
        this.initializeAppHotKeys();
    },

    initializeAppHotKeys:function () {
        var documentViewer = this.documentViewer;
        var docViewerEL = this.documentViewer.getEl();
        var viewerToolbar = this.viewerToolbar;
        var pageView = this.pageView;
        viewerToolbar.focus();

        //Focus Viewer toolbar so that all the events will be raised in documentViewer
        var keymap = new Ext.util.KeyMap(docViewerEL, [
            {
                key:190, //Key code for ". >" symbol
                ctrl:true,
                shift:true,
                fn:function () {
                    RM.Logger.debug("keymap", "fn", "Hot key for zoom in pressed");
                    viewerToolbar.zoomIn();
                    e.stopEvent();
                }
            },
            {
                key:188, //Key code for ", <" symbol
                ctrl:true,
                shift:true,
                fn:function () {
                    RM.Logger.debug("keymap", "fn", "Hot key for zoom out pressed");
                    viewerToolbar.zoomOut();
                    e.stopEvent();
                }
            },
            {
                key:219, //Key code for ". >" symbol
                ctrl:true,
                shift:true,
                fn:function () {
                    viewerToolbar.rotatePageLeft();
                }
            },
            {
                key:221, //Key code for ", <" symbol
                ctrl:true,
                shift:true,
                fn:function () {
                    viewerToolbar.rotatePageRight();
                }
            }
        ]);

        var nav = new Ext.util.KeyNav(docViewerEL, {
            "pageUp":function (e) {
                RM.Logger.info("keymap", "pageUp", " Hot key for navigation to previous frame pressed");
                pageView.navigateToPrevVisibleFrame();
            },
            "pageDown":function (e) {
                RM.Logger.info("keymap", "pageDown", " Hot key for navigation to next frame pressed");
                pageView.navigateToNextVisibleFrame();
            },
            "up":function (e) {
                RM.Logger.info("keymap", "up", " Hot key for navigation to previous frame pressed");
                pageView.navigateToPrevVisibleFrame();
            },
            "down":function (e) {
                RM.Logger.info("keymap", "down", " Hot key for navigation to next frame pressed");
                pageView.navigateToNextVisibleFrame();
            },
            scope:this
        });
    },

    onDocumentSetModified:function (docViewer, newDocumentSet) {
        //console.log('Controller: Document set modified '+ newDocumentSet.get('name'));
        this.documentViewer = docViewer;
        var pageCount = newDocumentSet.data.pageCount;
        var assetClass = newDocumentSet.data.assetClass;
        this.viewerToolbar.setDocumentPageCount(pageCount);

        if (this.communicationFunction && this.canShowThumbnail(assetClass, pageCount)) {
            RM.Logger.info("ViewerController", "onDocumentSetModified", "Calling VF communication function to init thumbnail control");
            this.communicationFunction.call(this, "currentDocumentChanged", {pageCount:pageCount, isFullyRendered:this.documentViewer.isFullyRenderedDoc});
        }
    },

    canShowThumbnail:function (assetClass, pageCount) {
        //Dont init thumbnail panel if the document is a image
        // or it is having page count  less than one(which means CTS is not yet processed the document)
        return assetClass != "Image" && pageCount > 0;
    },

    onLocaleChanged:function (docViewer, newLocale) {
        var localeArray = newLocale.split("_");
        var language;
        var country;
        if (localeArray.length > 0) {
            language = localeArray[0];
            if (localeArray.length > 1) {
                country = localeArray[1];
                if (country) {
                    language = newLocale;
                }
            }
        }
        if (!language) {
            language = "en";
        }

        language = (xcp && xcp.ckeditorlanguage) ? xcp.ckeditorlanguage : language;

        RM.Logger.log("ViewerController", "onLocaleChanged", "Locale changed to:" + language);
        RM.richEditorHelper.ckEditorConfig.language = language;
        RM.Logger.info("ViewerController", "onLocaleChanged", "Ck editor locale changed to:" + language);
    },

    setCommunicationFunction:function (docViewer, commFunction) {
        this.communicationFunction = commFunction;
    },

    fitPageToWidth:function () {
        this.pageView.fitToWidth();
    },

    fitPageToHeight:function () {
        this.pageView.fitToHeight();
    },

    navigateToPage:function (pageNo) {
        this.pageView.navigateToPage(pageNo);
    },

    zoomLevelChanged:function (zoomLevel, viewAdjust) {
        this.pageView.zoomLevelChanged(zoomLevel, viewAdjust);
    },


    navigateToPrevPage:function () {
        this.pageView.navigateToPreviousPage();
    },

    navigateToNextPage:function () {
        this.pageView.navigateToNextPage();
    },

    onCurrentPageChanged:function (pageView, pageNo) {
        this.viewerToolbar.setCurrentPage(pageNo);
        if (this.communicationFunction) {
            RM.Logger.debug("ViewerController", "onCurrentPageChanged", " Current page changed to:" + pageNo);
            this.communicationFunction.call(this, "currentPageChanged", pageNo);
        }
    },

    viewChanged:function (zoomLevel) {
        this.viewerToolbar.zoomChanged(zoomLevel);
    },

    //Will only called if the CTS is rendering the document right now
    totalPageCountUpdated:function (pageCount) {
        this.viewerToolbar.totalPageCountUpdated(pageCount);
        if (this.communicationFunction && pageCount > 0) {

            RM.Logger.info("ViewerController", "totalPageCountUpdated", "Calling VF communication function to init thumbnail control");
            this.communicationFunction.call(this, "currentDocumentChanged", {pageCount:pageCount, isFullyRendered:this.documentViewer.isFullyRenderedDoc});
        }
    },

    rotatePage:function (angle) {
        this.pageView.rotatePage(angle);
    }
});

/**
 * User: michad
 * Date: 7/15/11
 * Time: 12:27 PM
 */

Ext.define('RM.view.CommentMarker', {
    extend:'Ext.container.Container',
    autoHeight: true,
    autoWidth: true,
    shadow: false,
    alias: 'widget.rmCommentMarker',
    cls:'rmCommentMarker',
    layout: {
        type: 'hbox',
        pack: 'start',
        align: 'stretch'
    },

    statics: {
        getColorStyleRgb:function (commentColor) {
            var commentColorHex = "000000";
            if (commentColor != null) {
                commentColorHex = (commentColor.charAt(0) == "#") ? commentColor.substring(1, 7) : commentColor
            }
            var markerBackgroundRgb = RM.view.CommentMarker.hex2rgb(parseInt("0x" + commentColorHex));
            var commentColorRgb = "rgba(" + markerBackgroundRgb.R + "," + markerBackgroundRgb.G + "," + markerBackgroundRgb.B + "," + " 0.5)";
            return {commentColorHex:commentColorHex, commentColorRgb:commentColorRgb};
        },

        getIEStyleFilter: function (commentColor) {
            var colorWithAlpha = commentColor.replace("#", "#7f");
            return "progid:DXImageTransform.Microsoft.gradient(startColorstr="+colorWithAlpha+",endColorstr="+colorWithAlpha+")";
        },

        hex2rgb:function (hex){
            var r = (hex & 0xff0000) >> 16;
            var g = (hex & 0x00ff00) >> 8;
            var b = hex & 0x0000ff ;
            return {R:r, G:g, B:b};
        }
    },

    listeners: {
        afterrender: function() {
            if(Ext.isIE && this.el) {
                this.el.dom.style.filter = RM.view.CommentMarker.getIEStyleFilter(this.comment.commentColor);
            }
            var me = this;
            if(me.el){
                me.el.addListener('mouseover', me.mouseOverListener, me);

                me.el.addListener('click', function(event, target) {
                    RM.Logger.debug("CommentMarker", "click", " Clicked");
                    me.fireEvent('commentClicked', me.comment);
                });
            }
        },
        containermouseover: function() {
            this.registerQuickTip(this);
        }
    },
    config: {
        comment:{creatorName: ''},
        circleRadius: 8,
        targetDiv: ''
    },

    mouseOverListener: function(event, target){
        RM.Logger.debug("CommentMarker", "mouseOverListener", "Mouse over on comment marker");
        this.el.removeListener('mouseover', this.mouseOverListener, this);
        this.registerQuickTip(this, event);
    },

    initComponent:function() {
        this.addEvents('commentClicked');
        this.enableBubble('commentClicked');
        var circleRadius = 8;
        var targetDiv = this;
        // create circle and text element
        this.markerImage = this.createMarkerImage(this.circleRadius, this.targetDiv, this.comment);
        this.textElement = this.createNumberMarker(this.targetDiv, this.circleRadius, this.comment);
        //add as items to this component
        this.items = [ this.markerImage, this.textElement ];
        //positioning will be done for this whole component
        var __ret = RM.view.CommentMarker.getColorStyleRgb(this.comment.commentColor);
        var commentColorHex = __ret.commentColorHex;
        var commentColorRgb = __ret.commentColorRgb;
        if (!Ext.isIE) {
            this.style = {
                backgroundColor:commentColorRgb//comment.commentColor
            };
        }
        this.callParent(arguments);
        RM.Logger.debug("CommentMarker", "initComponent", "Created comment marker with color" + commentColorHex);

    },

    createMarkerImage:function (circleRadius, targetDiv, comment) {
        var me = this;
        var markerImage = new Ext.Component({
            width: circleRadius * 2, height: circleRadius * 2,
            padding: 0,
            cls: 'viewer-comment-ovr',
            draggable: false,
            constrain: true ,
            listeners: {
                scope: me,
                mouseover: function() {
                    me.registerQuickTip(me);
                }
            }
        });
        return markerImage;
    },

    createNumberMarker:function (targetDiv, circleRadius, comment) {
        var me = this;
        var markerNumber = {
            xtype: 'label',
            cls:'rmCommentNumber',
            text: this.comment.commentNumber,
            style: 'font-size:'+(circleRadius * 2)+'px',
            listeners:{
                afterrender: function() {
                    var numberMarginValue = me.getLeftRightMarginTotal(".rmCommentNumber");
                    var imageMarginValue = me.getLeftRightMarginTotal(".viewer-comment-ovr");
                    me.setWidth ( me.markerImage.width  + Ext.getCmp(this.id).getWidth() + numberMarginValue + imageMarginValue );
                }
            }
        };

        return markerNumber;
    },

    getLeftRightMarginTotal: function(componentStyleName) {
        var marginValue = 5;//default margin value
        var componentStyleRule = Ext.util.CSS.getRule(componentStyleName);
        if(!componentStyleRule){
            return marginValue;
        }
        var componentStyle = componentStyleRule.style;
        if(!Ext.isIE){
            marginValue = parseInt(componentStyle.getPropertyValue('margin-left').replace("px",""))
                + parseInt(componentStyle.getPropertyValue('margin-right').replace("px",""));
        }
        else{
            marginValue = parseInt(componentStyle.marginLeft.replace("px",""))
                + parseInt(componentStyle.marginRight.replace("px",""));
        }
        return marginValue;
    },

    getPreviewContent:function (previewContent) {
        var plainContent = Ext.util.Format.stripTags(previewContent);

        if (plainContent.length > 0) {
            previewContent = plainContent.replace(/&nbsp;/g, " ");
        }

        var previewPlain = Ext.String.ellipsis(previewContent, 250);
        RM.Logger.info("CommentMarker", "getPreviewContent", "Preview text"+ previewPlain);
        return previewPlain;
    },

    registerQuickTip: function(markerImage, event) {
        var comment = this.comment;
        var date = new Date(comment.creationDate)
        var previewContent = comment.commentContent;
        var previewPlain = this.getPreviewContent(comment.commentContent);
        var formattedCreationDate = Ext.Date.format(date, RM.Strings.Viewer.DocumentViewer.creationDateFormat);
        var commentHeaderText = Ext.String.format(RM.Strings.Viewer.DocumentViewer.commentHeaderFormat,
            comment.creatorName, formattedCreationDate);

        var tip = Ext.create('Ext.tip.ToolTip', {
            target: markerImage.id,
            cls: 'rmCommentHoverPanel',
            autoHide: true,
            shadow: false,
            dismissDelay: 0,
            preventHeader: true,
            items: [
                { xtype: 'component', cls:'rmHoverTopBar', html: commentHeaderText, cols: 32 },
                { xtype: 'component', cls: 'rmCommentPreviewSeparator' },
                { xtype: 'component', html: previewPlain, cls: 'rmCommentPreviewContent', grow: true, cols: 32 },
                { xtype: 'component', cls: 'rmCommentPreviewLowerSeparator' },
                { xtype: 'label', text: RM.Strings.Viewer.DocumentViewer.commentHoverPrompt, cls: 'rmHoverBottomBar' }
            ]
        });
        RM.Logger.debug("CommentMarker", "registerQuickTip", "Registered quick tip for marker:" + markerImage.id);
        var tipOffsetX = tip.getMouseOffset()[0];
        var tipOffsetY = tip.getMouseOffset()[1];
        if(event.browserEvent.pageX) {
            tip.showAt([event.browserEvent.pageX + tipOffsetX, event.browserEvent.pageY + tipOffsetY]);
        }
        else{
            tip.showAt([event.browserEvent.clientX + tipOffsetX, event.browserEvent.clientY + tipOffsetY]);
        }

        this.tip = tip;
    },

    applyComment: function(comment) {
        this.comment = comment;
        if(this.tip){
            this.tip.removeAll();
            this.tip.destroy();
            if(this.tip.ownerCt){
                this.tip.ownerCt.remove(this.tip, true);
            }
            delete this.tip;
        }
        this.el.addListener('mouseover', this.mouseOverListener, this);
        return comment;
    }
});


Ext.define('RM.model.DocumentPage', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'pageNumber', type: 'int'},
        {name: 'contentUrl', type: 'string'}
    ],
    idProperty: 'pageNumber',
    belongsTo: 'RM.model.Document',
    validations: [
        {type: 'presence', field: 'pageNumber'},
        {type: 'presence', field: 'contentUrl'},
        {type: 'length', field: 'contentUrl', min: 1}
    ]
});

Ext.define('RM.model.Document', {
    extend: 'Ext.data.Model',
    fields: [
         {name: 'objectId', type: 'string'},
         {name: 'objectName', type: 'string'},
         {name: 'rendering',  type: 'boolean', defaultValue: false},
         {name: 'rendered',  type: 'boolean', defaultValue: false},
         {name: 'pageCount', type: 'int'},
         {name: 'assetClass', type: 'string'},
         {name: 'format', type: 'string'}
    ],
    hasMany  : {model: 'RM.model.DocumentPage', name: 'documentPages', associationKey: 'pages'},

    validations: [
        {type: 'presence', field: 'objectId'},
        {type: 'presence', field: 'objectName'},
        {type: 'presence', field: 'coverPageUrl'},
        {type: 'length', field: 'pageCount', min: 1}
    ]
});

Ext.define('RM.model.CommentTypes', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'label', type:'String'},
        {name: 'id', type:'String'}
    ]
});

Ext.define('RM.model.Comment', {
    extend: 'Ext.data.Model',
    idProperty: 'commentId',
    fields: [
        {name: 'documentId', type: 'string'},
        {name: 'commentNumber', type: 'int'},
        {name: 'pageNumber', type: 'int'},
        {name: 'xPos', type: 'int'},
        {name: 'yPos', type: 'int'},
        {name: 'pageHeight', type: 'int'},
        {name: 'pageWidth', type: 'int'},
        {name: 'commentTitle', type: 'string'},
        {name: 'replyTo', type: 'string'},
        {name: 'commentContent', type: 'string'},
        {name: 'commentId', type: 'string'},
        {name: 'commentColor', type: 'string'},
        {name: 'creatorName', type: 'string'},
        {name: 'creationDate', type: 'int'},
        {name: 'unread', type: 'boolean'},
        {name: 'replies', type: 'int'},
        {name: 'unreadReplies', type: 'int'}
    ],

    cloneFrom: function(commentInfoObj) {
        var newClone = {};
        newClone.documentId = commentInfoObj.documentId;
        newClone.commentId = commentInfoObj.commentId;
        newClone.commentNumber = commentInfoObj.commentNumber;
        newClone.pageNumber = commentInfoObj.pageNumber;
        newClone.xPos = commentInfoObj.xPos;
        newClone.yPos = commentInfoObj.yPos;
        newClone.pageHeight = commentInfoObj.pageHeight;
        newClone.pageWidth = commentInfoObj.pageWidth;
        newClone.commentTitle = commentInfoObj.documentId;
        newClone.replyTo = commentInfoObj.replyTo;
        newClone.commentContent = commentInfoObj.commentContent;
        newClone.commentColor = commentInfoObj.commentColor;
        newClone.creatorName = commentInfoObj.creatorName;
        newClone.creationDate = commentInfoObj.creationDate;

        return newClone;
    }
});

Ext.define('RM.model.CommentSessionInfo', {
    extend: 'Ext.data.Model',
    idProperty:'commentId',
    belongsTo: 'RM.model.ViewerSessionInfo',
    fields: [
        {name: 'commentId'},
        {name: 'windowHeight', type: 'int'},
        {name: 'windowWidth', type: 'int'}
    ],
    hasMany  : {model: 'RM.model.Comment', name: 'collapsedNodes'}
});

Ext.define('RM.model.ViewerSessionInfo', {
    extend: 'Ext.data.Model',
    idProperty:'userId',
    fields: [
        {name: 'userId'}
    ],
    hasMany  : {model: 'RM.model.CommentSessionInfo', name: 'userCommentsInfo', associationKey: 'commentsInfo'}
});




/**
 * Created by IntelliJ IDEA.
 * User: michad
 * Date: 5/20/11
 * Time: 6:28 PM
 * To change this template use File | Settings | File Templates.
 */
Ext.define('RM.view.DynamicSizingScroller', {
    extend:'Ext.grid.PagingScroller',
    alias:'widget.dynamicSizingScroller',
    cls:'rmDynamicSizingScroller',

    enableSmoothScrolling: false,

    requestQueue: [],

    getSizeCalculation: function() {

        // Custom Viewer code start
        if(!this.ownerCt){ //Check if the owner Ct is not valid.
            return {width: 1,height: 1};
        }
        // Custom Viewer code end

        var owner = this.ownerCt,
                view = owner.getView(),
                store = this.store,
                dock = this.dock,
                elDom = this.el.dom,
                width = 1,
                height = 1;
/*
        if (!this.rowHeight) {
            this.rowHeight = view.el.down(view.getItemSelector()).getHeight(false, true);
        }
*/
        // Custom Viewer code start
        if(view.rendered && view.el.down(view.getItemSelector())!=null){
            this.rowHeight = view.el.down(view.getItemSelector()).getHeight(false, true);
            RM.Logger.debug("DynamicSizingScroller", "getSizeCalculation", "Setting the row height implicitly to:" + this.rowHeight);
        }
        // Custom Viewer code end

        height = store.getTotalCount() * this.rowHeight;
        if (isNaN(width)) {
            width = 1;
        }
        if (isNaN(height)) {
            height = 1;
        }

        // Custom Viewer code start
		//Never allow to remove the scrollbar.Scrollbar once removed
		//is not initalizing it properly while putting it back
        if(this.ownerCt && height < this.ownerCt.getHeight()){
            // Giving just a higher value than ownerCT height so as to prevent
            // the infinite scroller from disappearing.This 1.3 has no relevance here
            //just a higher percentage than the real value
            height = this.ownerCt.getHeight() * 1.3;
            RM.Logger.debug("DynamicSizingScroller", "getSizeCalculation", "Using hack to set the viewer scroll bar height " +
                "as we don't want scroll bar to disappear - height:" + height);
        }
        // Custom Viewer code end

        return {
            width: width,
            height: height
        };
    },

    syncTo: function() {
        var me            = this,
            pnl           = me.getPanel(),
            store         = pnl.store,
            scrollerElDom = this.el.dom,
            scrollHeight  = scrollerElDom.scrollHeight,
            clientHeight  = scrollerElDom.clientHeight,
            scrollTop     = scrollerElDom.scrollTop,
            rowOffset     = me.visibleStart - store.guaranteedStart,
            scrollBy,
            useMaximum;

        if (Ext.isIE9 && Ext.isStrict) {
            clientHeight = scrollerElDom.offsetHeight + 2;
        }

        if(this.enableSmoothScrolling){
            scrollBy = scrollTop - store.guaranteedStart* me.rowHeight;
        }
        else{
           /* var viewScrollTop = scrollTop - store.guaranteedStart* me.rowHeight;
            var viewNextPageScrollDelta = (viewScrollTop % me.rowHeight);

            if(viewNextPageScrollDelta != me.rowHeight){

               this.scrollByDeltaY(me.rowHeight - viewNextPageScrollDelta - 10);
            }*/
            scrollBy = rowOffset * me.rowHeight;

        }

        useMaximum = (scrollHeight - clientHeight - scrollTop <= 0);
        this.setViewScrollTop(scrollBy, useMaximum);
    },

    attemptLoad: function(start, end) {
        var me = this;
        if (!me.loadTask) {
            //console.log("Creating loadTask for request from "+ start+ " to "+ end);
            me.loadTask = Ext.create('Ext.util.DelayedTask', me.doAttemptLoad, me, []);
        }
        else{
            //console.log("Aborting call for request from "+ start+ " to "+ end);
            me.loadTask.cancel();
        }
        me.loadTask = Ext.create('Ext.util.DelayedTask', me.doAttemptLoad, me, []);
        me.loadTask.delay(me.scrollToLoadBuffer, me.doAttemptLoad, me, [start, end]);
    },

    doAttemptLoad: function(start, end) {
        //console.log("Calling from "+ start+ " to "+ end);
        var store = this.getPanel().store;
        store.guaranteeRange(start, end);
    },

    /*cancelLoad: function() {
        //console.log("Cancel called ");
        if (this.loadTask) {
            //console.log("Cancelling called loadTask");
            this.loadTask.cancel();
        }
    },*/

    /**
     * Overriding this behaviour because of how it handles case of 'end of request was past what the total is'
     * @param e
     * @param t
     */
    onElScroll: function(e, t) {
            var me = this,
                panel = me.getPanel(),
                store = panel.store,
                pageSize = store.pageSize,
                guaranteedStart = store.guaranteedStart,
                guaranteedEnd = store.guaranteedEnd,
                totalCount = store.getTotalCount(),
                numFromEdge = Math.ceil(me.percentageFromEdge * store.pageSize),
                position = t.scrollTop,
                visibleStart = Math.floor(position / me.rowHeight),
                view = panel.down('tableview'),
                viewEl = view.el,
                visibleHeight = viewEl.getHeight(),
                visibleAhead = Math.ceil(visibleHeight / me.rowHeight),
                visibleEnd = visibleStart + visibleAhead,
                prevPage = Math.floor(visibleStart / store.pageSize),
                nextPage = Math.floor(visibleEnd / store.pageSize) + 2,
                lastPage = Math.ceil(totalCount / store.pageSize),
                //requestStart = visibleStart,
                requestStart = Math.floor(visibleStart / me.snapIncrement) * me.snapIncrement,
                requestEnd = requestStart + pageSize - 1,
                activePrefetch = me.activePrefetch;

            me.visibleStart = visibleStart;
            me.visibleEnd = visibleEnd;


            me.syncScroll = true;
            // end of request was past what the total is, grab from the end back a pageSize
            if (requestEnd > totalCount - 1) {
                this.cancelLoad();
                if (store.rangeSatisfied(totalCount - pageSize, totalCount - 1)) {
                    me.syncScroll = true;
                }
                //console.log("Calling store.guaranteeRange (b) from "+ requestStart+ " to "+ requestEnd + " when totalCount is "+ totalCount);

                //DM Fixed this - why call last two if the pageSize > records in last page
                //store.guaranteeRange(totalCount - pageSize, totalCount - 1);
                store.guaranteeRange(requestStart, totalCount - 1);
            // Out of range, need to reset the current data set
            } else if (visibleStart < guaranteedStart || visibleEnd > guaranteedEnd) {
                if (store.rangeSatisfied(requestStart, requestEnd)) {
                    this.cancelLoad();
                    //console.log("Calling store.guaranteeRange (v) from "+ requestStart+ " to "+ requestEnd);
                    store.guaranteeRange(requestStart, requestEnd);
                } else {
                    if(!store.loading){
                        store.mask();
                        me.attemptLoad(requestStart, requestEnd);
                        store.addListener('load', function(){
                            store.removeListener('load', arguments.callee)
                            Ext.each(me.requestQueue, function(pendingRequest) {
                                //console.log("Attempting call to "+pendingRequest.start);
                                me.attemptLoad(pendingRequest.start, pendingRequest.end);
                            });
                            //console.log(me.requestQueue.length);
                            me.requestQueue = [];
                        })
                    }
                    else{
                        //queue requests
                        //if(me.requestQueue == undefined){
                            me.requestQueue = [];
                        //}
                        //console.log("Queueing request for " + requestStart + " to " + requestEnd);
                        me.requestQueue.push({"start":requestStart, "end":requestEnd});
                    }
                }
                // dont sync the scroll view immediately, sync after the range has been guaranteed
                me.syncScroll = false;
            } else if (activePrefetch && visibleStart < (guaranteedStart + numFromEdge) && prevPage > 0) {
                me.syncScroll = true;
                //console.log("Calling for prevPage "+ prevPage);
                store.prefetchPage(prevPage);
            } else if (activePrefetch && visibleEnd > (guaranteedEnd - numFromEdge) && nextPage < lastPage) {
                me.syncScroll = true;
                //console.log("Calling for nextPage "+ nextPage);
                store.prefetchPage(nextPage);
            }


            if (me.syncScroll) {
                me.syncTo();
            }
        },

    resetViewScroll:function(){
        RM.Logger.debug("DynamicSizingScroller", "resetViewScroll", "Setting view scroll top to 0");
        this.setViewScrollTop(0);
    }

})
/**
 * Created by IntelliJ IDEA.
 * User: michad
 * Date: 6/6/11
 * Time: 3:40 PM
 * To change this template use File | Settings | File Templates.
 */

Ext.define('RM.store.DocumentPageStore', {
    extend: 'Ext.data.Store',
    model:'RM.model.DocumentPage',
    autoLoad: false,
    buffered: true,
    leadingBufferZone : 0,
    trailingBufferZone : 0,
    purgePageCount: 0,
    sorters: [{
        property: 'pageNumber',
        direction: 'ASC'
    }]


})

Ext.define('RM.view.PageView', {
    extend:'Ext.Container',
    alias:'widget.rmDocumentPageViewer',
    layout:{
        type:'anchor'
    },
    cls:'rmDocumentPageViewer',
    border:false,
    padding:"0",
    statics:{
        FIT_TO_HEIGHT:'fitToHeight',
        FIT_TO_WIDTH:'fitToWidth',
        ZOOMED_STATE:'zoomed',
        ALIGN_VIEW:'alignView',
        NAVIGATION:'navigation',
        IMG_LOCATOR:'img.rmPageImage',
        PAGE_DIV_STYLE_ID:'rmPageDivStyleId',
        PAGE_CONTAINER_STYLES:'.rmPageDataView .rmPageContainer',
        PAGE_IMG_DIV_STYLE:'.rmPageDataView div .rmPageContainer',
        PAGE_IMG_STYLE:'.rmPageDataView .rmPageContainer img',
        WIDTH:'width',
        HEIGHT:'height',
        PAGE_NUMBER:'pagenumber'
    },
    config:{
        document:{},
        currentPage:1,
        documentUrl:"",
        documentPagesUrl:"",
        saveCommentsUrl:"",
        storePageSize:50,
        documentRendering:false,
        enableInfiniteScrolling:true,
        currentFitState:'',
        panRefPosition:{},
        pageChangeReason:'navigation',
        assetClass:""
    },

    populatePageDetails:function (image) {
        if (this.currentZoomLevel != null && this.currentFitState == RM.view.PageView.ZOOMED_STATE) {
            this.updateZoomLevelOnImage(this.currentZoomLevel, image);
        }

        if (this.currentFitState == RM.view.PageView.FIT_TO_HEIGHT) {
            this.delayedFitHeightTaskAfterImageLoad.delay(150);
            this.setCurrentZoomLevel(this);
        }

        if (this.currentFitState == RM.view.PageView.FIT_TO_WIDTH) {
            this.delayedFitWidthTaskAfterImageLoad.delay(150);
        }
    },

    setCurrentZoomLevel:function (me) {
        var divUniqueId = this.getUniquePageDivID(this.currentPage);
        var targetDiv = Ext.get(divUniqueId);
        if (targetDiv == undefined) {
            RM.Logger.warn("PageView", "setCurrentZoomLevel",
                "invalid comment marker received for current set at :" + this.currentPage);
            return;
        }

        var currentImage = targetDiv.down("img").dom;
        if (currentImage) {
            var currentZoomLevel = currentImage.height / this.getNatural(currentImage).height * 100;
            RM.Logger.debug("PageView", "setCurrentZoomLevel", "Setting current page's zoom to slider" + currentZoomLevel);
            me.fireEvent("zoomLevelChanged", currentZoomLevel);
        }
    },

    refreshViewScrollbar:function (view, vScrollbar) {
        if (view.rendered && view.el.down(view.getItemSelector()) != null) {
            var viewRowHeight = view.el.down(view.getItemSelector()).getHeight(false, true);
            if (vScrollbar.rowHeight != viewRowHeight) {
                RM.Logger.debug("Image", "onLoad - invalidateDocViewerScroller", "Scroller not in sync - Invalidate it");
                delete vScrollbar.rowHeight;  //DM 4.1 RC1
                vScrollbar.onViewRefresh(); //DM 4.1 beta
                vScrollbar.viewSize = 0;
                vScrollbar.onViewResize(vScrollbar.view, vScrollbar.view.getWidth(), vScrollbar.view.getHeight()); //DM 4.1 RC1
            }
            /*if (grid.scrollDelta != viewRowHeight) {  //DM 4.1 beta no scrollDelta?
             grid.scrollDelta = viewRowHeight;
             }*/
        }
    },

    initComponent:function () {
        //Set network location
        this.networkLocationId = "";
        if (xcp && xcp.UserPreferences)
            this.networkLocationId = xcp.UserPreferences.get('networkLocation');

        this.configureScrollerType();

        //Reduce the store page size to have faster results from CTS
        if (!this.isFullyRenderedDoc) {
            this.storePageSize = 5;
        }

        var me = this;

        //Sencha fix to have higher header size
        Ext.override(Ext.grid.plugin.HeaderResizer, {
            maxColWidth:10000
        });
        var delayResizeImgDivsTask = new Ext.util.DelayedTask(me.resizeImagesAfterLoad, me);
        this.delayedFitHeightTask = new Ext.util.DelayedTask(this.fitToHeight, this, [true]);
        this.delayedFitWidthTask = new Ext.util.DelayedTask(this.fitToWidth, this);
        this.delayedFitHeightTaskAfterImageLoad = new Ext.util.DelayedTask(this.fitToHeight, this, [true, true]);
        this.delayedFitWidthTaskAfterImageLoad = new Ext.util.DelayedTask(this.fitToWidth, this, [true]);
        this.delayedRefreshCache = new Ext.util.DelayedTask(Ext.util.CSS.refreshCache, Ext.util.CSS);
        this.delayedCommentPositioning = new Ext.util.DelayedTask(function () {
            RM.Logger.debug("PageView", "repositionComments", "Reposition Markers");
            me.fireEvent('repositionMarkers', this);
        });

        this.delayedSearchHitsPositioning = new Ext.util.DelayedTask(function () {
            RM.Logger.debug("PageView", "repositionSearchHighlights", "Reposition Search Highlights");
            me.fireEvent('repositionSearchHighlights', this);
        });

        this.pageLoaded = function (page) {
            var grid = me.pageDataView,
                view = grid.getView(),
                store = me.documentStore,
                vScroller = grid.verticalScroller;
            me.refreshViewScrollbar(view, vScroller);
            store.pageSize = me.storePageSize;
            me.populatePageDetails(page);
            delayResizeImgDivsTask.delay(500);
            var clickFunction = function (event) {
                me.imageClicked2(event, me);
            };
            //Focus the grid so that we will be able to have keyboard events firing
            grid.focus();
            if (!page.addEventListener) {
                page.attachEvent("onclick", clickFunction);
            }
            else {
                page.addEventListener('click', function (event) {
                    me.imageClicked2(event, me);

                });
            }
        }

        this.documentStore = new RM.store.DocumentPageStore({
            storeId:'rmStore' + this.id,

            pageSize:this.storePageSize,
            proxy:{
                type:'ajax',
                url:this.documentPagesUrl,
                timeout:3600000,
                extraParams:{
                    objectId:me.documentId,
                    totalPages:me.totalPageCount,
                    isFullyRenderedDoc:me.isFullyRenderedDoc,
                    location:me.networkLocationId
                },
                reader:{
                    type:'json',
                    root:'documentPages',
                    totalProperty:'pageCount'
                },
                simpleSortMode:true,
                afterRequest:function () {
                    me.hideRealTimeLoadingMask();
                    RM.Logger.info("documentStore", "afterRequest", "After fetch");
                    me.fireEvent('pagesReceived', me);
                },
                listeners:{
                    scope:this,
                    exception:function (proxy, response, operation) {
                        me.hideRealTimeLoadingMask();
                        me.removeLoadingCls();
                        RM.Logger.error("documentStore", "exception", "Exception occured while fetching page");
                        me.fireEvent("fatalError", "pageLoading");
                    }
                }
            },
            listeners:{
                beforeprefetch:function () {
                    me.showRealTimeLoadingMask();
                }
            }
        });


        this.pageDataView = Ext.create('Ext.grid.Panel', {
            store:'rmStore' + this.id,
            cls:'rmPageDataView',
            anchor:"100% 100%",
            documentId:me.documentId,
            saveCommentsUrl:this.saveCommentsUrl,
            getUniquePageDivID:this.getUniquePageDivID,
            verticalScroller:this.verticalScrollConfig,
            loadMask:true,
            autoScroll:true,
            invalidateScrollerOnRefresh:false,
            viewConfig:{
                cls:'rmPageGridView',
                trackOver:false,
                disableSelection:true,
                stripeRows:false,
                loadingText:RM.Strings.Viewer.DocumentViewer.loadingPagesMsg,
                listeners:{
                    scope:this,
                    afterrender:function () {
                        RM.Logger.debug("pageDataView", "afterrender", "Calling fit to height after render - Start" + {indent:1});
                        this.delayedFitHeightTask.delay(150);
                        RM.Logger.debug("pageDataView", "afterrender", "Fit to height completed - End" + {outdent:1});
                    }
                }
            },
            columns:[
                {dataIndex:'contentUrl', scope:this, sortable:false, renderer:this.renderDocumentPage, flex:1}
            ],
            hideHeaders:true,
            listeners:{
                scope:this,
                /*itemclick:this.pageClicked,*/
                itemmousedown:this.initPan
            }
        });

        this.realTimeRenderingMask = new Ext.LoadMask(this.pageDataView, {msg:RM.Strings.Viewer.DocumentViewer.loadingPagesMsg});

        if (this.enableInfiniteScrolling) {
            var scroller = this.pageDataView.verticalScroller;
            scroller.view.addListener("afterrender", function () {
                //If the scroller is at top then reset the view as well.
                //This is a workaround for EXTJS bug by which, view is not refreshing
                //eventhough it is at the scrolltop : Remove it when its fixed
                if (scroller.view.el.dom.scrollTop == 0) {
                    RM.Logger.debug("PageView", "scrollerAfterRender", "Reset view Scroller if the scroll top of inifinte scroller is top of page ");
                    //scroller.resetViewScroll();
                }
                RM.Logger.debug("PageView", "scrollerAfterRender", "Register scroll event to catch navigation event");
                scroller.view.mon(scroller.view.el, 'scroll', me.scrolled, me);
            });
        }

        this.items = [this.pageDataView];
        // add custom events
        this.addEvents('currentPageChanged', 'repositionMarkers', 'pagesReceived', 'zoomLevelChanged');
        this.callParent(arguments);
    },

    listeners:{
        afterrender:function () {
            RM.Logger.debug("pageDataView", "afterrender", "Calling fit to height after render - Start" + {indent:1});
            this.setCurrentPage(1);
            var view = this.pageDataView;
            //this.fitToHeight(true);
            this.delayedFitHeightTask.delay(150);
            RM.Logger.debug("pageDataView", "afterrender", "Fit to height completed - End" + {outdent:1});
        }
    },


    findPos:function (obj, stopAtElementType, addStopElementOffset) {
        var curleft = 0;
        var curtop = 0;
        if (obj.offsetParent) {
            do {
                curleft += obj.offsetLeft;
                curtop += obj.offsetTop;

                if (obj.offsetParent && obj.offsetParent.tagName == stopAtElementType) {
                    var offsetTop = obj.offsetParent.offsetTop;
                    if (addStopElementOffset && offsetTop > 0) {
                        curtop += offsetTop;
                    }
                    break;
                }

            } while (obj = obj.offsetParent);
            var position = {"curleft":curleft, "curtop":curtop};
            RM.Logger.debug("PageView", "findPos", "Current Left: " + curleft + " Current Top: " + curtop);
            return position;
        }

    },

    //private
    getUniquePageDivID:function (pageNumber) {
        var uniquePageDivID = this.id + this.documentId + pageNumber;
        return uniquePageDivID;
    },

    initPan:function (view, record, htmlItem, index, event, options) {
        if (this.currentFitState == RM.view.PageView.ZOOMED_STATE && !this.isWaitingForCommentLocation) {
            event.stopEvent();
            this.panRefPosition = {mouseX:event.getPageX(), mouseY:event.getPageY()};
            RM.Logger.debug("PageView", "initPan", "Pan from mouseX: " + event.getPageX() + " mouseY:" + event.getPageY());
            view.getEl().on('mousemove', this.doPan, this);
            Ext.getDoc().on('mouseup', this.stopPan, this);
        }
    },

    doPan:function (event) {
        event.stopEvent();
        var currX = event.getPageX();
        var currY = event.getPageY();
        var view = this.pageDataView.getView();

        //Hook with grid's infinite scroller instead of the view's vertical scroller
        //to manage dynamic loading
        var vScroller = this.pageDataView.verticalScroller;
        var cursor = this.grabCursorStyle();
        if (view.getEl().hasCls(cursor.grab)) view.getEl().removeCls(cursor.grab);
        if (!view.getEl().hasCls(cursor.grabbing)) view.getEl().addCls(cursor.grabbing);

        //Scroll
        if (event.within(view.getEl())) {
            var xDelta = this.panRefPosition.mouseX - currX;
            var yDelta = this.panRefPosition.mouseY - currY;

            view.el.dom.scrollLeft += xDelta;
            RM.Logger.debug("PageView", "doPan", "Pan horizontally: " + xDelta);
            if (vScroller.view.rendered) {
                RM.Logger.debug("PageView", "doPan", "Pan vertically: " + yDelta);
                vScroller.view.scrollBy(0, yDelta);
            }

        }
        this.panRefPosition = {mouseX:currX, mouseY:currY};
        RM.Logger.debug("PageView", "doPan", "Reseting pan position to mouseX: " + currX + " mouseY:" + currY);
    },

    stopPan:function () {
        var view = this.pageDataView.getView();
        view.getEl().un('mousemove', this.doPan, this);
        Ext.getDoc().un('mouseup', this.stopPan, this);
        var cursor = this.grabCursorStyle();
        if (view.getEl().hasCls(cursor.grabbing)) view.getEl().removeCls(cursor.grabbing);
        if (!view.getEl().hasCls(cursor.grab)) view.getEl().addCls(cursor.grab);
        RM.Logger.debug("PageView", "stopPan", "Un-registering all the mouse events and clearing grab cursors");
    },


    imageClicked2:function (event, pageView) {
        var imageElement;
        if (event.target) {
            imageElement = event.target;
        }
        else if (event.srcElement) {
            imageElement = event.srcElement;
        }
        if (!pageView.isWaitingForCommentLocation || !imageElement.tagName == "IMG") {
            return;
        }

        var pos_x, pos_y;
        // IE or Chrome
        if (event.offsetX) {
            RM.Logger.debug("PageViewCom", "imageClicked", "event.offsetX present");
            pos_x = window.event.offsetX;
            pos_y = window.event.offsetY;
        }
        // Firefox
        else {
            RM.Logger.debug("PageViewCom", "imageClicked", "event.layerX, event.layerY : " + event.layerX + ", " + event.layerY);
            RM.Logger.debug("PageViewCom", "imageClicked", "imageElement.offsetLeft, imageElement.offsetTop : " + imageElement.offsetLeft + ", " + imageElement.offsetTop);
            var offsetLeft = imageElement.offsetLeft;
            var offsetTop = imageElement.offsetTop;
            if (event.layerX < imageElement.offsetLeft) {
                offsetLeft = offsetTop = 0;
            }
            pos_x = event.layerX - offsetLeft;
            pos_y = event.layerY - offsetTop;
        }
        RM.Logger.debug("PageViewCom", "imageClicked", "X, Y : " + pos_x + ", " + pos_y);

        var pageNumber = imageElement.getAttribute('pageNumber');
        var newCommentInfo = new RM.model.Comment();
        newCommentInfo.pageNumber = pageNumber;
        newCommentInfo.documentId = pageView.documentId;
        newCommentInfo.yPos = pos_y;
        newCommentInfo.xPos = pos_x;
        this.updateIERotatedPosition(pageNumber, imageElement, newCommentInfo, pos_y, pos_x);
        newCommentInfo.pageHeight = imageElement.height;
        newCommentInfo.pageWidth = imageElement.width;

        Ext.create('rm.view.RichHtmlWindow', {
            newCommentInfo:newCommentInfo,
            saveCommentsUrl:pageView.saveCommentsUrl,
            layout:'fit',
            getBubbleTarget:function () {
                return pageView;
            }
        }).show();
        pageView.disableCommentMode();
        RM.Logger.debug("PageView", "imageClicked", "handling page click events completed - End", {outdent:1});
    },

    updateIERotatedPosition:function (pageNumber, imageElement, newCommentInfo, pos_y, pos_x) {
        var rotatedAngle = this.getEarlierRotateAngle(pageNumber);
        var xMidpoint, yMidpoint, xyRotated, toRotate;
        if (rotatedAngle > 0 && Ext.isIE) {
            //what is the angle to get it back to 0
            toRotate = 360 - rotatedAngle;
            xMidpoint = imageElement.width / 2;
            yMidpoint = imageElement.height / 2;
            xyRotated = RM.controller.CommentController.rotatedXY(newCommentInfo.xPos, newCommentInfo.yPos, xMidpoint, yMidpoint, toRotate);
            if (rotatedAngle == 180) {
                RM.Logger.debug("PageViewCom", "imageClicked", "X, Y : " + xyRotated[0] + ", " + xyRotated[1]);
                newCommentInfo.xPos = xyRotated[0];
                newCommentInfo.yPos = xyRotated[1];
            }
            else if (rotatedAngle == 90) {
                newCommentInfo.xPos = pos_y;
                newCommentInfo.yPos = imageElement.height - pos_x;
                RM.Logger.debug("PageViewCom", "imageClicked", "X, Y : " + newCommentInfo.xPos + ", " + newCommentInfo.yPos);
            }
            else if (rotatedAngle == 270) {
                newCommentInfo.yPos = pos_x;
                newCommentInfo.xPos = imageElement.width - pos_y;
                RM.Logger.debug("PageViewCom", "imageClicked", "X, Y : " + newCommentInfo.xPos + ", " + newCommentInfo.yPos);
            }

        }
    },

    scrolled:function () {
        RM.Logger.debug("PageView", "scrolled", "Scroll event received - Start", {indent:1});
        if (this.pageChangeReason == RM.view.PageView.ALIGN_VIEW) {
            var currPage = this.getCurrentPage();
            if (this.isPageVisible(currPage)) {
                //Switch back to navigation since it could get initiated by scrollbar
                this.pageChangeReason = RM.view.PageView.NAVIGATION;
                RM.Logger.debug("PageView", "scrolled", "Page in view, no change required", {outdent:1});
                return;
            }
            else {
                this.navigateToPage(currPage);
                RM.Logger.debug("PageView", "scrolled", "Page not in view, navigated to page:" + currPage, {outdent:1});
                return;
            }
        }
        var firstPageNoInCurrentVisibleFrame = this.getFirstPageNoInCurrentVisibleFrame();
        if (firstPageNoInCurrentVisibleFrame != this.getCurrentPage()) {
            RM.Logger.debug("PageView", "scrolled", "Going to Set current page as :" + firstPageNoInCurrentVisibleFrame + " - Start", {indent:1});
            this.setCurrentPage(firstPageNoInCurrentVisibleFrame);
            RM.Logger.debug("PageView", "scrolled", "Set current page to :" + firstPageNoInCurrentVisibleFrame + " - End", {outdent:1});
            //Switch back to navigation since it could get initiated by scrollbar
            this.pageChangeReason = RM.view.PageView.NAVIGATION;
        }
        RM.Logger.debug("PageView", "scrolled", "Scroll event received - End", {outdent:1});
    },

    approximatePage:function (pageNo, approxPercent) {
        if (Math.floor(pageNo) != Math.floor(pageNo + (1 - approxPercent))) {
            pageNo = Math.ceil(pageNo);
        }
        RM.Logger.debug("PageView", "approximatePage", "Page:" + pageNo);
        return pageNo;
    },

    getFirstPageNoInCurrentVisibleFrame:function () {
        var scrollElDom = this.pageDataView.verticalScroller.view.el.dom;
        var pageheight = scrollElDom.scrollHeight / this.totalPageCount;
        //If pageNo is given as around 90% (.9 precision) then approximate to next page
        var pageNo = this.approximatePage(scrollElDom.scrollTop / pageheight, .9);
        var firstPageNoInCurrentVisibleFrame;
        if (Math.ceil(pageNo) != pageNo) {
            firstPageNoInCurrentVisibleFrame = Math.ceil(pageNo);
        }
        else {
            firstPageNoInCurrentVisibleFrame = pageNo + 1;
        }
        RM.Logger.debug("PageView", "getFirstPageNoInCurrentVisibleFrame", firstPageNoInCurrentVisibleFrame);
        return firstPageNoInCurrentVisibleFrame;
    },

    currentPageFrameCapacity:function (currentTopPage) {
        var scrollerDom = this.pageDataView.verticalScroller.view.el.dom;
        var pageHeight = scrollerDom.scrollHeight / this.totalPageCount;
        var containerHeight = this.containerHeight(true);

        // Tail of the page which from the previous frame
        var perfectPageFitHeight = pageHeight * (currentTopPage);
        var previousPageTail = perfectPageFitHeight - scrollerDom.scrollTop;
        var pageCapacity = Math.ceil((containerHeight - previousPageTail) / pageHeight);
        if (pageCapacity < 0) {
            pageCapacity = 0;
        }
        RM.Logger.debug("PageView", "currentPageFrameCapacity", pageCapacity);
        return pageCapacity;
    },


    getCurrentVisiblePages:function () {
        RM.Logger.debug("PageView", "getCurrentVisiblePages", "Start", {indent:1});
        var visiblePages = [];
        if (this.pageDataView.verticalScroller.view.el == null) {
            return visiblePages;
        }
        var currentTopPage = this.getFirstPageNoInCurrentVisibleFrame();
        var framePageFillCapacity = this.currentPageFrameCapacity(currentTopPage);
        for (var i = currentTopPage; i <= currentTopPage + framePageFillCapacity
            && i <= this.totalPageCount; i++) {
            visiblePages.push(i);
        }
        if (framePageFillCapacity == 0) {
            var scrollElDom = this.pageDataView.verticalScroller.view.el.dom;
            var pageHeight = scrollElDom.scrollHeight / this.totalPageCount;
            var pagePosition = scrollElDom.scrollTop / pageHeight;
            var visiblePercentage = 1 - this.containerHeight(true) / pageHeight;
            if (Math.floor(this.approximatePage(pagePosition, visiblePercentage)) != Math.floor(pagePosition)) {
                visiblePages.push(currentTopPage + 1);
            }
        }
        RM.Logger.debug("PageView", "getCurrentVisiblePages", "Current Visible pages " + visiblePages.join(","));
        RM.Logger.debug("PageView", "getCurrentVisiblePages", "End", {outdent:1});
        return visiblePages;
    },

    isPageVisible:function (pageNo) {
        var visiblePages = this.getCurrentVisiblePages();
        var pageVisible = Ext.Array.contains(visiblePages, pageNo);
        if (pageVisible)RM.Logger.debug("PageView", "isPageVisible", pageNo + " is Visible");
        else RM.Logger.debug("PageView", "isPageVisible", pageNo + " is NOT visible");
        return pageVisible;
    },


    renderDocumentPage:function (val) {
        var isPageArgument;
        var docObject;
        var pageNumber = -1;

        Ext.each(arguments, function (argument) {
            if (argument instanceof RM.model.DocumentPage) {
                docObject = argument;
                pageNumber = parseInt(docObject.data.pageNumber);
            }
        });
        var divUniqueId = this.getUniquePageDivID(docObject.data.pageNumber);
        RM.Logger.debug("PageView", "renderDocumentPage", "Rendering page with page no:" + pageNumber);
        return '<div class="rmPageContainer" id="' + divUniqueId + '"><img class="rmPageImage" onload="Ext.getCmp(\'' + this.id + '\').pageLoaded(this)" style="display:none"  src="' + val + ' " pageNumber="' + pageNumber + '"></div>';
    },

    invalidateCustomScroller:function () {
        var view = this.pageDataView.getView();
        /*if (view.rendered && this.pageDataView.verticalScroller.view.rendered &&
         this.pageDataView.verticalScroller.view.rowHeight != view.el.down(view.getItemSelector()).getHeight(false, true)) {
         RM.Logger.debug("PageView", "invalidateCustomScroller", "Invalidate scroller");
         //this.pageDataView.verticalScroller.view.invalidate(); //DM 4.1 beta
         }*/  //DM 4.1 beta
    },

    applyDocument:function (newDocument) {
        this.documentId = newDocument.data.objectId;
        this.totalPageCount = newDocument.data.pageCount;
        this.documentFormat = newDocument.data.format;
        var assetClass = this.assetClass;
        var me = this;
        if (assetClass == "Image") {
            this.enableInfiniteScrolling = false;
            newDocument.data.documentPages = [
                {pageNumber:1, contentUrl:this.documentUrl}
            ];
            this.removeLoadingCls();
            this.fireEvent('isImageDocument');
            this.fireEvent('pagesReceived', this);
        }
        if (this.totalPageCount < 1) {//do real time requests
            me.showRealTimeLoadingMask()
            Ext.Ajax.request({
                url:this.documentPagesUrl,
                timeout:3600000,
                scope:this,
                method:"GET",
                params:{
                    objectId:this.documentId,
                    start:0,
                    limit:this.storePageSize,
                    totalPages:this.totalPageCount,
                    page:1,
                    format:this.documentFormat,
                    isFullyRenderedDoc:this.isFullyRenderedDoc,
                    location:this.networkLocationId
                },
                success:this.realTimeRenderingResponse,
                failure:function () {
                    me.hideRealTimeLoadingMask();
                    me.removeLoadingCls();
                    RM.Logger.error("Realtime", "request", "Real-time request failed");
                    this.fireEvent("fatalError", "pageLoading");
                }
            });
        }
        //The page would have already loaded with the first set and
        //no need for loading notification after it
        else if (this.totalPageCount <= 5) {
            this.removeLoadingCls();
        }

        if (this.enableInfiniteScrolling) {
            RM.Logger.debug("PageView", "applyDocument", "Using infinite scrolling to load document pages");
            this.documentStore.proxy.extraParams.objectId = this.documentId;
            this.documentStore.proxy.extraParams.format = this.documentFormat;
            this.pageDataView.documentId = this.documentId;
            if (this.totalPageCount > 0) { //Real time rendering is required here.
                this.documentStore.proxy.extraParams.totalPages = this.totalPageCount;
                this.loadDocumentPages();
            }
        }
        else if (newDocument.data.documentPages.length > 0 && !this.enableInfiniteScrolling) {
            RM.Logger.debug("PageView", "applyDocument", "Using memory proxy to load document pages");
            this.documentStore.buffered = false;
            this.documentStore.setProxy("memory");
            this.documentStore.loadData(newDocument.data.documentPages);
        }

        this.delayedRefreshCache.delay(150);
        return newDocument;
    },

    realTimeRenderingResponse:function (response) {
        var realTimeResponse = Ext.decode(response.responseText);
        this.totalPageCount = realTimeResponse.pageCount;
        //The page would have already loaded with the first set and
        //no need for loading notification after it
        if (this.totalPageCount > 0 && this.totalPageCount <= 5) {
            this.removeLoadingCls();
        }
        this.documentStore.proxy.extraParams.totalPages = this.totalPageCount;
        this.documentStore.loadData(realTimeResponse.documentPages);
        this.documentStore.totalCount = this.totalPageCount;
        this.documentStore.fireEvent('totalcountchange', this.totalPageCount);
        this.fireEvent('totalPageCountUpdated', this.totalPageCount);
        var storeRecords = this.documentStore.data.items;
        this.documentStore.cachePage(storeRecords, 1);
        this.hideRealTimeLoadingMask();
        this.fireEvent('pagesReceived', this);
    },

    applyCurrentPage:function (pageToSet) {
        RM.Logger.debug("PageView", "applyCurrentPage", "");
        this.fireEvent('currentPageChanged', this, parseInt(pageToSet));
        if (this.currentFitState == RM.view.PageView.FIT_TO_HEIGHT) {
            //the zoom level varies depending on natural page dimensions in fit-to-height mode for a doc with uneven page heights
            //so updating the zoom state of the page to the control bar slider
            this.setCurrentZoomLevel(this);
        }
        //console.log('applyCurrentPage : repositioning markers');
        this.repositionComments(this);
        this.repositionSearchHits(this);
        return pageToSet;
    },

    loadDocumentPages:function () {

        if (this.documentId != null && this.totalPageCount != null &&
            this.totalPageCount > (this.storePageSize - 1)) {
            RM.Logger.debug("PageView", "loadDocumentPages", "Setting guaranteed Range " + 0 + " to " + (this.storePageSize - 1));
            var viewId = RM.view.PageView.PAGE_DIV_STYLE_ID + this.id;
            var containerStyleNames = "#" + this.id + " " + RM.view.PageView.PAGE_CONTAINER_STYLES;
            this.maxImageHeight = this.containerHeight(true);
            var containerWidth = this.containerWidth(true);

            this.pageDataView.verticalScroller.rowHeight = this.maxImageHeight;
            var vScrollbar = this.pageDataView.verticalScroller;
            vScrollbar.handleViewScroll = this.handleViewScroll;
            vScrollbar.viewSize = 0;
            vScrollbar.onViewResize(vScrollbar.view, vScrollbar.view.getWidth(), vScrollbar.view.getHeight()); //DM 4.1 RC1
            this.createNewStyleSheet('', containerStyleNames, null, viewId, containerWidth);

            this.documentStore.guaranteeRange(0, (this.storePageSize - 1));
        }
        else {
            RM.Logger.debug("PageView", "loadDocumentPages", "Setting guaranteed Range " + 0 + " to " + (this.totalPageCount - 1));
            this.documentStore.guaranteeRange(0, this.totalPageCount - 1);
        }
    },

    handleViewScroll:function (direction) {
        var me = this,
            store = me.store,
            view = me.view,
            viewSize = me.viewSize,
            totalCount = store.getTotalCount(),
            visibleStart = me.getFirstVisibleRowIndex(),
            visibleEnd = me.getLastVisibleRowIndex(),
            requestStart,
            requestEnd;

        // Only process if the total rows is larger than the visible page size
        if (totalCount >= viewSize) {

            var storePageSize = store.pageSize;
            visibleStart++; //actual row count rather than index
            var firstVisiblePageSet = Math.ceil(visibleStart / storePageSize);
            requestStart = ( firstVisiblePageSet - 1 ) * storePageSize;
            //check if last visible is in current page set
            var lastVisiblePageSet = Math.ceil(visibleEnd / storePageSize);
            var pageSetDiff = lastVisiblePageSet - firstVisiblePageSet;
            requestEnd = requestStart + (storePageSize * (pageSetDiff + 1) ) - 1;
            if (requestEnd > totalCount) {
                requestEnd = totalCount;
            }
            if (requestStart !== undefined) {

                // If range is satsfied within the prefetch buffer, then just draw it from the prefetch buffer
                if (store.rangeCached(requestStart, requestEnd)) {
                    me.cancelLoad();
                    var isFirstRowLoaded = false;
                    var isLastRowLoaded = false;
                    var dataPageNumber = -1;
                    Ext.Array.some(store.data.items, function (pageInfo) {
                        dataPageNumber = pageInfo.data.pageNumber;
                        if (!isFirstRowLoaded) {
                            if (dataPageNumber == requestStart + 1) {
                                isFirstRowLoaded = true;
                            }
                        }
                        if (!isLastRowLoaded) {
                            if (dataPageNumber == requestEnd + 1) {
                                isLastRowLoaded = true;
                            }
                        }
                        return isFirstRowLoaded && isLastRowLoaded;
                    });

                    if (!(isFirstRowLoaded && isLastRowLoaded)) {
                        store.guaranteeRange(requestStart, requestEnd);
                    }
                }

                // Required range is not in the prefetch buffer. Ask the store to prefetch it.
                // We will recieve a guaranteedrange event when that is done.
                else {
                    me.attemptLoad(requestStart, requestEnd);
                }
            }
        }
    },

    applyDocumentPagesUrl:function (url) {
        RM.Logger.debug("PageView", "applyDocumentPagesUrl", url);
        this.documentPagesUrl = url;
        this.documentStore.proxy.url = url;
        this.loadDocumentPages();
    },

    applyCommentsUrl:function (url) {
        RM.Logger.debug("PageView", "applyCommentsUrl", url);
        this.saveCommentsUrl = url;
    },

    getPageImagePadding:function () {
        if (!this.pageDivPadding) {
            var cssRule = Ext.util.CSS.getRule(RM.view.PageView.PAGE_IMG_DIV_STYLE, true);
            var pageDivPadding;
            if (cssRule && !Ext.isIE) {
                pageDivPadding = cssRule.style.getPropertyValue('padding');
            }
            else {
                pageDivPadding = "5"; //TODO IE reading fails - need to fix this
            }
            pageDivPadding = parseInt(pageDivPadding) * 2;
            if (isNaN(pageDivPadding)) {
                pageDivPadding = 0;
            }
            RM.Logger.debug("PageView", "getPageImagePadding", pageDivPadding);
            this.pageDivPadding = pageDivPadding;
        }
        return this.pageDivPadding;
    },

    containerHeight:function (ignorePadding) {
        var thumbnailPadding;
        thumbnailPadding = ignorePadding ? 0 : this.getPageImagePadding();
        var containerHeight;
        if (this.pageDataView.view.rendered)
            containerHeight = this.pageDataView.getHeight() - thumbnailPadding;//this.pageDataView.view.getHeight();//this.container.getHeight();
        else
            containerHeight = this.container.getHeight();
        RM.Logger.debug("PageView", "containerHeight", containerHeight);
        return containerHeight;
    },

    containerWidth:function (ignorePadding) {
        var vScrollBar = this.pageDataView.verticalScroller;
        var scrollBarWidth = 0, imagePadding = 0;
        if (vScrollBar != null) { //DM not the best?
            scrollBarWidth = Ext.getScrollbarSize().width;
        }
        imagePadding = ignorePadding ? 0 : this.getPageImagePadding();
        var containerWidth;
        if (this.pageDataView.view.rendered)
            containerWidth = this.pageDataView.getWidth() - imagePadding - scrollBarWidth;//this.pageDataView.view.getHeight();//this.container.getHeight();
        else
            containerWidth = this.container.getWidth() - scrollBarWidth;
        RM.Logger.debug("PageView", "containerWidth", containerWidth);
        return containerWidth;
    },

    repositionComments:function (me) {
        this.delayedCommentPositioning.delay(150);
    },

    repositionSearchHits:function (me) {
        this.delayedSearchHitsPositioning.delay(150);
    },


    fitToWidth:function (ignoreAlignment) {
        RM.Logger.debug("PageView", "fitToWidth", "Start", {indent:1});
        this.clearPageImageStyles();
        this.updateCSSToFitWidth(this.containerWidth());
        RM.Logger.debug("PageView", "fitToWidth", "going to call resizeImgDivsBasedOnMaxLoaded");
        this.resizeImgDivsBasedOnMaxLoaded();
        this.currentFitState = RM.view.PageView.FIT_TO_WIDTH;
        this.correctRotatedImages();
        this.invalidateCustomScroller();
        this.repositionComments(this);
        this.repositionSearchHits(this);
        //Option to align to top when user is scrolling
        //Making navigation while scrolling can result
        // in negation of user scroll
        if (!ignoreAlignment) {
            this.navigateToPage(this.currentPage);
        }
        this.setCurrentZoomLevel(this);
        this.disablePanningMode();
        RM.Logger.debug("PageView", "fitToWidth", "End", {outdent:1});

    },

    fitToHeight:function (isFirstRender, ignoreAlignment) {
        RM.Logger.debug("PageView", "fitToHeight", "Start", {indent:1});
        if (!isFirstRender) {
            this.clearPageImageStyles();
        }
        this.resizeDivsToContainerHeight();
        this.maxImageHeight = this.containerHeight();
        this.updateCSSToFitHeight(this.maxImageHeight);
        this.currentFitState = RM.view.PageView.FIT_TO_HEIGHT;
        this.correctRotatedImages();
        this.invalidateCustomScroller();
        this.repositionComments(this);
        this.repositionSearchHits(this);
        //Option to align to top when user is scrolling
        //Making navigation while scrolling can result
        // in negation of user scroll
        if (!ignoreAlignment) {
            this.navigateToPage(this.currentPage);
        }
        this.setCurrentZoomLevel(this);
        this.disablePanningMode();
        RM.Logger.debug("PageView", "fitToHeight", "End", {outdent:1});
    },

    updateCSSToFitHeight:function (maxHeight) {
        var styleSelector, pageNumber, newWidth = "", newHeight;
        var imageElements = this.el.query(RM.view.PageView.IMG_LOCATOR);
        var pageViewComponent = this;
        //find height of each image
        Ext.Array.each(imageElements, function (imageElement, idx) {
            newHeight = maxHeight;
            newWidth = "";
            pageNumber = parseInt(imageElement.getAttribute(RM.view.PageView.PAGE_NUMBER));
            styleSelector = '#' + pageViewComponent.getUniquePageDivID(pageNumber) + ' img';
            if (pageViewComponent.rotated90List && Ext.Array.contains(pageViewComponent.rotated90List, pageNumber)) {
                newWidth = newHeight + "px";
                newHeight = "";
            }
            //Ext.util.CSS.updateRule(styleSelector, RM.view.PageView.WIDTH, newWidth);
            pageViewComponent.updateStyleForImage(imageElement, RM.view.PageView.WIDTH, newWidth);
            if (newHeight) {
                //Ext.util.CSS.updateRule(styleSelector, RM.view.PageView.HEIGHT, newHeight + "px");
                pageViewComponent.updateStyleForImage(imageElement, RM.view.PageView.HEIGHT, newHeight + "px");
            }
        });

    },

    updateCSSToFitWidth:function (maxWidth) {
        var styleSelector, pageNumber, newWidth = "", newHeight;
        var imageElements = this.el.query(RM.view.PageView.IMG_LOCATOR);
        var pageViewComponent = this;
        //find height of each image
        Ext.Array.each(imageElements, function (imageElement, idx) {
            newWidth = maxWidth;
            newHeight = "";
            pageNumber = parseInt(imageElement.getAttribute(RM.view.PageView.PAGE_NUMBER));
            styleSelector = '#' + pageViewComponent.getUniquePageDivID(pageNumber) + ' img';
            if (pageViewComponent.rotated90List && Ext.Array.contains(pageViewComponent.rotated90List, pageNumber)) {
                newHeight = newWidth + "px";
                newWidth = "";
            }
            if (newWidth) {
                //Ext.util.CSS.updateRule(styleSelector, RM.view.PageView.WIDTH, newWidth + "px");
                pageViewComponent.updateStyleForImage(imageElement, RM.view.PageView.WIDTH, newWidth + "px");
            }
            //Ext.util.CSS.updateRule(styleSelector, RM.view.PageView.HEIGHT, newHeight );
            pageViewComponent.updateStyleForImage(imageElement, RM.view.PageView.HEIGHT, newHeight);
        });

    },

    maintainUserFitSelection:function () {
        RM.Logger.debug("PageView", "maintainUserFitSelection", "Start", {indent:1});
        if (this.currentFitState == null) {
            return;
        }

        if (this.currentFitState == RM.view.PageView.FIT_TO_HEIGHT) {
            this.fitToHeight();
        }
        else if (this.currentFitState == RM.view.PageView.FIT_TO_WIDTH) {
            this.fitToWidth();
        }
        RM.Logger.debug("PageView", "maintainUserFitSelection", "End", {outdent:1});

    },

    showPage:function (pageNo, highlightXDelta, highlightYDelta) {  //TODO: refactor highlights out of this call
        var scroller = this.pageDataView.verticalScroller;
        RM.Logger.debug("PageView", "showPage", "Going to show page:" + pageNo + " - Start", {indent:1});
        if (scroller.view.rendered && !isNaN(pageNo) && pageNo >= 1 && pageNo <= this.totalPageCount) {
            this.navigationPageRequest = pageNo;
            this.refreshViewScrollbar(scroller.view, scroller);
            var scrollerDom = scroller.view.el.dom;
            RM.Logger.debug("PageView", "showPage", "scrollerDom.scrollHeight : " + scrollerDom.scrollHeight);
            var pageHeight = scrollerDom.scrollHeight / this.totalPageCount;
            var requiredScrollHeight = pageHeight * (pageNo - 1);
            var scrollDelta = requiredScrollHeight - scrollerDom.scrollTop;
            if (this.isScrollerAtBottomEnd(scrollerDom) && (scrollDelta > 0)) {
                this.setCurrentPage(pageNo);
            }
            else if (highlightYDelta && highlightYDelta > 0) {
                //if the page is not able to fit in the container
                // and the highlight is located at the lower  portion of the page
                // then find the highlight frame and navigate to it.
                var relativeYDelta = highlightYDelta / this.containerHeight(false);
                var relativeXDelta = highlightXDelta / this.containerWidth(false);
                var highlightYFrame = Math.floor(relativeYDelta);
                var highlightXFrame = Math.floor(relativeXDelta);


                var ybuffer = 0, xbuffer = 0;
                //Check if the highlight is near to corner of the container
                //if so add a buffer to it.
                if (highlightYFrame > 0 && relativeYDelta - Math.floor(relativeYDelta) > .7) {
                    ybuffer = 100;
                    RM.Logger.debug("PageView", "showPage", "Added extra 100 ybuffer");
                }
                if (highlightXFrame > 0 && relativeXDelta - Math.floor(relativeXDelta) > .7) {
                    xbuffer = 100;
                    RM.Logger.debug("PageView", "showPage", "Added extra 100 xbuffer");
                }

                var deltaY = scrollDelta + highlightYFrame * this.containerHeight(false) + ybuffer;
                scroller.view.scrollBy(0, deltaY);

                var highlightX = highlightXDelta % this.containerWidth(false)
                var view = this.pageDataView.getView();
                var deltaX = highlightXFrame * this.containerWidth(false) + xbuffer;
                view.el.dom.scrollLeft = deltaX;


                RM.Logger.debug("PageView", "showPage", "highlightYFrame: " + highlightYFrame);
                RM.Logger.debug("PageView", "showPage", "highlightXFrame: " + highlightXFrame);
                RM.Logger.debug("PageView", "showPage", "Moving X-scroll-bar by: " + deltaX);
                RM.Logger.debug("PageView", "showPage", "Moving Y-scroll-bar by: " + deltaY);
            }
            else {
                RM.Logger.debug("PageView", "showPage", "Scroll delta to show page :" + scrollDelta);
                scroller.view.scrollBy(0, scrollDelta);
            }
        }
        RM.Logger.debug("PageView", "showPage", "Showing page:" + pageNo + " - End", {outdent:1});
    },

    navigateToPage:function (pageNo) {
        RM.Logger.debug("PageView", "navigateToPage", "Navigate to page: " + pageNo);
        this.pageChangeReason = RM.view.PageView.NAVIGATION;
        this.showPage(pageNo);
    },

    alignView:function (pageNo, oldRowHeight, oldScrollTop, scroller) {
        RM.Logger.debug("PageView", "alignView", "Start aligning view to page no:" + pageNo, {indent:1});
        this.pageChangeReason = RM.view.PageView.ALIGN_VIEW;
        if (oldRowHeight == null || oldScrollTop == null || oldRowHeight == 0) {
            RM.Logger.warn("PageView", "alignView", "Using show page as enough info not available for calculation");
            this.showPage(pageNo);
        }
        else {
            var currentRowHeight = parseInt(this.currentDivHeight.replace("px", ""));
            var newScrollTop = (currentRowHeight * oldScrollTop) / oldRowHeight;
            var delta = newScrollTop - oldScrollTop;
            if (delta != 0) {
                scroller.view.scrollBy(0, delta);
                RM.Logger.debug("PageView", "alignView", "Scroll delta to show the same position before aligning: " + delta);
            }
            else {
                //Hack to make sure the viewer is showing the correct page
                //Scrolling by 1 will make sure the scroll event is raised and the
                //all the logic in scroll handler is executed
                scroller.view.scrollBy(0, 1);
                RM.Logger.debug("PageView", "alignView", "Making sure the page is aligned to:" + pageNo);
            }

        }
        RM.Logger.debug("PageView", "alignView", "Aligned to page no:" + pageNo, {outdent:1});
    },

    showSelectedSearchHighlight:function (pageNo, highlightXdelta, highlightYdelta) {
        this.pageChangeReason = RM.view.PageView.NAVIGATION;
        this.showPage(pageNo, highlightXdelta, highlightYdelta);
    },

    isScrollerAtBottomEnd:function (scrollerDom) { ///Check if it scroller is at the bottom end
        var isAtBottomEnd = scrollerDom.scrollHeight == (scrollerDom.clientHeight + scrollerDom.scrollTop);
        RM.Logger.debug("PageView", "isScrollerAtBottomEnd", isAtBottomEnd);
        return isAtBottomEnd;
    },

    navigateToNextVisibleFrame:function () {
        var scroller = this.pageDataView.verticalScroller;
        if (scroller.view.rendered) {
            scroller.view.scrollBy(0, this.containerHeight(true));
        }
        this.invalidateCustomScroller();
    },

    navigateToPrevVisibleFrame:function () {
        var scroller = this.pageDataView.verticalScroller;
        if (scroller.view.rendered) {
            scroller.view.scrollBy(0, -this.containerHeight(true));
        }
        this.invalidateCustomScroller();
    },

    navigateToNextPage:function () {
        this.navigateToPage(this.getCurrentPage() + 1);
    },

    navigateToPreviousPage:function () {
        this.navigateToPage(this.getCurrentPage() - 1);
    },

    enableCommentMode:function () {
        RM.Logger.debug("PageView", "enableCommentMode", "");
        this.isWaitingForCommentLocation = true;
        Ext.util.CSS.updateRule(RM.view.PageView.PAGE_IMG_STYLE, "cursor", "crosshair");
    },

    showDefaultCursor:function () {
        RM.Logger.debug("PageView", "showDefaultCursor", "Start", {indent:1});
        RM.Logger.debug("PageView", "showDefaultCursor", "Setting cursor to default");
        var cssRule = Ext.util.CSS.getRule(RM.view.PageView.PAGE_IMG_STYLE);
        if (cssRule && !Ext.isIE) {
            cssRule.style.removeProperty('cursor');
        }
        else {
            Ext.util.CSS.updateRule(RM.view.PageView.PAGE_IMG_STYLE, "cursor", "");
        }
        if (this.currentFitState == RM.view.PageView.ZOOMED_STATE && !this.isWaitingForCommentLocation) {
            this.showPanningMode();
        }
        RM.Logger.debug("PageView", "showDefaultCursor", "End", {outdent:1});

    },

    disableCommentMode:function () {
        RM.Logger.debug("PageView", "disableCommentMode", "");
        this.isWaitingForCommentLocation = false;
        this.showDefaultCursor();
    },

    showWaitMode:function () {
        RM.Logger.debug("PageView", "showWaitMode", "");
        Ext.util.CSS.updateRule(RM.view.PageView.PAGE_IMG_STYLE, "cursor", "wait");
    },

    grabCursorStyle:function () {
        var grabbingCursorCls = "grabbing-cursor";
        var grabCursorCls = "grab-cursor";
        if (Ext.isIE) {
            grabbingCursorCls += "-ie";
            grabCursorCls += "-ie";
        }
        return {grab:grabCursorCls, grabbing:grabbingCursorCls}
    },

    showPanningMode:function () {
        RM.Logger.debug("PageView", "showPanningMode", "Setting to grab cursor for page");
        var viewEL = this.pageDataView.getView();
        var cursor = this.grabCursorStyle();
        if (viewEL && viewEL.hasCls(cursor.grabbing)) {
            viewEL.removeCls(cursor.grabbing);
            Ext.util.CSS.refreshCache();

        }
        if (viewEL && !viewEL.hasCls(cursor.grab)) {
            viewEL.addCls(cursor.grab);
            Ext.util.CSS.refreshCache();
        }
    },

    disablePanningMode:function () {
        RM.Logger.debug("PageView", "disablePanningMode", "Removing grab cursors");
        var viewEL = this.pageDataView.getView();
        var cursor = this.grabCursorStyle();

        if (viewEL && viewEL.hasCls(cursor.grabbing)) {
            viewEL.removeCls(cursor.grabbing);
            Ext.util.CSS.refreshCache();
        }
        if (viewEL && viewEL.hasCls(cursor.grab)) {
            viewEL.removeCls(cursor.grab);
            Ext.util.CSS.refreshCache();
        }
    },

    configureScrollerType:function () {
        if (this.enableInfiniteScrolling && this.assetClass != "Image") {
            var snapIncrement = 10;
            var scrollToLoadBuffer = 1000;
            if (!this.isFullyRenderedDoc) {
                scrollToLoadBuffer = 2000;
            }
            this.verticalScrollConfig = {
                xtype:'paginggridscroller',
                activePrefetch:false, // preload new set just before you reach the end
                scrollToLoadBuffer:scrollToLoadBuffer,
                leadingBufferZone:0,
                trailingBufferZone:0,
                loadMask:false,
                snapIncrement:snapIncrement
            };
        }
        else {
            RM.Logger.debug("PageView", "configureScrollerType", "Using gridscroller");
            this.verticalScrollConfig = {
                xtype:'gridscroller'
            };
        }
    },

    setZoomLevelOnImages:function (zoomLevel) {
        RM.Logger.debug("PageView", "setZoomLevelOnImages", "Start", {indent:1});
        var imageElements = this.el.query(RM.view.PageView.IMG_LOCATOR);
        var pageViewComponent = this;
        //find height of each image
        Ext.Array.each(imageElements, function (imageElement, idx) {
            pageViewComponent.updateZoomLevelOnImage(zoomLevel, imageElement);
        });
        //get max height and width
        this.resizeImgDivsBasedOnMaxLoaded();
        RM.Logger.debug("PageView", "setZoomLevelOnImages", "End", {outdent:1});
    },

    updateZoomLevelOnImage:function (zoomLevel, imageElement) {
        var zoomedSize, styleSelector, pageNumber, imageNewHeight;
        zoomedSize = this.getZoomSize(zoomLevel, this.getNatural(imageElement));
        pageNumber = parseInt(imageElement.getAttribute(RM.view.PageView.PAGE_NUMBER));
        styleSelector = '#' + this.getUniquePageDivID(pageNumber) + ' img';
        //Ext.util.CSS.updateRule(styleSelector, RM.view.PageView.HEIGHT, zoomedSize.height + "px");
        this.updateStyleForImage(imageElement, RM.view.PageView.HEIGHT, zoomedSize.height + "px");
        //Ext.util.CSS.updateRule(styleSelector, RM.view.PageView.WIDTH, zoomedSize.width + "px");
        this.updateStyleForImage(imageElement, RM.view.PageView.WIDTH, zoomedSize.width + "px");
    },

    getNatural:function (domElement) {
        var naturalWidth, naturalHeight;
        if (domElement.naturalHeight) {
            naturalHeight = domElement.naturalHeight;
            naturalWidth = domElement.naturalWidth;
            natural = {width:domElement.naturalWidth, height:domElement.naturalHeight};
        }
        else {
            var img = new Image();
            img.src = domElement.src;
            natural = {width:img.width, height:img.height};
        }
        RM.Logger.debug("PageView", "getNatural", "Natural width:" + natural.width + "Natural height:" + natural.height);
        return natural;
    },

    zoomLevelChanged:function (zoomLevel, viewAdjust) {
        if (!viewAdjust) {
            RM.Logger.debug("PageView", "zoomLevelChanged", "Start", {indent:1});
            var oldDivHeight = this.currentDivHeight;
            oldDivHeight = parseInt(oldDivHeight.replace("px", ""));
            var scroller = this.pageDataView.verticalScroller;
            var oldScrollTop;
            if (scroller != null && scroller.view != null && scroller.view.el != null) {
                oldScrollTop = scroller.view.el.dom.scrollTop;
            }
            this.setZoomLevelOnImages(zoomLevel);
            this.makeImageContainersUniform(false);
            this.correctRotatedImages();
            this.invalidateCustomScroller();
            this.repositionComments(this);
            this.repositionSearchHits(this);

            //If it is just a view adjust because of fit to width
            // or fit to height, don't mark it as zoomed state
            if (!viewAdjust) {
                this.currentFitState = RM.view.PageView.ZOOMED_STATE;
                this.showPanningMode();
                this.alignView(this.currentPage, oldDivHeight, oldScrollTop, scroller);
            }
            RM.Logger.debug("PageView", "zoomLevelChanged", "End", {outdent:1});
            this.currentZoomLevel = zoomLevel;
        }
    },
    getZoomSize:function (zoomLevel, naturalDimensions) {
        var zoomedHeight = naturalDimensions.height * zoomLevel / 100;
        var zoomedWidth = naturalDimensions.width * zoomLevel / 100;
        var size = {height:zoomedHeight, width:zoomedWidth};
        RM.Logger.debug("PageView", "getZoomSize", "Zoomed height:" + size.height + " width:" + size.width);
        return size;
    },

    resizeImagesAfterLoad:function () {
        this.resizeImgDivsBasedOnMaxLoaded();
        this.repositionComments(this);
        this.repositionSearchHits(this);
    },

    resizeImgDivsBasedOnMaxLoaded:function () {
        RM.Logger.debug("PageView", "resizeImgDivsBasedOnMaxLoaded", "Start", {indent:1});
        //get the divs loaded using the class rmPageContainer
        //var elems = this.el.select("div.rmPageContainer").elements;
        var imageElements = this.el.query(RM.view.PageView.IMG_LOCATOR);
        var containerPadding = this.getPageImagePadding();
        this.maxImageHeight = 0;
        this.maxImageWidth = 0;
        var currentImgHeight, currentImgWidth, imageExtElement;
        var pageViewComponent = this;
        var imageDisplayedHeight, pageNumber;
        //find height of each image
        Ext.Array.each(imageElements, function (imageElement, idx) {
            //get max height and width
            currentImgHeight = imageElement.height;
            currentImgWidth = imageElement.width;
            pageNumber = parseInt(imageElement.getAttribute(RM.view.PageView.PAGE_NUMBER));
            if (pageViewComponent.rotated90List != null && Ext.Array.contains(pageViewComponent.rotated90List, pageNumber)) {
                imageDisplayedHeight = currentImgHeight;
                currentImgHeight = currentImgWidth;
                currentImgWidth = imageDisplayedHeight;
            }

            if (pageViewComponent.maxImageHeight < currentImgHeight) {
                pageViewComponent.maxImageHeight = currentImgHeight;
            }
            if (pageViewComponent.maxImageWidth < currentImgWidth) {
                pageViewComponent.maxImageWidth = currentImgWidth;
                RM.Logger.debug("PageView", "resizeImgDivsBasedOnMaxLoaded", "New maxImageWidth : " + pageViewComponent.maxImageWidth);
            }
        });
        pageViewComponent.maxImageHeight += containerPadding;
        pageViewComponent.maxImageWidth += containerPadding;
        this.makeImageContainersUniform(false);
        RM.Logger.debug("PageView", "resizeImgDivsBasedOnMaxLoaded", "End", {outdent:1});
    },

    resizeDivsToContainerHeight:function () {
        this.maxImageHeight = this.containerHeight(true);
        this.makeImageContainersUniform(true);
    },

    updateStyleForImgContainers:function (containerStyleNames, ignoreWidth, id) {
        var existing = document.getElementById(id);
        var stylesUpdated = false;
        var styles = '';
        var containerWidth = this.containerWidth(true);
        //if the max image width is lesser than container width than always set a width
        if (this.maxImageWidth <= containerWidth) {
            ignoreWidth = false;
        }
        var newWidth = ignoreWidth ? "" : ( this.maxImageWidth < containerWidth ? containerWidth + "px" : this.maxImageWidth + "px");

        if (!existing) {
            this.createNewStyleSheet(styles, containerStyleNames, newWidth, id, containerWidth);
            this.currentDivHeight = this.maxImageHeight + 'px';
        }
        else {
            var newHeight = this.maxImageHeight + "px";
            if (this.currentDivHeight != newHeight) {
                Ext.util.CSS.updateRule(containerStyleNames, RM.view.PageView.HEIGHT, newHeight);
                this.currentDivHeight = newHeight;
                stylesUpdated = true;
            }

            if (this.currentDivWidth != newWidth) {
                Ext.util.CSS.updateRule(containerStyleNames, RM.view.PageView.WIDTH, newWidth);
                this.currentDivWidth = newWidth;
                stylesUpdated = true;
            }

            if (stylesUpdated) {
                //Ext.util.CSS.refreshCache();
                this.delayedRefreshCache.delay(150);
            }
        }
    },

    createNewStyleSheet:function (styles, containerStyleNames, containerWidth, id, minWidth) {
        RM.Logger.debug("PageView", "updateStyleForImgContainers", "maxHeight : " + this.maxImageHeight + " & maxWidth : " + this.maxImageWidth);
        styles += containerStyleNames + '{' +
            'height: ' + this.maxImageHeight + 'px;';
        styles += 'min-width: ' + minWidth + 'px';
        if (this.maxImageWidth) {
            styles += 'width: ' + this.maxImageWidth + 'px;';
        }
        styles += '}';

        //creating a rule for each image
        var containerId, pageCount = this.totalPageCount;

        if (!Ext.isIE) {
            for (var n = 1; n <= pageCount; n++) {
                containerId = this.getUniquePageDivID(n);
                styles += '#' + containerId + ' img' + '{' +
                    '}';
            }
            ;
        }

        Ext.util.CSS.createStyleSheet(styles, id);
    },

    clearPageImageStyles:function () {
        var containerId, pageNumber, style, pageCount = this.getDocument().data.pageCount;
        var hashTag = '#', imageTag = ' img', empty = '';
        var imageElements = this.el.query(RM.view.PageView.IMG_LOCATOR);
        var pageViewComponent = this;
        //find height of each image
        Ext.Array.each(imageElements, function (imageElement, idx) {
            pageNumber = parseInt(imageElement.getAttribute(RM.view.PageView.PAGE_NUMBER));
            containerId = pageViewComponent.getUniquePageDivID(pageNumber);
            style = hashTag + containerId + imageTag;
            //Ext.util.CSS.updateRule(style, RM.view.PageView.WIDTH, empty);
            pageViewComponent.updateStyleForImage(imageElement, RM.view.PageView.WIDTH, empty);
            //Ext.util.CSS.updateRule(style, RM.view.PageView.HEIGHT, empty);
            pageViewComponent.updateStyleForImage(imageElement, RM.view.PageView.HEIGHT, empty);
        });
    },

    makeImageContainersUniform:function (ignoreWidth) {
        //var containersLoaded = this.el.query(RM.view.PageView.PAGE_CONTAINER_STYLES);
        if (this.el == null || this.el.query(RM.view.PageView.PAGE_CONTAINER_STYLES) == null
            || this.el.query(RM.view.PageView.PAGE_CONTAINER_STYLES).length == 0) {
            //too early for this call
            return;
        }
        //create a class with the height and width
        var id = RM.view.PageView.PAGE_DIV_STYLE_ID + this.id;
        var containerStyleNames = "#" + this.id + " " + RM.view.PageView.PAGE_CONTAINER_STYLES;
        this.updateStyleForImgContainers(containerStyleNames, ignoreWidth, id);
    },

    getImageStyleSelector:function (pageNumber) {
        var containerId = this.getUniquePageDivID(pageNumber);
        var styleSelector = '#' + containerId + ' img';
        return styleSelector;
    },

    rotatePage:function (angle) {
        var pageNumber = this.currentPage;
        var targetDiv = Ext.get(this.getUniquePageDivID(pageNumber));
        if (targetDiv == undefined) {
            return;
        }
        var currentImage = targetDiv.down("img").dom;

        var earlierRotateAngle = this.getEarlierRotateAngle(pageNumber);
        angle += earlierRotateAngle;
        angle = angle < 0 ? 360 + angle : angle;
        angle = angle >= 360 ? angle - 360 : angle;
        var ieAngle = RM.controller.ViewerController.getIERotationAngle(angle);
        RM.Logger.debug("PageView", "rotatePage", "Angle : " + angle);
        var oldDivHeight = this.currentDivHeight;
        oldDivHeight = parseInt(oldDivHeight.replace("px", ""));
        var scroller = this.pageDataView.verticalScroller;
        var oldScrollTop;
        if (scroller.view != null && scroller.view.el != null) {
            oldScrollTop = scroller.view.el.dom.scrollTop;
        }

        this.updateStyleToRotate(currentImage, angle, ieAngle, pageNumber);
        this.keepTrackOfRotated(pageNumber, angle);//as browser gives height as width if image is rotated from landscape to portrait or vice versa
        this.resizeImgDivsBasedOnMaxLoaded();
        this.invalidateCustomScroller();
        this.repositionComments(this);
        this.repositionSearchHits(this);
        this.maintainUserFitSelection();
        //this.alignView(this.currentPage, oldDivHeight, oldScrollTop, scroller);
    },

    getEarlierRotateAngle:function (pageNumber) {
        var result = 0;
        var earlierRotateAngle;
        if (this.rotatedAngles != null) {
            earlierRotateAngle = this.rotatedAngles.get(pageNumber);
            result = earlierRotateAngle == null ? 0 : earlierRotateAngle;
        }
        return result;
    },

    keepTrackOfRotated:function (pageNumber, angle) {
        if (this.rotated90List == null || this.rotatedAngles == null) {
            this.rotated90List = [];
            this.rotatedAngles = new Ext.util.HashMap();
        }
        Ext.Array.remove(this.rotated90List, pageNumber);
        this.rotatedAngles.add(pageNumber, angle);
        if (angle != 0 && angle != 180) {
            this.rotated90List.push(pageNumber);
        }
    },
    getIEBrowserVersionJs:function () {
        var version = 999;
        //To get the correct version of IE 10, we have to rely on 'Trident' property.
        if (navigator.appVersion.indexOf('Trident') != -1)
            version = parseFloat(navigator.appVersion.split('Trident/')[1]);
        return version;
    },
    updateStyleToRotate:function (image, angle, ieAngle, pageNumber) {
        this.updateStyleForImage(image, "-webkit-transform", "rotate(" + angle + "deg)");
        this.updateStyleForImage(image, "MozTransform", "rotate(" + angle + "deg)");
        //Only for IE10, we need to add the below style. Without this check, if the style is applied, IE 9 rotates by 180
        if(Ext.isIE && this.getIEBrowserVersionJs() >= 6)
		    this.updateStyleForImage(image, "-ms-transform", "rotate(" + angle + "deg)");
        this.updateStyleForImage(image, "filter", "progid:DXImageTransform.Microsoft.BasicImage(rotation=" + ieAngle + ")");
        this.correctRotatedImagePosition(angle, pageNumber, image);
    },

    correctRotatedImagePosition:function (angle, pageNumber, currentImage) {

        if (currentImage == null) {
            var targetDiv = Ext.get(this.getUniquePageDivID(pageNumber));
            if (targetDiv == null) {
                return;
            }
            currentImage = targetDiv.down("img").dom;
        }

        if (angle == 90 || angle == 270) {
            this.clearPositioningInfo(currentImage);
            this.updateStyleForImage(currentImage, "position", "relative");
            var toMoveDeltaX, toMoveDeltaY;
            if (this.currentFitState == RM.view.PageView.FIT_TO_HEIGHT || this.currentFitState == RM.view.PageView.ZOOMED_STATE) {
                if (!Ext.isIE) {
                    toMoveDeltaY = -((currentImage.height - currentImage.width) / 2 );
                    if (currentImage.width > currentImage.height) {
                        //toMoveDeltaY -= this.getPageImagePadding();
                    }
                }
                else {
                    toMoveDeltaX = -((currentImage.height - currentImage.width) / 2 );
                    this.updateStyleForImage(currentImage, "left", toMoveDeltaX + "px");
                    toMoveDeltaY = 0;
                }
                //Ext.util.CSS.updateRule(styleSelector, "top", toMoveDeltaY + "px");
                this.updateStyleForImage(currentImage, "top", toMoveDeltaY + "px");
            }
            else if (this.currentFitState == RM.view.PageView.FIT_TO_WIDTH) {
                if (!Ext.isIE) {
                    toMoveDeltaX = -((currentImage.width - currentImage.height) / 2  );
                    toMoveDeltaY = -((currentImage.height - currentImage.width) / 2 );
                    if (currentImage.width > currentImage.height) {
                        //Ext.util.CSS.updateRule(styleSelector, "left", toMoveDeltaX + "px");
                        this.updateStyleForImage(currentImage, "left", toMoveDeltaX + "px");
                    }
                    this.updateStyleForImage(currentImage, "top", toMoveDeltaY + "px");
                }
                else {
                    toMoveDeltaX = ((currentImage.width - currentImage.height) / 2  );
                    if (currentImage.height > currentImage.width) {
                        //Ext.util.CSS.updateRule(styleSelector, "left", toMoveDeltaX + "px");
                        this.updateStyleForImage(currentImage, "left", toMoveDeltaX + "px");
                    }
                    //this.updateStyleForImage(currentImage, "top", toMoveDeltaY + "px");

                }
            }
            else {
                this.clearPositioningInfo(currentImage);
            }
        }
        else {
            this.clearPositioningInfo(currentImage);
        }
        if (Ext.isIE) {
            Ext.util.CSS.refreshCache();
        }
    },

    clearPositioningInfo:function (image) {
        //Ext.util.CSS.updateRule(styleSelector, "position", "");
        this.updateStyleForImage(image, "position", "");
        //Ext.util.CSS.updateRule(styleSelector, "top", "");
        this.updateStyleForImage(image, "top", "");
        //Ext.util.CSS.updateRule(styleSelector, "left", "");
        this.updateStyleForImage(image, "left", "");
    },

    correctRotatedImages:function () {
        var pageView = this, pageRotatedAngle;
        Ext.Array.each(this.rotated90List, function (pageNumber, idx) {
            pageRotatedAngle = pageView.rotatedAngles.get(pageNumber);
            pageView.correctRotatedImagePosition(pageRotatedAngle, pageNumber, null);
        });
    },

    updateStyleForImage:function (image, styleName, value) {
        if (Ext.isIE) {
            image.style[styleName] = value;
        }
        else {
            var pageNumber = parseInt(image.getAttribute(RM.view.PageView.PAGE_NUMBER));
            Ext.util.CSS.updateRule(this.getImageStyleSelector(pageNumber), styleName, value);
        }
        if (image.style["display"] == "none") {
            image.style["display"] = "inline";
        }
    },

    deleteStyleSheetCreated:function () {
        Ext.util.CSS.removeStyleSheet(RM.view.PageView.PAGE_DIV_STYLE_ID + this.id);
    },

    cleanup:function () {
        if (this.realTimeRenderingMask) {
            this.realTimeRenderingMask.hide();
        }
    },

    showRealTimeLoadingMask:function () {
        if (!this.isFullyRenderedDoc && this.realTimeRenderingMask) {
            this.realTimeRenderingMask.show();
            this.removeLoadingCls();
        }
    },

    hideRealTimeLoadingMask:function () {
        if (this.realTimeRenderingMask) {
            this.realTimeRenderingMask.hide();
            //To show background loading in case of non-remote fetches from store
            this.addLoadingCls();
        }
    },

    removeLoadingCls:function () {
        if (this.pageDataView && this.pageDataView.getView() && this.pageDataView.getView().rendered) {
            this.pageDataView.getView().removeCls('rmPageGridView');
        }
    },
    addLoadingCls:function () {
        var view = this.pageDataView.getView();
        if (this.pageDataView && view && view.rendered
            &&!view.getEl().hasCls('rmPageGridView')) {
            view.addCls('rmPageGridView');
        }
    }
});

Ext.define("RM.view.PrintMenu", {
    extend:'Ext.menu.Menu',
    constructor:function(config) {
        var me=this;
        Ext.apply(config, {
            plain:true,
            items:[
                {text:RM.Strings.Viewer.DocumentViewer.printAll,
                    handler:function() {
                        var vwrCtrlBar = me.ownerButton.ownerCt,
                            pageCount = vwrCtrlBar.getDocumentPageCount();
                        if (pageCount > 100) {
                            me.printAlertDialog('all');
                            return;
                        }
                        vwrCtrlBar.fireEvent('printPages', "1-" + pageCount);
                    }
                },
                {text:RM.Strings.Viewer.DocumentViewer.printCurrent,
                    handler:function() {
                        var vwrCtrlBar = me.ownerButton.ownerCt;
                        vwrCtrlBar.fireEvent('printCurrentPage');
                    }
                },
                {text:RM.Strings.Viewer.DocumentViewer.printSpecific,
                    handler:function() {
                        var vwrCtrlBar = me.ownerButton.ownerCt;
                        var viewerCmp;
                        var win = me.printWindow();
                        win.show();
                        if (vwrCtrlBar.ownerCt != null && vwrCtrlBar.ownerCt.widgetId) {
                            viewerCmp = Ext.getCmp(vwrCtrlBar.ownerCt.widgetId);
                            win.alignTo(viewerCmp, "tl-c", [-20, -200]);
                        }
                    }
                }
            ]
        });
        this.callParent([config]);
    },

    initComponent:function () {
        this.callParent(arguments);
        //Register body scroll\mousewheel events so we
        //can auto hide the menu if it is displayed.
        this.addListener('show', function() {
            var evtHandler = function() {
                if(this.isVisible())
                    this.hide();
            };
            this.mon(Ext.getBody(), 'mousewheel', evtHandler, this);
            this.mon(Ext.getBody(), 'scroll', evtHandler, this);
        }, this);

        //Unregister the body scroll\mousewheel events if
        //we have hidden the menu   +
        this.addListener('hide', function() {
            this.mun(Ext.getBody(), 'mousewheel');
            this.mun(Ext.getBody(), 'scroll');
        },this);
    },

        printWindow:function(){
        var me=this,
            vwrCtrlBar = me.ownerButton.ownerCt;

        function validate(pageStr,totalCount){
            var pageNums = RM.controller.PrintController.getPageNums(pageStr);
            for (i = 0; i < pageNums.length; i++) {
                if (pageNums[i] > totalCount)
                    return RM.Strings.Viewer.DocumentViewer.printValidPgNum;
                if (pageNums[i] == pageNums[i + 1]) {
                    return RM.Strings.Viewer.DocumentViewer.printConstraintOverlap;
                }
            }

            if(pageNums.length>100)
               return 'exceeds';

            return 'valid';
        }

        Ext.apply(Ext.form.field.VTypes, {
            whitespace: function(val, field) {
                if (val == "" || (/^\s*$/).test(val))
                    return false;
                else {
                    if(printBtn && printBtn.isDisabled())
                       printBtn.setDisabled(false);
                    return true;
                }
        }});

        if(!win)
        var win = new Ext.Window({
            width:340,
            height:140,
            modal:true,
            resizable:false,
            layout:{
              type:'vbox',
              padding:12
            },
            title:RM.Strings.Viewer.DocumentViewer.printWinTitle,
            items:[
                {xtype:'textfield',id:'printPgTxt',fieldLabel:RM.Strings.Viewer.DocumentViewer.pages,labelWidth:60,width:275,labelSeparator:" :",
                    regex:/^[0-9, -]*$/,
                    regexText:RM.Strings.Viewer.DocumentViewer.printConstraintInvalidChar,
                    msgTarget:'side',
                    allowBlank:false,
                    blankText:RM.Strings.Viewer.DocumentViewer.printConstraintBlank,
                    vtype:'whitespace',
                    vtypeText:RM.Strings.Viewer.DocumentViewer.printConstraintBlank,
                    listeners:
                    {
                        errorChange:function(field, error, eOpts) {
                            if (printBtn)
                                printBtn.setDisabled(error.length > 0);                          //disable ok button when there is a validation error
                        }
                    }
                }
            ],
            buttons:[
                printBtn= new Ext.button.Button({text:RM.Strings.Viewer.DocumentViewer.print,disabled:true,
                    handler:function() {
                    var printPgField = Ext.getCmp('printPgTxt'),
                        pageStr = printPgField.getValue(),
                        totalCount = vwrCtrlBar.getDocumentPageCount(),
                        err;
                    if (pageStr.indexOf('-') == 0)
                        pageStr = "1" + pageStr;
                    if (pageStr.indexOf('-') == pageStr.length - 1)
                        pageStr = pageStr + totalCount;
                    pageStr = this.trimSpaceAround(pageStr, " ");
                    pageStr = this.trimSpaceAround(pageStr, ",");
                    pageStr = this.trimSpaceAround(pageStr, "-");
                    pageStr = pageStr.replace(/ /g, ",");
                    err = validate(pageStr,totalCount);
                    if (err == "exceeds") {
                        win.close();
                        me.printAlertDialog('specific');
                        return;
                    }
                    if (err != 'valid') {
                        printPgField.markInvalid(err);
                        printBtn.setDisabled(true);
                        return;
                    }
                    vwrCtrlBar.fireEvent('printPages',pageStr);
                    win.close()
                },
                trimSpaceAround:function(pageString, character){
                    var result = pageString;
                    var spaceBeforeExp = new RegExp(" " +character,"g");
                    var spaceAfterExp = new RegExp(character+" ","g");
                    while(result.indexOf(" "+character) != -1 || result.indexOf(character+" ") != -1){
                        result = result.replace(spaceBeforeExp, character);
                        result = result.replace(spaceAfterExp, character);
                    }
                    return result;
                }
                }),
                {text:RM.Strings.Viewer.DocumentViewer.close,handler:function() {
                    win.close()
                }}
            ]
        });

        return win;

    },
    printAlertDialog : function(options) {
        var msg;
        if (options.indexOf('all') != -1)
            msg = RM.Strings.Viewer.DocumentViewer.printAllAlertMsg + '<br/><br/><span style="padding-left:15px">1. ' + RM.Strings.Viewer.DocumentViewer.printDownloadInstMsg + '<br/><span style="padding-left:15px">2. ' + RM.Strings.Viewer.DocumentViewer.printDocInsMsg;
        else if (options.indexOf('specific') != -1)
            msg = RM.Strings.Viewer.DocumentViewer.printRangeAlertMsg + '<br/><br/><span style="padding-left:15px">1. ' + RM.Strings.Viewer.DocumentViewer.printDownloadInstMsg + '<br/><span style="padding-left:15px">2. ' + RM.Strings.Viewer.DocumentViewer.printPgInsMsg;
        Ext.Msg.show({
            title:'Print',
            msg: msg,
            width:400,
            buttons: Ext.Msg.OK
        });

    }

});

/**
 * User: michad
 */


Ext.define(
    'rm.view.RichHtmlWindow', {
        extend: 'Ext.Window',
        title: RM.Strings.Viewer.DocumentViewer.addCommentTitle,
        constrain: true,
        renderTo: "",
        modal:true,
        cls:'rmViewerRichHtmlWindow',
        iconCls:'viewer-add-comment',
        alias:'widget.rmViewerRichHtmlWindow',
        height: 250,
        width: 465,
        minWidth: 330,
        layout: 'fit',

        config: {
            newCommentInfo: {},
            saveCommentsUrl: ""
        },

        initComponent: function() {
            var me =this;
            RM.Logger.debug("RichHtmlWindow", "initComponent", "Initalized Rich Html editor");
            this.addEvents('commentAdded', 'commentAddFailed', 'commentAddRequested');
            this.enableBubble('commentAdded', 'commentAddFailed', 'commentAddRequested');

            me.richEditor = Ext.create('widget.ckeditor',{
                CKConfig: RM.richEditorHelper.ckEditorConfig
            });
            me.items =  me.richEditor;

            var okBtn = Ext.create('Ext.button.Button', {
                text    : RM.Strings.Viewer.DocumentViewer.ok,
                cls:'rmRichHtmlOkButton',
                disabled: false,
                scope   : me,
                handler : me.okHandler
            });

            this.okBtn = okBtn;

            me.bbar = Ext.create('Ext.Toolbar', {
                ui: 'footer',
                dock: 'bottom',
                items: [
                    {xtype: 'component', flex: 1},
                    okBtn,
                    {xtype: 'button', cls:'rmRichHtmlCancelButton', text : RM.Strings.Viewer.DocumentViewer.close, scope:me, handler: me.cancelHandler}
                ]
            });
            me.callParent();
        },

        validateInputText: function(editor, html) {
            var newValue = html;
            if(newValue.trim != undefined){
                newValue = newValue.trim();
                RM.Logger.debug("RichHtmlWindow", "validateInputText", "Trim html");
            }
            if(RM.richEditorHelper.isEmptyText(html)){
                this.okBtn.disable();
                RM.Logger.info("RichHtmlWindow", "validateInputText", "Disabled ok button");
            }
            else{
                this.okBtn.enable();
                RM.Logger.log("RichHtmlWindow", "validateInputText", "Enable ok button");
            }
        },

        okHandler: function(btn) {
            RM.Logger.info("RichHtmlWindow", "okHandler", "Editor value: " + this.richEditor.getValue() );
            if(this.richEditor.getValue() != null && RM.richEditorHelper.getEditorValue(this.richEditor) != ""){

                var commentDataObj = {};
                commentDataObj.pageNumber  = this.getNewCommentInfo().pageNumber;
                commentDataObj.pageHeight  = this.getNewCommentInfo().pageHeight;
                commentDataObj.pageWidth  =  this.getNewCommentInfo().pageWidth;
                commentDataObj.commentColor  = "#79BB3F";
                commentDataObj.commentContent = RM.richEditorHelper.getEditorValue(this.richEditor);
                commentDataObj.commentTitle = "";//TODO:Leaving it empty for now.Will use it when required
                commentDataObj.xPos = this.getNewCommentInfo().xPos;
                commentDataObj.yPos = this.getNewCommentInfo().yPos;
                RM.Logger.info("RichHtmlWindow", "okHandler", "Saving comment",{dump:commentDataObj});
                this.fireEvent('commentAddRequested', commentDataObj);
            }
            //Fix to Firefox issue where closing this normally results in all scroll bars in the browser (not just viewer control) snapping to the top
            var me = this;
            var task = new Ext.util.DelayedTask(function(){
                me[me.closeAction]();
            });
            // Wait 500ms before calling our function.
            task.delay(500);
        },

        cancelHandler: function (btn) {
            this[this.closeAction]();
        },

        onCommentAdded: function (comment) {
            this.fireEvent('commentAdded',comment);
        },

    listeners: {
        resize:function() {
            if (this.richEditor != null && this.richEditor.editor != null) {
                this.richEditor.resizeCkEditor(this.richEditor);
                RM.Logger.debug("RichHtmlWindow", "resize", "Re-sized CK editor");
            }
        }
    }

    });
// DocumentViewer.js - an editable text block

/*
 * Copyright (c) 2011 EMC Corporation. All Rights Reserved.
 */

Ext.define('RM.view.DocumentViewer', {
    extend:"Ext.Panel",
    autoScroll:false,
    alias:'widget.rmDocumentViewer',
    border:false,
    cls:'rmDocumentViewer',
    layout:"fit",
    padding:"0",
    config:{
        document:{},
        renderContainer:"document.body",
        widgetId:"",
        currentPage:{},
        locale:'',
        communicationFunction:{},
        documentUrl:"",
        documentPagesUrl:"",
        allCommentsUrl:"",
        userCommentsUrl:"",
        saveCommentsUrl:"",
        deleteCommentUrl:"",
        textualMetaDataUrl:"",
        searchUrl:"",
        isCommentingAllowed:false,
        isServerSideSearch:false,
        userLoginInfo:{},
        enableRemotePagesFetch:true,
        pageChunkSize:50,
        isFullyRenderedDoc:false,
        assetClass:""
    },
    initComponent:function () {
        RM.Logger.debug("DocumentViewer", "initComponent", "Initialization Started", {indent:1});
        this.addEvents('currentDocumentChanged', 'currentPageChanged', 'navigateToPrevPageRequest', 'navigateToNextPageRequest', 'localeChanged');
        //Render only required document

        this.pageView = new RM.view.PageView({
            height:600,
            autoScroll:true,
            storePageSize:this.pageChunkSize,
            isFullyRenderedDoc:this.isFullyRenderedDoc,
            enableInfiniteScrolling:this.enableRemotePagesFetch,
            documentPagesUrl:this.documentPagesUrl,
            saveCommentsUrl:this.saveCommentsUrl,
            documentUrl:this.documentUrl,
            assetClass:this.assetClass
        });

        this.items = this.pageView;
        this.controlbar = new RM.view.ViewerControlBar({
            height:36,
            allowedCommenting:this.isCommentingAllowed,
            isServerSideSearch:this.isServerSideSearch,
            commentingPermission:this.hasCommentingPermission(),
            assetClass:this.assetClass
        });
        this.tbar = this.controlbar;
        Ext.EventManager.onWindowResize(this.resizeToContainer, this);

        this.pageViewController = new RM.controller.ViewerController();
        this.pageViewController.initialize(this, this.pageView, this.controlbar);
        this.commentController = new RM.controller.CommentController();
        this.commentController.initialize(this, this.pageView, this.controlbar);
        this.searchController = new RM.controller.SearchController();
        this.searchController.initialize(this, this.pageView, this.controlbar);
        this.printController = new RM.controller.PrintController();
        this.printController.initialize(this, this.pageView, this.controlbar);
        this.callParent(arguments);
        RM.Logger.debug("DocumentViewer", "initComponent", "Initialization Complete", {outdent:1});
    },

    listeners:{
        afterrender:function () {
            this.resizeToContainer();
            this.fireEvent('viewerRendered', this);
            RM.Logger.debug("DocumentViewer", "afterrender", "View Rendered");
        }
    },

    applyDocument:function (documentSet) {
        var newDocumentSet = Ext.ModelMgr.create(documentSet, 'RM.model.Document');
        this.fireEvent('resetToNewDocument', this, newDocumentSet);
        RM.Logger.log("DocumentViewer", "applyDocument", " New document is set", {dump:newDocumentSet});
        this.pageView.setDocument(newDocumentSet);
        this.fireEvent('currentDocumentChanged', this, newDocumentSet);
        return documentSet;
    },

    applyRenderContainer:function (elementName) {
        this.renderContainerName = elementName;
        this.render(elementName);
        RM.Logger.log("DocumentViewer", "applyRenderContainer", "Rendereing to the container: " + elementName);
    },

    applyCurrentPage:function (currentPage) {
        this.fireEvent('navigateToPageRequest', currentPage);
        return currentPage;
    },

    navigateToNextPage:function () {
        this.fireEvent('navigateToNextPageRequest');
    },

    navigateToPreviousPage:function () {
        this.fireEvent('navigateToPrevPageRequest');
    },

    applyLocale:function (newLocale) {
        this.fireEvent('localeChanged', this, newLocale);
    },

    applyCommunicationFunction:function (communicationFunction) {
        this.fireEvent('interactionFunctionSet', this, communicationFunction);
    },

    applyDocumentPagesUrl:function (url) {
        this.pageView.setDocumentPagesUrl(url);
        RM.Logger.log("DocumentViewer", "applyDocumentPagesUrl", "Set document pages url: " + url);
    },

    applyCommentsUrl:function (url) {
        this.pageView.setCommentsUrl(url);
        RM.Logger.log("DocumentViewer", "applyCommentsUrl", "Set comments url: " + url);
    },

    applyTextualMetaDataUrl:function (url) {
        RM.Logger.log("DocumentViewer", "applySearchXmlUrl", "Set textual meta data xml:" + url);
    },


    resizeToContainer:function () {
        if(this.isDestroyed == true){
            return; //ideally this should not reach here - but could still be waiting to be removed
        }

        RM.Logger.debug("DocumentViewer", "resizeToContainer", "Initiate resize to container", {indent:1});
        var container = Ext.get(this.renderContainerName);
        var padding = 0;
        var newHeight;
        if (container && container.dom) {
            if (this.controlbar.rendered) {
                padding = this.controlbar.getHeight();
            }
            newHeight = container.dom.clientHeight;
            if (newHeight - padding < 1) return;
            this.pageView.setHeight(newHeight - padding);
            RM.Logger.debug("DocumentViewer", "resizeToContainer", "New height of pageView: " + ( newHeight - padding));
            this.pageView.maintainUserFitSelection();
            this.pageView.repositionComments();
        }
        RM.Logger.debug("DocumentViewer", "resizeToContainer", "Resized to container", {outdent:1});

    },

    refreshLabels:function () {
        //console.log('Refreshing labels');
        //TODO place holder for refreshing labels
    },

    hasCommentingPermission:function () {
        var enabled = false;
        if (this.getSaveCommentsUrl()) {
            enabled = true;
        }
        RM.Logger.info("DocumentViewer", "hasCommentingPermission", enabled);
        return enabled;
    },

    applyWidgetId:function (widgetId) {
        this.widgetId = widgetId;
        this.subscribeToResize();
        return widgetId;
    },

    subscribeToResize:function () {
        if (xcp && xcp.event) {
            var evtBus = xcp.event.EventBus;
            evtBus.subscribe(this.widgetId + '.thm.collapse', this.resizeToContainer, this, null);
            evtBus.subscribe(this.widgetId + '.thm.expand', this.resizeToContainer, this, null);
            RM.Logger.debug("DocumentViewer", "subscribeToResize", "Subscribe to resize of widget: " + this.widgetId);
        }
    },

    destroyViewer:function () {
        this.pageViewController.cleanup();
        this.commentController.cleanup();
        this.searchController.cleanup();
        this.printController.cleanup();
        if (xcp && xcp.event) {
            var evtBus = xcp.event.EventBus;
            evtBus.unsubscribe(this.widgetId + '.thm.collapse');
            evtBus.unsubscribe(this.widgetId + '.thm.expand');
            RM.Logger.debug("DocumentViewer", "unsubscribe", "unSubscribe to resize of widget: " + this.widgetId);
        }
        Ext.EventManager.removeResizeListener(this.resizeToContainer, this);
        this.removeAll();
        Ext.destroy(this);
    }
});


Ext.define('RM.view.ViewerControlBar', {
    extend:"Ext.Toolbar",
    alias:'widget.rmViewerToolbar',
    cls:'rmViewerToolBar',
    layout:{
        overflowHandler:'Menu'
    },
    statics:{
        MIN_ZOOM_SLIDER_INTERNAL:0,
        MAX_ZOOM_SLIDER_INTERNAL:100
    },

    config:{
        documentPageCount:0,
        currentPage:1,
        allowedCommenting:false,
        commentingPermission:false,
        isServerSideSearch:false,
        assetClass:"",
        _currentInternalZoomLevel:0
    },

    plugins: [{
        ptype: 'toolbarscroll',
        widgetScrollHandlers: [
            { widgetId:'button, splitbutton, menu',
                widgetEvents: [{
                    eventName: 'show',
                    evtHandlerFn: function(evtArgs, html, opts) {
                        var comp = opts;
                        if(comp) {
                            if(comp.hide && typeof comp.hide === 'function')
                                comp.hide();
                        }
                    }
                }, {
                    eventName: 'hide',
                    evtHandlerFn: null
                }]
            }]
    }],

    initComponent:function () {
        this.layout = {
            overflowHandler:'Menu'
        };

        this.items = this.generateToolBarRegion();

        this.addEvents('fitToHeight', 'fitToWidth', 'fitToWindow', 'navigateToPage', 'enableCommentMode',
            'showAllComments', 'showMyComments', 'hideComments', 'zoomLevelChanged', 'rotatePage');

        RM.view.ViewerControlBar.superclass.initComponent.apply(this, arguments);
        RM.Logger.debug("ViewerControlBar", "initComponent", "Initialized Viewer Control bar");
    },

    changeToImageDocumentView:function () {
        //Remove Search
        this.remove('searchButton');
        this.remove('searchSeperator');

        //Remove pagination
        this.remove('previousPageButton');
        this.remove('pageField');
        this.remove('paginationSpacer1');
        this.remove('totalPages');
        this.remove('paginationSpacer2');
        this.remove('nextPageButton');
        this.remove('paginationSeperator');
    },

    listeners:{
        afterrender:function () {
            var commentButton = this.getComponent('commentButton');
            if (!this.allowedCommenting) {  //No commenting aspect attached to doc
                commentButton.disable();
                commentButton.setTooltip(RM.Strings.Viewer.DocumentViewer.commentingNotAllowed);
            }
            //No relate permission
            //Should be allowed to see comments
            if (!this.commentingPermission) {
                commentButton.addCls("rmCommentingNotAllowed");
                RM.Logger.debug("ViewerControlBar", "afterrender", "Disabled commenting button");
            }

            this.setDocumentPageCount(this.getDocumentPageCount());
        }
    },

    applyDocumentPageCount:function (pageCount) {
        if (this.rendered) {
            if(pageCount > 0){
                this.add(this.getPrintMenuDefinition(pageCount));
            }
            var pageField = this.getComponent('pageField');
            var pageCountLabel = this.getComponent('totalPages');
            if (!pageField || !pageCountLabel) {   //Requirement Check
                return;
            }
            if (pageCount <= 0) {
                pageCountLabel.setText('/ ...');
                this.updatePaginationControls(0, 0);//disable all

            } else {
                pageCountLabel.setText('/ ' + pageCount);
                pageField.setValue(1);
                this.updatePaginationControls(1, pageCount);
            }


            RM.Logger.debug("ViewerControlBar", "applyDocumentPageCount", "Setting page field to:" + 1);
        }
        return pageCount;
    },

    totalPageCountUpdated:function (pageCount) {
        this.setDocumentPageCount(pageCount)
    },

    applyCurrentPage:function (page) {
        if (this.rendered) {
            var totalPageCount = this.getDocumentPageCount();
            var pageField = this.getComponent('pageField');
            if (!pageField) {   //Requirement Check
                return;
            }
            this.updatePaginationControls(page, totalPageCount);
            pageField.setValue(page);
            RM.Logger.debug("ViewerControlBar", "applyCurrentPage", "Setting page field to:" + page);
        }
        if (1 <= page && page <= this.getDocumentPageCount()) {
            RM.Logger.debug("ViewerControlBar", "applyCurrentPage", "Set current page to:" + page);
            return page;
        }
        else if (this.getCurrentPage() == undefined) {
            RM.Logger.debug("ViewerControlBar", "applyCurrentPage", "Set current page to:" + 1);
            return 1;
        }
    },

    navigateToPage:function (pageNo) {
        if (1 <= pageNo && pageNo <= this.getDocumentPageCount()) {
            //this.setCurrentPage(pageNo);
            //console.log( "Navigate to " + pageNo);
            RM.Logger.debug("ViewerControlBar", "navigateToPage", "Navigating to page" + pageNo, {indent:1});
            this.fireEvent('navigateToPage', pageNo);
            RM.Logger.debug("ViewerControlBar", "navigateToPage", "Navigated to page" + pageNo, {outdent:1});
        }
        else {
            //It is out of range so revert to the old value.
            var pageField = this.getComponent('pageField');
            if (!pageField) {   //Requirement Check
                return;
            }
            RM.Logger.debug("ViewerControlBar", "navigateToPage", "Out of range - page:" + pageNo + " so revert to the old value:" + this.getCurrentPage());
            pageField.setValue(this.getCurrentPage());
        }
    },

    previousPage:function () {
        if (this.getCurrentPage() > 1) {
            var page = this.getCurrentPage() - 1;
            RM.Logger.debug("ViewerControlBar", "previousPage", "To page:" + page);
            this.navigateToPage(page);
        }
    },

    nextPage:function () {
        //Navigate to next page if it is not in last page
        if (this.getCurrentPage() < this.getDocumentPageCount()) {
            var page = this.getCurrentPage() + 1;
            RM.Logger.debug("ViewerControlBar", "previousPage", "To page:" + page);
            this.navigateToPage(page);
        }
    },

    updatePaginationControls:function (page, totalPageCount) {
        var previousPageButton = this.getComponent('previousPageButton');
        var nextPageButton = this.getComponent('nextPageButton');
        if (!previousPageButton || !nextPageButton) { //Requirement check
            return;
        }
        if (page <= 1) {
            RM.Logger.debug("ViewerControlBar", "updatePaginationControls", "Disable prev page control since curr page is less than 1");
            previousPageButton.disable(true);
        }
        else {
            RM.Logger.debug("ViewerControlBar", "updatePaginationControls", "Enabling prev page control");
            previousPageButton.enable(true);
        }
        if (page >= totalPageCount) {
            RM.Logger.debug("ViewerControlBar", "updatePaginationControls", "Disable next page control since curr page is higher than total count");
            nextPageButton.disable(true);
        }
        else {
            RM.Logger.debug("ViewerControlBar", "updatePaginationControls", "Enabling next page control");
            nextPageButton.enable(true);
        }
    },

    fitToWidth:function () {
        RM.Logger.debug("ViewerControlBar", "fitToWidth", "Fit to width button clicked");
        this.fireEvent('fitToWidth', this);
    },

    fitToHeight:function () {
        RM.Logger.debug("ViewerControlBar", "fitToHeight", "Fit to height button clicked");
        this.fireEvent('fitToHeight', this);
    },

    enableCommentingMode:function () {
        if (this.allowedCommenting) {
            RM.Logger.debug("ViewerControlBar", "enableCommentingMode", "Enabling comment mode");
            this.fireEvent('enableCommentMode', this);
        }
    },

    onShowAllCommentsClick:function () {
        RM.Logger.debug("ViewerControlBar", "onShowAllCommentsClick", "Show all comments clicked");
        this.fireEvent('showAllComments', this);
    },

    onShowMyCommentsClick:function () {
        RM.Logger.debug("ViewerControlBar", "onShowMyCommentsClick", "Show my comments clicked");
        this.fireEvent('showMyComments', this);
    },

    onShowNoCommentsClick:function () {
        RM.Logger.debug("ViewerControlBar", "onShowNoCommentsClick", "Show no comments clicked");
        this.fireEvent('hideComments', this);
    },

    refreshDocumentComments:function () {
        RM.Logger.debug("ViewerControlBar", "refreshDocumentComments", "Refresh document comments started", {indent:1});
        var commentDisplayOption = this.getCommentDisplayMode();
        if (commentDisplayOption == "mine") {
            this.onShowMyCommentsClick();
        }
        else if (commentDisplayOption == "all") {
            this.onShowAllCommentsClick();
        }
        RM.Logger.debug("ViewerControlBar", "refreshDocumentComments", "Refresh document comments complete", {outdent:1});
    },

    isCurrentUserMarkerSetVisible:function () {
        var commentDisplayOption = this.getCommentDisplayMode();
        if (commentDisplayOption == "mine" || commentDisplayOption == "all") {
            RM.Logger.debug("ViewerControlBar", "isCurrentUserMarkerSetVisible", true);
            return true;
        }
        else {
            RM.Logger.debug("ViewerControlBar", "isCurrentUserMarkerSetVisible", false);
            return false;
        }
    },

    getCommentDisplayMode:function () {
        var currentSelection;
        Ext.each(this.commentOptionsMenu.items.items, function (menuItem) {
            if (menuItem.checked) {
                currentSelection = menuItem.id;
                return false;
            }
        });
        RM.Logger.debug("ViewerControlBar", "getCommentDisplayMode", currentSelection);
        return currentSelection;
    },

    changeCommentDisplayToMine:function () {
        var toSelectId = 'mine';
        var me = this;
        var hasSelectionChanged = false;
        Ext.each(me.commentOptionsMenu.items.items, function (menuItem) {
            if (menuItem.id == toSelectId) {
                if (!menuItem.checked) hasSelectionChanged = true;
                menuItem.setChecked(true, true);
                RM.Logger.debug("ViewerControlBar", "changeCommentDisplayToMine", true);
            }
            else {
                menuItem.setChecked(false, true);
            }
        });

        return hasSelectionChanged;
    },

    getInternalZoomLevel:function () {
        var zoomSlider = this.getComponent('zoomSlider');
        if (zoomSlider) {
            return zoomSlider.getValue();
        }
        else {
            return this._currentInternalZoomLevel;
        }
    },

    setInternalZoomLevel:function (level, value) {
        var zoomSlider = this.getComponent('zoomSlider');
        if (zoomSlider) {
            zoomSlider.suspendEvents(false);
            zoomSlider.setValue(level, value);
            zoomSlider.resumeEvents();
        }
        this._currentInternalZoomLevel = level;
    },

    zoomIn:function () {
        var internalZoomLevel = this.getInternalZoomLevel();
        if (internalZoomLevel < RM.view.ViewerControlBar.MAX_ZOOM_SLIDER_INTERNAL) {
            this.setInternalZoomLevel(++internalZoomLevel, true);
            RM.Logger.debug("ViewerControlBar", "zoomIn", "Zoom In action started with slider value: " + internalZoomLevel, {indent:1});
            this.zoom(internalZoomLevel, false);
            RM.Logger.debug("ViewerControlBar", "zoomIn", "Zoom In action completed", {outdent:1});
        }
    },

    zoomOut:function () {
        var internalZoomLevel = this.getInternalZoomLevel();
        if (internalZoomLevel > RM.view.ViewerControlBar.MIN_ZOOM_SLIDER_INTERNAL) {
            this.setInternalZoomLevel(--internalZoomLevel, true);
            RM.Logger.debug("ViewerControlBar", "zoomOut", "Zoom Out action started with slider value" + internalZoomLevel, {indent:1});
            this.zoom(internalZoomLevel, false);
            RM.Logger.debug("ViewerControlBar", "zoomOut", "Zoom Out action completed", {outdent:1});
        }
    },

    zoomChanged:function (zoomLevel) {
        RM.Logger.debug("ViewerControlBar", "zoomChanged", "Zoom changed due to change in view");
        var max = RM.view.ViewerControlBar.MAX_ZOOM_SLIDER_INTERNAL;
        var min = RM.view.ViewerControlBar.MIN_ZOOM_SLIDER_INTERNAL;
        var midValue = max / 2;
        var internalZoomLevel;
        if (zoomLevel > 100) {
            internalZoomLevel = Math.floor((zoomLevel - 100) * midValue / 400 + midValue);
        }
        else {
            internalZoomLevel = Math.floor((zoomLevel - 10) * midValue / 90)
        }
        this.setInternalZoomLevel(internalZoomLevel, true);
        RM.Logger.debug("ViewerControlBar", "zoomChanged", "Aligning view started to adjust to next lower slider value:" + internalZoomLevel, {indent:1});
        this.zoom(internalZoomLevel, true);
        RM.Logger.debug("ViewerControlBar", "zoomChanged", "Aligning view complete to adjust to next lower slider value", {outdent:1});
    },

    getCurrentZoomLevel:function () { //For automation purpose
        var zoomSlider = this.getComponent('zoomSlider');
        var internalZoomLevel = zoomSlider.getValue();
        return this.calculateZoom(internalZoomLevel);
    },

    zoom:function (internalZoomLevel, viewAdjust) {
        var zoomPercent = this.calculateZoom(internalZoomLevel);
        RM.Logger.debug("ViewerControlBar", "zoom", "Zooming to percent:" + zoomPercent);
        //viewAdjust indicates that it is just a zoom readjustment
        // for the fit to width and fit to height
        this.fireEvent("zoomLevelChanged", zoomPercent, viewAdjust);
    },

    calculateZoom:function (internalZoomLevel) {
        var max = 100;
        var min = 0;
        var midValue = max / 2;
        var zoomPercent = 10;
        if (internalZoomLevel < midValue) {
            zoomPercent = 10 + internalZoomLevel * 90 / midValue;
        }
        else {
            zoomPercent = 100 + ((internalZoomLevel - midValue) / midValue) * 400;
        }
        return zoomPercent;
    },

    rotatePageLeft:function () {
        this.fireEvent("rotatePage", -90);
    },

    rotatePageRight:function () {
        this.fireEvent("rotatePage", 90);
    },

    generateCommentsToolBar:function () {
        var me = this;
        var commentTypes = [
            {"text":RM.Strings.Viewer.DocumentViewer.showAllLabel,
                id:"all", group:'commentType', checked:true, scope:this,
                checkedCls:'viewer-comment-group-icon', uncheckedCls:'', /*, activeCls: 'viewer-comment-ovr'*/
                handler:this.onShowAllCommentsClick},
            {"text":RM.Strings.Viewer.DocumentViewer.showMineLabel,
                id:"mine", group:'commentType', checked:false, scope:this,
                checkedCls:'viewer-comment-group-icon', uncheckedCls:'',
                handler:this.onShowMyCommentsClick},
            {"text":RM.Strings.Viewer.DocumentViewer.showNoneLabel, scope:this,
                id:"none", group:'commentType', checked:false, /* groupCls:"viewer-comment-group-icon",*/
                checkedCls:'viewer-comment-group-icon', uncheckedCls:'',
                handler:this.onShowNoCommentsClick}
        ];

        this.commentOptionsMenu = new Ext.menu.Menu({
            scope:this,
            cls:'rmViewerCommentTypeList',
            items:commentTypes
        });

        return [
            { xtype:'tbspacer' },
            { xtype:'splitbutton',
                scope:this,
                itemId:"commentButton",
                iconCls:'viewer-add-comment',
                height:36,
                cls:'rmViewerCommentAddButton',
                tooltip:{
                    text:RM.Strings.Viewer.DocumentViewer.addCommentLabel,
                    autoHide:true
                },
                handler:this.enableCommentingMode,
                menu:this.commentOptionsMenu
            },
            { xtype:'tbspacer' }
        ];
    },

    generateLayoutToolBar:function () {
        return [
            { xtype:'tbspacer'},
            { xtype:'button',
                scope:this,
                id:'fitToHeight',
                cls:'rmViewerFitToHeightButton',
                iconCls:'rmviewer-toolbar-button fit-to-height',
			    height:36,
                tooltip:{
                    text:RM.Strings.Viewer.DocumentViewer.fitHeightLabel,
                    autoHide:true
                },
                handler:this.fitToHeight},
            { xtype:'tbspacer' },

            { xtype:'button',
                id:'fitToWidth',
                cls:'rmViewerFitToWidthButton',
                scope:this,
                tooltip:{
                    text:RM.Strings.Viewer.DocumentViewer.fitWidthLabel,
                    autoHide:true
                },
                handler:this.fitToWidth,
                height:36,
                iconCls:'rmviewer-toolbar-button fit-to-width'}
        ];
    },

    generateRotateTools:function () {
        return [
            { xtype:'tbspacer' },
            { xtype:'button',
                scope:this,
                id:'rotateLeft',
                cls:'rmViewerRotateLeftButton',
                iconCls:'rmviewer-toolbar-button rm-rotate-left',
			    height:36,
                tooltip:{
                    text:RM.Strings.Viewer.DocumentViewer.rotateLeft,
                    autoHide:true
                },
                handler:this.rotatePageLeft},
            { xtype:'tbspacer' },
            { xtype:'button',
                id:'rotateRight',
                cls:'rmViewerRotateRightButton',
                iconCls:'rmviewer-toolbar-button rm-rotate-right',
	            height:36,
                scope:this,
                tooltip:{
                    text:RM.Strings.Viewer.DocumentViewer.rotateRight,
                    autoHide:true
                },
                handler:this.rotatePageRight
            }
        ];
    },

    generateSearchToolbar:function () {
        var me = this;
        var searchControls = me.searchControls = new RM.view.SearchControls({isServerSideSearch:me.isServerSideSearch});
        var searchMenu = me.searchMenu = Ext.create("RM.view.SearchMenu", {
            plain:true,
            bodyCls:"rmViewerSearchMenu",
            cls:"rmViewerSearchMenu",
            items:[searchControls]
        });

        searchMenu.addListener("beforeRender", function (searchTerm) {
            me.fireEvent("searchControlInit");
        });

        return [
            {
                xtype:'button',
                itemId:'searchButton',
                cls:'rmViewerSearchIcon',
                iconCls:'rmviewer-toolbar-button viewer-search-icon',
				height:36,
                tooltip:{
                    text:RM.Strings.Viewer.DocumentViewer.search,
                    autoHide:true
                },
                menu:searchMenu,
                handler:function (e) {
                    if (this.showingSearch) {
                        searchMenu.hide(true);
                        this.showingSearch = false;
                    } else {
                        this.showingSearch = true;
                        searchControls.focusSearchBox();
                    }
                },
                listeners:{
                    scope:this,
                    disable:function () {
                        searchMenu.hide(true);
                    },
                    destroy:function () {
                        searchMenu.hide(true);
                    },
                    hide:function () {
                        searchMenu.hide(true);
                    },
                    removed:function () {
                        searchMenu.hide(true);
                    }
                }
            }
        ];
    },

    setSearchCount:function (hitCount) {
        if (this.searchControls) {
            this.searchControls.showSearchResultCount(hitCount);
        }
    },

    notifySearchingOnServer:function () {
        if (this.searchControls) {
            this.searchControls.showSearchingLabel();
        }
    },

    notifySearchingComplete:function () {
        if (this.searchControls) {
            this.searchControls.hideSearchResultCount();
        }
    },

    setSearchNavPrevBtnState:function (enable) {
        if (this.searchControls) {
            this.searchControls.setSearchNavPrevBtnState(enable);
        }
    },

    setSearchNavNextBtnState:function (enable) {
        if (this.searchControls) {
            this.searchControls.setSearchNavNextBtnState(enable);
        }
    },

    disableSearchBtn:function () {
        var searchBtn = this.getComponent('searchButton');
        if (searchBtn)  searchBtn.disable();
    },

    notifySearchXmlLoading:function () {
        if (this.searchControls) {
            this.searchControls.notifySearchXmlLoading();
        }
    },

    notifySearchXmlLoadCompletion:function () {
        if (this.searchControls) {
            this.searchControls.notifySearchXmlLoadCompletion();
        }
    },


    generatePaginationToolBar:function () {

        return [

            { xtype:'button',
                itemId:'previousPageButton',
                cls:'rmViewerPreviousPageButton',
                scope:this,
                iconCls:"rmviewer-toolbar-button viewer-prev-page-enabled",
				height:36,
                handler:this.previousPage,
                tooltip:{
                    text:RM.Strings.Viewer.DocumentViewer.previousPageLabel,
                    autoHide:true
                }
            },
            {xtype:'tbspacer',width:2},
            { xtype:'textfield',
                itemId:'pageField',
                cls:'rmViewerPageField',
                allowBlank:false,
                labelAlign:"center",
                scope:this,
                listeners:{
                    scope:this,
                    specialkey:function (textfield, e) {
                        if (e.getKey() == e.ENTER) {
                            this.navigateToPage(parseInt(textfield.getValue()));
                        }
                    }
                },
                width:30 },
            { xtype:'tbspacer', itemId:'paginationSpacer1'},

            { xtype:'tbtext',
                itemId:'totalPages',
                cls:'rmTotalDocPagesLabel',
                text:RM.Strings.Viewer.DocumentViewer.defaultPagesLabel },
            { xtype:'tbspacer', itemId:'paginationSpacer2' },
            { xtype:'button',
                itemId:'nextPageButton',
                cls:'rmViewerNextPageButton',
                scope:this,
                iconCls:"rmviewer-toolbar-button viewer-next-page-enabled",
				height:36,
                handler:this.nextPage,
                tooltip:{
                    text:RM.Strings.Viewer.DocumentViewer.nextPageLabel,
                    autoHide:true
                }
            }
        ];
    },

    generateZoomToolbar:function () {
        var me = this;
        var zoomSlider = {
            xtype:"slider",
            itemId:"zoomSlider",
            cls:"rmViewerZoomSlider",
            increment:1,
            minValue:RM.view.ViewerControlBar.MIN_ZOOM_SLIDER_INTERNAL,
            maxValue:RM.view.ViewerControlBar.MAX_ZOOM_SLIDER_INTERNAL,
            tipText:function (thumb) {
                var currValue = thumb.value;
                var max = RM.view.ViewerControlBar.MAX_ZOOM_SLIDER_INTERNAL;
                var midValue = max / 2;
                if (currValue < midValue) {
                    return (10 + currValue * 90 / midValue) + "%";
                }
                else {
                    return (100 + ((currValue - midValue) / midValue) * 400) + "%";
                }
            },
            listeners:{
                scope:this,
                afterrender:function (slider) {
                    var dh = Ext.core.DomHelper;
                    dh.append(slider.id, {tag:'div', cls:'rm-viewer-zoom-slider-tic'});
                },
                change:function (slider, value) {
                    var currValue = slider.getValue();
                    this.zoom(currValue);
                }
            }
        };


        var zoomOutButton = {
            xtype:"button",
            itemId:"zoomOutButton",
            cls:"rmViewerZoomOut",
            iconCls:"rmviewer-toolbar-button rm-viewer-zoom-out",
            height:36,
            listeners:{
                render:{
                    fn:function (zoomOutBtn) {
                        zoomOutBtn.el.on(me.getZoomOutEvents());
                    }
                }
            },
            tooltip:{
                text:RM.Strings.Viewer.DocumentViewer.zoomOut,
                autoHide:true
            }
        };

        var zoomInButton = {
            xtype:"button",
            itemId:"zoomInButton",
            cls:"rmViewerZoomIn",
            iconCls:"rmviewer-toolbar-button rm-viewer-zoom-in",
			height:36,
            listeners:{
                render:{
                    fn:function (zoomInBtn) {
                        zoomInBtn.el.on(me.getZoomInEvents());
                    }
                }
            },
            tooltip:{
                text:RM.Strings.Viewer.DocumentViewer.zoomIn,
                autoHide:true
            }
        };

        return [ zoomOutButton, zoomSlider, zoomInButton ];
    },

    getZoomOutEvents:function () {
        var me = this;
        var zoomOutTask = null;
        if (Ext.is.iPad) {
            return {
                click:function () {
                    me.zoomOut();
                }
            };
        }
        else {
            return {
                mousedown:function () {
                    if (zoomOutTask != null) {
                        Ext.TaskManager.stop(zoomOutTask);
                    }
                    zoomOutTask = { run:me.zoomOut, interval:500, scope:me};
                    Ext.TaskManager.start(zoomOutTask);
                },
                //Stop the zoom out task even when moving away from button
                //because mouseup event wont raise sometimes
                mouseout:function () {
                    if (zoomOutTask != null) {
                        Ext.TaskManager.stop(zoomOutTask);
                    }
                    zoomOutTask = null;
                },
                mouseup:function () {
                    if (zoomOutTask != null) {
                        Ext.TaskManager.stop(zoomOutTask);
                    }
                    zoomOutTask = null;
                }};
        }
    },

    getZoomInEvents:function () {
        var me = this;
        var zoomInTask = null;
        if (Ext.is.iPad) {
            return {
                click:function () {
                    me.zoomIn();
                }
            };
        }
        else {
            return {
                mousedown:function () {
                    if (zoomInTask != null) {
                        Ext.TaskManager.stop(zoomInTask);
                    }
                    zoomInTask = { run:me.zoomIn, interval:500, scope:me};
                    Ext.TaskManager.start(zoomInTask);
                },
                //Stop the zoom in task even when moving away from button
                //because mouseup event wont raise sometimes
                mouseout:function () {
                    if (zoomInTask != null) {
                        Ext.TaskManager.stop(zoomInTask);
                    }
                    zoomInTask = null;
                },
                mouseup:function () {
                    if (zoomInTask != null) {
                        Ext.TaskManager.stop(zoomInTask)
                    }
                    zoomInTask = null;
                }
            };
        }
    },

    getPrintMenuDefinition: function (pageCount) {
        var printMenuDefinition = {
            xtype:'button',
            itemId:'Print',
            iconCls:'rmviewer-toolbar-button viewer-print',
            height:36,
            tooltip:RM.Strings.Viewer.DocumentViewer.print
        };
        if(this.assetClass == "Image" || pageCount == 1){
            printMenuDefinition.listeners =  {
                click:function (btn, e, opts) {
                    btn.ownerCt.fireEvent('printCurrentPage');
                }
            };
        }
        else{
            printMenuDefinition.menu = new Ext.create("RM.view.PrintMenu", {plain:true});
        }

        return printMenuDefinition;
    },

    generateToolBarRegion:function () {
        var toolBarComponents = [];

        var searchToolBar = this.generateSearchToolbar();
        toolBarComponents = toolBarComponents.concat(searchToolBar);
        toolBarComponents.push({ xtype:'tbseparator', itemId:'searchSeperator' });
        var commentToolBar = this.generateCommentsToolBar();
        toolBarComponents = toolBarComponents.concat(commentToolBar);
        toolBarComponents.push({ xtype:'tbseparator' });
        var zoomToolBar = this.generateZoomToolbar();
        toolBarComponents = toolBarComponents.concat(zoomToolBar);
        toolBarComponents.push({xtype:'tbspacer',width:2});
        toolBarComponents.push({ xtype:'tbseparator' });
        toolBarComponents = toolBarComponents.concat(this.generatePaginationToolBar());
        toolBarComponents.push({ xtype:'tbseparator', itemId:'paginationSeperator'});
        toolBarComponents = toolBarComponents.concat(this.generateLayoutToolBar());
        toolBarComponents = toolBarComponents.concat(this.generateRotateTools());
        toolBarComponents.push({ xtype:'tbseparator' });
        return toolBarComponents;
    }

});

/**
 * This plugin was created to handle scrolling events
 * on controls placed within a toolbar such as:
 * - Tooltips
 * - Combobox
 * - Split buttons
 * - Menus
 *
 * This plugin registers the body scroll\mousewheel
 * events with the toolbar control and any of its
 * child items that need to be collapsed or hidden
 * when the document is scrolled. The widgets to be
 * registered can be configured with the following
 * object type:
 *
 * var widgetScrollHandler = [{
 *   widgetId:"combobox",
 *   widgetEvents: [
 *   {
 *      eventName: expand,
 *      evtHandlerFn: function () {}
 *   },
 *   {
 *      eventName: collapse,
 *      evtHandlerFn: null ---> can be null of undefined, this will use this event to unregister body scroll\mousewheel events
 *   }]
 * },
 * {...},
 * {...}
 * ]
 */
Ext.define('RM.view.plugin.ToolbarScroll', {
    extend: 'Ext.AbstractPlugin',
    alias: 'plugin.toolbarscroll',

    /**
     * Default constructor
     * @param config
     */
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);

        //Set the widget scroll event handlers if there are any
        me.widgetScrollHandlers = config.widgetScrollHandlers;
    },

    /**
     * Template method that initiates the plugin
     * @param container
     */
    init: function(container) {
        var me = this;
        me.callParent(arguments);

        me.container = container;
        me.container.on('afterrender', me.onAfterRender, me);
    },

    /**
     * Template method called when container widget
     * is destroyed. Cleans up listeners
     */
    destroy: function() {
        var me = this;
        me.container.removeListener('afterrender', me.onAfterRender);

        //Remove scroll\mousewheel event handlers to
        //hide the tooltips here.
        me.addTooltipHandlers(me.container, null, false);
    },

    /**
     * The 'afterrender' event handler method which is
     * used to add body scroll\mousewheel event handling
     * for tooltips and any widgets configured to be
     * handled.
     *
     * If no widgets are configured, then only tooltips are
     * set to be handled.
     *
     * @param container
     * @param evtArgs
     */
    onAfterRender: function(container, evtArgs) {
        var me = this;
        //Add tooltip event handlers here.
        me.addTooltipHandlers(container, function(comp, args) {
            //Hide the current tooltip if it is visible
            var tip = Ext.tip.QuickTipManager.getQuickTip();
            if(tip && tip.isVisible())
                tip.hide();
        }, true);


        //Set up widget scroll event monitoring here
        //by looping through the configured widget
        //handlers.
        if(!Ext.isEmpty(me.widgetScrollHandlers)) {
            Ext.Array.forEach(me.widgetScrollHandlers, function(scrollHandler, idx, allHandlers) {
                if(!Ext.isEmpty(scrollHandler))  {
                    var id = scrollHandler.widgetId;
                    if(id && Ext.isString(id)) {
                        //Check to see if we have multiple widgets defined with the
                        //scroll event handling
                        if(id.indexOf(',') !== -1) {
                            var ids = id.split(',');
                            for(var i=0;idx<=ids.length;idx++)
                                me.setTbarWidgetHandlers(ids[idx], scrollHandler.widgetEvents);
                        } else {
                            me.setTbarWidgetHandlers(id, scrollHandler.widgetEvents);
                        }
                    }
                }
            });
        }
    },
    /**
     * Adds managed listeners to the body scroll\mousewheel
     * events and attaches the handler function passed in.
     *
     * @param comp - the widget\component that will add the listener
     * @param evtHandlerFn - the event handler function
     * @param bAdd - whether we are adding or removing the listener
     * @return {Boolean}
     */
    addTooltipHandlers: function(comp, evtHandlerFn, bAdd) {
        if(!Ext.isEmpty(comp) && Ext.isFunction(evtHandlerFn)) {
            if(bAdd) {
                comp.mon(Ext.getBody(), 'scroll', evtHandlerFn, comp);
                comp.mon(Ext.getBody(), 'mousewheel', evtHandlerFn, comp);
            } else {
                comp.mun(Ext.getBody(), 'scroll');
                comp.mun(Ext.getBody(), 'mousewheel');
            }

            return true;
        }

        return false;
    },

    /**
     * Sets the body scroll\mousewheel for the widget(s) specified
     * by the query term. This query term returns a list of widgets
     * contained inside the toolbar. The array of objects returned
     * then has the configured widget events registered.
     *
     * @param qryTerm - selector to return a list of items contained
     * in the toolbar
     * @param widgetEvents - an array of events to be applied to the
     * specified widget(s)
     */
    setTbarWidgetHandlers : function(qryTerm, widgetEvents) {
        var me = this;
        //Search the toolbar for specified widgets
        //and register configured events.
        var comps=me.container.query(qryTerm);
        if(comps && comps.length>0) {
            Ext.Array.forEach(comps, function(comp, idx, allComps) {
                //In our case, we want to collapse or hide menu so
                //we will just act on the menu widget itself. We may
                //want to revisit this behavior later.
                if(comp.menu)
                    comp = comp.menu;

                //Loop through the configured events and register them
                //with the component.
                if(!Ext.isEmpty(widgetEvents)) {
                    Ext.Array.forEach(widgetEvents, function(widgetEvt, idx2, allWidgetEvt) {
                        //Only register scroll\mousewheel events after the specified widget
                        //is displayed by firing an event such as 'expand' or 'show' which
                        //displays the control. In this case we need to auto-close on scroll
                        if(widgetEvt.evtHandlerFn && Ext.isFunction(widgetEvt.evtHandlerFn)) {
                            comp.on(widgetEvt.eventName, function() {
                                comp.mon(Ext.getBody(), 'scroll', widgetEvt.evtHandlerFn, me.container, comp);
                                comp.mon(Ext.getBody(), 'mousewheel', widgetEvt.evtHandlerFn, me.container, comp);
                            }, me);
                        } else {    //Unregister scroll\mousewheel events after widget fires a collapse\hide event
                            comp.on(widgetEvt.eventName, function() {
                                comp.mun(Ext.getBody(), 'mousewheel');
                                comp.mun(Ext.getBody(), 'scroll');
                            }, me);
                        }
                    });
                }
            });
        }
    }
});

Ext.Loader.setConfig({enabled: true});

Ext.Loader.setPath('RM', '../app/');

Ext.require([
    'Ext.Panel',
    'RM.controller.ViewerController',
    'RM.view.ViewerControlBar',
    'RM.view.DocumentViewer',
    'RM.view.PageView',
    'RM.model.Document'
]);

Ext.create('Ext.app.Application', {
    name: 'RM',

    autoCreateViewport: false,

    controllers: [
    ],

    views: [
        'DocumentViewer','PageView'
    ],

    launch: function() {

    }
});



/* ivf_videoviewer_lib/content/xcp/viewer/pkg/fullscreen.js */

//Ext.ns('Ext.ux');


/******************** Ext.ux.FullScreenMixin ***********************/

Ext.define('Ext.ux.FullScreenMixin', {

    toggleFullScreen : function(allowInput)
    {
        var bAllowInput;
        if (typeof allowInput == 'boolean')
            var bAllowInput = allowInput;
        
        // enter or exit fullscreen
        if (Ext.ux.FullScreenUtil.isInFullScreen)
            this.exitFullScreen();
        else
            this.enterFullScreen(bAllowInput);
    },
    
    enterFullScreen: function(allowInput) {
        var me = this;
        
        // Register fullscreen event listener
        if (Ext.ux.FullScreenUtil.supportsFullScreen && !me.fullscreenListenerIsOn)
        {
            me.getEl().on(
                Ext.ux.FullScreenUtil.fullScreenEventName,
                me.fullscreenEventHandler,
                me);
            me.fullscreenListenerIsOn = true;
        }

        Ext.ux.FullScreenUtil.enterFullScreen(this, allowInput);

        // Manully call event handler in full window mode since there is no fullscreen event. 
        if (!Ext.ux.FullScreenUtil.supportsFullScreen)
            me.fullscreenEventHandler();
    },
    
    exitFullScreen: function() {
        Ext.ux.FullScreenUtil.exitFullScreen();

        // Manully call event handler in full window mode since there is no fullscreen event. 
        if (!Ext.ux.FullScreenUtil.supportsFullScreen)
            this.fullscreenEventHandler();
    },

    isInFullScreen: function() {
        return Ext.ux.FullScreenUtil.isInFullScreen;
    },
    
    fullscreenEventHandler: function(event) {
       this.onFullScreenChanged(Ext.ux.FullScreenUtil.isFullScreen());
    },

    // Override this empty onFullScreenChanged()   
    onFullScreenChanged : function(isInFullScreen){}

});


/******************** Ext.ux.FullScreenUtil ***********************/

Ext.define('Ext.ux.FullScreenUtil', {
    
    singleton: true,
    
    targetContainer : null,
    normalWidth: -1,
    normalHeight: -1,
    isInFullScreen : false,
    docStyleOverflow: null,

    supportsFullScreen: false,
    isFullScreen: function() { return false; },
    requestFullScreen: Ext.emptyFn(),
    cancelFullScreen: Ext.emptyFn(),
    fullScreenEventName: '',
    prefix: '',

    constructor: function(config) {
        
        // detect native JavaScript fullscreen (Safari/Firefox/Chrome)
        var me = this;
    
        var browserPrefixes = 'webkit moz o ms khtml'.split(' ');
     
        // check for native support
        if (typeof document.cancelFullScreen != 'undefined' ||
            typeof document.exitFullscreen != 'undefined') {
            me.supportsFullScreen = true;
        } else {
            // check for fullscreen support by vendor prefix
            for (var i = 0, il = browserPrefixes.length; i < il; i++ ) {
                me.prefix = browserPrefixes[i];
     
                if (typeof document[me.prefix + 'CancelFullScreen' ] != 'undefined' ) {
                    me.supportsFullScreen = true;
     
                    break;
                }
            }
        }
        
        // check if browser disabled the fullscreen 
        if ( (typeof document.fullScreenEnabled != 'undefined') 
             && (false == document.fullScreenEnabled))
        {
            me.supportsFullScreen = false;
        }
     
        // update methods to do something useful
        if (me.supportsFullScreen) {
            me.fullScreenEventName = me.prefix + 'fullscreenchange';
     
            // function: Check if in fullscreen
            me.isFullScreen = function() {
                switch (this.prefix) {
                    case '':
                        return document.fullScreen;
                    case 'webkit':
                        return document.webkitIsFullScreen;
                    default:
                        return document[this.prefix + 'FullScreen'];
                }
            }

            // function: Request full screen
            me.requestFullScreen = function(el, allowInput) {
                allowInput == !!allowInput;

                if (allowInput)
                {
                    if (typeof el.requestFullScreenWithKeys != 'undefined') //Mozilla
                    {
                        return el.requestFullScreenWithKeys();
                    }
                    else if (typeof el.webkitRequestFullScreen != 'undefined') // Webkit
                    {
                        return el.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)
                    }
                    // else fallback to API call without keyboard input
                }

                if (el.requestFullScreen) { // Mozilla Proposal
                    return el.requestFullScreen();  
                } 
                else if (el.requestFullscreen) { // W3C Proposal
                    return el.webkitRequestFullScreen();  
                }  
                else if (el.mozRequestFullScreen) { // Firefox 10
                    return el.mozRequestFullScreen();  
                } 
                else if (el.webkitRequestFullScreen) { // Webit browsers
                    return el.webkitRequestFullScreen();  
                } 

                /*
                return (this.prefix === '') 
                    ? el.requestFullScreen() 
                    : el[this.prefix + 'RequestFullScreen']();
                */
            }
            
            // function: Cancel full screen
            me.cancelFullScreen = function() {
                if (document.cancelFullScreen) { // Mozilla proposal   
                    document.cancelFullScreen();  
                } 
                else if (document.exitFullscreen) { //W3C
                    document.exitFullscreen();  
                }
                else if (document.mozCancelFullScreen) { // Firefox 10
                    document.mozCancelFullScreen();  
                } 
                else if (document.webkitCancelFullScreen) { // Webkit
                    document.webkitCancelFullScreen();  
                } 

                /*
                return (this.prefix === '') 
                    ? document.cancelFullScreen() 
                    : document[this.prefix + 'CancelFullScreen']();
                */ 
            }
        }
    },

    enterFullScreen: function( container, allowInput ) {

        var el = container.getEl();
        var me = this;
        me.targetContainer = container;

        // store overflow 
        docStyleOverflow = document.documentElement.style.overflow;
        // set it to not show scroll bars so 100% will work
        document.documentElement.style.overflow = 'hidden';         
    
        // store sizing and styles
        normalHeight = container.getHeight();
        normalWidth = container.getWidth();
        //me.containerStyles = el.getStyles("width", "height"); 
        if (container.body)
        {
            me.bodyStyles = container.body.getStyles("width", "height"); 
        }
        
        // attempt to do true fullscreen
        if (me.supportsFullScreen) {
            me.requestFullScreen(el.dom, allowInput);
            
            // Register handler on user press ESC to exit fullscreen
            me.targetContainer.el.on(
                me.fullScreenEventName,
                me.fullscreenEventHandler,
                this);
        }

        // Reposition & Resize the component

        // Applys the styles
        if (container.body)
        {
            container.body.applyStyles({width: '100%', height: '100%'});
        }
        container.addCls('fullscreen-container');
        //el.applyStyles({width: '100%', height: '100%'});

        // Expand the container to full browser window code
        var fsWidth, fsHeight;
        if (me.supportsFullScreen) {
            fsWidth = screen.width;
            fsHeight = screen.height;
        }
        else {
            var vpSize = Ext.getBody().getViewSize();
            fsWidth = vpSize.width;
            fsHeight = vpSize.height;
            
            Ext.Function.defer(function(){
                container.setSize(fsWidth, fsHeight);
                container.fireEvent('resize', container, fsWidth, fsHeight);
            }, 100);
        }
        //container.fireEvent('bodyresize', container, fsWidth, fsHeight);
        //container.fireEvent('resize', container, fsWidth, fsHeight);
        
        Ext.EventManager.onWindowResize(this.onWindowResize, this);

        me.isInFullScreen = true;

    },
    
    exitFullScreen: function() {
        var me = this;
        if (me.targetContainer == null)
            return;
            
        var container = me.targetContainer;

        Ext.EventManager.removeResizeListener(this.onWindowResize, this);
    
        // Exit native fullscreen
        if (me.supportsFullScreen && (me.isFullScreen() /*|| me.isInFullScreen*/)) {
            me.targetContainer.el.un(me.fullScreenEventName, me.fullscreenEventHandler, me);
            // Remove the fullscreen event handler
            me.cancelFullScreen();
        }   

        // restore scroll bars to document
        document.documentElement.style.overflow = docStyleOverflow;                 
            
        container.removeCls('fullscreen-container')

        if (container.body)
        {
            container.body.applyStyles(me.bodyStyles);
        }
        
        if (me.supportsFullScreen) {
            container.setSize(normalWidth, normalHeight);
        }
        else
        {
            Ext.Function.defer(function(){
                container.setSize(normalWidth, normalHeight);
                me.targetContainer.fireEvent("resize", normalWidth, normalHeight);

            }, 100);
        }
        Ext.EventManager.onWindowResize(this.onWindowResize, this);

        //container.getEl().applyStyles(me.containerStyles);
        me.targetContainer.fireEvent("resize", normalWidth, normalHeight);

        me.isInFullScreen = false;
//        me.targetContainer = null;
    },

    // Handler: exit from fullscreen by user pressing ESC
    fullscreenEventHandler: function(width, height){
        var me = this;
        if (!me.isFullScreen()){
            me.exitFullScreen(); 
        }
    },

    onWindowResize: function(width, height)
    {
        if (this.targetContainer) {
            this.targetContainer.setSize(width, height);
            this.targetContainer.fireEvent("resize");
        }
    }

});

/* ivf_videoviewer_lib/content/xcp/viewer/pkg/video-viewer-all.js */

/*
 * Copyright (c) 2011 EMC Corporation. All Rights Reserved.
 */

Ext.namespace("RM");

Ext.define('RM.view.VideoViewer', {
    extend:"Ext.panel.Panel",
    autoScroll:false,
    alias:'widget.rmVideoViewer',
    border:false,
    layout:"anchor",
    padding:"0",
    config:{
        documentInfo:{},
        videoInfo:{},
        renderContainer:"document.body",
        contentServiceUrl:"",
        videoServiceUrl:"",
        storyboardServiceUrl:"",
        locale:'',
        flashViewer:null,
        flashPlaybackFormats:["flv", "f4v", "mpeg-4v"]
    },

    initComponent:function () {

       Ext.EventManager.onWindowResize(this.resizeToContainer, this);
        this.addEvents('currentDocumentChanged', 'localeChanged');
        this.addListener('playerInitalized', this.afterPlayerInit, this);
        this.addListener('playbackError', this.showFatalError, this);
        this.callParent(arguments);

        this.on({
            afterrender:this.onAfterRender,
            beforedestroy:function () {
                this.un(this.afterrender, this.onAfterRender);
                this.videoPanel = null;
            }
        });

    },

    onRender:function () {
        this.resizeToContainer(this.renderContainerName);
        RM.view.VideoViewer.superclass.onRender.apply(this, arguments);
    },


    playVideo:function () {
        this.el.unmask();
        if (this.bigPlayButton) this.bigPlayButton.hide();
        this.videoPanel.playOrPause(false, this.getFlashSwfId());
    },

    onAfterRender:function () {
        this.setLoading(true);
        if (this.videoInfo) {
            this.createVideoControl(this.videoInfo);
        }
        else {
            //TODO: control reuse this.getVideoInfo();
        }
        if (!Ext.is.iOS) {
            var id = this.el.id;
            var dh = Ext.core.DomHelper;

            this.bigPlayButton = dh.append(id, {tag:'div', cls:'big-play-button-x-mask-msg'}, true);
            this.bigPlayButton.on('click', this.onClickBigPlayButton, this);
            //Mask on startup
            this.el.mask();
        }

    },

    onClickBigPlayButton:function () {
        if (this.playerInitalized) {
            this.playVideo();
        }
        else {
            this.playWhenReady = true;
        }
    },

    getVideoInfo:function () {
        var serviceRequest = this.videoServiceUrl + "/" + this.documentInfo.objectId;

        Ext.Ajax.request({
            url:serviceRequest,
            scope:this,
            success:function (response) {
                var videoInfo = Ext.decode(response.responseText);
                this.createVideoControl(videoInfo);
            },
            failure:function (response, request) {
                if (xcp.core.FeedbackManager)
                    xcp.core.FeedbackManager.showFeedback(null, "", RM.Strings.Viewer.VideoViewer.getVideoInfoError, "systemErrors");
//                Ext.MessageBox.alert(
//                RM.Strings.Viewer.VideoViewer.getVideoInfoError, response.responseText);
            }
        });
    },

    createVideoControl:function (videoInfo) {
        this.videoInfo = videoInfo;

        var videoSrc = [];
        Ext.each(videoInfo.streamInfo, function (videoInfo) {
            videoSrc.push({
                src:videoInfo.url,
                type:videoInfo.type,
                format:videoInfo.format
            });
        });

        //Try Html 5 first then default back to flash
        this.isUsingFlashFallback = false;

        this.videoPanel = new RM.view.HTML5VideoPanel({
            layout:"anchor",
            border:false,
            preload:'metadata',
            autoplay:false,
            controls:false,
            anchor: "100% 100%",
            src:videoSrc,
            videoInfo:videoInfo,
            fallbackHTML:this.getFlashPlayerHTML(videoSrc)
        });

        /* 
         this.videoPanel.on({
         scope: this,
         "canplay": function(e)
         {
         debugger;
         //this.setLoading(false);
         },
         "error": function(e)
         {
         debugger;
         //this.setLoading(false);
         }
         });
         */

        // Add video player panel
        this.add(this.videoPanel);

        // Hide the loading mask
        this.setLoading(false);
    },

    afterPlayerInit:function () {
        this.playerInitalized = true;
        if (this.playWhenReady) {
            this.playVideo();
        }
    },
    onFlashEvent:function (e) {
        var data = {videoInfo:this.videoInfo, resources:RM.Strings.Viewer.VideoViewer}
        switch (e.eventName) {
            case "creationComplete":
                return data;
            case "playerInitalized":
                this.afterPlayerInit();
                break;
            case "playbackError":
                this.showFatalError();
                break;
            case "appEventUnsubscribe":
                this.appEventUnsubscribe(e.eventName);
                return;
        }
    },

    showFatalError:function () {
        this.el.unmask();
        this.setLoading(false);
        this.bigPlayButton.hide();
        var me =this;
        //Including the delay for rendering the text after panel is reached its
        //fully rendered height
        var showError = new Ext.util.DelayedTask(function(){
            me.el.mask(RM.Strings.Viewer.VideoViewer.playbackError, 'xcp-mask-error');
        });
        showError.delay(500);
    },

    getFlashSwfId:function () {
        // Return a unique flash object id
        return this.getId() + '-FlashVideoPlayer';
    },

    getFlashPlayerHTML:function (videoSrc) {
        var swfPlayer = this.flashViewer;

        var flashPlaybackUrl = null; //videoSrc[0].src;
        var format, formatFound = false;
        var flashPlaybackFormats = this.flashPlaybackFormats;
        for (var i = 0; i < videoSrc.length; i++) {
            format = videoSrc[i].format;
            for (var j = 0; !formatFound && j < flashPlaybackFormats.length; j++) {
                formatFound = (format == flashPlaybackFormats[j]);
            }
            if (formatFound) {
                flashPlaybackUrl = videoSrc[i].src;
                break;
            }
        }

        if (flashPlaybackUrl == null) {
            //TODO : show download link if flash playback not avaiable?
            // var flashPlaybackUrl = encodeURIComponent(flashPlaybackUrl);
            return;
        }

        var flashValues = "elementID=" + this.getId()
            + "&eventHandler=Ext.ux.FlashCallback.get"
            + "&locale=" + "en"
            + "&localeURL=" + "Resources_en.swf"
            + "&fallbackFormats=" + this.flashPlaybackFormats;

        var flashVars = "<param name='flashVars' value='" + flashValues + "'/>";

        return "<object id=\"" + this.getFlashSwfId()
            + "\" width=\"100%\" height=\"100%\""
            + "type=\"application/x-shockwave-flash\""
            + "data=\"" + swfPlayer + "\">"
            + "<param name=\"movie\" value=\"" + swfPlayer + "\"/>"
            + flashVars
            + "<param name=\"wmode\" value=\"opaque\" />"
            + "<param name=\"quality\" value=\"high\" />"
            + "<param name=\"allowfullscreen\" value=\"true\" />"
            + "<param name=\"allowScriptAccess\" value=\"always\" />"
            + "</object>";
    },

    resizeToContainer:function () {
        var container = Ext.get(this.renderContainerName);
        if (container && container.parent()) {
            var size = container.parent().getSize();
            // Resize the video container and video control
            this.setSize(size.width, size.height);

        }
    },

    applyRenderContainer:function (elementName) {
        this.renderContainerName = elementName;
        this.render(elementName);
    },

    // Reload video info for given new document info  
    applyDocument:function (documentInfo) {
        this.documentInfo = documentInfo;
        this.getVideoInfo();
    },

    applyLocale:function (newLocale) {
        this.fireEvent('localeChanged', this, newLocale);
    },

    destroyViewer:function () {
        this.videoPanel.cleanUp();
        this.destroy();
    }

});

/* ***************************************************************************** */
/*                          Ext.ux.FlashCallback Global Function                 */
/* ***************************************************************************** */
/*  We create this global callback gettor because of ExtJS 4 Ext.flash.Component does not support callback functonalities.
 *  See ExtJs 3.x Ext.FlashEventProxy and Ext.FlashComponent for details
 */
Ext.ux.FlashCallback = {
    get:function (id, e) {
        var fp = Ext.getCmp(id);
        if (fp) {
            return fp.onFlashEvent(e);
        } else {
            arguments.callee.defer(10, this, [id, e]);
        }
    }
}

/* ***************************************************************************** */
/*                          RM.view.HTML5VideoUtil                             */
/* ***************************************************************************** */
Ext.namespace("RM");
Ext.define('RM.view.HTML5VideoUtil', {

    singleton:true,

    /**
     * Converts a timecode in milliseconds.
     *
     * @param{string} timecode is the timecode  in format "hh:mm:ss;ff"
     * @param{int} frameRate video frame rate
     * @return the timecode in milliseconds
     */
    getMillisecondsFromTimecode:function (timecode, frameRate) {
        frameRate = parseFloat(frameRate);
        if (isNaN(frameRate))
            frameRate = 24;

        // "hh:mm:ss;ff" or "hh:mm:ss:ff" - The ff is in unit of frames/second
        // "hh:mm:ss.SSS" - SSS is milliseconds
        var milliseconds = parseInt(timecode.substring(0, 2), 10) * 3600 * 1000;
        milliseconds = milliseconds + parseInt(timecode.substring(3, 5), 10) * 60 * 1000;
        milliseconds = milliseconds + parseInt(timecode.substring(6, 8), 10) * 1000;
        var c = timecode.charAt(8);
        if (c == ';' || c == ':') {
            var s = parseInt(timecode.substring(9, 11), 10);
            milliseconds = milliseconds + Math.floor((s / frameRate) * 1000);
        }
        else {
            var s = parseInt(timecode.substring(9, 12), 10);
            milliseconds = milliseconds + s;
        }

        return milliseconds;
    },

    getDisplayTimeFromTimecode:function (timecode, frameRate, duration) {
        frameRate = "";
        frameRate = parseFloat(frameRate);
        if (isNaN(frameRate))
            frameRate = 24;

        var seconds = parseInt(timecode.substring(6, 8), 10);

        var c = timecode.charAt(8);
        if (c == ';' || c == ':') {
            var s = parseInt(timecode.substring(9, 11), 10);
            seconds += Math.floor(s / frameRate);
        }
        else {
            var s = parseInt(timecode.substring(9, 12), 10);
            seconds += s;
        }

        var s = seconds.toString();
        if (s.length < 2) s = "0" + s;

        timecode = timecode.substring(0, 6) + s;

        // UxD: only show minutes and seconds when less then an hour
        if (duration < 3600)
            return timecode.substring(3);
        else
            return timecode;
    },

    /* Return video duration in seconds */
    getVideoDuration:function (container) {
        if (!container.video || !container.video.dom || !container.video.dom.duration) {
            var metadata = container.videoInfo.metadata;
            if (metadata && metadata["Duration"]) {
                var duration = this.getMillisecondsFromTimecode(metadata["Duration"], metadata["Frame Rate"]) / 1000;
                return duration;
            } else if (container.storyboardInfo && container.storyboardInfo.length > 0) {
                var info = container.storyboardInfo[container.storyboardInfo.length - 1];
                return info.time / 1000;
            } else {
                return null;
            }
        } else {
            return container.video.dom.duration;
        }
    }

});

/* ***************************************************************************** */
/*                          RM.view.HTML5VideoPanel                               */
/* ***************************************************************************** */
Ext.namespace("RM");

Ext.define('RM.view.HTML5VideoPanel', {

    extend:'Ext.panel.Panel',
    alias:'widget.rmHTML5VideoPanel',

    mixins:{
        fullscreen:'Ext.ux.FullScreenMixin'
    },
    bubbleEvents:["playerInitalized", "playbackError"],

    cleanUp:function () {
        if (this.video) {
            var player = this.video.dom;
            player.pause();
            player.src = "";
            player.load();
            delete this.video;
        }
        if(this.progressBar)
            this.progressBar.destroy();
        this.destroy();
    },

    constructor:function (config) {

        this.thumbnailView = config.thumbnailView;
        this.videoInfo = config.videoInfo;
        this.config = config;

        if (config.storyboardInfo)
            this.storyboardInfo = config.storyboardInfo;

        Ext.applyIf(config, {
            frame:false,
            border:false,
            bodyCls:'videoplayer-body',
            autoplay:false,
            controls:false,
            suggestChromeFrame:false
        });

        this.callParent([config]);

        this.on({
            scope:this,
            render:this._render,
            beforedestroy:function () {
                if (this.controlSlider)
                    delete this.controlSlider;
            },
            resize:function (panel, width, height) {
                var me = this;
                if(!me.playButton || !me.controlSlider) //Flash player is rendered currently
                    return;
                var w = me.playButton.getWidth() + me.speakerButton.getWidth()
                    + me.timeLable.getWidth() + me.fsButton.getWidth();
                w += 30;
                var videoWidth = me.video.getWidth() - w;
                if (me.controlSlider && me.controlSlider.rendered) {
                    //console.log("resize + me.controlSlider");

                    // resize the control bar width
                    if (me.controlSlider.getWidth() != videoWidth) {
                        me.controlSlider.setWidth(videoWidth);
                    }
                    me.controlSlider.setMaxValue(me.controlSlider.getWidth());
                }
                if (me.progressBar && me.progressBar.rendered) {
                    //console.log("resize + me.progressBar");
                    // resize the control bar width
                    if (me.progressBar.getWidth() != videoWidth) {
                        me.progressBar.setWidth(videoWidth);
                    }
                    //making sure the slider is aligned with progress bar
                    me.controlSlider.setWidth(me.progressBar.getWidth());
                    me.controlSlider.setMaxValue(me.progressBar.getWidth());
                    me.controlSlider.el.setLeft(me.progressBar.el.getLeft(true));
                    me.controlSlider.setValue(me.progressBar.value * me.progressBar.getWidth());
                }

                /* Comment out so that video content can be resized in fullscreen
                 * use CSS width='100%', height='100%' instead.
                 var bbar = this.getDockedItems();
                 if (bbar && bbar.length > 0) {
                 if (bbar[0].rendered)
                 height = height - bbar[0].getHeight();
                 }

                 if (this.video);
                 this.video.setSize(width, height);
                 */
            }
        });
    },

    createControlBar:function () {
        var config = this.config;

//        this.controlSlider = new RM.view.HTML5VideoSlider({
//            width: 100,
//            increment: 1,
//            minValue: 0,
//            maxValue: 100,
//            playerPanel: this,
//            videoSrc: config.src,
//            videoInfo: this.videoInfo
//        });
//        this.controlSlider.setVideo(this.video);

        this.progressBar = new Ext.ProgressBar({
            width:100,
            value:0,
            height:12,
            cls:'videoplayer-controller-progressbar',
            videoPanel:this,
            listeners:{
                resize:{
                    fn:function () {
                        this.slider.setWidth(this.getWidth());
                        this.slider.setMaxValue(this.getWidth());
                        this.slider.el.setLeft(this.el.getLeft(true));
                        this.slider.setValue(this.value * this.getWidth());
                    }
                },
                render:{
                    fn:function () {
                        var parentId = this.el.parent().id;
                        var videoPanel = this.videoPanel;

                        var parentDiv = Ext.get(parentId);
                        this.timelineIndicator = this.el.createChild({
                            tag:'div',
                            cls:'videoplayer-controller-timeline-div'
                        });

                        videoPanel.controlSlider = new RM.view.HTML5VideoSlider({
                            width:100,
                            increment:1,
                            minValue:0,
                            maxValue:100,
                            playerPanel:videoPanel,
                            videoSrc:videoPanel.config.src,
                            videoInfo:videoPanel.videoInfo,
                            cls:'videoplayer-controller-slider',
                            width:this.getWidth(),
                            left:this.left,
                            minValue:0,
                            hideLabel:true,
                            useTips:false,
                            maxValue:this.getWidth(),
                            value:0,
                            pb:this,
                            timelineIndicator:this.timelineIndicator,
                            listeners:{
                                render:{
                                    fn:function () {
                                        this.timelineIndicator.hide();
                                        this.mon(this.el, 'mousemove', function (e) {
                                            var left = e.getX() - this.el.getLeft();
                                            var maxLeft = this.getWidth() - 2 - this.timelineIndicator.getWidth();
                                            if (left > maxLeft)
                                                left = maxLeft;
                                            this.timelineIndicator.setLeft(left);
                                            if (!this.timelineIndicator.isVisible())
                                                this.timelineIndicator.show();
                                        }, this);
                                    }
                                }
                            }
                        });
                        this.ownerCt.add(videoPanel.controlSlider);
                        videoPanel.controlSlider.setVideo(this.videoPanel.video);
                        this.slider = videoPanel.controlSlider;
                    }
                }
            }
        });

        this.defaultVolume = 5;

        this.volumnSlider = new Ext.Slider({
            vertical:true,
            cls:'video-viewer-volume-slider',
            height:100,
            increment:1,
            value:this.defaultVolume,
            useTips:false,
            minValue:0,
            maxValue:10,
            listeners:{
                scope:this,
                change:this.changeVolumn
            }
        });

        var volumeLow  = {
            xtype:"component",
            cls:'videoplayer-controller-button videoplayer-controller-speaker-low-button '
        };

        var volumeHigh  = {
            xtype:"component",
            cls:'videoplayer-controller-button videoplayer-controller-speaker-high-button'
        };

        // Create a dummy <DIV> to support fullscreen view
        var tipDiv = this.body.createChild({
            tag:'div'
        });

        var me = this;
        this.volumnCtrlTip = new Ext.Tip({
            autoHide:false,
            dismissDelay:0,
            floating:true,
            width:26,
            height:150,
            minWidth:26,
            cls:"videoplayer-controller-volume",
            items:[volumeHigh, this.volumnSlider, volumeLow],
            tipDiv:tipDiv,
            listeners:{
                afterrender:function (obj) {
                    //FullScreen: Append this HTML element into dummy <DIV>
                    tipDiv.appendChild(this.getEl());
                    this.getEl().on("mouseout", function (e) {
                        var xy = e.getXY();
                        var box = this.getBox();
                        var maxX = box.x + box.width - 2;
                        var maxY = box.y + box.height;
                        if (xy[0] <= box.x || xy[0] >= maxX || xy[1] <= box.y || xy[1] >= maxY) {
                            if (this.isVisible()) this.hide();
                        }
                        me.speakerButton.removeCls('x-btn-default-toolbar-small-over');
                    }, this);
                    this.getEl().on("mouseover", function (e) {
                        me.speakerButton.addCls('x-btn-default-toolbar-small-over');
                    }, this);
                }
            }
        });

        this.playButton = new Ext.Button({
            scope:this,
            cls:'video-viewer-play-button',
            height:36,
            iconCls:"videoplayer-controller-button videoplayer-controller-play-button",
            handler:function (btn) {
                this.playOrPause();
            }
        });

        this.speakerOn = true;
        this.speakerButton = new Ext.Button({
            iconCls:"videoplayer-controller-button videoplayer-controller-speaker-unmute-button",
            volumnCtrl:this.volumnCtrlTip,
            scope:this,
            height:36,
            cls:'video-viewer-volume-button',
            handler:this.volumnOnOff,
            listeners:{
                afterrender:function (obj) {
                    this.getEl().on("mouseover", function (e, obj, e2) {
                        if (this.volumnCtrl.isVisible())
                            return;

                        if (this.volumnCtrl.rendered) {
                            this.volumnCtrl.show();
                            var p = e.getXY();
                            p[1] = this.el.getY() - this.volumnCtrl.getHeight();
                            p[0] = this.el.getX() - (this.volumnCtrl.getWidth() - this.getWidth()) / 2;
                            if (p[0] < 0) p[0] = 0;
                            this.volumnCtrl.showAt(p);
                        }
                        else {
                            this.volumnCtrl.showAt(-1000, -1000);
                            var p = e.getXY();
                            p[1] = this.el.getY() - this.volumnCtrl.getHeight();
                            p[0] = this.el.getX() - (this.volumnCtrl.getWidth() - this.getWidth()) / 2;
                            if (p[0] < 0) p[0] = 0;
                            this.volumnCtrl.showAt(p);
                        }
                    }, this);

                    this.getEl().on("mouseout", function (e) {
                        var xy = e.getXY();
                        var box = this.getBox();
                        var maxX = box.x + box.width;
                        var maxY = box.y + box.height - 4;
                        if (xy[0] <= box.x || xy[0] >= maxX || xy[1] >= maxY) {
                            this.volumnCtrl.hide();
                        }
                    }, this);
                }
            }
        });

        var videoDuration = RM.view.HTML5VideoUtil.getVideoDuration(this);
        if (videoDuration) {
            this.durationLabel = this.getTimeLabel(videoDuration, true);
        } else {
            this.durationLabel = "--:--"
        }
        var labelText = this.getTimeLabel(0);
        var labelWidth = 72; //00:00
        if (this.durationLabel.length > 5) //00:00:00
            labelWidth = 90;
        this.timeLable = new Ext.form.Label({
            cls:'video-viewer-time-label',
            text:labelText,
            width:labelWidth
        });

        //Fullscreen button
        this.fsButton = new Ext.Button({
            scope:this,
            height:36,
            cls:'video-viewer-full-screen-btn',
            iconCls:"videoplayer-controller-button videoplayer-controller-maximize-button",
            handler:this.enterFullscreen
        });

        var controlItems = [
            this.playButton,
            { xtype:'tbspacer', width:10},
            this.progressBar,
            //this.controlSlider,
            { xtype:'tbspacer', width:10},
            this.timeLable,
            { xtype:'tbspacer', width:10},
            this.speakerButton,
            this.fsButton];

        var toolbar = Ext.create('Ext.toolbar.Toolbar', {
            cls:'videoplayer-toolbar',
            items:controlItems,
            height:36
        });

        this.vidHtml5ToolbarId = toolbar.id;
        this.items.add(toolbar);
    },

    canPlayVideoFormats:function (streamInfo) {
        var video = this.video.dom; //document.createElement('video');
        var canPlay = false;

        if (video.canPlayType) {
            // <video> tag is supported by browser!
            for (var i = 0; i < streamInfo.length && !canPlay; i++) {
                var info = streamInfo[i];
                canPlay = video.canPlayType(info.type);
            }
        }
        video = null;
        return canPlay;
    },

    replaceHtml5WithFlash:function () {
        if(this.isDestroyed)
            return;
        this.video.remove();
        delete this.video;
        this.isUsingFlashFallback = true;
        if (this.fallbackHTML) {
            this.body.createChild(this.fallbackHTML);
        }
        else {
            this.fireEvent('playbackError', this);
        }
    },

    _render:function () {

        this.createHtml5VideoControl();
        //Use iOS native controls, Ext-js Controls don't work well with iOS.
        if (Ext.is.iOS) {
            return;
        }

        this.isHtml5VideoSupported = !!this.video.dom.canPlayType;
        var canPlay = this.canPlayVideoFormats(this.videoInfo.streamInfo);

        /* uncomment to test flash back on HTML5 browsers*/
        // this.isHtml5VideoSupported = canPlay = false;
        var me = this;

        if (this.isHtml5VideoSupported) {
            if (canPlay) {
                this.createControlBar();
                this.video.on({
                    scope:this,
                    timeupdate:this.timeUpdate,
                    loadeddata:this.videoLoaded,
                    ended:this.ended
                });
                //this.relayEvents(this.video, ['canplay', 'error']);
                this.video.on({
                    scope:this,
                    "error":function (e) {
                        // Ignore any 'fake' error generate by Firefox 3.6
                        var error;
                        if (e.currentTarget) {
                            error = e.currentTarget.error;
                        }
                        else if (e.getTarget != null) { // IE consideration
                            error = e.getTarget().error;
                        }
                        if (error && error.code && (error.code != error.MEDIA_ERR_ABORTED)) {
                            //Remove the toolbar
                            if (this.vidHtml5ToolbarId != "") {
                                this.remove(this.vidHtml5ToolbarId);
                            }
                            this.replaceHtml5WithFlash();
                        }
                    }
                });
                Ext.Array.each(this.video.dom.childNodes, function (videoChildNode) {
                    if (videoChildNode.localName == "source") {
                        videoChildNode.onerror = function () {
                            var networkState = me.video.dom.networkState;
                            if (networkState == HTMLMediaElement.NETWORK_NO_SOURCE) {
                                //Remove the toolbar
                                if (me.vidHtml5ToolbarId != "") {
                                    me.remove(me.vidHtml5ToolbarId);
                                }
                                me.replaceHtml5WithFlash();
                            }
                        };
                    }
                });
            }
            else {
                // The browser supports html5 video but cannot play current videos
                this.replaceHtml5WithFlash();
            }
        }
        else {
            this.replaceHtml5WithFlash();
        }
    },

    createHtml5VideoControl:function () {

        var fallback = '';

        if (!this.fallbackHTML) {
            if (Ext.isIE && this.suggestChromeFrame) {
                /* chromeframe requires that your site have a special tag in the header
                 * see http://code.google.com/chrome/chromeframe/ for details
                 */
                fallback += 'Get Google Chrome Frame for IE';
            } else if (Ext.isChrome) {
                fallback += 'Upgrade Chrome';
            } else if (Ext.isGecko) {
                fallback += 'Upgrade to Firefox 3.5 or above';
            }
        }

        //var size = this.getSize();
        var features = 'poster, start, loopstart, loopend, playcount, autobuffer, preload, loop';
        if (Ext.is.iOS) {  //Use iOS native controls, Ext-js Controls don't work well with iOS.
            features += ", controls"
        }
        var cfg = Ext.copyTo({
            tag:'video',
            //width : size.width,
            //height: size.height,
            style:{
                width:'100%',
                height:'100%'
            }
        }, this, features);

        /* just having the params exist enables them */
        if (this.autoplay) cfg.autoplay = 1;
        if (this.controls) cfg.controls = 1;

        /* handle multiple sources */
        if (Ext.isArray(this.src)) {
            cfg.children = [];

            for (var i = 0, len = this.src.length; i < len; i++) {
                if (!Ext.isObject(this.src[i])) {
                    throw "source list passed to html5video panel must be an array of objects";
                }
                cfg.children.push(
                    Ext.applyIf({
                        tag:'source'
                    }, this.src[i]));
            }

            cfg.children.push({
                html:fallback
            });
        } else {
            cfg.src = this.src;
            cfg.html = fallback;
        }
        delete this.video;
        this.video = this.body.createChild(cfg);
    },

    setStoryboardInfo:function (info) {
        this.controlSlider.setStoryboardInfo(info);
    },

    playOrPause:function (isEnd, flashPlayerId) {

        if (this.isUsingFlashFallback) { // if flash player
            var flashPlayer = Ext.get(flashPlayerId);
            flashPlayer.dom.playVideo();
        } else {  //If html5 player
            var player = this.video.dom;
            var btn = this.playButton;
            if (isEnd) {
                btn.setIconCls("videoplayer-controller-button videoplayer-controller-play-button");
                player.currentTime = 0;
                player.pause();
            } else if (player.paused) {
                player.play();
                btn.setIconCls("videoplayer-controller-button videoplayer-controller-pause-button");
            } else {
                player.pause();
                btn.setIconCls("videoplayer-controller-button videoplayer-controller-play-button");
            }
        }

    },

    //Fullscreen
    enterFullscreen:function () {
        this.toggleFullScreen();
    },

    onFullScreenChanged:function (inFullScreen) {
        var btn = this.fsButton;
        if (inFullScreen) {
            this.dockedItem = this.getDockedItems()[0];
            //TODO show/hide toolbar
            //.setVisible(true); //x-docked-noborder-bottom
            //this.removeDocked(this.dockedItem, false);
            btn.setIconCls("videoplayer-controller-button videoplayer-controller-unmaximize-button");
        } else {
            btn.setIconCls("videoplayer-controller-button videoplayer-controller-maximize-button");
            //this.addDocked(this.dockedItem);
        }
    },

    changeVolumn:function (e, size) {
        var player = this.video.dom;
        var vol = size / e.maxValue;
        player.volume = vol;

        if (vol == 0) {
            this.speakerOn = false;
            this.speakerButton.setIconCls("videoplayer-controller-button videoplayer-controller-speaker-mute-button");
        } else if (!this.speakerOn) {
            this.speakerOn = true;
            this.speakerButton.setIconCls("videoplayer-controller-button videoplayer-controller-speaker-unmute-button");
        }
    },

    volumnOnOff:function (e) {
        this.speakerOn = !this.speakerOn;
        var btn = this.speakerButton;
        var player = this.video.dom;

        if (this.speakerOn) {
            // Set to current volume or default volume
            this.volumnSlider.setValue(this.defaultVolume);
            player.volume = this.defaultVolume / this.volumnSlider.maxValue;
            btn.setIconCls("videoplayer-controller-button videoplayer-controller-speaker-unmute-button");
        } else {
            // Save current volume
            this.defaultVolume = this.volumnSlider.getValue();
            player.volume = 0;
            this.volumnSlider.setValue(0);
            btn.setIconCls("videoplayer-controller-button videoplayer-controller-speaker-mute-button");
        }
    },

    videoLoaded:function () {
        var videoDuration = RM.view.HTML5VideoUtil.getVideoDuration(this);
        if (videoDuration) {
            this.durationLabel = this.getTimeLabel(videoDuration, true);
        }
        this.fireEvent('playerInitalized', this);
    },

    timeUpdate:function (e) {
        this.controlSlider.syncValue();
        var t;
        if (e.target == null) // IE 9
            t = this.video.dom.currentTime;
        else
            t = e.target.currentTime
        this.timeLable.setText(this.getTimeLabel(t));
    },

    getTimeLabel:function (t, isSetDurationLabel) {
        var h = Math.floor(t / 3600);
        t = t % 3600;
        var m = Math.floor(t / 60);
        t = Math.floor(t % 60);

        /* pad the minute and second strings to two digits */
        if (t.toString().length < 2) t = "0" + t;
        if (m.toString().length < 2) m = "0" + m;

        var label;
        if (h > 0)
            label = Ext.String.format("{0}:{1}:{2}", h, m, t);
        else
            label = Ext.String.format("{0}:{1}", m, t);

        if (isSetDurationLabel)
            return label;
        else
            return label + "/" + this.durationLabel;
    },

    ended:function (e) {
        this.playOrPause(true);
    }

});


/* ***************************************************************************** */
/*                          RM.view.HTML5VideoSlider                             */
/* ***************************************************************************** */
Ext.define('RM.view.HTML5VideoSlider', {

    extend:'Ext.Slider',
    alias:'widget.rmHTML5VideoSlider',
    useTips:false,

    constructor:function (config) {
        Ext.applyIf(config, {
            width:'100%',
            video:null,
            mousedown:false
        });

        this.config = config;
        this.videoInfo = config.videoInfo;
        this.storyboardInfo = this.videoInfo.storyboard;

        this.callParent([config]);

        this.initStoryboardInfo();

        this.on({
            scope:this,
            drag:this.seekVideo,
            changecomplete:this.seekVideo,
            beforedestroy:function () {
                if (this.tip)
                    delete this.tip;
                if (this.video)
                    delete this.video;
            }
        });
    },

    setVideo:function (video) {
        this.video = video;
        this.video.on({
            scope:this,
            durationchange:this.resetControlBar
        });
    },

    onRender:function () {
        this.callParent(arguments);

        //Fullscreen: Create a dummy <DIV> for tooltip
        var playerPanel = this.config.playerPanel;
        var tipDiv = playerPanel.body.createChild({
            tag:'div'
        });

        // Create tooltip inside the dummy <DIV>
        this.tip = this.createTooltip(tipDiv);

        this.getEl().on('mousemove', function (e) {
            if (this.mousedown) return;

            if (!this.storyboardInfo || this.storyboardInfo.length == 0)
                return;

            var p = e.getXY();
            this.xOffset = p[0] - this.getEl().getX();
            var t = this.getCurrentTime(this.xOffset, RM.view.HTML5VideoUtil.getVideoDuration(this));
            var tip = this.tip;
            if (!this.playingTime || Math.abs(t - this.playingTime) > 1 || !tip.isVisible()) {
                this.playingTime = t;
                p[1] = this.el.getY() - tip.height; //100
                p[0] = p[0] - 19;
                if (p[0] < 0) p[0] = 0;
                try {
                    tip.showAt(p);
                } catch (err) {
//                    tip.showAt(p);
                }
                if (this.tip.isVisible()) {
                    // ExtJS 4 only: If tooltip is visible, the showAt() function does not fire beforeShow event
                    this.preview();
                }
            }

        }, this);

        this.getEl().on('mouseout', function (e) {
            if (this.tip.isVisible())
                this.tip.hide();
            this.timelineIndicator.hide();
        }, this);

        /*
         this.getEl().on('mousedown', function (e) {
         //        this.mousedown = true;
         //        if (this.tip.isVisible())
         //            this.tip.hide();
         }, this);
         */

        this.getEl().on('mouseup', function (e) {
            this.mousedown = false;
        }, this);
    },

    createTooltip:function (tipDiv) {

        var tipItems = [];
        var tipHtml = null;
        if (this.storyboardInfo) {
            tipHtml = this.getStoryboardImage(0);
        }

        var tip = new Ext.ToolTip({
            html:tipHtml,
            autoHide:false,
            dismissDelay:0,
            shadow:"false",
            cls:"videoplayer-controller-thumbnail-box",
            bodyCls:"videoplayer-controller-thumbnail-box-body",
            floating:true,
            showDelay:0,
            hidden:true,
            autoHeight:true,
            autoWidth:true,
            width:160, //TODO can we get the thumbnail size from backend?
            height:115, // 90(image) + 30 (label)
            anchor:'bottom',
            anchorToTarget:false,
            anchorOffset:0, // center the anchor on the tooltip
            imgIndex:0,
            items:tipItems,
            tipDiv:tipDiv,
            listeners:{
                afterrender:function (obj) {
                    if (tipDiv)
                        tipDiv.appendChild(this.getEl());
                },
                beforeshow:{
                    fn:this.preview,
                    scope:this
                }
            }
        });

        return tip;
    },

    preview:function () {
        var tip = this.tip;
        var t = this.getCurrentTime(this.xOffset, RM.view.HTML5VideoUtil.getVideoDuration(this));
        var html = this.getStoryboardImage(t);
        tip.update(html);
    },

    // Video related functions
    resetControlBar:function (e) {
        this.setValue(0);
    },

    seekVideo:function (e) {
        this.changingValue = true;
        if (this.video) {
            var video = this.video.dom;
            if (this.tip.isVisible() && this.playingTime)
                video.currentTime = this.playingTime;
            else
                video.currentTime = this.getCurrentTime(this.getValue(), video.duration);
        }
    },

    getCurrentTime:function (offset, duration) {
        return offset / this.getWidth() * duration;
    },

    syncValue:function () {
        if (this.video && !this.dragging) {
            var video = this.video.dom;
            var value = video.currentTime / video.duration * this.getWidth(); //this.pb.el.getWidth(true); //
            if (this.changingValue) {
                this.changingValue = false;
            } else {
                this.setValue(value, true);
            }
            this.pb.updateProgress(this.getValue() / this.getWidth()); //this.pb.el.getWidth(true));//
        }
    },

    //Storyboard related functions
    /**
     * Convert storyboardInfo time code to milliseconds
     */
    setStoryboardInfo:function (info) {
        this.storyboardInfo = info;
        if (info && info.length > 0) {
            this.initStoryboardInfo();
            this.tip.update(this.getStoryboardImage(0));
        } else {
            if (window.console)
                console.log("storyboard info not available.");
        }
    },

    initStoryboardInfo:function () {
        var frameRate = this.videoInfo.metadata["Frame Rate"];
        var duration = RM.view.HTML5VideoUtil.getVideoDuration(this);
        Ext.each(this.storyboardInfo, function (info) {
            info.time = RM.view.HTML5VideoUtil.getMillisecondsFromTimecode(info.timeCode, frameRate);
            info.displayTime = RM.view.HTML5VideoUtil.getDisplayTimeFromTimecode(info.timeCode, frameRate, duration);
        }, this);
    },

    getStoryboardImage:function (time) {
        var infos = this.storyboardInfo;
        if (!infos || infos.length == 0) return '';

        var info = infos[0];
        time = time * 1000;
        for (var i = 1; i < infos.length; i++) {
            if (info.time >= time) break;

            nextInfo = infos[i];
            if (nextInfo.time > time) {
                if (nextInfo.time - time < time - info.time) info = nextInfo;
                break;
            }
            info = nextInfo;
        }

        var url = info.frameUrl;
        //        if (window.console)
        //            console.log("time(ms): " + time + "==>" + info.timeCode + "=" + info.time);
        //return "<img src='" + url + "'><div class='videoplayer-controller-thumbnail-label'>" + info.displayTime + "</div>";
        return "<div class='videoplayer-controller-thumbnail-label'>" + info.displayTime + "</div>"
            + "<img src='" + url + "'>";
    }

});
Ext.namespace("RM.Strings.Viewer.VideoViewer");
Ext.apply(RM.Strings.Viewer.VideoViewer, {
//Ext.apply(xcp.Strings.viewer.impl.VideoViewer, {
    
    // VideoViewer
    getVideoInfoError:"Unable to get video information",
    playbackError:"Content not yet available. Please try again. "

});

/* ivf_videoviewer_lib/content/xcp/viewer/impl/VideoViewer.js */

Ext.define('xcp.viewer.impl.VideoViewer', 
{
    extend: 'xcp.viewer.impl.ViewerObject',

    constructor:function(elementId) {
        var config = {};
        this.elementId = config.elementId = elementId;
        config.providerName = "VideoViewer";
        this.callParent([config]);
    },
    
    postRender : function(json)
    {
        xcp.util.IvfUtil.debug("postRender(): Rendering VideoViewer");
        
        var imageHandlerFunction =  this.m_elementId + "_initializerEvent";
        var me = this;
        window[imageHandlerFunction] = function(){
            //Remove the temorary <img> tag which used for trigger this function @onLoad.
            var loadIndicatorImage = Ext.get(me.m_elementId + "_img");
            if(loadIndicatorImage == null){
                return;
            }
            loadIndicatorImage.remove();

            me.videoViewer = new RM.view.VideoViewer({
               videoInfo: me.videoInfo,
               videoServiceUrl: me.videoServiceUrl,
               flashViewer: me.flashViewer,
               flashPlaybackFormats: me.flashPlaybackFormats
            });
            me.videoViewer.setRenderContainer(me.m_elementId);
            
         }
        return "";
    },
    
    renderControl : function(tagName, attrList, paramList)
    {
        var viewerId = this.m_elementId;

        var imageHandlerFunction =  this.m_elementId + "_initializerEvent";

        var htmlContent = "<" + tagName + " id='"+viewerId+"' height='100%' width='100%'>";
        htmlContent += "\<img id='"+viewerId+"_img' src= '"+Ext.BLANK_IMAGE_URL+"' height='0' width='0' onload='"+imageHandlerFunction+"()'/>";
        htmlContent += "</" + tagName + ">";

        if(paramList)
        {
            var paramName, paramValue;
            var eventHandlerName;

            for(var i=0; i < paramList.length; i++)
            {
                paramName = paramList[i].name;
                paramValue = paramList[i].value;
                if (paramName == 'videoInfo')
                {
                    this.videoInfo = eval('(' + paramValue + ')');
                }
                if( paramName == 'language'){
                    this.locale = paramValue;
                }
                else if( paramName == 'videoServiceUrl'){
                    this.videoServiceUrl = paramValue;
                }
                else if( paramName == 'flashViewer'){
                    this.flashViewer = paramValue;
                }
                else if (paramName == 'flashPlaybackFormats')
                {
                    this.flashPlaybackFormats = paramValue.split(",");
                }
                /*
                else if(paramName == 'eventhandler')
                {
                    this.eventHandlerName = viewerId + "_" + paramValue;
                    paramValue = this.eventHandlerName;
                    window[this.eventHandlerName] = function(eventId, msg) {
                        ivfclient.handleViewerEvent(widgetId,  eventId, msg);
                    };
                }
                */
            }
        }
        return htmlContent;
    },

    cleanup: function() {
        if (this.videoViewer)
            this.videoViewer.destroyViewer();
    }
    
});  


/* xcp_error_message_window/content/xcp/widget/window/ErrorMessageWindow.js */

// ErrorMessageWindow_test.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * @class xcp.widget.window.ErrorMessageWindow
 * @extends Ext.container.Container
 * 
 */
Ext.define("xcp.widget.window.ErrorMessageWindow", {
    extend: "Ext.container.Container",
    alias: "widget.xcp_error_message_window",
    minHeight: 25,
    config: {
        message:""
    },
    
    constructor: function(config) {
    	config = config || {};
    	if (typeof config.iconCls === 'undefined'){
    		// Error icon is the default.
    		config.iconCls = 'xcp-notification-error-icon';
    	}
    	this.initConfig(config);
    	
        xcp.widget.window.ErrorMessageWindow.superclass.constructor.call(this, Ext.apply(config, {
            layout: 'column',
            cls: 'xcp-notification-error',
            items: [{
                xtype : 'box',
                width : 16,
                cls : 'xcp-statusicon ' + config.iconCls,
                margin: '0 10 0 0'
            }, {
                xtype: 'component',
                columnWidth: 1.0,
                html: Ext.util.Format.stripScripts(config.message || ""), // allow rich text.
                margin: '0 10 0 0'
            }, {
                listeners: {
                    'afterrender': function(component) {
                        component.mon(component.getEl(), 'click', function() {
                            var ownerCt = component.ownerCt;
                            ownerCt.ownerCt.remove(ownerCt);
                        }, component);
                    }
                },
                xtype : 'box',
                width : 16,
                cls : 'xcp-statusicon xcp-notify-close-icon',
                overCls : 'xcp-notify-close-icon-hover',
                margin : '0 10 0 5'
            }]
        }));
    },

    renderMe: function(container) {
    	container.insert(0, this);
    }
});
/* xcp_notification_window/content/xcp/widget/window/NotificationWindow.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// NotificationWindow.js

/**
 * @class xcp.widget.window.NotificationWindow
 * @extends Ext.container.Container
 *
 * config.progress (optional; false default) -- if true, progress notification, else completion.
 */
Ext.define("xcp.widget.window.NotificationWindow", {
    extend: "Ext.container.Container",
    alias: "widget.xcp_notification_window",

    minWidth: 325,
    minHeight: 75,
    maxWidth: 450,

    inUpdateHeight: false,
    config: {
        message:"",
        progress: false
    },
    getCls: function(){
        return "xcp-notification-"+ (this.config.progress ? "progress" : "complete");
    },
    constructor: function(config) {
        this.initConfig(config);
        this.callParent([Ext.apply(config, {
            layout: 'column',
            width: this.maxWidth,
            cls: this.getCls(),
            items: [{
                xtype : 'container',
                cls : 'xcp-statusicon ' +this.getCls()+'-icon',
                margin: '0 20 0 0'
            }, {
                //using label to get htmlEncoding for free
                xtype: 'label',
                columnWidth: 1.0,
                text: config.message
            }]
        })]);
    },

    renderMe: function(container) {
    	if (container == null)
    		container = Ext.get("_topPageContainer");
    	if (container instanceof Ext.Component)
    		container = container.getEl();

        console.log("NotificationWindow.renderMe container is found"+(container != null));
    	this.render(container);

    	var panelEl = this.getEl();
        var panelWidth = panelEl.getWidth();
        var panelHeight = panelEl.getHeight();

        panelEl.setVisible(false);

        var panelX = container.getX(true) + (container.getWidth() / 2) - (panelWidth / 2);
        panelEl.setSize(panelWidth, panelHeight);
        panelEl.position('absolute', 9999, panelX, 1);
        // This has to be set because ExtJS will set it such that it offsets the page position.
        // Setting this to '0px' will make sure it is truly at the top of the page.
        panelEl.setStyle('top', '0px');

        console.log("NotificationWindow.renderMe before panelEl.slideIn");
        panelEl.slideIn("t", {duration:500, easing:"easeIn"});
        console.log("NotificationWindow.renderMe after panelEl.slideIn");
        panelEl.animate({duration: 3000});
        if (!this.config.progress)
            this.close();
    },

    close: function(){
        var panelEl = this.getEl();
        panelEl.ghost("t", {duration:1000, remove:true});
    },

    /**
     * Update message and optionally turn progress into completion
     */
    updateNotification: function(message, bComplete){
        var el;
        var label = this.down("label");  // $NON-NLS-1$
        if (label){
            label.setText(message);
        }
        if (bComplete){
            var oldCls = this.getCls();
            this.config.progress=false;
            el = this.getEl();
            if (el){
                el.addCls(this.getCls());
                el.removeCls(oldCls);
            }
            var icon = this.getEl().down(".xcp-statusicon");
            if (icon){
                icon.removeCls(oldCls+'-icon');
                icon.addCls(this.getCls()+'-icon');
            }
            Ext.defer(this.close,2000,this);
        }
    }

});


/**   Progress and Notification helper -- Auto show progress after delay... allows update of progress &
 *         replace with completion message.
 */
Ext.define("xcp.ProgressNotifier", {
    extend: "Ext.Base",
    progressTimeout: 2000,

    timer: null,
    component: null,
    progressWindow: null,

    constructor: function(component, progressMessage){
        this.callParent(arguments);
        this.component = component;
        this.updateProgress(progressMessage);
    },

    destroy: function(){
        this.component=undefined;
        this.endOperation();
    },

    startOperation: function(progressMessage/*optional*/){
        if (progressMessage)
            this.updateProgress(progressMessage);
        this.timer = setTimeout(Ext.bind(this.showProgress, this), this.progressTimeout);
    },
    endOperation: function(bKeepForCompletion){
        if (this.timer){
            clearTimeout(this.timer);
            this.timer=null;
        }
        if (!bKeepForCompletion && this.progressWindow){
            this.progressWindow.close();
            this.progressWindow=undefined;
        }
    },
    updateProgress: function(progressMessage){
        this.progressMessage = progressMessage;
        if (this.progressWindow){
            this.progressWindow.updateNotification(progressMessage);   // does html encode for us

        }
    },
    showProgress: function(){
        this.progressWindow=xcp.core.FeedbackManager.showFeedback(this.component, "", this.progressMessage, "notifications", {progress:true});
    },
    showSuccess:function(completionMessage){
        this.endOperation(true);
        if (this.progressWindow){
            this.progressWindow.updateNotification(completionMessage, true);
            this.progressWindow = null;
        }else{
            xcp.core.FeedbackManager.showFeedback(this.component, "", completionMessage, "notifications");
        }
    }

});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.core.FeedbackManager");

Ext.apply(xcp.Strings.core.FeedbackManager, {
    serviceErrorFeedbackMessage:  "An error occurred while performing the requested operation. Please try again.",
    serviceErrorDetails:  "Details",
    serviceErrorCode:      "Error code:",
    connectionTimeoutMessage: "The requested operation has timed out."
});
/* xcp_feedback_lib/content/xcp/core/FeedbackManager.js */

/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

(function() {

/**
 * Gets the component configuration for showing the feedback of an service error response.
 *
 * @param json The error response in JSON
 */
function getServiceErrorFeedbackConfig(json) {
    var topElCls = "xcp-notify-server-errors";
    var toggleCls = "xcp-notify-toggle";
    var expandCls = "xcp-notify-expand-icon";
    var collapseCls = "xcp-notify-collapse-icon";
    var detailsCls = "xcp-notify-server-errors-details";

    var strCls = xcp.Strings.core.FeedbackManager;
    var markup = [
        "<div>",
        strCls.serviceErrorFeedbackMessage,
        "</div>"];

    if (json.errorCode || json.message || json.detailedMessage) {
        markup.push("<table class='"),  // $NON-NLS-1$ 
        markup.push(topElCls);
        markup.push("'><tr><td class='");
        markup.push(toggleCls);
        markup.push(" ");
        markup.push(expandCls);
        markup.push("'></td>");
        markup.push("<td style='width:10px'></td><td>");
        markup.push(strCls.serviceErrorDetails);
        markup.push("</td></tr>");

        markup.push("<tr class='");  // $NON-NLS-1$ 
        markup.push(detailsCls);
        markup.push("' style='display:none;'>");
        markup.push("<td>&nbsp;</td><td>&nbsp;</td><td>");

        var detailsMarkup = [];
        if (json.message) {
            detailsMarkup.push(json.message);
        }
        if ((json.errorCode || json.detailedMessage) && detailsMarkup.length > 0) {
            detailsMarkup.push("<br><br>");
        }
        if (json.errorCode) {
            detailsMarkup.push(strCls.serviceErrorCode);
            detailsMarkup.push("&nbsp;");
            detailsMarkup.push(json.errorCode);
        }
        if (json.detailedMessage) {
            if (detailsMarkup.length > 0) {
                detailsMarkup.push("<br>");
            }
            detailsMarkup.push(json.detailedMessage);
        }
        if (json.operationErrors)
        {
            detailsMarkup.push(":<br>");
            for (var operationFailure in json.operationErrors)
            {
                var failure = json.operationErrors[operationFailure];
                detailsMarkup.push("<br>")   ;
                detailsMarkup.push(failure.errorMessage) ;
            }
        }
        markup.push(detailsMarkup.join(''));
        markup.push("</td></tr></table>");
    }

    return {
        message: markup.join(''),
        listeners: {
            'afterlayout': function(container, layout) {
                var containerEl = container.el;
                var toggleEl= containerEl.query("." + topElCls + " ." + toggleCls);
                if (toggleEl) {
                    var toggle = Ext.get(toggleEl);
                    container.mon(toggle, "click", function() {
                        var detailsEl = containerEl.query("." + detailsCls);
                        if (detailsEl && detailsEl.length > 0) {
                            var style = detailsEl[0].style;
                            if (style.display === "none") {
                                toggle.removeCls(expandCls);
                                toggle.addCls(collapseCls);
                                style.display = "table-row";
                            } else {
                                style.display = "none" ;
                                toggle.removeCls(collapseCls);
                                toggle.addCls(expandCls);
                            }
                            container.doLayout();
                        }
                    });
                }
            },
            single:true
        }
    }
}

/**
 * Gets the component configuration for showing the feedback of an service validation error response.
 *
 * @param json The error response in JSON
 */
function getValidationErrorFeedbackConfig(json, showCloseIcon) {
    var message = !Ext.isEmpty(json.validationMessage) ? json.validationMessage : json.detailedMessage;
    message = !Ext.isEmpty(message) ? message : json.message;
    message = !Ext.isEmpty(message) ? message.concat("<br>") : "";
    if(showCloseIcon === undefined) {
        showCloseIcon = false;
    }
    return {
        message: message,
        showCloseIcon: showCloseIcon
    }
}

/**
 * @class xcp.core.FeedbackManager
 *
 */
Ext.define("xcp.core.FeedbackManager", {
    singleton: true,
    config: {
        defaultFeedbackTypeComponentMapping: {
            "systemErrors":"xcp_error_message_window",
            "progress":"xcp_progress_window",
            "notifications":"xcp_notification_window",
            "validationErrors":"xcp_validation_error_window",
            "systemWarning":"xcp_error_message_window"
        }
    },

    HTTP_404_ERROR_PAGE_NAME: "page_not_found",

    constructor: function(config) {
        this.initConfig(config);
        this.callParent(arguments);
    },
    /**
     * Show feedback in the nearest relevant feedback container
     * @param component source of the user feedback
     * @param messageTitle title of the feedback message
     * @param message text to display as feedback
     * @param feedbackType indicates what type of feedback to display.  Valid values are "systemErrors", "notifications",
     *        "validationErrors", "systemWarning" or any registered feedback type
     * @param feedbackComponentConfig optional configuration for the feedback component
     * @param feedbackComponentXType optional value indicating what component to use as the feedback component.  The
     *        component must implement the setText and setTitle methods.  If no value is specified, the default
     *        component xType for the feedback type is used.
     */
    showFeedback: function(component, messageTitle, message, feedbackType, feedbackComponentConfig, feedbackComponentXType) {
        console.log("FeedbackManager.showFeedback starts");
        var container = null;
        var feedbackContainer = null;
        var feedbackMapping = xcp.core.FeedbackManager.getDefaultFeedbackTypeComponentMapping();
        var feedbackWindow = null;
        var feedbackXType = null;

        // Find a feedback container which accepts the requested type of feedback
        if (component) {
            if (component.isXType('container', false)) {
                container = component;
            } else {
                container = component.ownerCt;
            }
        }
        container = xcp.core.FeedbackManager.findNextFeedbackContainer(container);
        while (container != null) {
            if (container.isFeedbackTypeSupported(feedbackType)) {
                feedbackContainer = container;
                break;
            }
            container = xcp.core.FeedbackManager.findNextFeedbackContainer(container.ownerCt);
        }

        if (!feedbackContainer) {
        	// Top page by default.
        	feedbackContainer = Ext.getCmp("_topPageContainer");
        }

        console.log("FeedbackManager feedbackContainer is found: "+(feedbackContainer != null));
        // Determine the type of feedback window that should be created
        if (feedbackComponentXType) {
            feedbackXType = feedbackComponentXType;
        } else {
            feedbackXType = feedbackMapping[feedbackType];
        }

        // Create an instance of the feedback window
        feedbackComponentConfig = feedbackComponentConfig ? feedbackComponentConfig : {};
        feedbackComponentConfig = Ext.applyIf(feedbackComponentConfig, {'message': message});
        if (feedbackType == 'validationErrors') {
            this.clearFeedback(feedbackContainer, this.defaultFeedbackTypeComponentMapping.validationErrors, false);
        } else if (feedbackType == 'systemWarning') {
        	Ext.apply(feedbackComponentConfig, {'iconCls' : 'xcp-notification-warning-icon'});
        }
        feedbackWindow = Ext.create('widget.' + feedbackXType, feedbackComponentConfig);

        feedbackWindow.renderMe(feedbackContainer);
        console.log("FeedbackManager feedbackWindow created");
        return feedbackWindow;
    },
    /**
     * Clears the feedback of the specified type
     * @param component source of the user feedback
     * @param feedbackType type of feedback to clear
     * @param all optional parameter indicating whether the feedback type should be cleared from all feedback containers
     *        starting from nearest feedback container.  Defaults to false, implying that only the feedback from the
     *        nearest feedback container is cleared
     */
    clearFeedback: function(component, feedbackType, all) {
        if(!all)
        {
            var compArray = component.query(feedbackType);
            var len = compArray.length;
            for (var c = 0; c < len ; c++ )
                component.remove(compArray[c]);
        }
    },
    /**
     * Registers additional feedback types for display
     * @param feedbackType name of the feedback type
     * @param componentXType xtype of the component to use as the default component
     */
    registerFeedbackType: function(feedbackType, componentXType) {
        // TBD
    },
    /**
     * Finds the next feedback container starting with the passed in container
     * @param container starting point for feedback container search
     */
    findNextFeedbackContainer: function(container) {
        var feedbackContainer = null;

        while (container != null) {
            if (container.isXcpFeedbackContainer) {
                feedbackContainer = container;
                break;
            }
            container = container.ownerCt;
        }

        return feedbackContainer;
    },

    /**
     * Show 500x server errors to the feedback component.
     * This method is automatically invoked when a service error occurred.
     * The original XHR request option can have "feedbackContainer" specified for the feedback container instance.
     *
     * @param response  The error response from the request for Ext.data.Connection
     * @param options   The options for the request for Ext.data.Connection
     */
    showServiceErrorResponse: function(response, options) {
        if(response.status == 0 && Ext.isEmpty(response.responseText)) {
            response.responseText = "{\"message\": \""+ xcp.Strings.core.FeedbackManager.connectionTimeoutMessage + "\"}";
        }
        else {
            var contextType = response.getResponseHeader("Content-Type");
            if (!Ext.isGecko && (!contextType || contextType.indexOf("application/json") < 0)) {  // $NON-NLS-1$
                // only errors in JSON are handled.
                // Note:  Firefox does not put application/json on Accept request header, so server sets
                // response Content-Type header to 'text/html'.  But the service layer always
                // serializes ServiceExceptions to JSON, so we want to force JSON decoding in this case.
                return;
            }
        }
        try {
            var json = Ext.JSON.decode(response.responseText);
            if ('E_CORE_VALIDATION_FAILED' == json.errorCode) {
                //get widget by xcp id
                var getWidgetByXcpId = function(container, xcpId) {
                    var componentQueryStr = "component[xcpId='" + xcpId + "']", component;
                    if (container instanceof Ext.container.Container) {
                        component = container.query(componentQueryStr);
                        if (!component || component.length == 0) {
                            //fallback to name property
                            componentQueryStr = "component[name='" + xcpId + "']";
                            component = container.query(componentQueryStr);
                        }
                        if (component && component.length > 0) {
                            return component[0];
                        }
                    }

                    var items = container.items;
                    if (items) {
                        if (!Ext.isArray(items)) {
                            items = [items];
                        }
                        for (var i = 0; i < items.length; i++) {
                            component = getWidgetByXcpId(items[i], xcpId);
                            if (component) {
                                return component;
                            }
                        }
                    }
                    return null;
                };

                //format the field eror message and mark the widget invalid
                var processError = function(container, fieldName, fieldErrorMsg, xcpIds) {
                    var label = "", formattedMsg = "", i, widget;
                    if (!Ext.isEmpty(fieldErrorMsg)) {
                        for (i = 0; i <xcpIds.length; i++) {
                            widget = getWidgetByXcpId(container, xcpIds[i]);
                            if (widget) {
                                widget.markInvalid(fieldErrorMsg);
                                if (!Ext.isEmpty(widget.getFieldLabel())) {
                                    //widget has label
                                    label = label.concat(widget.getFieldLabel(), ", ");
                                }
                                else {
                                    //widget does not have label, display its xcpId
                                    label = label.concat(xcpIds[i], ", ");
                                }
                            }
                            else {
                                label = label.concat(xcpIds[i], ", ");
                            }
                        }
                        label = label.substring(0, label.lastIndexOf(","));
                    }

                    if (!Ext.isEmpty(fieldErrorMsg))
                        return formattedMsg.concat("<span class='xcp_form_field_validation_label'>", label, "</span>: ", fieldErrorMsg);
                    else
                        return formattedMsg;
                };

                //flatten json object to a hashmap.
                var flatten = function(json) {
                    var worker = {};

                    function rFlatten(obj, prefix) {
                        var name, value;

                        for (name in obj) {
                            value = obj[name];

                            if (Ext.isString(value)) {
                                if (!Ext.isEmpty(prefix))
                                    name = prefix+"."+name;

                                worker[name]=value;
                            } else {
                                if (!Ext.isEmpty(prefix))
                                    name = prefix+"."+name;

                                rFlatten(value, name);
                            }
                        }

                        return worker;
                    }

                    return rFlatten(json);
                };

                var errors = json.validationErrors, fieldName, validationMessage="", j, mapping, fieldError;

                //container will be wizard or form
                var container = options.feedbackContainer.up('xcp_form');
                if (!container || options.feedbackContainer instanceof xcp.widget.window.Wizard){
                    container = options.feedbackContainer;
                }

                //look up mapping config
                if (options.operation && options.operation.actionConfig) {
                    var actionConfig = options.operation.actionConfig;
                    if(!actionConfig.plugins) {
                        actionConfig.plugins = [];
                    }
                    mapping = (!Ext.isEmpty(actionConfig) && !Ext.isEmpty(actionConfig.plugins[0])) ? actionConfig.plugins[0].mapping : null;
                }

                //flatten the structured json error object to a map
                errors = flatten(errors);

                if (errors) {
                    for (fieldName in errors) {
                        var xcpIds = null;
                        fieldError = errors[fieldName];
                        if (mapping) {
                            xcpIds = mapping[fieldName];
                            xcpIds = Ext.Array.from(xcpIds);
                        }

                        if (Ext.isEmpty(xcpIds) || xcpIds.length == 0){
                            xcpIds = Ext.Array.from(fieldName);
                        }

                        fieldError = processError(container, fieldName, fieldError, xcpIds);
                        validationMessage = validationMessage.concat(fieldError, ", ");
                    }
                }
                if (!Ext.isEmpty(validationMessage)) {
                    validationMessage = validationMessage.substring(0, validationMessage.lastIndexOf(","));
                    json["validationMessage"] = validationMessage;
                }
                //assumption: if there is no xcpId, then the action is invoked from context menu
                var showCloseIcon = false;
                if (!(options.operation && options.operation.actionConfig && options.operation.actionConfig.xcpId)) {
                    showCloseIcon = true;
                }
                this.showFeedback((options.feedbackContainer instanceof xcp.widget.window.Wizard) ? options.feedbackContainer.getCurrentComponent(): options.feedbackContainer, "", null, "validationErrors", getValidationErrorFeedbackConfig(json, showCloseIcon));
            }
            else {
                this.showFeedback((options.feedbackContainer instanceof xcp.widget.window.Wizard) ? options.feedbackContainer.getCurrentComponent(): options.feedbackContainer, "", null, "systemErrors", getServiceErrorFeedbackConfig(json));
            }
            xcp.Logger.error("An error response returned while requesting: '" + options.url +
                "' - error code: " + (json.errorCode || '') +  // $NON-NLS-1$ 
                " - message: " + (json.message || '') +  // $NON-NLS-1$ 
                " - detailed message: " + (json.detailedMessage || ''));  // $NON-NLS-1$ 
        } catch( e ) {
            // don't causing an exception when reporting an error.
            xcp.Logger.error(e);
        }
    },
    formatServiceErrorFeedback: function(errorJson) {
        return getServiceErrorFeedbackConfig(errorJson);
    }
});


/**
 * Intercept server response errors, and report it automatically.
 */
Ext.data.Connection.override({
    onComplete : function(request) {
        var options = request.options;
        if (!request.options) {
            options = request.options = {};
        }

        var FeedbackManager = xcp.core.FeedbackManager;
        var oldFailureHandler = options.failure;
        request.options.failure = function(response, options) {
            if (response.status == 401) {
                //Redirect to the login page
                // Handle authentication error. Remember the # in a cookie. Then, redirect.
                Ext.util.Cookies.set("xcp-login-hash", escape(window.location.hash), null, "/" + xcp.util.Utils.getAppPathName());
                window.location = "/" + xcp.util.Utils.getAppPathName();
                return false;
            }

            //handle 404 error
            if (response.status == 404 && (options.support404Redirect || (options.operation && options.operation.support404Redirect))) {
                var url = xcp.appContext.namespace + "_"+ xcp.core.FeedbackManager.HTTP_404_ERROR_PAGE_NAME;
                xcp.navigationManager.navigate(url);
                return false;
            }

            if (!options.feedbackContainer && options.operation && options.operation.feedbackContainer)
                options.feedbackContainer = options.operation.feedbackContainer;
            if (options.feedbackContainer) {  // some failures need to be handled locally
                FeedbackManager.showServiceErrorResponse(response, options);
            }
            if (oldFailureHandler) {
                oldFailureHandler.call(options.scope || this, response, options);
            }
        };
        return this.callOverridden(arguments);
    }
});


})();

/* xcp_feedback_lib/content/xcp/util/mixin/FeedbackContainer.js */

/**
 * Mixin for containers to indicate that the container supports xCP feedback display
 */
Ext.define("xcp.util.mixin.FeedbackContainer", {
    extend: "Ext.Base",
    isXcpFeedbackContainer: true,

    /**
     * Indicates whether the specified feedback type is displayable in the context of this feedback container
     * @param feedbackType string representing the feedback type
     * @return true
     */
    isFeedbackTypeSupported: function(feedbackType) {
        var i;
        var types = this.includeFeedbackTypes;
        if (types) {
            for (i = 0; i < types.length; i++) {
                if (types[i] == feedbackType) {
                    return true;
                }
            }
        }
        return false;
    }
});


/* xcp_action_lib/content/xcp/action/Action.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.ns("xcp");

/**
 * Action Enablement constants
 */
xcp.Enablement = {
        HIDE: -1,
        DISABLE: 0,
        ENABLE: 1
    };

/**
 * Values for selection support (number of targets supported)
 * NOTE: a number can be used to mean an exact number of targets
 */
xcp.SelectionType = {
    ANY: "ANY",
    SINGLE: "SINGLE",
    "MULTI": "MULTI",
    "TWO": "TWO"
};

/**
 * Object Permit constants (TODO: these belong with service/data related definitions)
 * NOTE: These are used a BITS rather than native content server levels.
 *       ie. There is no "EXTENDED_DELETE" since "DELETE" is a bit rather than level that implies all lower levels.
 */
Ext.define("xcp.Permit", {
    statics:{
        BROWSE: "browse",
        READ: "read",
        RELATE: "relate",
        VERSION: "version",
        WRITE: "write",
        DELETE: "delete",
        CHANGE_OWNER: "CHANGE_OWNER",
        CHANGE_LOCATION: "CHANGE_LOCATION",
        CHANGE_STATE: "CHANGE_STATE",
        CHANGE_PERMISSION: "CHANGE_PERMISSION",
        CHANGE_OWNERSHIP: "CHANGE_OWNERSHIP",
        CHANGE_FOLDER_LINKS: "CHANGE_FOLDER_LINKS",

        /**
         * Check if permits object has specified permit
         * @param permits
         * @param hasPermit
         */
        hasPermit: function(permits, hasPermit){
            return (permits && Ext.Array.indexOf(permits,hasPermit)!=-1);
        }

    }
});


/**
 * @class xcp.action.Action
 * @extends Ext.Action
 * Base class for xCP actions
 */
Ext.define("xcp.action.Action", {
    extend: "Ext.Action",

    /**
     * Default action handler (NOTE: Avoid calling handler directly; see callHandler)
     * @param actionArgs
     * @param action
     */
    handler: function(actionArgs, action){
        throw new Error("Action.handler not overridden");
    },

    // text, iconCls, tooltip -- each can be specified here on the prototype but should be in config for consistency.

    /**
     *   Action specific config arguments (and action trigger config)
     *   These are the action's configuration as well as the trigger's configuration.
     */
    config: {
        preconditions: {
            selection: xcp.SelectionType.SINGLE    // by default actions are single target
//            // -- Possible top level attributes
//            //   selection: xcp.SelectionType.*
//            //   targets : { attributes }   // attributes are checked against action target(s)
//            //   page : {attributes}        // attributes are checked against form/page
//            //   -- attributes for targets/page:
//            //   effectivePermissions: [xcp.Permit.DELETE]
//
//            targets : {   // preconditions for targets (aka selection)
//                effectivePermissions: [xcp.Permit.DELETE]
//            },
//            page :{       // preconditions for page
//                effectivePermissions: [xcp.Permit.WRITE]
//            }
//
        } // end preconditions

//        requiredAttributes: null        // array of attributes needed to enablement and handler

//        // 1) text, iconCls, tooltip attributes can be here
//        // 2) action specific config
//
//        // WARNING: keep in mind that all attributes in config as well as those merged from
//        //   constructor config and JSON action attribute are merged as a single config
//        //   passed to the Ext.Action() constructor.  ALL of these arguments are in turn passed
//        //   by Ext to the button/menu trigger control from the saved config (action's .initialConfig)
//        //   This means that everything from config is passed to the Ext trigger component
//        //   as constructor arguments.
//        //  SO, name your config to avoid name collisions with button/menu constructor arguments.
//        //
//        //  It may be good to try to separate these configs so that action config is in a sub-object of config.
    },   // end config

    /**
     *  Pseudo-destructor -- called when last removeComponent() called and this.items.length==0
     * @param comp
     *
     * protected (automatically called when last component is removed)
     */
    destroy: function(comp){
        // your cleanup code here
        // * WARNING: if an action is shared between components and components are all removed and then
        //   re-added, this destructor will run!
    },

    // override private
    removeComponent : function(comp){
        this.callParent(arguments);
        if (this.items.length==0)
            this.destroy(this);
    },

    /**
     * Constructor
     * @param config
     */
    constructor: function(config){
        config = config || {};
        var prototype = this.self.prototype;
        // copy primary attributes from prototype (so handler doesn't have to be in config)
        var prototypeConfig=Ext.copyTo({},prototype, ["text", "iconCls", "tooltip", "handler"]);
        Ext.applyIf(config, prototypeConfig);

        // send all handlers thru Action Manager
        if (!config._handler){
            if (config.handler){
                config._handler = config.handler;
                config.handler = xcp.core.ActionManager.internalHandler;
            } else if(this.self.prototype.handler) {
                config._handler = prototype.handler;
                config.handler = xcp.core.ActionManager.internalHandler;
            }
        }
        this.items=[];
        this.initConfig(config);  // merge prototype's .config object
        this.callParent([this.config]);
    },

    applyConfig: function(name, value) {
        if (!this.$configInited)
            return this;   // called before base constructor was called; just leave!
        return this.callParent(arguments);
    },

    /**
     * get action instance config (reflects JSON overridden config)
     * @param forModel -- (optional)  if specified, get model specific config
     */
    getConfig: function(forModel /*optional*/){
        if (!forModel || !this.config.configMap)
            return this.config;
        else{
            var rType = forModel.get("r_object_type");
            if (!rType){
                throw "getConfig -- model missing r_object_type";  // $NON-NLS-1$ 
            }
            var model = xcp.util.Utils.getModelFromObjectType(rType);
            return this.config.configMap[model];
        }
    },

    /**
     * get action targets from actionArgs (allows for action attributes to determine targets)
     *    NOTE: action could potentially be configured to identify specific target on the page
     * @param actionArgs
     * @param actionModel (optional)
     */
    getTargets: function(actionArgs, actionModel /*optional*/){
        var targets = [];
        if (!actionArgs || !actionArgs.selection)
            return targets;
        var items = actionArgs.selection;
        if (!actionModel)
            return actionArgs.selection;
        if (Ext.isArray(items)) {
            for (var i=0, len=items.length; i<len; i++){
                targets.push(xcp.util.Utils.getAsModel(items[i], actionModel));
            }
        }
        return targets;
    },

// EXPERIMENTAL-----
// EXPERIMENTAL-----
// Move enablement inside actions...
    getActionArgs: function(){
        return this.actionArgs;
    },
    evalEnablement: function() {
        return xcp.action.Enablement.evalEnablement(this.getActionArgs(), this);
    },

    updateEnablement: function(){
        var en=this.evalEnablement(this.getActionArgs());
        this.setEnablement(en);
    },
    getInitialEnablement: function() {
        return xcp.Enablement.ENABLE;
    },

    setEnablement: function(enablement) {
        switch(enablement){
            case xcp.Enablement.HIDE:
                this.hide();
                break;
            case xcp.Enablement.DISABLE:
                this.disable();
                this.show();
                break;
            case xcp.Enablement.ENABLE:
                this.show();
                this.enable();
                break;
        }
    }
// END EXPERIMENTAL-----
// END EXPERIMENTAL-----

});


/**
 * @class xcp.core.ActionArgs
 * xCP action arguments
 */
Ext.define("xcp.core.ActionArgs", {
    isActionArgs: true,

    _pageModel: null,      // use getPageModel()! Cached model associated with page (don't access directly!)

    /**
     * Get model associated with form/page
     * @param modelName (optional)
     */
    getPageModel: function(modelName /*optional*/)
    {
        if (!this._pageModel)  // cache on 1st access
            this._pageModel = xcp.widget.form.Form.getFormModel(this.component);
        return xcp.util.Utils.getAsModel(this._pageModel, modelName);
    },

    /**
     * Ext component associated with action trigger (ie. Grid or Form)
     */
    component: null,

    /**
     * Array of Model objects representing selection (or single model from form; dlm todo RENAME to "targets")
     */
    selection: [],

    constructor: function(config){
        Ext.apply(this,config);
    },

    /**
     * Get model name from target model (fallback to component.typeName or component.ownerCt.typeName)
     * @param model
     */
    getTypeName: function(model){
        var typeName;
        if (model){
            var rType = model.get("r_object_type");
            if (rType)
                typeName = xcp.util.Utils.getModelFromObjectType(rType, model.get("id"));
        }
        if (!typeName){
            var cmp = this.component;
            if (cmp)
                typeName = cmp.typeName;
            if (!typeName && cmp.ownerCt)
                typeName = cmp.ownerCt.typeName;
            else if (cmp.models && cmp.models[0] && cmp.modelNames)
                typeName = cmp.modelNames[cmp.models[0]];

        }
        return typeName;
    }


});


/* xcp_action_lib/content/xcp/action/ModelUpdater.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
(function() {


// private trace function
    function logIt(s){
        console.debug("ModelUpdater: "+s);
    }

Ext.define("xcp.action.ModelUpdater", {
    singleton: true,

    /**
     * Get array of models that are missing fields
     * @param models -- array of models to check
     * @param fields -- field names that must have values
     */
    getIncompleteModels: function(models, fields){
        var updateModels = [];
        for (var i=0, len=models.length; i<len; i++){
            var model=models[i];
            for (var j=0, count=fields.length; j<count; j++){
                var field = fields[j];
                if (Ext.isEmpty(model.get(field))) {
                    updateModels.push(model);
                    break;
                }
            }
        }
        return updateModels;
    },

    /**
     * Get the model that can load metadata if metadata is missing
     * @param model
     */
    getTypeModel: function(model){
        var name = model.get("r_object_type");
        return Ext.ModelManager.getModel(name);
    },

    /**
     * ensure required metadata is present in models; callback when done
     * NOTE: callback args are as follows:
     *  true: data was fetched
     *  false: data was
     *  error: first error
     * @param models -- array of models to update
     * @param options {fields[], callback, scope, feedbackContainer}
     */
    ensureModels: function(models, options) {
        var updateModels = this.getIncompleteModels(models, options.expressionFields);
        if (updateModels.length==0){
            logIt("ensureModels() -- no missing data");
            if (options.callback){
                options.callback.call(options.scope||this, false); // callback(true) if already complete
            }
            return true;
        }
        logIt("ensureModels() -- fetching missing attributes: "+ options.expressionFields.join(","));
        this.updateModels(updateModels, options);
    },
    /**
     * Update array of models;
     *   dlm TODO TEMP HACK uses model.load() Need service get attributes for multiple objects!!!
     *   NOTE: Currently we sequentially process multi-select.  We could change this to be
     *   parallel, but there are limits (2-8 connections).  Could do 2-4 item chunks in parallel??
     * NOTE: callback args:
     *      true -- update completed
     *      false -- update no needed
     *      operation(Object) -- failed operation
     * @param models
     * @param options -- {fields[], callback, scope}
     */
    updateModels: function(models, options) {
        var count = models.length,
            index = 0;
        function doCallback(ret){
            if (!options.callback)
                return;
            options.callback.call(options.scope || this, ret);
        }
        function doFail(record, operation){
            xcp.Logger.error("updateModels load error: "+ operation.error);
            logIt("load error: "+ operation.error);
            doCallback(operation);
        }
        function doNext(record, operation){
            logIt("doNext(): " + (record || "[starting]"));

            if (record){
                // update model
                logIt("load success; merging data");
                var updateModel = this;
                xcp.action.ModelUpdater.applyModelChanges(updateModel, record, options);
            }
            if (index<count){
                var model = models[index];
                var clazz = xcp.action.ModelUpdater.getTypeModel(model);
                if (!model){
                    logIt("can't determine type from model");
                    xcp.Logger.error("can't determine type from model");
                }
                else {
                    index++;
                    if (clazz) {
                        logIt("loading " + model.getId());
                        // TEMP: chain service calls TODO need polymorphic/batched service!!
                        clazz.load(model.getId(), {
                            scope:model, // model to be updated
                            success:doNext,
                            failure:doFail,
                            feedbackContainer:options.feedbackContainer
                        });
                    }
                }
            }
            if (index==count && options.callback){
                doCallback(true);
            }
        }
        doNext.call(this);   // start chain of calls
    },

    /**
     * Merge/apply updates to model
     * @param model
     * @param mergeData
     * @param options
     */
    applyModelChanges: function(model, mergeData, options){
        Ext.copyTo(model.data, mergeData.data, options.expressionFields);
    }

});

})();

/* xcp_action_lib/content/xcp/action/Enablement.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function() {

// get empty model for enablement
var emptyModel;
function getEmptyModel(){
    if(!emptyModel){
//        emptyModel= Ext.ModelManager.getModel('RootBO');
        var model= Ext.ModelManager.getModel('RootBO');
        emptyModel=model.create();
        emptyModel.set("object_name","");
//  empty Model doesn't need permits.
//        emptyModel.set("effectivePermissions",[]);
    }
    return emptyModel;
}


// private helper
    function actionInfo(action){
        var info = [];
        var clazz = Ext.ClassManager.getName(action);
        if (action.initialConfig.text)
            info.push(action.initialConfig.text);
        return clazz + " " + info.join(", ");
    }

// private trace function
    function logIt(s){
        console.debug("AEN: "+s);
    }

/**   Enablement Controller
 *
 */
Ext.define("xcp.action.EnablementController",{
    extend: 'Ext.app.Controller',
    init:function(){
        /**
         * Monitor all form 'load' events to perform enablement when metadata arrives.
         */
        Ext.util.Observable.observe(xcp.widget.form.Form);
        xcp.widget.form.Form.on('load', this.onFormModelLoad);
//        Ext.util.Observable.observe(Ext.form.Basic);
//        Ext.form.Basic.on('load', this.onFormModelLoad);

        /**
         * Monitor all menu 'beforeshow' to perform enablement based on current state (dropdown menus, buttons w/ menus)
         */
        Ext.util.Observable.observe(Ext.menu.Menu);
        Ext.menu.Menu.on('beforeshow', this.onMenuBeforeShow);
    },

    // global menu 'beforeshow' handler
    onMenuBeforeShow: function(cmp, options){
        if (cmp.autoEnablement) {  // only do enablement if marked
            // this is a freestanding menu on a button
            var msg = [];
            if (cmp.baseAction){
                msg.push("menu.baseAction="+Ext.ClassManager.getName(cmp.baseAction));
            }
            logIt('Controller -- menu beforeshow: ' + msg.join(", "));  // $NON-NLS-1$ 
            if (cmp && !cmp.isDestroyed){
                xcp.action.Enablement.updateActionComponents(null, cmp);
            }
        }
    },


    // global form 'load' handler
    onFormModelLoad: function(cmp, model){
        if (!cmp){
            xcp.Logger.error("null component");  // don't localize
            return;
        }
        logIt('Controller -- load form.objectId: ' + cmp.objectId);
        if (!model)   // make fake metadata available
            model = getEmptyModel();

        var doIt = function(){
            try{

                if (window.location.href.indexOf('?version=') > 0){
                    if (window.location.href.substr(window.location.href.indexOf('?version=')+9, window.location.href.length) == "true"){
                     /*For version pages we want to render readonly pages with no actions existing*/
                        xcp.action.Enablement.updateActionContainerToHide(cmp, model);
                        xcp.action.Enablement.displayReadOnlyPage(cmp,model);
                        return;
                    }
                }

                xcp.action.Enablement.updateActionContainer(cmp, model, true);
                var permits = model.get("effectivePermissions");
                var lockOwner = model.get("r_lock_owner");
//                if (permits && !xcp.Permit.hasPermit(permits, xcp.Permit.WRITE)){
//                	var noPermitMsg = xcp.Strings.action.EditFile.noPermitWarning;
//                	xcp.core.FeedbackManager.showFeedback(null, "", noPermitMsg,
//                			"systemWarning", false);
//                } else
                if ((lockOwner != '') && (lockOwner != undefined) &&
                		(xcp.currentUser.currentUser != lockOwner)) {
                	var warningMsg = Ext.String.format(
                			xcp.Strings.action.EditFile.attributeEditWarning,
                			lockOwner);
                	xcp.core.FeedbackManager.showFeedback(null, "", warningMsg,
                			"systemWarning", false);
                }
            }catch(ex){
                xcp.Logger.error(ex.message);   // don't localize
            }
        };
        if (!cmp.rendered)
            cmp.on("afterrender", doIt, this);
        else
            doIt();
    }
});




//Ext.define("xcp.action.PreconditionManager",{
//    extend: "Object",
//    singleton:true,
//    statics: {
//        registerEventType: function(name, eventClass){
//            this._eventTypes.add(name, eventClass);
//        },
 //_eventTypes: new Ext.util.HashMap()
 //    constructor: function(){
//        this.handlerMap = new Ext.util.HashMap();
//        this.callParent(arguments)
//    }
//
//});

//Ext.define("xcp.action.Precondition",{
//    extend: "Object",
//    name: "",
//    handler: function(actionArgs, action, models, attr){
//    }
//});

    Ext.ClassManager.registerPostprocessor("applicationEventType", function(name, cls, data){
        xcp.event.ApplicationEvent.registerEventType(data.applicationEventType, cls);
    });
    Ext.ClassManager.setDefaultPostprocessorPosition("applicationEventType", "last");  // $NON-NLS-2$ 


/**  Enablement evaluation and application
 *
 */
Ext.define("xcp.action.Enablement", {
    singleton:true,
    debug:false,
    debugEnableAll:false,

//    getPreconditionHandler: function(name){
//
//    },
    /**
     * handlers for named action precondition
     */
    preconditionHandlers: {
        // target must have valid documentum ID (if no targets, enabled); only hide if has target(s) and ID not valid.
        validId: function (actionArgs, action, models, attr){
            function isValidDctmId(oid){
                return (oid!="" && oid!="root");
            }
            if (!Ext.isArray(models))
                return xcp.Enablement.ENABLE;
            for (var i=0, len=models.length; i<len; i++){
                if(!isValidDctmId(models[i].getId()))
                    return xcp.Enablement.HIDE;
            }
            return xcp.Enablement.ENABLE;
        },
        // target counts allowed
        selection: function (actionArgs, action, models, attr){
            var count = models ? models.length: 0;
            switch (attr){
                case xcp.SelectionType.MULTI:    // can be multiple
                    if (count>=1) return true;
                    break;
                case xcp.SelectionType.SINGLE:
                    if (count==1 || count==0) return true;    // dlm: allow single w/ no selection? ie. ActionMenu
                    break;
                case xcp.SelectionType.TWO:
                    if (count==2) return true;
                    break;
                default:   // specific number (ie. 2 for compare)
                    if (Ext.isNumber(attr)){
                        if (count==attr) return true;
                    }
            }
            return xcp.Enablement.HIDE;
        },
        // page model attributes
        page: function(actionArgs, action, models, attr){
            var target = actionArgs.getPageModel();
            if (!target)   // enable if no page model available
                return xcp.Enablement.ENABLE;
            return this.evalPreconditionAttributes(actionArgs, action, [target], attr);
        },
        // container (actionArgs.container) attributes
        container: function(actionArgs, action, models, attr){
            var target = actionArgs.container;
            if (!target)   // enable if no container model available
                return xcp.Enablement.ENABLE;
            return this.evalPreconditionAttributes(actionArgs, action, [target], attr);
        },
        // targets (action.getTargets()) attributes
        targets: function(actionArgs, action, models, attr){
            var targets = action.getTargets(actionArgs);
            return this.evalPreconditionAttributes(actionArgs, action, targets, attr);
        },
        // targets must all have
        effectivePermissions: function (actionArgs, action, models, attr){
            var aen = xcp.Enablement.HIDE;
            if (!Ext.isArray(models))
                return aen;
            for (var i=0, len=models.length; i<len; i++){
                var target = models[i];
                var permits = target.get("effectivePermissions");
//                if (!permits && target.raw){
//                    // fallback to raw (if attr is not in model)
//                    logIt("Warning: effectivePermissions missing from model! checking from .raw!");
//                    permits = target.raw.effectivePermissions;
//                }
                if (permits===undefined || permits=="") return xcp.Enablement.ENABLE;   // dlm XCPUIC-1106  effectivePermissions missing! Remove is delete action, but required no permits!
                if (!permits) return xcp.Enablement.HIDE;   // metadata is missing!
                var foo=Ext.each(attr, function(permit){
                    if (!xcp.Permit.hasPermit(permits, permit)){
                        aen=xcp.Enablement.HIDE;
                        return false;  // stops Ext.each()
                    } else{
                        aen = true;
                    }
                });
            }
            return aen;
        }
    },

    evalExpression: function(expression, actionArgs, isHiddenExpression){
        var  page = Ext.getCmp("_topPageContainer");
        var exprConfig = Ext.apply({}, expression);
        //EvaluationContext would not be able to locate the model object from page
        //So passing them explicitly.
        var selection = actionArgs.selection[0];
        exprConfig.models = {};
        var modelName = xcp.util.Utils.getModelFromObjectType(selection.get("r_object_type"), selection.get("id"));
        exprConfig.models[modelName] = new xcp.data.MetaDataAwareModel(selection);
        var expValue = xcp.core.expr.ExpressionManager.evaluate(page, exprConfig);

        if (isHiddenExpression){
            if (expValue == true)
                return xcp.Enablement.HIDE;
        }else{
            if (expValue == true)
                return xcp.Enablement.DISABLE;
        }
        return xcp.Enablement.ENABLE;
    },

    /**
     * Evaluate a specific
     * @param actionArgs
     * @param action
     * @param targets
     * @param attr
     * @param obj -- optional; defaults to action's preconditions
     */
    evalPreconditionAttribute: function(actionArgs, action, targets, attr, obj/*optional*/){
        var aen = xcp.Enablement.ENABLE;
        var handler =this.preconditionHandlers[attr];
        if (!Ext.isFunction(handler)){
            xcl.Logger.error("Unknown precondition handler: "+ attr);  // $NON-NLS-1$ 
            throw "Unknown precondition handler: "+ attr;    // internal exception $NON-NLS-1$ 
        }
        var preconditions = obj || action.getConfig().preconditions;
        if (!preconditions || !preconditions[attr])
            return undefined;
        aen=handler.call(this, actionArgs, action, targets, preconditions[attr]);
        if (Ext.isBoolean(aen)){
            aen = (aen) ? xcp.Enablement.ENABLE : xcp.Enablement.DISABLE;
        }
        if(aen!=xcp.Enablement.ENABLE)
            return aen;
        return aen;
    },

    /**
     * Evaluate action's pre-condition attributes
     * @param actionArgs
     * @param action
     * @param targets
     * @param obj -- optional; detaults to action's precondition's object
     */
    evalPreconditionAttributes: function(actionArgs, action, targets, obj /*optional*/){
        var aen = xcp.Enablement.ENABLE;
        if (!action.getConfig)   // viewer doesn't use base class
            return aen;
        var attrs = obj || action.getConfig().preconditions;
        for(var attr in attrs){
            var handler =this.preconditionHandlers[attr];
            if (!Ext.isFunction(handler)){
                // error
                xcl.Logger.error("Unknown precondition handler: "+ attr);  // $NON-NLS-1$ 
                throw "Unknown precondition handler: "+ attr;    // internal exception $NON-NLS-1$ 
            }
            aen=handler.call(this, actionArgs, action, targets, attrs[attr]);
            if (Ext.isBoolean(aen)){
                aen = (aen) ? xcp.Enablement.ENABLE : xcp.Enablement.DISABLE;
            }
            if(aen!=xcp.Enablement.ENABLE)
                return aen;
        }
        return aen;
    },

    /**
     * evaluate action's precondition attributes
     * @param actionArgs
     * @param action
     */
    evalPreconditions: function(actionArgs, action){
        if (!action.getTargets)    // watch out; some actions don't use xcp base class
            return xcp.Enablement.ENABLE;
        var targets = action.getTargets(actionArgs);
        var aen=this.evalPreconditionAttributes(actionArgs, action, targets);
        return aen;
    },
    /**
     * Evaluate action enablement
     * @param actionArgs
     * @param action
     * @param cmp  -- trigger component
     */
    evalEnablement: function(actionArgs, action, cmp) {
        if (this.debug && this.debugEnableAll)    // for testing/debugging; make all enabled to test failure cases.
            return xcp.Enablement.ENABLE;

        try {

            var aen=this.evalPreconditions(actionArgs, action);
            if (aen !=xcp.Enablement.ENABLE) {
                return aen;
            }
            aen = undefined;
            if (this.debug){
                logIt("   evalEnablement action="+actionInfo(action)+", "+ aen);  // $NON-NLS-1$
            }

            // Evaluating the Behavior properties
            //Hidden When
            if (action.initialConfig.expression){
                if (action.initialConfig.expression[0]){
                    if (action.initialConfig.expression[0].propertyId == 'isHidden')
                        aen = this.evalExpression(action.initialConfig.expression[0], actionArgs, true);
                    else
                        aen = this.evalExpression(action.initialConfig.expression[0], actionArgs, false);
                }
            }

            if (aen !== undefined && aen!=xcp.Enablement.ENABLE)
                return aen;

            aen = undefined;
            //Disable When
            if (action.initialConfig.expression){
                if (action.initialConfig.expression[1]){
                    if (action.initialConfig.expression[1].propertyId == 'isHidden')
                        aen = this.evalExpression(action.initialConfig.expression[1], actionArgs, true);
                     else
                        aen = this.evalExpression(action.initialConfig.expression[1], actionArgs, false);
                }
            }

            if (aen !== undefined && aen!=xcp.Enablement.ENABLE)
                return aen;

            if (this.debug){
                logIt("   evalEnablement EXPRESSION action="+actionInfo(action)+", "+ aen);
            }
            var triggerHasExpression = false;
            if (cmp && cmp.hasExpressionProps !== undefined && cmp.hasExpressionProps !== null && cmp.hasExpressionProps === true) {
                triggerHasExpression = true;
            }
            aen = undefined;

            var afn = action.getEnablement || cmp.getEnablement;   // prefer action, then trigger function
            if (typeof afn=="function"){
                // Action specific getEnablement function
                aen=afn.call(cmp, actionArgs, action, cmp);
                if (this.debug) {
                    logIt("   getEnablement() action="+actionInfo(action)+", "+ aen);  // $NON-NLS-1$ 
                }
            }
            if (aen != undefined) {

                if (xcp.Enablement.HIDE == aen)
                    return aen;  //return if it is hidden
                else if (Ext.isBoolean(aen) && !aen){
                    return xcp.Enablement.DISABLE;  //return if it is disabled
                } else if (aen === xcp.Enablement.ENABLE && !triggerHasExpression) {
                    return xcp.Enablement.ENABLE;
                }
            }
            aen = xcp.Enablement.ENABLE;
            //otherwise continue to honor the original hide/disable properties in the action/component
            var flag;
            //cmp is hidden
            if (cmp) {
                afn = cmp.isHidden;
                if (typeof afn=="function"){
                    flag = afn.call(cmp);
                    if (flag)
                        return xcp.Enablement.HIDE;
                }
            }

            //cmp is enabled
            if (cmp) {
                afn = cmp.isDisabled;
                if (typeof afn=="function"){
                    flag = afn.call(cmp);
                    if (flag)
                        return xcp.Enablement.DISABLE;
                }
            }

            // convert true/false into enablement
            if (Ext.isBoolean(aen)){
                aen = (aen) ? xcp.Enablement.ENABLE : xcp.Enablement.DISABLE;
            }
            return aen;
        }
        catch(ex){
            xcp.Logger.error("evalEnablement error. action="+ actionInfo(action)+ ", error: "+ ex.message);
            throw ex;
        }
    },

    /**
     * Set "enablement" of component (ie. button or menuitem)
     * @param cmp
     * @param enablement -- xcp.Enablement enum value
     */
    setComponentEnablement: function(cmp, enablement) {
        switch(enablement){
            case xcp.Enablement.HIDE:
//                if (typeof cmp.disable=="function") cmp.disable();
                if (typeof cmp.hide=="function") cmp.hide();
                break;
            case xcp.Enablement.DISABLE:
                if (typeof cmp.disable=="function") cmp.disable();
                if(cmp.isHidden()) cmp.setVisible(true);
                break;
            case xcp.Enablement.ENABLE:
                if (typeof cmp.enable=="function") cmp.enable();
                if(cmp.isHidden()) cmp.setVisible(true);
                break;
        }
    },

    /**
     * Query for action triggers
     * @param cmp
     */
    queryActionTriggers: function(cmp, actionType /*optional*/) {
        var retItems = [];
        if (cmp && Ext.isFunction(cmp.query)) {
            var items = cmp.query("button");  // $NON-NLS-1$ 
            for (var i=0, len=items.length; i<len; i++){
                var item=items[i];
                if (item.baseAction && item.baseAction instanceof xcp.action.Action || (actionType && Ext.ClassManager.getName(item.baseAction)==actionType))  // dlm: Not all actions are using common base class!
                    retItems.push(item);
            }
        }
        return retItems;
    },
    /**
     * update form/page/etc that contains action triggers
     * @param cmp
     */
    updateActionContainer: function(cmp, model, bSetActionArgs){
        var actionArgs = xcp.core.ActionManager.getActionArgs(cmp);
        actionArgs.selection = [model];
        var items = this.queryActionTriggers(cmp);
        for (var i=0, len=items.length; i<len; i++){
            var item=items[i];
            this.updateActionComponent(actionArgs, item, bSetActionArgs)
        }
    },

    updateActionContainerToHide: function(cmp, model){
            var actionArgs = xcp.core.ActionManager.getActionArgs(cmp);
            actionArgs.selection = [model];
            var items = this.queryActionTriggers(cmp);
            for (var i=0, len=items.length; i<len; i++){
                var item=items[i];
                var action = item.baseAction;
                if(action instanceof xcp.action.Action){
                    this.setComponentEnablement(item, xcp.Enablement.HIDE);
                }
            }
        },

    displayReadOnlyPage: function(cmp, model){
         if (cmp && Ext.isFunction(cmp.query)) {

            if (this.queryActionTriggers(cmp, "xcp.action.form.UpdateAction").length == 1){

                var fields = cmp.getForm().getFields();
                if (fields.length > 0){      //Check to distinguish View page from Edit page (TODO: need to do a accurate check)

                    var warningMsg = Ext.String.format(xcp.Strings.action.EditFile.attributeEditWarning, model.get('r_lock_owner'));
                    xcp.core.FeedbackManager.showFeedback(null, "", warningMsg, "systemErrors", false);

                    for (var i=0, len=fields.length; i<len; i++){
                        var item=fields.items[i];
                        item.setReadOnly(true);
                    }
                }
            }
        }
    },
    /**
     * update a component's enablement/resources using it's action definition
     *   NOTE: Component must have been created w/ action as constructor arg.
     * @param actionArgs
     * @param cmp -- menu, button, etc.
     * @return xcp.Enablement (or undefined if not action)
     */
    updateActionComponent: function(actionArgs, cmp, bSetActionArgs) {
        var action = cmp.baseAction;
        if(action instanceof xcp.action.Action){
            if (bSetActionArgs){
                // page actions get page context
                action.actionArgs = actionArgs;
            }
            var en=this.evalEnablement(actionArgs, action, cmp);
            this.setComponentEnablement(cmp, en);
            // dlm update resource here (if we need this)
            // In CenterStage actions could change their icon/text/tooltip w/ selection
            //   and metadata changes.  Best done here!
            return en;
        }else{
            if (this.debug) {
                if (Ext.isObject(cmp))
                    logIt("   non-action = "+ Ext.ClassManager.getName(cmp));
                else
                    logIt("   non-action cmp="+ cmp);  // $NON-NLS-1$ 
            }
        }
        return undefined;
    },
    /**
     * Update all component.items action enablement and resources (as needed)
     * @param actionArgs
     * @param cmp
     */
    updateActionComponents: function(actionArgs, cmp){
        logIt("updateActionComponents: "+cmp.id);
        if (!actionArgs)
            actionArgs = xcp.core.ActionManager.getActionArgs(cmp);
        if (!actionArgs)
            return;

        var items = cmp.items.items;
        for (var i=0, len=items.length; i<len; i++){
            var item = items[i];
            var en=this.updateActionComponent(actionArgs, item);
        }
        this.hideExtraSeparators(items);
    },
    /**
     * Hide adjacent separators due to hidden items
     * @param items
     */
    hideExtraSeparators:function(items){
        var prevSep = -1,
            lastSep=-1,
            idx=0;
        function isSep(o){
            return (o=="-" || (o.isXType && o.isXType("menuseparator")));
        }
        for (var i=0, len=items.length; i<len; i++){
            var item = items[i];
            if (isSep(item)){
                lastSep = i;
                if (idx>0 && i!=len-1 && idx!=prevSep+1) {
                    if (item.hidden)
                        this.setComponentEnablement(item, xcp.Enablement.ENABLE);
                    prevSep = idx;
                    idx++;
                }else{
                    this.setComponentEnablement(item, xcp.Enablement.HIDE);
                }
            }else if (!item.hidden)
                idx++;
        }

        // hide empty separator
        for(i=lastSep+1, len=items.length; i!=-1 && i<len; i++){
            item = items[i];
            if (!isSep(item) && !item.hidden){
                lastSep = -1;
                break;
            }
        }
        if (lastSep>=0)
            this.setComponentEnablement(items[lastSep], xcp.Enablement.HIDE);

    }

});


})();


/* xcp_action_lib/content/xcp/action/TestAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 *   Test Action -- Displays ActionArgs object and context information
 */
Ext.define("xcp.action.TestAction", {
    extend: "xcp.action.Action",
    alias: "action.test",
    config: {
        text: "(!Test)"
    },
    handler: function(actionArgs, action) {
        var targets = action.getTargets(actionArgs);  // get input models   (vs. getModels)

        var me=this,
            items = [],
            html = [],
            indent = "&nbsp;&nbsp;",
            config = action.getConfig();    // action's config (not polluted w/ trigger component properties)
        var format = Ext.String.format;
        function className(obj){
            if (!obj) return Ext.encode(obj);  // return "null", etc...
            return Ext.ClassManager.getName(obj);
         }
        function formatObjToHtml(obj) {
            var skipList = "plugins";
            if (!obj) return Ext.encode(obj);  // return "null", etc...
            var indent = "&nbsp;&nbsp;";
            var fmt = indent+"<b>{0}</b>:&nbsp;{1}";
            var ret = [];
            ret.push("{");
            for (var key in obj){
                if(skipList.indexOf(key)!=-1){
                    ret.push(format(fmt, key, "..."));
                    continue;
                }
                var o = obj[key];
                ret.push(format(fmt, key, Ext.htmlEncode(Ext.encode(o))));
            }
            ret.push("}");
            return ret.join("<br>");
        }
        function addActionInfo(){
            var action = me.baseAction;
            html=[];
            html.push("<b>Trigger</b>");
            html.push(format("trigger={0} ({1})",me.id, className(me)));
            html.push("<br><b>Action</b>");
            html.push(format("action={0}",className(action)));
            html.push("");
            if (action && action.isAction){
                html.push("<i>NOTE: <b>action.getConfig()</b> provides clean/uncluttered action config!</i><br>");
                html.push("action.getConfig() = "+formatObjToHtml(config));
            }

            items.push({title: "Action / Trigger"
                        ,html: html.join("<br>")
                        ,autoScroll:true });
        }
        function addActionArgs() {
            if (!actionArgs){
                items.push({title: "ActionArgs Missing!"
                           ,html: "actionArgs is NULL"
                           ,autoScroll:true });
                return;
            }

            // -----------------------------------------------------------
            html=[];
            var component=actionArgs.component;
            if (component){
                html.push("<br><b>Component</b>");
                html.push(format("component={0} ({1})", component.id, className(component)));
                html.push(format("component.typeName={0}", component.typeName));
                html.push(format("component.model={0}", component.model));
                html.push("<br><b>Form</b> -- actionArgs.getPageModel()");
                var formModel=actionArgs.getPageModel();
                if(formModel){
                    if (formModel && formModel.data)
                        html.push(format("model.data ({0})=&nbsp;{1}", className(formModel), formatObjToHtml(formModel.data)));
                }
                else{
                    html.push("(no form/page)");
                }
            } else{
                html.push("NULL");
            }
            items.push({title: "Page / Form / Component"
                       ,html: html.join("<br>")
                       ,autoScroll:true });

            // -----------------------------------------------------------
            html=[];
            if (actionArgs.selection){
                html.push("<b>Selection</b>");
                html.push(format(".selection.length={0}",actionArgs.selection.length));
                html.push("");
                for (var i=0, len=actionArgs.selection.length; i<len; i++){
                    var sel=actionArgs.selection[i];
                    if (sel && sel.data)
                        html.push(format(".selection[{0}] {1}:&nbsp;{2}", i, className(sel), formatObjToHtml(sel.data)));
                    else
                        html.push(format(".selection[{0}] {1}:&nbsp;{2}", i, className(sel), "null"));
                }
            } else{
                html.push("NULL");
            }
            items.push({title: "Targets / Selection"
                       ,html: html.join("<br>")
                       ,autoScroll:true });


        } // end addActionArgs()

        addActionInfo();
        addActionArgs();

        var win = Ext.create("Ext.window.Window", {
                    title: "!Test -- "+className(me.baseAction),
                    height: 350,
                    width: 650,
                    layout: "fit",
                    activeItem: 0,
                    items: {xtype:"tabpanel", items: items},
                    dockedItems: [{
                        xtype: 'toolbar',
                        dock: 'bottom',
                        ui: 'footer',
                        items: [
                            {xtype: 'component', flex: 1 }
                            ,new xcp.action.CloseWindow()
                            ,{text:"Enable All",handler:function(){
                                xcp.action.Enablement.debug=true;
                                xcp.action.Enablement.debugEnableAll=true;
                            }}
                            ,{text:"Normal Enablement",handler:function(){
                                xcp.action.Enablement.debugEnableAll=false;
                            }}
                        ]
                    }]
                });
        win.show();
    },
    getEnablement:function(actionArgs, action){
        return true;  // Can return xcp.Enablement or true/false (true==ENABLE, false==DISABLE)
    }
});

/** Window close button
 *
 */
Ext.define("xcp.action.CloseWindow", {
    extend: "xcp.action.Action",
    config: {
        text: "Close",
        tooltip: "Click me to close..."
    },
    handler: function(actionArgs){
        var win=this.up("window");
        if (win)
            win.close();
    }
});

/** Window close button
 *
 */
Ext.define("xcp.action.MenuAction", {
    extend: "xcp.action.Action",
    config: {
        text: "Menu Action",
        menu: []
    },
    handler: function(actionArgs){
        // do nothing
    }
});


/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.core.ActionManager");

Ext.apply(xcp.Strings.core.ActionManager, {
    unknownAction: "Could not find action '{0}'",
    unknownType: "Unknown action definition type or format",
    noactionargs: "Could not get action arguments",
    loading: "Loading..."
});
/* xcp_action_lib/content/xcp/core/ActionManager.js */

// ActionManager.js

/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

(function() {

// private trace function
function logIt(s){
    console.debug("AM: "+s);
}

// return a map of type/models to config
function getConfigsOfType(inMenus, findActionType){
    var configs={};
    for (var model in inMenus){
        var items=inMenus[model];
        for (var i=0, len=items.length; i<len; i++){
            var component =items[i];
            if (Ext.isObject(component)){
                var action = component.baseAction || component;
                var config = action.getConfig();
                var actionType = config.actionType;
                if (actionType==findActionType){
                    configs[model]=Ext.clone(config);
                }
            }
        }
    }
    return configs;
}


Ext.define("xcp.core.ActionManager", {
    singleton: true,
    userActionsDefReg : null,
    contextMenuReg : null,
    enableJIT: true,    // use ModelUpdater to fetch missing metadata just-in-time

    debug: false,  // cause debug action to be added, etc (also adds shift-click debug info for actions)

    /**
     * Initializes action related information
     * @param {Function} [callback] The callback function invoked after picklist data has been initialized
     * @param {Object} [scope] The scope (<code>this</code> reference) in which the callback is executed.
     */
    init : function(callback, scope){
        // Enablement Controller
        // xcp doesn't have an application object so can't currently register any controllers
        this.enablementController = new xcp.action.EnablementController();
        this.enablementController.init();

        this.initActionFlow();
        this.initContextMenu(callback, scope);
    },
    /**
     * initializes the action flow. Gets the actions flow definitions
     * @param {Function} [callback] The callback function invoked after picklist data has been initialized
     * @param {Object} [scope] The scope (<code>this</code> reference) in which the callback is executed.
     */
    initActionFlow : function(callback, scope) {
        var url = xcp.util.Utils.buildResourceUrl("ui/user_defined_actions", true);
        Ext.Ajax.request({
            url: url,
            async: true,
            scope: this,
            disableCaching: false,
            success: function(response, options) {
                logIt("Got User defined actions");  // $NON-NLS-1$ 
                var responseText = response.responseText;
                this.userActionsDefReg = Ext.JSON.decode(responseText);
                if (callback) {
                    callback.call(scope);
                }
            },
            failure: function(response, options) {
                this.userActionsDefReg = {};
                xcp.Logger.log("Failed to load user defined actions definitions");
                if (callback) {
                    callback.call(scope);
                }
            }
        });
    },
    /**
     * initializes the context menu, gets the context menu configurations
     * @param {Function} [callback] The callback function invoked after picklist data has been initialized
     * @param {Object} [scope] The scope (<code>this</code> reference) in which the callback is executed.
     */
    initContextMenu : function(callback, scope) {
        var url = xcp.util.Utils.buildResourceUrl("ui/contextMenu", true);
        Ext.Ajax.request({
            url: url,
            async: true,
            scope: this,
            disableCaching: false,
            success: function(response, options) {
                xcp.Logger.debug("Got Context menu actions");
                var responseText = response.responseText;
                this.contextMenuReg = Ext.JSON.decode(responseText);
                if (callback) {
                    callback.call(scope);
                }
            },
            failure: function(response, options) {
                this.contextMenuReg= {};
                xcp.Logger.log("Failed to load context menu definitions");
                if (callback) {
                    callback.call(scope);
                }
            }
        });
    },

    // old create;; see getAction()
    create: function(actionConfig) {
        var zlass;
        if(actionConfig.actionType)
        {
            zlass = Ext.ClassManager.getByAlias("action." + actionConfig.actionType);
            //Adding check of isFunction as during unit test case somehow Ext.ClassManager.getByAlias is returning Window object
            if (zlass && Ext.isFunction(zlass)) {
                // Found the action, create an instance of it
                return new zlass(actionConfig);
            }
        }
        // return base action
        return new xcp.action.Action(actionConfig);
    },

    /**
     * Returns the specified user defined action flow definition from the registry
     * @param type
     * @param actionId
     */
    getUserActionDefConfig: function(type, actionId) {
        var typeActions = this.userActionsDefReg[type];

        if (typeActions) {
            return typeActions[actionId];
        }
        return null;
    },
    getUserActionDefConfigFromActionType: function(type, actionType) {
        var typeActions = this.userActionsDefReg[type];

        if (typeActions) {
            for (var flowId in typeActions) {
                var flowDef = typeActions[flowId]["flowDef"];
                if (flowDef && flowDef["action-type"] && flowDef["action-type"] == actionType) {
                    return typeActions[flowId];
                }
            }
            return null;
        }
        return null;
    },

    /**
     * Internal handler used for all actions;  Calls trigger's _handler() with action's decorated ActionArgs object
     */
    internalHandler: function(triggerThis, evt){
        var handler, actionArgs;
        handler = triggerThis._handler;
        actionArgs = xcp.core.ActionManager.getActionArgs(triggerThis);
        var args = [];
        args.push(actionArgs);
        args.push(this.baseAction);
        for(var i=0, len=arguments.length; i<len;i++){
            args.push(arguments[i]);
        }

        // shift click of button/menu will open test action (debug mode only)
        if (xcp.core.ActionManager.debug && evt &&  evt.hasModifier && evt.hasModifier()){  // WARNING: Unit tests create fake event objects!!!
            handler=xcp.action.TestAction.prototype.handler;
        }
        handler.apply(this, args);
    },

    /**
     * Get action config from actionDef.  Merge actionDef w/ contained .action.
     * @param actionDef -- {xtype:"foo", action: {actionType:"delete", text:"override Text", showConfirmation: false}
     */
    getConfigFromActionDef: function (actionDef, clazz){
        var config = {};

        // dlm: todo: REMOVE THIS merge?!
        // On the plus side, keeping it means top level ActionDef attributes are passed as action config and then via .initialConfig to trigger component
        //
        //  This is NOT needed if all attributes are in .action attribute
        //    ie. text:"fooo" should be inside action as child.
        //    Builder doesn't need to be specifying text in the 1st place!
//      // overlay config from attributes
        Ext.Object.merge(config, actionDef);

        if (actionDef.action){
            Ext.Object.merge(config, actionDef.action)
        }
        return config;
    },

    getAction: function(actionDef){
        return this.getActionInst(actionDef);
    },

    getActionInstances: function(actionDefs){
        var items=[];
        for (var i=0, len=actionDefs.length; i<len; i++){
            items.push(this.getActionInst(actionDefs[i]));
        }
        return items;
    },

    /**
     * Get action instance from action defintion
     * @param actionDef -- can be Ext.Action or object: {xtype:...", action: "action | actionid | actionclass", text: ...}
     */
    getActionInst: function(actionDef){
        var clazz, aid;
        if (actionDef.isAction) return actionDef;

        if (typeof (actionDef=="object")){
            //PRIMARY PATH
            if (actionDef.action) {
                if (Ext.isObject(actionDef.action)){
                    // primary case
                    aid = actionDef.action.actionType;
                }
                else{
                    xcp.Logger.error("actionDef.action is not an object");
                    throw new Error (xcp.Strings.core.ActionManager.unknownType);
                }
                if (aid) {
                    var hasPrefix=aid.indexOf("action.")==0;  // $NON-NLS-1$ 
                    if (hasPrefix || aid.indexOf(".")==-1)
                        clazz = Ext.ClassManager.getByAlias( (hasPrefix?"":"action.") + aid);
                    else{
                        // get by name; most likely a class(aka function), but, can be an object
                        //   instance;  Allows use of common action instance
                        clazz = this.evalDotPath(aid);
                    }
                    if (typeof clazz=="function"){
                        // PRIMARY PATH!
                        // create action instance with overriding config
                        return new clazz(this.getConfigFromActionDef(actionDef, clazz));
                    }else if (clazz && typeof clazz=="object") {
                        // ALTERNATE (not likely)
                        if (clazz.isAction){
                            // this is an action instance! use it!!!
                            return clazz;
                        }
                    }
                    xcp.Logger.error("getActionInst() unknown action: "+ aid);
//dlm temp hack                    throw new Error (Ext.String.format(xcp.Strings.core.ActionManager.unknownAction, aid));
                    return new xcp.action.Action({text: 'Missing: '+aid});
                }
            }
        } else if(typeof actionDef=="string") {
            // simple lookup by namespaced name
            // NOT PRIMARY PATH!!!
            clazz = this.evalDotPath(actionDef);
            if (!clazz) return null;
            if (clazz.isAction) return clazz;
            throw new Error (Ext.String.format(xcp.Strings.core.ActionManager.unknownAction, actionDef));
        }
        else
            throw new Error(xcp.Strings.core.ActionManager.unknownType);
        return actionDef;   // has no .action attribute; just return definition
    },

    /**
     * Get component for given action definition
     * @param actionArgs
     * @param actionDef -- xtype markup w/ action attribute, action or menu/toolbar separator/fill items ("-", etc...)
     * @param options -- {defaultType, etc}
     * @return Ext.Component
     */
    getComponent: function(actionArgs, actionDef, options){
        var cmp = null;
        if (typeof actionDef=="string") {  // "-", "->", etc
            return actionDef;
        }
        //Pass the object type to the action so that it can be used to find out action flow def from the action config
        if (actionDef.action) {
            var objectType = this.getEffectiveObjectType(actionArgs, actionDef);
            if (objectType) {
                actionDef.action.objectType = objectType;
            }

        }
        var actionInst = this.getActionInst(actionDef);
        actionInst.actionArgs = actionArgs;
        var defaultType = options.defaultType;
        if (actionDef.xtype){
            var clazz = Ext.ClassManager.getByAlias("widget."+actionDef.xtype);
            cmp=new clazz(actionInst);
        }else if (defaultType){
            if (typeof defaultType=='string'){
                defaultType = Ext.ClassManager.getByAlias("widget."+defaultType);
            }
            cmp=new defaultType(actionInst);
        }
        if (cmp){
            cmp.actionArgs = actionArgs;
        }
        if (cmp && options.autoEnablement){
            var aen = xcp.action.Enablement.evalEnablement(actionArgs, actionInst, cmp);
            xcp.action.Enablement.setComponentEnablement(cmp, aen);
        }
        return cmp;
    },
    getEffectiveObjectType: function(actionArgs, actionDef) {

        var objectTypePropName = actionDef.action["objectTypePropName"];

        var objectType = null;
        if (objectTypePropName) {
            var selection = actionArgs.selection;
            if (selection && selection.length > 0) {
                objectType = selection[0].get(objectTypePropName);
            }
        }
        if (!objectType) {
            if (actionDef.action['objectType']) {
                objectType = actionDef.action['objectType'];
            } else {

                if (Ext.isArray(actionArgs.selection) && actionArgs.selection.length > 0) {
                    var target = actionArgs.selection[0];
                    objectType = actionArgs.getTypeName(target);
                } else {
                    var cmp = actionArgs.component;
                    objectType = cmp.typeName;
                    if (!objectType && cmp.ownerCt) {
                        objectType = cmp.ownerCt.typeName;
                    }
                }
            }
        }
        return objectType;
    },

    /**
     * Get array of components given an array of action definitions
     * @param actionArgs
     * @param actions  -- array of actions, xtype markup w/ action attributes or menu/toolbar "-", etc.
     * @param options -- {defaultType: "..."}
     * @return Array -- array of components created from action instances
     */
    getComponents: function(actionArgs, actions, options){
        var items = [];
        for (var i=0, len=actions.length; i<len; i++){
            items.push(this.getComponent(actionArgs, actions[i], options))
        }
        return items;
    },

    /**
     * Get action definitions for a given component area
     * @param actionArgs
     * @param areaName  -- ie. "{typename}-ContextMenu"
     * @return Array
     */
    getActionDefs: function(actionArgs, areaName){
        var containerName=this.getContextMenuName(actionArgs, areaName);
        var defs=this.getContextMenuDefByName(containerName);

//        if (this.debug && xcp.action.TestAction){    // add debug/test action
//            defs = Ext.clone(defs);
//            defs.push(new xcp.action.TestAction());
//        }
        return defs;
    },

    /**
     * return only actions that support the selection
     * @param actionArgs
     * @param targets
     * @param componentOrActions
     */
    filterForSelection:function(actionArgs, targets, componentOrActions){
        var items=[];
        for (var i=0, len=componentOrActions.length; i<len; i++){
            var component = componentOrActions[i];
            if (!Ext.isObject(component)){
                continue;
            }
            var action = component.baseAction || component;
            if (action){
                var aen=xcp.action.Enablement.evalPreconditionAttribute(actionArgs, action, targets, "selection");  // $NON-NLS-1$ 
//                logIt("filterForSelection: "+ aen + ", "+ Ext.ClassManager.getName(action));
                if (aen==xcp.Enablement.ENABLE)
                    items.push(component);
            }
        }
        return items;
    },

    /**
     * Merge menu definitions and return only multi-select items; common actions are combined and provided with type specific config.
     * @param actionArgs
     * @param areaName
     * @param options
     */
    mergeMenus: function (actionArgs, areaName, options){
        var items = [];
        var targets = actionArgs.selection;
        var typeCount = 0;
        var targetCount = targets.length;
        var defs = {};
        var types = {};
        var menus ={};

        var component = actionArgs.component;

        // get action definitions for each unique type in selection
        //    and keep only actions that support the current selection (ie. multiple).
        for(var i=0; i<targetCount; i++){
            var target=targets[i];
            var modelName = actionArgs.getTypeName(target);
            if(!modelName){
                xcp.Logger.error("mergeMenus: component.typeName & r_object_type missing");
                return null;
            }

            if (!types[modelName]) types[modelName] = 0;
            types[modelName]++;
            if (types[modelName]==1){
                // for each unique modelName, get menu defs
                typeCount++;
                var defName = modelName +'-'+ areaName;
                defs[modelName]=this.getContextMenuDefByName(defName);
                if (!defs[modelName]){
                    xcp.Logger.error("mergeMenus: can't find def name: "+ defName);
                    return null;
                }
                menus[modelName]=this.getActionInstances(defs[modelName]);
                menus[modelName]=this.filterForSelection(actionArgs, targets, menus[modelName]);
            }
        }

        // Count all with the same type/model
        var action, actionType, len, cmp;
        var actionCounts = {};
        for (var key in menus){
            var multiOnly = menus[key];
            for (i=0, len=multiOnly.length; i<len; i++){
                cmp = multiOnly[i];
                action = cmp.baseAction || cmp;
                actionType=action.getConfig().actionType;
                if (action && actionType){
                    if (!actionCounts[actionType]) actionCounts[actionType]=0;
                    actionCounts[actionType]++;
                }
            }
        }

        // keep only actions that apply to all (provide config map on action)
        for(actionType in actionCounts){
            if (actionCounts[actionType]==typeCount) {   // there's an action per type
                // each target supports this action
                var configs = getConfigsOfType(menus, actionType);
                var first;
                for (var t in configs){
                    first = configs[t];
                }
                var config = Ext.clone(first);
                config.configMap = configs;
                var aid = (actionType.indexOf(".")==-1) ? "action."+actionType : actionType;
                action = Ext.create(aid, config);
                items.push(action);
            }
        }

        return items;
    },

    getContextMenu: function(actionArgs, nameOrActions, options){
        var actions;
        options = options || {};
        Ext.applyIf(options, {
            autoEnablement: true,
            destroyOnHide:true,
            defaultType: "xcp_menuitem"}
        );
        // no object id then no need for menu.
        if (actionArgs.selection[0] && !actionArgs.selection[0].get("id"))
            return null;

        var targets = (actionArgs && actionArgs.selection) ? actionArgs.selection : [];

        var len = targets.length;
        if (typeof nameOrActions=='string'){
            var areaName = nameOrActions || "ItemContextMenu";  // dlm default???
            if (len>1){
                actions = this.mergeMenus(actionArgs, areaName, options);
            }else{
                actions = this.getActionDefs(actionArgs, areaName);
            }
            if (!actions || actions.length<1)
                return null;
        }else {
            actions = nameOrActions;
        }
        var items = this.getComponents(actionArgs, actions, options);
        var menuCfg = {items: items, actionArgs:actionArgs, ignoreParentClicks:true, enableScrolling:false};
        if (options.loading){
            menuCfg.disabled = true;
        }
        var menu = Ext.create("widget.xcp_menu", menuCfg);
        if (options.destroyOnHide) {
            menu.on("hide", menu.destroy, menu);
        }
        if (options.autoEnablement!==undefined)
            menu.autoEnablement = options.autoEnablement;   // mark menu for enablement
        return menu;
    },


    /**
     * Find component that has either .actionArgs property or .actionArgsProvider function and returns actionArgs.
     *    Uses ownerCt to walk up the component hierarchy.
     * @param startCmp -- component
     */
    findActionArgsProvider: function(startCmp){
        var cmp = startCmp;
        do{
            if(cmp.actionArgs)
                return cmp.actionArgs;
            else if (cmp.actionArgsProvider){
                return cmp.actionArgsProvider();
            }
        }while(cmp=cmp.ownerCt);
        return null;
    },

    /**
     *  Get ActionArgs associated with the component (or trigger)
     * @param triggerThis
     */
    findActionArgsFromTrigger:function(triggerThis){
        var actionArgs=null;
        function findMenuActionArgs(cmp){
            do{
                if (cmp.actionArgs) return cmp.actionArgs
            }while(cmp=cmp.parentMenu);
            return null;
        }
        if (triggerThis.isMenuItem || triggerThis.isMenu) {
            actionArgs = findMenuActionArgs(triggerThis);
        }
        if (!actionArgs)
            actionArgs = this.findActionArgsProvider(triggerThis);
        return actionArgs;
    },

    /**
     * Get actionArgs from trigger control
     * @param triggerThis
     */
    getActionArgs: function(triggerThis){
        var actionArgs = this.findActionArgsFromTrigger(triggerThis);
        if (!actionArgs){
            xcp.Logger.warn("AM: Can't find action args!");
//            // TEMP HACK We should already have this from findActionArgsFromTrigger()!!! forms todo: form needs actionArgs provider like CenterStage. ie) Walk up till we fine .actionArgs or .actionArgsProvider()
//            var model = xcp.action.form.DataAction.getModelForComponent(triggerThis);
//            var component = triggerThis.up('xcp_form');
//            actionArgs = new xcp.core.ActionArgs({selection: [model], component: component});
        }

// dlm don't throw for now.
//        if (!actionArgs){
//            throw new Error(xcp.Strings.core.ActionManager.noactionargs);
//        }
        return actionArgs;
    },

    /**
     * Get name of context menu definition.
     * @param actionArgs
     * @param areaName
     */
    getContextMenuName: function(actionArgs, areaName){
        var typeName = null;
        if (actionArgs) {
            if (Ext.isArray(actionArgs.selection) && actionArgs.selection.length>0){
                var target = actionArgs.selection[0];
                typeName = actionArgs.getTypeName(target);
                if (typeName=="dm_cabinet")   // dlm todo: are there other types?
                    typeName="dm_folder";
            }
        }
        return (typeName || "application") + "-"+areaName;  // $NON-NLS-L$ 
    },

    /**
     * Gets the context menu definition for the given menu name
     * @param containerName
     */
    getContextMenuDefByName: function(containerName){
        if (containerName.indexOf(".")!=-1)
            return this.evalDotPath(containerName);
        else
            return this.contextMenuReg[containerName];
    },

    /**
     * Get JS object from name (without dangers of eval())
     * @param str
     */
    evalDotPath: function(str) {
        if (!str)
            return null;
        if (typeof str!="string")
            return null;
        var props = str.split(".");
        var result = window;
        for (var i=0, len=props.length; i < len; ++i) {
            result = result[props[i]];
            if (typeof result == "undefined")
                break;
        }
        return result;
    },

    /**
     * Get required attribute names from actions (or items based on actions)
     * @param items
     * @return Array of string (attribute names)
     */
    gatherRequiredAttributes: function(items){
        var required=[];
        for(var i=0, len=items.length; i<len; i++){
            var item = items[i];
            if (!Ext.isObject(item))
                continue;
            var action = item.baseAction || item;
            if (!action.isAction)
                continue;
            var cfg = action.config;
            if (!cfg)
                continue;
            var attributes = cfg.requiredAttributes;
            if (Ext.isArray(attributes))
                for(var j=0, jlen=attributes.length; j<jlen; j++) {
                    var attr=attributes[j];
                    Ext.Array.include(required, attr);
                }
        }
        return required;
    },

     /**
     * Get required attribute names from expressions on actions
     * @param items
     * @param actionArgs
     * @return Array of string (attribute names)
     */
    gatherExpressionRequiredAttributes: function(items, actionArgs){
        var required=[];
        var allExpressions=[];
        for(var i=0, len=items.length; i<len; i++){
            var item = items[i];
            if (!Ext.isObject(item))
                continue;
            var action = item.baseAction || item;
            if (!action.isAction)
                continue;
            var cfg = action.config;
            if (!cfg)
                continue;
            // Add all expressions on the Content Menu actions into an Array
            if (item.expression){
                for (var k=0, kLen=item.expression.length; k<kLen; k++){
                    Ext.Array.include(allExpressions, item.expression[k]);
                }
            }
        }

        if (allExpressions.length > 0){
            //If expressions exist, preEvaluate if they contain any required attributes
            //which are missing and need to be loaded JIT.

            var  page = Ext.getCmp("_topPageContainer");
            var selection = actionArgs.selection[0];
            var modelName = xcp.util.Utils.getModelFromObjectType(selection.get("r_object_type"), selection.get("id"));
            var preActionEnablementModel = new xcp.data.MetaDataAwareModel(selection);

            for (var iExp=0 ; iExp < allExpressions.length; iExp++){
                var exprConfig = Ext.apply({}, allExpressions[iExp]);
                exprConfig.models = {};
                exprConfig.models[modelName] = preActionEnablementModel;
                var expValue = xcp.core.expr.ExpressionManager.preEvaluate(page, exprConfig);
            }

            if(preActionEnablementModel.reqAttributes){
                for (var iCustomAtt=0; iCustomAtt < preActionEnablementModel.reqAttributes.length; iCustomAtt++){
                    Ext.Array.include(required, preActionEnablementModel.reqAttributes[iCustomAtt]);
                }
            }
        }
        return required;
    },
    /**
     * Show context menu and align to provided element
     *   NOTE:
     * @param actionArgs
     * @param area
     * @param alignEl (if null, show at event's XY)
     * @param event
     * @param options [optional] -- {callback, scope} NOTE: callback(menu)
     */
    showContextMenu: function(actionArgs, area, alignEl, event, options) {
        var xy, el;
        options = options || {};

        Ext.menu.Manager.hideAll();   // dlm chrome isn't auto closing other menus!?
        event.preventDefault();

        if (alignEl){
            el = Ext.get(alignEl);
            if (!el)
                return;
        }else
            xy = event.getXY();   // note: ext doc says getPageXY()!

        var menu = this.getContextMenu(actionArgs, "ItemContextMenu", {autoEnablement:false, loading:this.enableJIT});

        var starttime = new Date();
        if (!menu){
            if (options.callback)
                options.callback.call(options.scope||window, null);
            return;
        }

        var fields = this.gatherRequiredAttributes(menu.items.items);
        var expressionFields = this.gatherExpressionRequiredAttributes(menu.items.items, actionArgs);

        var mask = null;
        if (this.enableJIT){
            // show initial menu disabled
            if (xy)
                menu.showAt(xy[0], xy[1]);
            else
                menu.showBy(el);
            mask= new Ext.LoadMask(menu, {msg:xcp.Strings.core.ActionManager.loading});
            mask.show();
        }

        var ops = {
            fields: fields,
            expressionFields: expressionFields,
            scope: this,
            callback: function(ret)
            {
                if (mask)
                    mask.hide();
                if (ret===false)
                    logIt("metadata found");  // $NON-NLS-1$ 
                else if (ret===true)
                    logIt("missing metadata fetched JIT");  // $NON-NLS-1$ 
                else{
                    // error
                    if (!menu.isDestroyed)
                        menu.destroy();
                    // error already reported due to service error
                    return;
                }
                if(menu.isDestroyed)
                    return;

                // re-evaluate enablement now that we have permissions and other missing metadata
                xcp.action.Enablement.updateActionComponents(actionArgs, menu);
                if(this.enableJIT){
                    menu.enable();
                }
                //need to invoke showAt or showBy regardless of enableJIT or not, so that in the case of some menu items got disbled after the JIT,
                // it will know how to reposition itself correctly
                if (xy)
                    menu.showAt(xy[0],xy[1]);
                else
                    menu.showBy(el);

//                logIt("duration = "+ Ext.Date.getElapsed(starttime));

                if (options.callback)
                    options.callback.call(options.scope||window, menu, ret);
            }
        };
        this.ensureMetadata(actionArgs, ops);
        return menu;
    },
    /**
     * Ensure required metadata is present in context and selection models; callback when done.
     * @param actionArgs
     * @param options -- {fields[], callback, scope, feedbackContainer}
     */
    ensureMetadata: function(actionArgs, options) {
        options = options || {};

        if (!xcp.action.ModelUpdater || !this.enableJIT)
        {
            if (options.callback)
                options.callback.call(this,false);
            return false;
        }
        // gather array of models to be checked
        var models = Ext.Array.clone(actionArgs.selection);
        var pageModel = actionArgs.getPageModel();
        if (pageModel)
            models.push(pageModel);
        var ops = Ext.clone(options);
        Ext.applyIf(ops, {
                feedbackContainer: actionArgs.component
            });
        xcp.action.ModelUpdater.ensureModels(models, ops);
    }

});

})();


/* xcp_action_lib/content/xcp/core/Clipboard.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
(function() {

// Private clipboard data
var clipboardData;

/**
 * xCP Clipboard object (HAS NOTHING TO DO WITH WINDOWS/Browser Clipboard!)
 */
Ext.define('xcp.Clipboard', {
    singleton: true,
    extend: 'Ext.util.Observable',
    constructor: function(config){
        this.callParent(arguments);
        config = config || {};
        this.addEvents("clear", "change");  // $NON-NLS-L$ 
        this.clear();
    },

    isEmpty: function(){
        return clipboardData.op==undefined;
    },
    clear: function(){
        clipboardData= {
            op: undefined,
            items: [],
            pageModel: undefined,
            container: undefined,
            fn: undefined,
            actionConfig: undefined
        };
        this.fireEvent("clear", this);
        this.fireEvent("change", this);
    },
    getData:function(){
        return clipboardData;
    },

    /**
     * Add models to clipboard
     *
     * @param models (Array) -- Array of models
     * @param container (Model)  -- optional is known; location (for cut, fromLocation)
     * @param pageModel (Model)  -- optional; maybe location (for cut, fromLocation) (if no container)
     * @param op   -- name of op ("cut", "copy")
     * @param fn   -- paste handler (static ideally)
     * @param actionConfig -- copy of action's config object
     */
    setData: function(models, container, pageModel, op, fn, actionConfig){
        clipboardData.items = [];
        clipboardData.op = op;
        clipboardData.fn = fn;

        clipboardData.pageModel = undefined;
        if (pageModel){
            clipboardData.pageModel = pageModel.copy();
        }

        clipboardData.container = undefined;
        if (container){
            clipboardData.container = container.copy();
        }

        clipboardData.actionConfig = undefined;
        if (actionConfig){
            clipboardData.actionConfig = Ext.clone(actionConfig);
        }

        Ext.each(models, function(model){
            clipboardData.items.push(model.copy());
        });
        this.fireEvent("change", this);
    }
});

})();


/* xcp_action_lib/content/xcp/action/ActionInvoker.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * A Mixin to handle the invokerEvents configuration defined on action.
 */
Ext.define('xcp.action.ActionInvoker', {

    /**
     * Initilize the mixin for an action instance
     * @param config    config
     */
    initMixin: function(config) {
        var me = this;
        config = config || this.initialConfig;
        var invokerEvents = config.invokerEvents;
        //Check if the expression config is available.
        if (invokerEvents) {
            me.on("beforerender", this.processEventsConfig, this);
        }
    },
    /**
     * Process the invokerEvents configuration, subscribe to the list of events.
     * @private
     */
    processEventsConfig: function() {
        var me = this;
        var invokerEvents = me.config["invokerEvents"];

        if (!invokerEvents) {
            return;
        }
        var containerXType = "xcp_page";
        var baseChannelName = "";

        var container = undefined;
        if (Ext.isFunction(me.getPage) && me.getPage()) {
            container = me.getPage();
        } else {
            container = me.up(containerXType);
        }

        if (container) {
            baseChannelName = container.id;
        }
        if (baseChannelName) {
            baseChannelName += ".";
        }

        //Subscribe to events for dynamic inputs
        if (invokerEvents) {
            if (!Ext.isArray(invokerEvents)) {
                invokerEvents = [invokerEvents];
            }
            //Keep track of registered events to eliminate the duplicate events
            var registeredEvents = new Ext.util.MixedCollection();
            for (var k = 0; k < invokerEvents.length; k++) {
                var event = baseChannelName + invokerEvents[k];
                if (!registeredEvents.containsKey(event)) {
                    var eventHandler = this.createEventHandler(me);
                    var handle = xcp.event.EventBus.subscribe(event, eventHandler, me);
                    //Cache the subscribed event for cleaning purpose
                    me.xcpEventSubs.add(handle, handle);
                    registeredEvents.add(event, event);
                }

            }
        }
    },
    /**
     * Provide an event handler function which calls the action.handler intern.
     */
    createEventHandler : function() {
        var timeout=undefined;
        var actionHandler = function() {
            var actionScope = this;
            //Delay action handler call, to reduce unwanted action invocation.
            if (timeout) {
                clearTimeout(timeout);
            }
            var delayedCall = function() {
                actionScope.handler(actionScope);
            };
            timeout = setTimeout(delayedCall, 40);
        };
        return actionHandler;
    }
});


/* xcp_action_lib/content/xcp/action/ActionLinker.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define('xcp.action.ActionLinker', {

    /**
     * Mixin to link the triggering control to action, if actionInstanceId configuration is available.
     * @param config
     */
    initMixin: function(config) {
        var me = this;
        config = config || me.initialConfig;
        var actionInstanceId  = (config && config.actionInstanceId ) || me.actionInstanceId;
        if (actionInstanceId) {
            me.actionInstanceId = actionInstanceId;
            if (me.setHandler) {
                me.setHandler(me.internalHandler, me);
            }
            this.on("beforerender", me.linkActionInstance, me);
        }
    },

    /**
     * Link action instance to a triggering control.
     * @private
     */
    linkActionInstance: function() {
        var me = this;
        var actionInstanceId = me.actionInstanceId;
        var action = undefined;
        if (actionInstanceId) {
            var page = undefined;
            if (Ext.isFunction(me.getPage) && me.getPage()) {
                page = me.getPage();
            } else {
                page = me.up("xcp_page");
            }
            if (page) {
                var actionContainer = page.getComponentByXType("xcp_action_container");
                action = actionContainer.getComponent(actionInstanceId);
                if (action) {
                    me.baseAction = action;
                    me.isAction=true;
                    action.addComponent(this);
                    me.action = action;
                    if (Ext.isFunction(action.getInitialEnablement) && !me.hasExpressionProps) {
                        var enablement = action.getInitialEnablement();
                        xcp.action.Enablement.setComponentEnablement(me, enablement);
                    } else {
                        if (action.isDisabled() !== undefined && action.isDisabled != null) {
                            me.setDisabled(action.isDisabled());
                        }
                    }
                }
            }
        }
    },
    /**
     * Wrapper action handler.
     * @private
     */
    internalHandler: function() {
        var me = this;
        if (me.action) {
            me.action.handler(me.action);
        }
    }
});


/* xcp_action_lib/content/xcp/action/form/DataAction.js */

// DataAction.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.form.DataAction
 * @extends xcp.action.Action
 * Base class for action implementations calling RESTful services
 */
Ext.define("xcp.action.form.DataAction", {
    extend: "xcp.action.Action",
    requires: ["xcp.action.Action"],
    alias: "action.dataaction",
    mixins: {
        observable: 'Ext.util.Observable',
        xcppublisher: 'xcp.event.Publisher',
        xcpsubscriber: 'xcp.event.Subscriber',
        invoker:'xcp.action.ActionInvoker'
    },
    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {
            return newValue;
        }
    }],

    statics: {
        REDIRECT_CURRENT: "current",
        REDIRECT_PREVIOUS: "previous",
        REDIRECT_SPECIFIED: "specified",
        REDIRECT_APPLICATION: "application",
        REDIRECT_NONE: "none",

        /**
         * Copy model instance data.
         *
         * @param {Ext.data.Model} source source model
         * @param {Ext.data.Model} target target model
         */
        copyModelInstance: function(source, target) {
            //action model is different from the form model, copy the value from
            //form model into action model based on the action model fields
            var fields, count, i, field, name, inputProperties = {};

            //create action model instance
            fields = source.fields;
            count = fields.getCount();

            //copy data from formInstance to a temporary array
            for (i=0; i < count; i++) {
                field = fields.getAt(i);
                name = field.mapping || field.name;
                inputProperties[name] = source.get(field.name);
            }

            //copy the data from temporary array to the action model
            fields = target.fields;
            count = fields.getCount();
            for (i = 0; i < count; i++) {
                field = fields.getAt(i);
                name = field.mapping || field.name;
                target.set(field.name, inputProperties[name]);
            }

            //return the action model
            return target;
        },

        /**
         * Gets the model associated with a selection
         *
         * @param selection The selection.
         * @param actionModel The actionModel
         */
        getModelForSelection: function(selection, actionModel) {
            var actionModelInstance = null;
            if (selection && actionModel) {
                if (Ext.ClassManager.getName(selection) === actionModel) {
                    actionModelInstance = selection;
                } else {
                    actionModelInstance = Ext.ModelManager.create({}, actionModel);
                    actionModelInstance = xcp.action.form.DataAction.copyModelInstance(selection, actionModelInstance);
                }
            }

            return actionModelInstance;
        },
        /**
         * Formats a string template using values from a model.  Templated values have the form {fieldName} and are
         * replaced by the associated field values from the model instance.
         *
         * @param stringTemplate string template
         * @param model model OR object
         */
        formatTemplateString: function(stringTemplate, model) {
            var i;
            var formatedString = stringTemplate;
            var templates = stringTemplate.match(/{[^{}]*}/);
            if (templates)
            {
                for (i = 0; i < templates.length; i++)
                {
                    var template = templates[i];
                    var fieldName = template.substring(1, template.length - 1);
                    var fieldValue = model ? model.get(fieldName) : "";
                    if (fieldValue)
                        formatedString = formatedString.replace(template, fieldValue);
                }
            }
            return formatedString;
        },

        /**
         * Formats a string template using values from the models.  Multiple items only support a count for now but
         * Single selection supports Templated values have the form {fieldName} and are
         * replaced by the associated field values from the model instance.
         *
         * @param stringTemplate string template
         * @param model model
         */
        formatTemplateStringMultiple: function(stringTemplate, models) {
            var i;
            var templates = stringTemplate.match(/{[^{}]*}/);
            var formattedString = stringTemplate;
            if (models.length == 1)
            {
                formattedString = this.formatTemplateString (stringTemplate, models[0]);
            }
            else if (templates && stringTemplate)
            {
                for (i = 0; i < templates.length; i++)
                {
                    var template = templates[i];
                    var fieldName = template.substring(1, template.length - 1);
                    // Currently only Count is supported for MultiSelect
                    var fieldValue = "";
                    if (fieldName == "Count")  // $NON-NLS-1$ 
                        fieldValue = models.length.toString(10);
                    formattedString = formattedString.replace(template, fieldValue);
                }
            }
            return formattedString;
        },

        /**
         * Handles the redirection of action success. By default, it will handle to application,
         * previous or no redirect cases. It relies on each individual action to handle the redirection to
         * instance page.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_APPLICATION) {
                xcp.navigationManager.navigate(action.redirectUrl);
            } else if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_PREVIOUS) {
                var loginHash = Ext.util.Cookies.get("xcp-login-hash");
                //user starts the application from current page, history back one does not make sense
                if (loginHash && loginHash.indexOf(Ext.util.History.getToken()) != -1) {
                    //looking for application home page
                    var modelsConfig = xcp.appConfiguration['modelsConfig'];
                    if (modelsConfig && modelsConfig["application"]) {
                        var navUrl = modelsConfig["application"].homePageUrlName;
                        if (navUrl) {
                            xcp.navigationManager.navigate(navUrl);
                            return;
                        }
                    }
                }

                window.history.back();

            } else if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_CURRENT){
                var url = xcp.navigationManager.currentNavigationContext.navigationPath;
                xcp.navigationManager.loadPage(url);
            }
        },

        /**
         * Show action error.
         * @private
         * @param {Object} component -- The eval context component (form or grid, etc)
         * @param {String} errorTemplate The action default error message NLS key
         * @param {Object} error The error
         * @param {Object} model
         */
        showActionError: function(component, errorTemplate, error, model) {
//            if (!error) {
//                // provide a reasonable error message if operation doesn't return an error object
//                var model = xcp.action.form.DataAction.getModelForComponent(component);
//                error = xcp.action.form.DataAction.formatTemplateString(errorTemplate, model);
//            } else {
//                error = error.status + " " + error.statusText + " [" + error.detailedMessage + "]";
//            }

            //always display the pre-defined error message bug #xcpuic-166
            var errorMsg = xcp.action.form.DataAction.formatTemplateString(errorTemplate, model);
            xcp.core.FeedbackManager.showFeedback(component, "", errorMsg, "systemErrors", false);
        },

        /**
         * Show success notification.
         * @private
         * @param {Object} component -- The eval context component (form or grid, etc)
         * @param {String} msgTemplate The action default error message NLS key
         * @param {Object} model
         *
         */
        notifyActionSuccess: function(component, msgTemplate, model) {
            console.log("DataAction.notifyActionSuccess before formatTemplateString");
            var successMessage = xcp.util.Utils.formatTemplateString(msgTemplate, model);
            console.log("DataAction.notifyActionSuccess after formatTemplateString");
            xcp.core.FeedbackManager.showFeedback(component, "", successMessage, "notifications");
        }
    },

    config: {

        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to true)
         */
        showConfirmation: true,
        /**
         * @cfg {String} redirectStyle Indicates redirection behavior ("none", "previous", or "specified") after
         * successfully creating the object (defaults to "none")
         */
        redirectStyle: "none",
        /**
         * @cfg {String} redirectUrl Indicates redirect location if redirectStyle is set to "specified", ignored
         * otherwise
         */
        redirectUrl: "",
        /**
         * @cfg {Boolean} showSuccessNotification True to show a success notification once the action has completed
         * successfully (defaults to true)
         */
        showSuccessNotification: true,

        /**
         * @cfg (String) redirectUrlModel indicated the data model on the redirected page.
         * (default is empty, non-empty value and redirectStyle:"specified" means the redirect will go to instance page)
         */
        redirectUrlModel: '',

        /**
         * @cfg (String) actionModel indicated the data model the action will apply to.
         * (default is empty)
         */
        actionModel: ''

    },

    constructor: function(config) {
        var me = this;
        config = (config) || {};

        me.config = config;

        me.callParent(arguments);

        me.mixins.observable.constructor.call(me, config);

        /**
         * Add beforerender and afterrender events action, this is to make expression plug-in work for action.
         */
        me.addEvents(
                "beforerender",
                "afterrender",
                "destroy",  // $NON-NLS-1$ 
                "change");  // $NON-NLS-1$ 

        me.mixins.xcppublisher.initMixin.call(me, config);
        me.mixins.xcpsubscriber.initMixin.call(me, config);
        if (me.plugins) {
            me.plugins = [].concat(me.plugins);
            for (i = 0, len = me.plugins.length; i < len; i++) {
                me.plugins[i] = me.constructPlugin(me.plugins[i]);
                me.plugins[i] = me.initPlugin(me.plugins[i]);
            }
        }

        //Subscribe to configured events for action invocation.
        me.mixins.invoker.initMixin.call(me, config);

        me.inputProperties = {};
    },

    /**
     * Initialize associated plug-ins.
     * @param plugin
     */
    constructPlugin: function(plugin) {
        if (plugin.ptype && typeof plugin.init != 'function') {
            plugin.cmp = this;
            plugin = Ext.PluginManager.create(plugin);
        }
        else if (typeof plugin == 'string') {
            plugin = Ext.PluginManager.create({
                ptype: plugin,
                cmp: this
            });
        }
        return plugin;
    },
    /**
     * Initialize individual plug-in
     * @param plugin
     */
    initPlugin : function(plugin) {
        plugin.init(this);
        return plugin;
    },


    /**
     * Delegate the parent container search to action container.
     * @param arg
     */
    up :function(arg) {
        if (this.ownerCt) {
            return this.ownerCt.up(arg);
        }
        return undefined;
    },
    /**
     *  Return the action type, it would be same as action xtype.
     */
    getXType : function() {
        return this.config.actionType;
    },
    /**
     * Returns false
     */
    isXType: function() {
        return false;
    },
    /**
     * Get the input property.
     * @param propId
     */
    getInputProperty: function(propId) {
        return this.inputProperties[propId];
    },

    /**
     * Set the input property.
     * @param value : (String) (Required) property value
     * @param propId : (String) (Required) property Id
     */
    setInputProperty: function(value, propId) {
        if(propId && !Ext.isEmpty(this.inputProperties)) {
            //format datetime to the service acceptable format
            if (Ext.isDate(value)){
                value = Ext.Date.format(value, xcp.widget.form.DateTimeField.BACKEND_DATE_VALUE_FORMAT+xcp.widget.form.DateTimeField.BACKEND_TIME_VALUE_FORMAT)
            }
            var props = propId.split(".");
            var obj = this.inputProperties;
            if (props.length > 1) {
                for (var i=0; i < props.length-1; i++) {
                    if (!(props[i] in obj)) {
                        obj[props[i]] = {};
                    }
                    obj = obj[props[i]];
                }
            }
            obj[props[props.length-1]] = value;
        }
    },
    getOutputProperty: function(propId) {
        if (this.actionModelInstance) {
            return this.actionModelInstance.get(this._getFieldName(propId));
        }
        return null;
    },
    _getFieldName: function(propId) {
        var fields = this.actionModelInstance.fields;
        var count = fields.getCount();
        for (var i=0; i < count; i++) {
            var field = fields.getAt(i);
            var name = field.mapping || field.name;
            if (name == propId) {
                return name;
            }
        }
        return propId;
    },

    /**
     * Associates model instance with this action.
     * @param model
     */
    setInputModel: function(model) {
        if (model) {
            this.inputModel = model;
        }
    },

    /**
     * Get action model instance.
     *
     */
    getActionModel: function() {
        var inputModelProperties = {}, model;
        if (!Ext.isEmpty(this.actionModel)) {
            model = Ext.ModelManager.create({}, this.actionModel);
            this.clearDefaultModelData(model);
        }
        if ((this.inputModel instanceof Ext.data.Model)
            && (this.inputModel.modelName == this.actionModel)) {
            model = this.inputModel;
        } else {
            var i, j, fields, count;
            //copy properties from input model if it exists
            if (!Ext.isEmpty(this.inputModel) && (this.inputModel instanceof Ext.data.Model)) {
                fields = this.inputModel.fields;
                count = fields.getCount();
                for (i = 0; i < count; i++) {
                    var field = fields.getAt(i);
                    var name = field.mapping || field.name;
                    inputModelProperties[name] = this.inputModel.get(field.name);
                }
            }
            //Copy input properties to action model
            fields = model.fields;
            count = fields.getCount();
            for (j = 0; j < count; j++) {
                field = fields.getAt(j);
                var name = field.mapping || field.name;
                //get latest value from inputProperties first if it exists
                if (name in this.inputProperties) {
                    var value = this.inputProperties[name];
                    this.setNestedModelProperty(model, name, this.inputProperties[name]);
                    //model.set(field.name, this.inputProperties[name]);
                }
                //otherwise copy value from input model
                else if (name in inputModelProperties) {
                    model.set(field.name, inputModelProperties[name]);
                }
            }
        }
        this.normalizeModelInstance(model);
        return model;
    },
    setNestedModelProperty: function(model, name, value) {
        if (value === undefined || value === null) {
            return;
        }
        if (Ext.isObject(value) && !Ext.isArray(value)) {
            for (var childName in value) {
                if (!childName) {
                    continue;
                }
                this.setNestedModelProperty(model, name + "." + childName, value[childName]);
            }
        } else {
             model.set(name, value);
        }
    },
    clearDefaultModelData: function(parentModel) {
        parentModel.data = {};
    },
    normalizeModelInstance: function(model) {
        var fields = model.fields;
        for (var i=0; i< fields.getCount(); i++) {
            var field = fields.getAt(i);
            if (model && Ext.isFunction(model.isNestedModelField) && model.isNestedModelField(field)) {
                var nestedInstance = model.getNestedModelInstance(field.name);
                if (nestedInstance) {
                    this.normalizeModelInstance(nestedInstance);
                    if (nestedInstance && this.canDeleteEmptyModelInstance(nestedInstance)) {
                        if (this.isEmptyModelInstance(nestedInstance)) {
                            model.set(field.name, undefined);
                        }
                    }
                }
            }
        }
    },
    canDeleteEmptyModelInstance: function(model) {
        var flag=false;
        if (model.hasIdProperty()) {
            var idValue = model.getId();
            if (model.phantom || Ext.isEmpty(idValue)) {
                flag=true;
            }
        }
        return flag;
    },
    isEmptyModelInstance: function(model) {
        var empty = true;
        if (model && model.data) {
            var fields = model.fields;
            for (var i=0; i< fields.getCount(); i++) {
                var field = fields.getAt(i);
                var value = model.get(field.name);
                if (!(Ext.isEmpty(value) || value === false || value === 0)) {
                    empty = false;
                    break;
                }
            }
        }
        return empty;
    },
    destroy: function() {
        this.inputProperties = null;
        this.fireEvent("destroy", this);
    }
});

/* xcp_action_lib/content/xcp/action/task/BaseTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// BaseTaskDataAction.js

/**
 * @class xcp.action.task.BaseTaskDataAction
 * @extends xcp.action.form.DataAction
 * Base Action implementation for task actions.
 */
Ext.define("xcp.action.task.BaseTaskDataAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.xcp_base_task",

    statics: {
        TaskAttributeMapping: {
            "isdelegable": "is_delegable",
            "performer":"task_performer_name",
            "state": "task_state",
            "queue_name": "workqueue_name",
            "isrejectable": "is_rejectable",
            "isrepeatable":"is_repeatable"
        },
        CurrentTaskAttributeBase : "executionData.currenttask.",
        WorkflowAttributeMapping: {
            "supervisor_name":"supervisor_name"
        },
        WorkflowAttributeBase : "executionData.taskworkflow.",
        QueueRoles : {
            QUEUE_ADMIN : "queue_admin",
            QUEUE_MANAGER: "queue_manager",
            QUEUE_ADVANCE_PROCESSOR : "queue_advance_processor",
            QUEUE_PROCESSOR : "queue_processor"
        },
        UserPrivileges : {
            SYSTEM_ADMIN : 8,
            SUPER_USER : 16
        },
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {string} id  instance id
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, id, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;
            if (xcp.action.form.DataAction.REDIRECT_SPECIFIED == action.redirectStyle) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    url = action.redirectUrlModel + "/" + id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        },

        /**
         * Returns true if the logged in user is queue admin.
         */
        isQueueAdmin : function() {
            if(! Ext.isEmpty(xcp.currentUser)) {
                if(xcp.currentUser.queueRole === xcp.action.task.BaseTaskDataAction.QueueRoles.QUEUE_ADMIN) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Returns true if the logged in user is queue manager
         */
        isQueueManager : function() {
            if(! Ext.isEmpty(xcp.currentUser)) {
                if(xcp.currentUser.queueRole === xcp.action.task.BaseTaskDataAction.QueueRoles.QUEUE_MANAGER) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Returns true if the logged in user is queue advance processor
         */
        isQueueAdvanceProcessor : function() {
            if(! Ext.isEmpty(xcp.currentUser)) {
                if(xcp.currentUser.queueRole === xcp.action.task.BaseTaskDataAction.QueueRoles.QUEUE_ADVANCE_PROCESSOR) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Returns true if the logged in user is queue process
         */
        isQueueProcessor : function() {
            if(! Ext.isEmpty(xcp.currentUser)) {
                if(xcp.currentUser.queueRole === xcp.action.task.BaseTaskDataAction.QueueRoles.QUEUE_PROCESSOR) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Returns true if the logged in user has Sysadmin
         */
        isSysAdmin : function() {
            if(! Ext.isEmpty(xcp.currentUser)) {
                    if(xcp.currentUser.userPrivileges >= xcp.action.task.BaseTaskDataAction.UserPrivileges.SYSTEM_ADMIN) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Returns true if the logged in user is Superuser
         */
        isSuperUser : function() {
            if(! Ext.isEmpty(xcp.currentUser)) {
                if(xcp.currentUser.userPrivileges >= xcp.action.task.BaseTaskDataAction.UserPrivileges.SUPER_USER) {
                    return true;
                }
            }
            return false;
        },
        hasTaskState: function(actionArgs, action, state) {
            var me = xcp.action.task.BaseTaskDataAction;
            var targets = action.getTargets(actionArgs);
            if (targets && targets.length > 0) {
                var target = targets[0];
                if (state !== undefined && state !== null) {
                    var taskState = me.getTaskAttribute(actionArgs, action, "state");
                    if (Ext.isArray(state)) {
                        for (var i=0; i < state.length; i++) {
                            if (state[i] === taskState)  {
                                return true;
                            }
                        }
                    } else {
                        return (state === taskState);
                    }
                }
            }
            return false;
        },
        isTaskPerformer:function(actionArgs, action) {
            var me = xcp.action.task.BaseTaskDataAction;
            var performer = me.getTaskAttribute(actionArgs, action, "performer");
            return performer == xcp.currentUser.currentUser;
        },
        isWorkflowSupervisor: function(actionArgs, action) {
            var me = xcp.action.task.BaseTaskDataAction;
            var supervisorName = me.getWorkflowAttribute(actionArgs, action, "supervisor_name");
            return supervisorName == xcp.currentUser.currentUser;
        },
        isTaskActionApplicable: function(actionArgs, action, superUser, sysAdmin, supervisor, taskPerformer, state, roles) {
            var me = xcp.action.task.BaseTaskDataAction;
            var targets = action.getTargets(actionArgs);
            var applicable=false;
            var applicableState = !Ext.isEmpty(state) ? me.hasTaskState(actionArgs, action, state) : true;
            if (targets && targets.length > 0) {
                var target = targets[0];
                if (applicableState) {
                    if (superUser) {
                        applicable = applicable || me.isSuperUser();
                    }
                    if (sysAdmin && !applicable) {
                        applicable = applicable || me.isSysAdmin();
                    }
                    if (taskPerformer && !applicable) {
                        applicable = applicable || me.isTaskPerformer(actionArgs, action);
                    }
                    if (supervisor && !applicable) {
                        applicable = applicable || me.isWorkflowSupervisor(actionArgs, action);
                    }
                }
            }
            return applicable;
        },
        isQueueTaskActionApplicable: function(actionArgs, action, queueAdmin, queueManager, queueAdvanceProcessor, queueProcessor, taskPerformer, state, roles) {
            var me = xcp.action.task.BaseTaskDataAction;
            var targets = action.getTargets(actionArgs);
            var applicable=false;
            var applicableState = !Ext.isEmpty(state) ? me.hasTaskState(actionArgs, action, state) : true;
            if (targets && targets.length > 0 &&
                xcp.action.task.BaseTaskDataAction.isQueueTask(actionArgs, action)) {
                var target = targets[0];
                if (applicableState) {
                    if (queueAdmin) {
                        applicable = applicable || me.isQueueAdmin();
                    }
                    if (queueManager && !applicable) {
                        applicable = applicable || me.isQueueManager();
                    }
                    if (taskPerformer && !applicable) {
                        applicable = applicable || me.isTaskPerformer(actionArgs, action);
                    }
                    if (queueProcessor && !applicable) {
                        applicable = applicable || me.isQueueProcessor();
                    }
                    if (queueAdvanceProcessor && !applicable) {
                        applicable = applicable || me.isQueueAdvanceProcessor();
                    }
                }
            }
            return applicable;
        },
        isQueueTask: function(actionArgs, action) {
            var targets = action.getTargets(actionArgs);
            var queueTask = false;
            if (targets && targets.length > 0) {
                var wqName = targets[0].get('workqueue_name');
                if (Ext.isEmpty(wqName)) {
                    wqName = targets[0].get('executionData.currenttask.queue_name');
                }
                queueTask = !Ext.isEmpty(wqName);
            }
            return queueTask;

        },
        getAttribute: function(actionArgs, action, attributeName, mapping, attributeBase) {
            var targets = action.getTargets(actionArgs);
            var value = undefined;
            if (targets && targets.length > 0) {
                var taskListAttributeName = mapping[attributeName];
                if (Ext.isEmpty(taskListAttributeName)) {
                    taskListAttributeName = attributeName;
                }
                var target = targets[0];
                value = target.get(taskListAttributeName);
                if (Ext.isEmpty(value)) {
                    attributeName = attributeBase + attributeName;
                    value = target.get(attributeName);
                }
            }
            return value;
        },
        getTaskAttribute: function(actionArgs, action, attributeName){
            var me = xcp.action.task.BaseTaskDataAction;
            return me.getAttribute(actionArgs, action,
                                            attributeName,
                                            me.TaskAttributeMapping,
                                            me.CurrentTaskAttributeBase);
        },
        getWorkflowAttribute: function(actionArgs, action, attributeName) {
            var me = xcp.action.task.BaseTaskDataAction;
            return me.getAttribute(actionArgs, action,
                                            attributeName,
                                            me.WorkflowAttributeMapping,
                                            me.WorkflowAttributeBase);
        },
        isContextMenuAction: function(action) {
            if(action) {
                if(!(action.ownerCt && action.xcpId)) {
                    return true;
                }
            }
            return false;
        },
        isTaskViewPageExist: function(actionArgs, action) {
            var targets = action.getTargets(actionArgs);
            if(targets && targets.length > 0) {
                var taskObj = targets[0];
                if (taskObj){
                    var processName = taskObj.get("process_system_name");
                    var activityName = taskObj.get("activity_system_name");
                    if (xcp.util.Utils.isPageExist(processName, activityName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    },
    getInitialEnablement: function() {
        return xcp.Enablement.HIDE;
    },
    getComponents: function() {
        return this.items;
    },
    getLocaleBundle: function() {
        var bundleName = this.getLocaleBundleName();
        if (bundleName) {
            try {
                return eval(bundleName);
            } catch (e) {
                xcp.Logger.error("The locale bundle : [" + bundleName + "] not defined")
            }
        } else {
            //TODO: get the name of the class
            xcp.Logger.error("No locale bundle defined for the class : "+ this.className);
        }
        return {};
    },
    /**
     * Returns the localized string
     * @param localeKey: Resource key
     */
    getLocalizedString: function(localeKey) {
        var localeObject = this.getLocaleBundle();
        if (localeObject && localeObject[localeKey]) {
            return localeObject[localeKey];
        } else {
            xcp.Logger.error("Could not find the locale key : "+ localeKey + " in locale bundle" + this.getLocaleBundleName());
        }
    },
    /**
     * Returns the localized formatted confirmation message.
     * @param model
     */
    getConfirmationMessage: function(model) {
        return xcp.action.form.DataAction.formatTemplateString(this.getConfirmationPromptTemplate(), model);
    },
    /**
     * Returns the confirmation prompt message template
     */
    getConfirmationPromptTemplate: function() {
        return this.getLocalizedString("confirmationPromptTemplate");
    },
    /**
     * Returns the localized confirmation message dialog title.
     */
    getConfirmationTitle: function() {
        return this.getLocalizedString("confirmationTitle");
    },
    /**
     * Returns the success notification template
     */
    getSuccessNotificationTemplate: function() {
        return this.getLocalizedString("updateSuccessNotificationTemplate");
    },
    /**
     * Returns the error feedback target component. There can be different targets depending on
     * the invoker of the action instance.
     */
    getEffectiveErrorFeedbackComponent: function(actionArgs) {
        var comp = this.ownerCt;
        if (this.errorFeedbackContainer) {
            comp = this.errorFeedbackContainer;
        } else if (this.ownerCt) {
            comp = this.ownerCt;
        } else {
            comp = actionArgs.component;
        }
        return comp;
    },
    /**
     * Returns the success feedback target component.
     */
    getEffectiveSuccessFeedbackContainer: function(actionArgs) {
        var comp = this.ownerCt;
        if (this.successFeedbackContainer) {
            comp = this.successFeedbackContainer;
        } else if (this.ownerCt) {
            comp = this.ownerCt;
        } else {
            comp = actionArgs.component;
        }
        return comp;
    },
    /**
     * Action invocation success handler, ideally the sub-classes should override this
     * method to do the action execution post processing rather than overriding the
     * action handler method.
     * @param record: Affected record/model instance
     * @param operation: An operation object which contains various details about server response
     * @param model: The original model object on which the operation was performed.
     */
    successHandler: function(record, operation, model, actionArgs) {
        var successFeedBackContainer = this.getEffectiveSuccessFeedbackContainer(actionArgs);
        var callBackConfig = this.callBackConfig;
        if (callBackConfig) {
            var scope = callBackConfig.scope || new Object();
            var handler = callBackConfig.handler;
            if (handler && Ext.isFunction(handler)) {
                var successData = {
                    operation: operation,
                    records: record
                };
                handler.call(scope, successData);
            }

        }
        var id = model.getId();
        //Don't publish the event if the redirect style is specified
        if(xcp.action.form.DataAction.REDIRECT_NONE === this.redirectStyle) {
            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, id);
        }
        if (this.showSuccessNotification) {
            xcp.action.form.DataAction.notifyActionSuccess(successFeedBackContainer, this.getSuccessNotificationTemplate(), model);
        }

        var workflowAutoNextTask = xcp.UserPreferences.get('workflowAutoNextTask');
        var workflowAutoNextTask = (workflowAutoNextTask == "true");
        var doAutoNextTask = (workflowAutoNextTask) && this.isGetNextTaskAction();
        if (doAutoNextTask) {
            //in call back of the service call check if there is any response sent
            var handleGetNextTaskSuccess = function(record, operation) {
                xcp.event.EventBus.publish(xcp.event.ItemModified.NAME);
                var activityName = record.get("activityName");
                var processName = record.get("processName");
                if (xcp.util.Utils.isPageExist(processName, activityName)) {
                    xcp.action.task.GetNextTaskDataAction.handleRedirection(record);
                } else {
                    xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.GetNextTaskDataAction.GetNextTaskAssignNotificationTemplate, record);
                    xcp.action.task.BaseTaskDataAction.handleRedirection(this, id, record, operation);
                }

            };

            // if no new task are sent, then redirect using the action redirect configuration
            var handleGetNextTaskFailure = function(record, operation) {
                var error = operation.getError();
                xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, '');
                if (error !== undefined && error.status == 404) {
                    xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.GetNextTaskDataAction.TasksUnavailableNotificationTemplate);
                    xcp.action.task.BaseTaskDataAction.handleRedirection(this, id, record, operation);
                }
                xcp.Logger.log("No work queue tasks available for the user");
            };

            //make get next task service call
            get_next_task_model.load(null, {
                        scope: this,
                        success : handleGetNextTaskSuccess,
                        failure : handleGetNextTaskFailure
                    });

        } else {
            xcp.action.task.BaseTaskDataAction.handleRedirection(this, id, record, operation);
        }

    },

    /**
     * Handler for the UpdateAction
     */
    handler: function(actionArgs, action) {
        var config = null;
        var targets= null;
        var model = null;
        if (Ext.isEmpty(action)) { //delete action invoked from form button
//            //update action's input model when action is invoked.
//            if (!Ext.isEmpty(actionArgs.selection))
//                this.setInputModel(actionArgs.selection[0]);
//
            action = this;
            config = this.getConfig();
            targets = [this.getActionModel()];
            model = targets && targets.length>0 ? targets[0] : {};
        }
        else {
            config = action.getConfig();
            targets = action.getTargets(actionArgs);

            model=xcp.action.form.DataAction.getModelForSelection(targets[0], this.actionModel);
        }

        //to set model instance property "phantom" to be false since this action model is just created
        //and ExtJs expected this value to be false so it can issue a "PUT" action to the server
        model.phantom = false;

        var id = model.getId();

        var errorFeedBackContainer = action.getEffectiveErrorFeedbackComponent(actionArgs);

        var successHandlerInternal= function(record, operation) {
            action.successHandler(record, operation, model, actionArgs);
        };
        // Show confirmation if configured
        if (action.getShowConfirmation(config)) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    model.save({success: successHandlerInternal, feedbackContainer: errorFeedBackContainer, scope: action, actionConfig: config});
                }
            };
            Ext.Msg.show({
                title:  action.getConfirmationTitle(),
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: action.getConfirmationMessage(model),
                scope: action
            });
        } else {
            model.save({success: successHandlerInternal, feedbackContainer: errorFeedBackContainer, scope: action, actionConfig: config});
        }
    },
    /**
     * Return the show confirmation configuration.
     * @param config
     */
    getShowConfirmation: function(config) {
        if (config && config.showConfirmation) {
            return config.showConfirmation;
        } else if (this.showConfirmation) {
            return this.showConfirmation;
        }
        return false;
    },

    /**
    * Return if get next task should be triggered from this action. Defaulted to "false"
    */
    isGetNextTaskAction: function() {
        return false;
    }
});

/* xcp_pagelayoututils/content/xcp/util/PageLayoutUtils.js */

/**
 * @class xcp.util.PageLayoutUtils
 *
 * A singleton utility class used to support page layout
 */
Ext.define("xcp.util.PageLayoutUtils", {
    extend: 'Ext.util.Observable',
    singleton: true,

    constructor: function() {
        this.callParent();

        /**
         * Fires when there are no more deferred tasks.
         */
        this.addEvents(
            /* Fires when there are no more deferred tasks, but before layouts were done */
            "afterexecution",

            /* Fires when there are no more deferred tasks, but after layouts were done */
            "afterlayout"
        );

        var me = this;
        me.delayedHandlers = [];
        me.task = new Ext.util.DelayedTask(function () {
            try {
                Ext.suspendLayouts();
                for (var i=0; i<me.delayedHandlers.length; i++) {
                    me.delayedHandlers[i].call(this);
                }
            }
            finally {
                me.fireEvent("afterexecution");
                me.delayedHandlers = [];
                Ext.resumeLayouts(true);
                me.fireEvent("afterlayout");
            }
        })
    },

    /**
     * Method for adding a deferred layout
     *
     * @param handler the layout handler
     * @param scope the scope for the layout handler
     */
    defer: function(handler, scope) {
        var fn = Ext.Function.bind(handler, scope);
        this.delayedHandlers.push(fn);
        this.task.delay(1);
    }
});
/* xcp_expression_lib/content/xcp/core/expr/EvaluationContext.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */
/*
* @class xcp.core.expr.EvaluationContext
* An Evaluation context is a sole data provider required for evaluating expressions, it provides data like
*    - Model instances from expression execution scope (page)
*    - Widget from expression execution scope (page)
*    - Application context
*    - User Profile
*    - Expression arguments like localized strings
 */
Ext.define("xcp.core.expr.EvaluationContext", {
    /**
     * @cfg {Container} (Required) The scope in which the required components and models for evaluting the expression
     * are located.
     */
    evalScope: null,
    /**
     * @cfg {Object} (Optional) The list of expression const (typically localized strings) used in expression.
     */
    arguments : {},
    /**
     * @cfg {Object} (Optional) The list of model instances which could not be located from evalScope container.
     * Example : For evaluating the expression associated with result list column value during result list rendering,
     * the selection model on the result list would not have been set.
     */
    models: {},
    /**
     * @constructor
     * @param evalScope {Container} The scope in which the required components and models for evaluting the expression
     * are located.
     * @param expressionConfig {Object} The expression configuration object.
     */
    constructor : function (evalScope, expressionConfig) {
        this.evalScope = evalScope;
        if (expressionConfig)   {
            if (expressionConfig.models) {
                this.models = expressionConfig.models;
            }
            if (expressionConfig.arguments)
            this.arguments = expressionConfig.arguments;
        }
        if (Ext.isFunction(evalScope.getFlowExecutionContext)) {
            this.flowExecutionContext = evalScope.getFlowExecutionContext();
        } else {
            this.flowExecutionContext = {};
        }

    },
    /**
     * Locate and returns the model instance for the given model name/alias.
     * @param modelNameOrAlias {String} (Required) model name/alias
     * @return {Ext.data.Model} model instance
     */
    getModel : function(modelNameOrAlias) {
        if (this.models && this.models[modelNameOrAlias]) {
            return this.models[modelNameOrAlias];
        }
        var component = undefined;
        if (this.evalScope instanceof xcp.widget.Page) {
            component = this.evalScope.getComponentByModelName(modelNameOrAlias);
        } else {
            component = xcp.util.Utils.queryComponentByModelName(this.evalScope, modelNameOrAlias);
        }
        if (component && Ext.isFunction(component.getModel)) {
            return component.getModel(modelNameOrAlias);
        }
        return null;
    },
    /**
     * Locate and returns the component instance for the given component id/name.
     * @param compIdOrName {String} (Required)
     * @return (Ext.Component) Component object.
     */
    getComponent:function(compIdOrName) {
        var component = undefined;
        if (this.evalScope instanceof xcp.widget.Page) {
            component = this.evalScope.getComponentByXCPId(compIdOrName);
        } else {
            component = xcp.util.Utils.queryComponentByXCPIdOrName(this.evalScope, compIdOrName);
        }
        if (component && component.length > 0) {
            if (component.length == 1) {
                component = component[0];
            } else {
                // Somehow ended up with multiple components with the same id, maybe from nested content pages
                // Most likely want the component from the same container/page rather than one from a nested content
                // so prioritize the one that is closest
                var topContainer = this.evalScope;
                var indexFinder = function(component) {
                    var index = 0;
                    var container = component.ownerCt;
                    while (topContainer != container) {
                        if (container.isXType("xcp_page")) {
                            index = index + 1;
                        }
                        container = container.ownerCt;
                    }
                    return index;
                };
                var candidates = component;
                component = candidates[0];
                var lowestIndex = indexFinder(component);
                var i = 1;
                for (; i < candidates.length; i++) {
                    var currentIndex = indexFinder(candidates[i]);
                    if (currentIndex < lowestIndex) {
                        lowestIndex = currentIndex;
                        component = candidates[i];
                    }
                }
            }
        } else {
            component = null;
        }
        return component;
    },
    /**
     * Returns the expression arguments list.
     * @return {Object}
     */
    getArguments : function() {
        return this.arguments;
    },
    /**
     * Returns the application context object
     * @return {Object}
     */
    getAppContext : function() {
        return xcp.appContext;
    },
    /**
     * Returns the logged in user details
     * @return {Object}
     */
    getUserContext: function() {
        //TODO add role and theme details to the return object
        return xcp.currentUser;
    },
    /**
     * Returns the current navigation context.
     * @return {Object}
     */
    getNavigationContext: function() {
        if (!xcp.navigationManager) {
            // happens during unit test
            return {};
        }
        return xcp.navigationManager.currentNavigationContext;
    },
    /**
     * Returns the parameter context
     * @return {Object}
     */
    getParameterContext: function() {
        return xcp.core.ApplicationParameterManager;
    },
    /**
     * Returns the action instances from action container.
     * @param actionId
     */
    getAction: function(actionId) {
        var actionContainer = this.evalScope.down("xcp_action_container");
        if (actionContainer) {
            return actionContainer.getComponent(actionId);
        }
    },
    /**
     * Returns the action flow evaluation context
     */
    getFlowExecutionContext:function()  {
        return this.flowExecutionContext;
    }

});


/* xcp_expression_lib/content/xcp/core/expr/BaseExpression.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * A set of utility functions to fetch values from various sources during expression eval.
 */
Ext.define("xcp.core.expr.BaseExpression", {
    /**
     * Returns the empty string if return of the expr eval is undefined or null.
     * @private
     * @param value
     */
    statics : {
        checkValue : function (value) {
            if (value === undefined || value === null) {
                value = "";
            }
            return value;
        }
    },

    /**
     * Returns field value from the model instance.
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param modelNameOrAlias  {String} (Required) The model name/alias
     * @param fieldId  {String} (Required)
     */
    getValueFromModel: function(context, modelNameOrAlias, fieldId) {
        var model = context.getModel(modelNameOrAlias);
        var value = "";
        if (model) {
            value = model.get(fieldId);
        } else {
            xcp.Logger.warn("Could not find the model : " + modelNameOrAlias);
        }
        return xcp.core.expr.BaseExpression.checkValue(value);
    },

    /**
     * Returns property value from the widget.
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param compId  {String} (Required) The component id.
     * @param propId {String} (Required)
     */
    getValueFromWidget: function(context, compId, propId) {
        var comp = context.getComponent(compId);
        var value = "";
        var getterFun = null;
        if (comp && propId) {
            var getterFunName = 'get' + Ext.String.capitalize(propId);  // $NON-NLS-1$ 
            getterFun = comp[getterFunName];
        }
        if (!comp || !(propId in comp || Ext.isFunction(getterFun))) {
            xcp.Logger.warn("Could not find the component with id : " + compId);
        } else {
            value =  Ext.isFunction(getterFun) ? getterFun.call(comp) : comp[propId];
        }
        return xcp.core.expr.BaseExpression.checkValue(value);
    },

    /**
     * Returns the field value from the selection model associated with the given component
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param compId  {String} (Required) The component id
     * @param fieldId  {String} (Required)
     */
    getValueFromSelectionModel: function(context, compId, fieldId) {
        var comp = context.getComponent(compId);
        var value = "";
        if (!comp) {
            xcp.Logger.warn("Could not find the component : " + compId);
        }
        else {
            //case: the obtained component is the wrapper not grid itself. XCPUIC-3092
            if(comp.getXType() == 'xcp_facet_container') {
                comp = comp.up('xcp_results_list').down('xcp_results_list_grid');
            }
            var models = comp.getSelectionModel().getSelection();
            var model = null;
            if (Ext.isArray(models)) {
                if (models.length == 1) {
                    model = models[0];
                    value = model.get(fieldId);
                    return xcp.core.expr.BaseExpression.checkValue(value);
                }
                else if (models.length > 1) {
                    model = models;
                    value = [];
                    for (var i = 0; i < model.length; i++)
                        value.push(model[i].get(fieldId));
                }
            }
        }
        return xcp.core.expr.BaseExpression.checkValue(value);
    },
    /**
     * Returns the property value from Data Source action model.
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param actionId {String} (Required) The action instance id
     * @param fieldId  {String} (Required)
     */
    getValueFromDataSourceActionModel: function(context, actionId, fieldId) {
        var action = context.getAction(actionId);
        var value = "";
        if (!action) {
            xcp.Logger.warn("Could not find the action with id : " + compId);
        } else {
            value =  action.getOutputProperty(fieldId);
        }
        return xcp.core.expr.BaseExpression.checkValue(value);
    },

    /**
     * Returns the value for the expression argument.
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param argId  {String} (Required) argument Id.
     */
    getValueFromArgument : function(context, argId) {
        var args = context.getArguments();
        return xcp.core.expr.BaseExpression.checkValue(args[argId]);
    },
    /**
     * Returns the value for the given app context property.
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param propId  {String} (Required) app context property Id.
     */
    getValueFromAppContext : function(context, propId) {
        var appContext = context.getAppContext();
        return xcp.core.expr.BaseExpression.checkValue(appContext[propId]);
    },

    /**
     * Returns the value for the given user context property.
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param propId  {String} (Required) user context property Id.
     */
    getValueFromUserContext : function(context, propId) {
        var userContext = context.getUserContext();
        return xcp.core.expr.BaseExpression.checkValue(userContext[propId]);
    },
    /**
     * Returns the value for the given navigation context property
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param propId  {String} (Required) user context property Id.
     */
    getValueFromNavContext : function(context, propId) {
        var navContext = context.getNavigationContext();
        return xcp.core.expr.BaseExpression.checkValue(navContext[propId]);
    },
    /**
     * Returns the value for the application parameter
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param namespace {String} {Required} namespace associated with the parameter
     * @param propId  {String} (Required) user context property Id.
     */
    getValueFromParameterContext : function(context, namespace, propId) {
        var parameterContext = context.getParameterContext();
        var value = parameterContext.getAppParameter(namespace, propId);
        return xcp.core.expr.BaseExpression.checkValue(value);
    },
    /**
     * Predefined expression function to get the current object id from the navigation context
     * @param Context
     */
    currentObjectId:function(context) {
        return this.getValueFromNavContext(context, "objectId");
    },
    /**
     * Returns the model instance.
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param modelNameOrAlias  {String} (Required) The model name/alias
     */
    getModel: function(context, modelNameOrAlias) {
        return context.getModel(modelNameOrAlias);
    },
    /**
     * Returns the action flow input properties
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param propId  {String} (Required) user context property Id.
     */
    getValueFromActionFlowInputModel: function(context, modelId, propId) {
        var value = undefined;
        var actionFlowExecutionContext = context.getFlowExecutionContext();
        if (actionFlowExecutionContext) {
            value = actionFlowExecutionContext.getInputPropertyValue(propId);
        }
        //return xcp.core.expr.BaseExpression.checkValue(value);
        return value;
    },
    getValueFromStringArray: function(arrayObj, index) {
        return this.getValueFromArray(arrayObj, index, "");
    },
    getValueFromIntegerArray: function(arrayObj, index) {
    	return this.getValueFromArray(arrayObj, index, 0);
    },
    getValueFromFloatArray: function(arrayObj, index) {
    	return this.getValueFromArray(arrayObj, index, 0);
    },
    getValueFromDatetimeArray: function(arrayObj, index) {
    	return this.getValueFromArray(arrayObj, index, new Date());
    },
    getValueFromBooleanArray: function(arrayObj, index) {
    	return this.getValueFromArray(arrayObj, index, false);
    },
    getValueFromArray: function(arrayObj, index, defaultValue) {
        var value= defaultValue;
        if (arrayObj !== null && arrayObj !== undefined && Ext.isArray(arrayObj)) {
            if (arrayObj.length > index) {
                value = arrayObj[index];
            }
        }
        return value;
    }
});

/* xcp_expression_lib/content/xcp/core/expr/ExpressionManager.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * A facade to expression functions execution.
 */
Ext.define("xcp.core.expr.ExpressionManager", {
    singleton:true,
    /**
     * Execute the expression function as per the given expression config.
     * @param evalScope {Ext.Container} (Required} The scope in which the required components and models for evaluting the expression
     * are located.
     * @param exprConfig {Object} (Required} The expression config object.
     */
    evaluate : function(evalScope, exprConfig) {
        var exprValue = "";
        if (exprConfig.etype) {
            var evaluationContext = new xcp.core.expr.EvaluationContext(evalScope, exprConfig);
            var func = null;

                if (xcp.expression && Ext.isFunction(xcp.expression.Generated[exprConfig.etype])) {
                    exprValue = xcp.expression.Generated[exprConfig.etype](evaluationContext);
                } else {
                    try {
                        func = eval(exprConfig.etype);
                        exprValue = func.apply(new Object(), [evaluationContext]);
                    } catch(e) {
                        xcp.Logger.error("Could not find the generated expression function :" + exprConfig.etype);
                    }
                }
        } else {
            //Could not find expression function, assume as a static value binding and so
            // return the expr config as expression value
            exprValue =  exprConfig;
        }
        return exprValue;
    },

    /**
     * Execute the expression function as per the given expression config.
     * IMPORTANT:  This method is used on MetaDataAwareModel classes to gather any attributes missing in existing metadata.
     * @param evalScope {Ext.Container} (Required} The scope in which the required components and models for evaluting the expression
     * are located.
     * @param exprConfig {Object} (Required} The expression config object.
     */
     preEvaluate : function(evalScope, exprConfig) {

        var exprValue = "";
        if (exprConfig.etype) {
            var evaluationContext = new xcp.core.expr.EvaluationContext(evalScope, exprConfig);
            var func = null;

                if (xcp.expression && Ext.isFunction(xcp.expression.Generated[exprConfig.etype])) {
                    exprValue = xcp.expression.Generated[exprConfig.etype](evaluationContext);
                }
        }
    }

});


/* xcp_expression_lib/content/xcp/core/expr/ExpressionPropertiesPlugin.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function() {
/**
 * A plugin which adds ability to component for handling the expression configuration for calculated properties
 */
Ext.define('xcp.core.expr.ExpressionPropertiesPlugin', {
    extend: 'Ext.AbstractPlugin',
    alias: 'plugin.xcp_expression_properties',
    /**
     * @constructor
     * @param config {Object} (Required) expression configuration.
     */
    constructor : function(config) {
        if (config) {
            this.config = config;
        } else {
            this.config = {};
        }
    },
    processExpressionConfig: function() {
        var widget = this.ownerWidget;
        var exprConfigs = this.config.expression;

        //Check if the expression config is available.
        if (exprConfigs) {
            //TODO: get the containerXType from expressionConfig for action flow wizard
            var containerXType = "xcp_page";
            var baseChannelName = "";
            var container = undefined;
            //Look for page container in page context first
            if (widget && Ext.isFunction(widget.getPage)) {
                container = widget.getPage();
            }
            if (!container) {
                container = widget.up(containerXType);
            }
            if (container) {
                baseChannelName = container.id;
            }
            if (baseChannelName) {
                baseChannelName += ".";
            }
            if (!Ext.isArray(exprConfigs)) {
                exprConfigs = [exprConfigs];
            }
            for (var i = 0; i < exprConfigs.length; i++) {
                var exprConfig = exprConfigs[i];
                var events = exprConfig["events"];
                var eventHandler = this.createEventHandler(widget, exprConfig, containerXType);
                //Subscribe to events for dynamic inputs
                if (events) {
                    if (!Ext.isArray(events)) {
                        events = [events];
                    }
                    //Keep track of registered events to eliminate the duplicate events
                    var registeredEvents = new Ext.util.MixedCollection();
                    for (var k = 0; k < events.length; k++) {
                        var event = baseChannelName + events[k];
                        if (!registeredEvents.containsKey(event)) {

                            var handle = xcp.event.EventBus.subscribe(event, eventHandler, widget);
                            //Cache the subscribed event for cleaning purpose
                            widget.xcpEventSubs.add(handle, handle);
                            registeredEvents.add(event, event);
                        }

                    }
                }
                else {

                        //Call the expression eval function manually after component is rendered to handle, things like
                        // 1. All expression inputs are static.
                        // 2. Some of the dynamic input have the initial values.
                        eventHandler.call(widget, true);
                }
                widget.on("afterrender", eventHandler, widget);
            }
        }
    },
    /**
     * Handles the expression configuration and perform the required event hookups.
     * @override
     * @param widget {Ext.Component} (Required)
     */
    init: function(widget) {
        var exprConfigs = this.config.expression;
        //Check if the expression config is available.
        if (exprConfigs && exprConfigs.length > 0) {
            this.ownerWidget = widget;
            widget.hasExpressionProps = true;
            widget.on("beforerender", this.processExpressionConfig, this);
        }
    },
    /**
     * Create an expression evaluation handler function, the generated function gets registered as event handler to any
     * dynamic expression inputs change events.
     * @private
     * @param sourceComp {Ext.Component} the component
     * @param exprConfig
     * @param containerXType
     */
    createEventHandler : function(sourceComp, exprConfig, containerXType) {
        var outputPropId = exprConfig["propertyId"];
        var propSetterFunName = exprConfig["setterFunName"];

        //Create expression eval handler function
        var exprEvalHandler = function(noDelay) {

            var evalScope = sourceComp;
            var delayedCall = function() {
                if (evalScope.getXType() !== containerXType) {
                    if (containerXType == "xcp_page") {
                        //look into the page context to get page
                        if (evalScope && Ext.isFunction(evalScope.getPage) && evalScope.getPage()) {
                            evalScope = evalScope.getPage();
                        } else {
                            evalScope = evalScope.up(containerXType);
                        }
                    } else {
                        evalScope = evalScope.up(containerXType);
                    }

                }
                //Lets set the evalScope to the top container
                if (!evalScope) {
                    evalScope = Ext.getCmp("_topPageContainer");

                    // doing nothing when a viewport is destroyed during unit test
                    if (!evalScope) {
                        return;
                    }
                }

                var value = xcp.core.expr.ExpressionManager.evaluate(evalScope, exprConfig);
                xcp.Logger.debug("[" + outputPropId + "] : " + value);
                //Pass on the evaluated value (if not null) to source Comp
                if (value !== undefined && value !== null) {
                    //Call the property setter function if it is configured
                    //If value display is configured to have expression, the below call,
                    // causes the expression input widget to loss focus.

                    if (propSetterFunName) {
                        var setterFun = sourceComp[propSetterFunName];
                        if (!Ext.isFunction(sourceComp[propSetterFunName])) {
                            //TODO need to handle non X Type source comp
                            var classAlias = sourceComp
                            if (Ext.isFunction(sourceComp['getXType'])) {
                                classAlias = sourceComp.getXType();
                            }
                            xcp.Logger.warn("On component " + classAlias + " missing expression property setter function : " + propSetterFunName);
                            return null;
                        }
                        setterFun.call(sourceComp, value, outputPropId);
                    }
                    else {
                        //Property setter function is not defined, set property directly on the widget
                        sourceComp[outputPropId] = value;
                    }

                    //If value display is configured to have expression, the value display takes the focus.
                    if (Ext.FocusManager.enabled) {
                         Ext.FocusManager.focusLast();
                    }
                }
            };
            if (noDelay === true || exprConfig.sync === true) {
                delayedCall.call(this);
            } else {
                xcp.util.PageLayoutUtils.defer(delayedCall);
            }

        };
        return exprEvalHandler;

    }
});
})();/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.core.actionflow.ActionCommand");

Ext.apply(xcp.Strings.core.actionflow.ActionCommand, {
    successMessage: "Success.",
    errorMessage: "An error occurred while performing the operation."
});
/* xcp_actionflow_lib/content/xcp/core/actionflow/ActionCommand.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.ActionCommand
 * ActionCommand class executes the dataaction
 */
Ext.define("xcp.core.actionflow.ActionCommand", {
    constructor : function(def, stateId) {
        if (!def) {
            throw Error("Require action name in action-state: "+stateId);  // $NON-NLS-1$ 
        }
        this.name = def;
    },
    /**
     * Creates the flow model and populates the data with the specified attribute mappings
     * @param flowEngine
     * @param flowExecutionContext
     */
    createFlowModel : function(flowEngine, flowExecutionContext) {
        var model = Ext.ModelMgr.create({}, flowEngine.actionmodel.name);
        var attributeMapping = flowEngine.actionmodel["attribute-mapping"];
        for (var attrName in attributeMapping) {
            var mappings = attributeMapping[attrName].split(".");
            var outputModelName = mappings[0];
            var modelAttribute = mappings[1];
            var outputModel =  flowEngine.getStateOutputModel(outputModelName);
            if (outputModel && Ext.isFunction(outputModel.get)) {
                model.set(attrName, outputModel.get(modelAttribute));
            }
        }
        model.data["id"] = flowEngine.flowExecutionContext.inputModel.data.id;
        return model;
        
    },
    /**
     * Execute the command, calls the dataaction
     * @param context
     */
    execute : function(context) {
        //TODO need to get better way to pass context to callback functions
        var model = this.createFlowModel(context.flowEngine,context.flowEngine.flowExecutionContext);
        var handleSuccess = function(record, operation) {
            var successMessage = xcp.Strings.core.actionflow.ActionCommand.successMessage;
            var topContainer = Ext.getCmp("_topPageContainer");
            xcp.core.FeedbackManager.showFeedback(topContainer, "", successMessage, "notifications");
            context.callback.call(context.callbackScope, "success");  // $NON-NLS-1$ 
        };
        var handleError = function(record, operation) {
            var errorMessage =  operation.error.message || xcp.Strings.core.actionflow.ActionCommand.errorMessage;
            context.errorCallback.call(context.callbackScope, errorMessage);
        } ;

        if (this.name == "save") {  // $NON-NLS-1$ 
            model.save({success: handleSuccess, feedbackContainer:context.errorCallbackScope, scope: this});
            xcp.Logger.debug("Action executed...", model);
        }
    }
});

/* xcp_actionflow_lib/content/xcp/core/actionflow/ActionState.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.ActionState
 * ActionState class represents the action state of the action flow
 */
Ext.define("xcp.core.actionflow.ActionState", {
   constructor:function(stateDef) {
        if (!stateDef.id) {
            throw Error("State needs id");  // $NON-NLS-1$ 
        }
        this.id = stateDef.id;
        this.command = null;

        if (stateDef.action) {
            this.setCommand(new xcp.core.actionflow.ActionCommand(stateDef.action, this.id));
        } else if (stateDef.event) {
            this.setCommand(new xcp.core.actionflow.EventCommand(stateDef.event, this.id));
        } else if (stateDef.method) {
            this.setCommand(new xcp.core.actionflow.MethodComand(stateDef.method,this.id));
        } else if (stateDef.actionInstanceId) {
            this.setCommand(new xcp.core.actionflow.ActionInstanceCommand(stateDef.actionInstanceId, this.id))
        }
        else {
            throw Error("Action state needs either of evaluate, action or event");  // $NON-NLS-1$ 
        }
        if (stateDef.transition) {
            this.setTransitions(stateDef.transition);
        }
    },
    /**
     * Execute business logic of the state
     * @param context
     */
    execute : function(context) {
        return this.getCommand().execute(context);
    },
    /**
     * Set the command for the state. Can be action, event or method command
     * @param action
     */
    setCommand : function(action) {
        this.command = action;
    },
    /**
     * Returns the command of the state. Can be action, event or method command
     */
    getCommand : function() {
        return this.command;
    },
    /**
     * Set the transitions for the state
     * @param transitions
     */
    setTransitions : function(transitions) {
        this.transitionSet = transitions;
    },
    /**
     * Get the transitions of the state
     */
    getTransitions : function() {
        return this.transitionSet;
    }
});

/* xcp_actionflow_lib/content/xcp/core/actionflow/DecisionState.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.DecisionState
 * @extend xcp.core.actionflow.ActionState
 * DecisionState class represents the decision state of the action flow
 * Note: Place holder for future implementation
 */

Ext.define("xcp.core.actionflow.DecisionState", {
   extend:"xcp.core.actionflow.ActionState",
    constructor : function(stateDef) {
/*        if (!stateDef.id) {
            throw Error("Decision state needs id");
        }
        if (!stateDef['if']) {
            throw Error("Decision state needs if condition");
        }
        this.id = stateDef.id;
        var transitionSet = [];
        var expression = "";
        var closingPar = "";
        var addTransition = function(str) {
            var transition = {};
            transition["on"] = str;
            transition["to"] = str;
            transitionSet.push(transition);
        };
        var add = function(def, isNested) {
            if (isNested) {
                expression +="(";
                closingPar +=")";
            }
            expression += def['test'] + " ? \"" + def['then'] + "\" : ";
            addTransition(def['then']);
        };

        add(stateDef['if'], false);
        var elseIfDef = stateDef['if']['else-if'];
        if (elseIfDef && !Ext.isArray(elseIfDef)) elseIfDef = [elseIfDef];
        if (elseIfDef && elseIfDef.length > 0) {
            for (var i=0; i < elseIfDef.length; i++) {
                add(elseIfDef[i], true);
            }
        }
        var elseTransition = stateDef['if']['else'];
        if (!elseTransition) {
            elseTransition = "undefined";
        }
        addTransition(elseTransition);
        expression += "\"" + elseTransition + "\"" + closingPar;

        this.setComand(new xcp.actionflow.Expression({expression : expression}));
        this.setTransitions(transitionSet);*/
    }
});
/* xcp_actionflow_lib/content/xcp/core/actionflow/EndState.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.EndState
 * EndState class represents the end state of the action flow
 */
Ext.define("xcp.core.actionflow.EndState", {
    constructor:function(stateDef) {
         if (!stateDef.id) {
             throw Error("State needs id");  // $NON-NLS-1$ 
         }
         this.id = stateDef.id;
    }
});


/* xcp_actionflow_lib/content/xcp/core/actionflow/EventCommand.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.EventCommand
 * @extend xcp.core.actionflow.ActionCommand
 * EventCommand class fires the event specified in the action state
 */

Ext.define("xcp.core.actionflow.EventCommand", {
    extend:"xcp.core.actionflow.ActionCommand",
    execute : function(context) {
        //TODO need to make a call to event manager
        return "success";  // $NON-NLS-1$ 
    }

});

/* xcp_actionflow_lib/content/xcp/core/actionflow/FlowEngine.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.FlowEngine
 * FlowEngine is the engine which run the action flow defintions. Provides the views and state transitions
 */

//TODO:Refactor the FlowEngine to have Flow instanses and make the enginee singleton
Ext.define("xcp.core.actionflow.FlowEngine",{
   statics : {
       CLOSE_DIALOG_STATE : "CLOSE_DIALOG",
       FLOW_DATA_ACTION_SECTION_NAME:"data-action",      // $NON-NLS-1$
       FLOW_DATA_ACTION_EXE_CONFIG: "postExecutionConfig" // $NON-NLS-1$
   },
    /**
     * Constructor
     * @param flowDef
     */
   constructor:function(flowConfig) {
        this.flowDef = flowConfig.flowDef;
        this.states = this.buildStateMap();
        var initialStateId = this.flowDef['initial-state'];
        this.currentState = this.states[initialStateId];
        var contextConfig = {
            container : flowConfig.container,
            inputModel: flowConfig.inputModel,
            actionModel: this.flowDef.actionModel,
            initialStateId:initialStateId
        };
        this.flowExecutionContext = new xcp.core.actionflow.FlowExecutionContext(contextConfig);
        this.flowExecutionContext.setCurrentStateId(initialStateId);
        this.actionmodel = this.flowDef.actionmodel;
   },
    /**
     * Builds a state map based on the give flow definition
     */
    buildStateMap : function() {
        var flowDef = this.flowDef;
        //assumption, only linear action flow is considered.
        // The flowDef is patched for transitions and end-state
        var viewStates = this.flowDef["view-state"];
        if (viewStates) {
            for (var i=0; i < viewStates.length; i++) {

                var viewstate = viewStates[i];
                if(!viewstate.transition) {
                    viewstate.transition = [{"on": "finish","to": "finish"}, {"on": "cancel","to": "cancel"}];
                }
            }
        }
        var actionstate = this.flowDef["action-state"];
        if(!actionstate.transition) {
                      actionstate.transition = [{"on": "success", "to": "success"}, {"on": "error", "to": this.flowDef["initial-state"] }];
        }
        var endstate = [{"id": "success"}, {"id": "cancel"}];
        if(! this.flowDef["end-state"]) {
            this.flowDef["end-state"] = endstate;
        }

        var states = {};
        var parseStates = function(stateCls, stateTag) {

            if (flowDef[stateTag]) {
                var statesDef = flowDef[stateTag];
                if (!Ext.isArray(statesDef)) {
                    statesDef = [statesDef];
                }
                for (i = 0; i < statesDef.length; i++) {
                    var stateDef = statesDef[i];
                    var state = new stateCls(stateDef);
                    states[state.id] = state;
                }
            }
        };
        parseStates(xcp.core.actionflow.ViewState, "view-state");
        parseStates(xcp.core.actionflow.ActionState, "action-state");
        parseStates(xcp.core.actionflow.DecisionState, "decision-state");
        parseStates(xcp.core.actionflow.EndState, "end-state");

        return states;
    },
    /**
     * Get the current view state id
     */
    getCurrentViewId : function() {
        return this.currentState.id;
    },
    /**
     * Returns the current view's xcpId.
     */
    getCurrentViewXcpId: function() {
        return this.currentState.xcpId;
    },
    /**
     * Return xCP Id for given view state id.
     * @param viewStateId
     */
    getViewStateXcpId: function(viewStateId) {
        var viewState = this.states[viewStateId];
        if (viewState) {
            return viewState.xcpId;
        }
        return viewStateId;
    },
    /**
     * Get the current view page url
     */
    getCurrentViewPageUrl : function() {
        return this.currentState.pageUrl;
    },
    /**
     * Get the current view state transition ids
     */
    getCurrentViewTransitionIds : function() {
        var ids = {};
        for (var i = 0; i < this.currentState.transitionSet.length; i++) {
            var transition = this.currentState.transitionSet[i];
            ids[transition.on] = transition.on;
        }
        return ids;
    },
    /**
     * Get the output model object defined in the state
     * @param outputModelName
     */
    getStateOutputModel: function(outputModelName) {
        for(var stateName in this.states) {
            var state = this.states[stateName];
            if(state[outputModelName])
            {
                return state[outputModelName];
            }
        }
        return {};
    },
    setCurrentState: function(state) {
        this.currentState = state;
        this.flowExecutionContext.setCurrentStateId(state.id);
    },
    getStateIdFromXcpId: function(xcpId) {
        for (var stateId in this.states) {
            var state = this.states[stateId];
            if (state && state.xcpId == xcpId) {
                return state.id;
            }
        }
        return null;
    },
    /**
     * Evaluates transition from the current state to next state
     * @param transitionContext
     */
    evaluateTransition : function(transitionContext) {
        this.flowExecutionContext.clearTransitionId();
        var viewStateId = this.getStateIdFromXcpId(transitionContext.component.xcpId);
        if (viewStateId && viewStateId != this.currentState.xcpId) {
            xcp.Logger.warn("Current State and Current Component mismatch, resetting current state to : "+transitionContext.component.xcpId)
        }
        this.setCurrentState(this.states[viewStateId]);

        this.currentState.updateOutputModels(transitionContext.component);
        this.flowExecutionContext.setCurrentTransitionId(transitionContext.eventId);
        this.evaluateTransitionInternal(transitionContext);
    },
    //private
    evaluateTransitionInternal : function(transitionContext) {
        if (typeof transitionContext.eventId == 'boolean') {
            transitionContext.eventId = transitionContext.eventId.toString();
            this.flowExecutionContext.setCurrentTransitionId(transitionContext.eventId);
        }
        var nextStateId = null;
        for (var i = 0; i < this.currentState.transitionSet.length; i++) {
            var transition = this.currentState.transitionSet[i];
            var on = transition.on;
            if (on == transitionContext.eventId) {
                if (!transition.to) {
                    nextStateId = transition.on;
                } else {
                    nextStateId = transition.to;
                }
                break;
            }
        }
        if (nextStateId) {
            var nextState = this.states[nextStateId];
            if (nextState) {
                this.setCurrentState(nextState);
                if (nextState instanceof xcp.core.actionflow.ViewState) {
                    transitionContext.callback.call(transitionContext.callbackScope, nextStateId);
                }
                var result = null;
                if (nextState instanceof xcp.core.actionflow.ActionState) {
                    var callback = function(result) {
                        this.flowExecutionContext.setCurrentTransitionId(result);
                        transitionContext.eventId = result;
                        return this.evaluateTransitionInternal(transitionContext);
                    };
                    // call back handler to re initialize flow engine to last view state  
                    var errorCallback = function(result){
                        var lastViewStateId = this.flowExecutionContext.sourceStateId;
                        this.setCurrentState(this.states[lastViewStateId]);
                        this.flowExecutionContext.clearTransitionState();
                        transitionContext.errorCallback.call(transitionContext.callbackScope,lastViewStateId,result);
                    };
                    var stateExecContext = new xcp.core.actionflow.StateExecutionContext({
                        flowEngine: this,
                        callback: callback,
                        errorCallback:errorCallback,
                        callbackScope:this,
                        errorCallbackScope:transitionContext.callbackScope,
                        component: transitionContext.component
                    });
                    nextState.execute(stateExecContext);
                }
                if (nextState instanceof xcp.core.actionflow.EndState) {
                    //Close the wizard;
                    transitionContext.callback.call(transitionContext.callbackScope, xcp.core.actionflow.FlowEngine.CLOSE_DIALOG_STATE);
                }
            }
        }
    }
});


/* xcp_actionflow_lib/content/xcp/core/actionflow/FlowExecutionContext.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * @class xcp.core.actionflow.FlowExecutionContext
 * Stores the context data for the flow execution 
 */
Ext.define("xcp.core.actionflow.FlowExecutionContext", {
    //TODO define config object
    config: {
        inputModel:null,
        actionModel:null,
        container:null,
        initialStateId:null,
        previousStateId:null,
        sourceStateId:null,
        sourceTransitionId:null,
        previousTransitionId:null,
        currentTransitionId:null

    },
    constructor: function(config) {
        //TODO should not be assigned to this
        Ext.apply(this, config);
    },
    setCurrentTransitionId: function(transitionId) {
        this.previousTransitionId = this.currentTransitionId;
        this.currentTransitionId = transitionId;
        if (this.sourceTransitionId === undefined || this.sourceTransitionId === null) {
            this.sourceTransitionId = transitionId;
        }
    },
    clearTransitionId:function() {
        this.currentTransitionId=null;
        this.previousTransitionId=null;
        this.sourceTransitionId=null;
        this.clearTransitionState();
    },
    setCurrentStateId : function(stateId) {
        if (this.previousStateId && this.previousStateId !== stateId) {
            this.previousStateId = this.currentStateId;
        }
        this.currentStateId = stateId;
        if (this.sourceStateId === undefined || this.sourceStateId === null) {
            this.sourceStateId = stateId;
        }
    },
    clearTransitionState:function() {
        this.sourceStateId=null;
        this.previousStateId=null
    },
    getInputPropertyValue: function(propId) {
        if (propId.indexOf("Inputs.") != -1) {
            propId = propId.substring(7);
        }
        if (this.inputModel) {
            return this.inputModel.get(propId);
        }
        return undefined;
    }
});

/* xcp_actionflow_lib/content/xcp/core/actionflow/MethodComand.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.MethodCommand
 * @extends xcp.core.actionflow.ActionCommand
 * MethodCommand executes a method specified in the action state.
 * Note: Place holder for future implementation 
 */
Ext.define("xcp.core.actionflow.MethodCommand", {
    extend:"xcp.core.actionflow.ActionCommand",
    constructor : function(def, stateId) {
        xcp.actionflow.MethodComand.superclass.constructor.call(this, def, stateId);
        this.method = eval(this.name);
    },
    resolveMethodScope : function() {
        //TODO Need to figure out what would be the scope for method call.
        return {};
    },
    execute : function(context) {
        return true;
    }
});

/* xcp_actionflow_lib/content/xcp/core/actionflow/ViewState.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.ViewState
 * Represents a view state of the action flow
 */
Ext.define("xcp.core.actionflow.ViewState", {
    statics : {
        MODEL_NAME_PROP:"modelName",
        /**
         * Search for a model component for a given model name
         * @param component
         * @param modelName
         */
        findModel : function(component, modelName) {
            if (component) {
                if (component[xcp.core.actionflow.ViewState.MODEL_NAME_PROP] &&
                    component[xcp.core.actionflow.ViewState.MODEL_NAME_PROP] == modelName) {
                    return component.getModel();
                }

                //component is a form that contains multiple model instances
                if (component["modelNames"] &&
                    component.modelNames[modelName]) {
                    return component.getModel(modelName);
                }

                var items = component.items;
                if (items) {
                    if (!Ext.isArray(items)) {
                        items = [items];
                    }
                    for (var i = 0; i < items.length; i++) {
                        var model = xcp.core.actionflow.ViewState.findModel(items[i], modelName);
                        if (model) {
                            return model;
                        }
                    }
                }
            }
            return null;
        }
    },
    constructor : function(stateDef) {
        if (!stateDef.id) {
            throw Error("View State needs id");  // $NON-NLS-1$ 
        }
        this.id = stateDef.id;
        this.pageUrl=stateDef.pageUrl;
        // In most cases the xcpId and view state id are same, however in some
        // rare cases the might differ
        if (stateDef.xcpId) {
            this.xcpId = stateDef.xcpId;
        } else {
            this.xcpId = stateDef.id;
        }

        this.transitionSet = stateDef.transition;
        this.outputModels = stateDef["output-model"];
    },
    /**
     * Updates the output models with the input data
     * @param component
     */
    updateOutputModels : function(component) {
        var outputModels = this.outputModels;
        if (outputModels) {
            for (var outputModelName in outputModels) {
                var modelName = outputModels[outputModelName];
                //Search for a model component for a given model name;
                this[outputModelName] = xcp.core.actionflow.ViewState.findModel(component, modelName);
            }
        }

    }
});


/* xcp_actionflow_lib/content/xcp/core/actionflow/TransitionContext.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.TransitionContext
 * Stores the context for the state transition
 */
Ext.define("xcp.core.actionflow.TransitionContext", {
    config: {
        "eventId": "",
        "component" : null,
        "callback" : null,
        "errorCallback":null,
        "callbackScope": null
    },

    constructor: function(config) {
        this.initConfig(config);
    }
});

/* xcp_actionflow_lib/content/xcp/core/actionflow/StateExecutionContext.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.core.actionflow.StateExecutionContext
 * Stores the context data for the action flow state execution 
 */

Ext.define("xcp.core.actionflow.StateExecutionContext", {
    config: {
        "flowEngine" : null,
        "callback" : null,
        "errorCallback":null,
        "callbackScope":null,
        "component": null,
        "errorCallbackScope":null
    },

    constructor: function(config) {
        this.initConfig(config);
    }
});

/* xcp_actionflow_lib/content/xcp/core/actionflow/ActionFlowExpressionPropertiesPlugin.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * A plugin which adds ability to component for handling the expression configuration for calculated properties.
 * This is a specialized plugin for handling expression evaluation defined at action flow level.
 * Example : Action flow data action.
 */
//TODO extract the common code in seperate methods in base class
Ext.define('xcp.core.actionflow.ActionFlowExpressionPropertiesPlugin', {
    extend: 'xcp.core.expr.ExpressionPropertiesPlugin',
    alias: 'plugin.xcp_actionflow_expression_properties',
    /**
     * @constructor
     * @param config {Object} (Required) expression configuration.
     */
    constructor : function(config) {
        if (config) {
            this.config = config;
        } else {
            this.config = {};
        }
    },
    /**
     * Returns the step page for given xcpId.
     * @param stepPageId
     * @param container
     */
    getStepPage:function(stepPageId, container) {
        if (container) {
            var stepPageQuery = "component[xcpId='" + stepPageId + "']";
            var stepPage = container.query(stepPageQuery);
            if (stepPage && stepPage.length != 0) {
                return stepPage[0];
            }
        }
        return null;
    },
    /**
     * Return the event base channel name for given evaluation scope.
     * @param evalScope: Can be xcp_page or xcp_wizard containers
     */
    getBaseChannelName: function(evalScope) {
        var baseChannelName = null;
        if (evalScope) {
            baseChannelName = evalScope.id;
        }
        if (baseChannelName) {
            baseChannelName += ".";
        }
        return baseChannelName;
    },
    /**
     * Process the expression configuration defined on the attached component.
     * @param stepId
     */
    processExpressionConfig: function(stepId) {
        var widget = this.ownerWidget;
        var exprConfigs = this.config.expression;

        //Check if the expression config is available.
        if (exprConfigs) {
            //Get the step page access
            var wizardXType = "xcp_wizard";

            var container = widget.up(wizardXType);
            if (!container) {
                xcp.Logger.error("Cannot find the wizard container");
                return;
            }
            if (!Ext.isArray(exprConfigs)) {
                exprConfigs = [exprConfigs];
            }
            for (var i = 0; i < exprConfigs.length; i++) {
                var exprConfig = exprConfigs[i];
                if (exprConfig["handled"]) {
                    xcp.Logger.info("Expression configuration already handled for property Id : " +  exprConfig["propertyId"] )
                    continue;
                }
                var pageId = exprConfig['pageId'];
                var evalScope = container;
                if (pageId) {
                    evalScope = this.getStepPage(pageId, container);
                    if (evalScope == null) {
                        exprConfig['handled'] = false;
                        continue;
                    }
                }
                var baseChannelName = this.getBaseChannelName(evalScope);
                exprConfig["handled"] = true;
                var events = exprConfig["events"];
                var eventHandler = this.createEventHandler(widget, exprConfig, evalScope);
                //Subscribe to events for dynamic inputs
                if (events) {
                    if (!Ext.isArray(events)) {
                        events = [events];
                    }
                    //Keep track of registered events to eliminate the duplicate events
                    var registeredEvents = new Ext.util.MixedCollection();
                    for (var k = 0; k < events.length; k++) {
                        var event = baseChannelName + events[k];
                        if (!registeredEvents.containsKey(event)) {
                           var handle = xcp.event.EventBus.subscribe(event, eventHandler, widget);
                            //Cache the subscribed event for cleaning purpose
                            widget.xcpEventSubs.add(handle, handle);
                            registeredEvents.add(event, event);
                        }

                    }
                }
                widget.on("afterrender", eventHandler, widget);
            }
        }
    },
    /**
     * Handles the expression configuration and perform the required event hookups.
     * @override
     * @param widget {Ext.Component} (Required)
     */
    init: function(widget) {
        var exprConfigs = this.config.expression;
        //Check if the expression config is available.
        if (exprConfigs) {
            this.ownerWidget = widget;
            widget.on("beforerender", this.processExpressionConfig, this);
        }
    },
    /**
     * Create an expression evaluation handler function, the generated function gets registered as event handler to any
     * dynamic expression inputs change events.
     * @private
     * @param sourceComp {Ext.Component} the component
     * @param exprConfig
     * @param containerXType
     */
    createEventHandler : function(sourceComp, exprConfig, container) {
        var outputPropId = exprConfig["propertyId"];
        var propSetterFunName = exprConfig["setterFunName"];

        var timeout=undefined;
        //Create expression eval handler function
        var exprEvalHandler = function() {

            //Delay the expression eval, to eat up repeated events fired by widgets
            // e.g. value change from drop-down gets fired twice.
            if (timeout) {
                clearTimeout(timeout);
            }
            var evalScope = container;
            var delayedCall = function() {
                var value = xcp.core.expr.ExpressionManager.evaluate(evalScope, exprConfig);
                xcp.Logger.debug("[" + outputPropId + "] : " + value);
                //Pass on the evaluated value (if not null) to source Comp
                if (value !== undefined && value !== null) {
                    //Call the property setter function if it is configured
                    //If value display is configured to have expression, the below call,
                    // causes the expression input widget to loss focus.

                    if (propSetterFunName) {
                        var setterFun = sourceComp[propSetterFunName];
                        if (!Ext.isFunction(sourceComp[propSetterFunName])) {
                            //TODO need to handle non X Type source comp
                            var classAlias = sourceComp
                            if (Ext.isFunction(sourceComp['getXType'])) {
                                classAlias = sourceComp.getXType();
                            }
                            xcp.Logger.warn("On component " + classAlias + " missing expression property setter function : " + propSetterFunName);
                            return null;
                        }
                        setterFun.call(sourceComp, value, outputPropId);
                    }
                    else {
                        //Property setter function is not defined, set property directly on the widget
                        sourceComp[outputPropId] = value;
                    }

                    //If value display is configured to have expression, the value display takes the focus.
                    if (Ext.FocusManager.enabled) {
                         Ext.FocusManager.focusLast();
                    }
                }
            };
            timeout = setTimeout(delayedCall, 20);
        };
        return exprEvalHandler;

    }
});

/* xcp_actionflow_lib/content/xcp/core/actionflow/ActionInstanceCommand.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.core.actionflow.ActionInstanceCommand", {
    constructor : function(def, stateId) {
        if (!def) {
            throw Error("Require action instance id in action-state: "+stateId);
        }
        this.name = def;
    },

    /**
     * Execute the command, calls the dataaction
     * @param context
     */
    execute : function(context) {
        //Get handel to action instance
        var flowExecutionContext = context.flowEngine.flowExecutionContext;
        var container = flowExecutionContext.container;
        if (container) {
            var actionContainer = container.getActionContainer();
            if (actionContainer != null) {
                var actionInstance = actionContainer.getComponent(this.name);
                if (actionInstance) {
                    var handleSuccess = function(successData) {
                        context.callback.call(context.callbackScope, "success");
                    };
                    var callBackConfig = {
                        scope: this,
                        handler: handleSuccess
                    };
                    actionInstance.callBackConfig = callBackConfig;
                    actionInstance.errorFeedbackContainer = context.component;
                    actionInstance.handler(actionInstance, null);
                } else {
                    throw Error("Could not find action instance to execute the action : "+this.name);
                }
            } else {
                throw Error("Could not find action container to execute the action : "+this.name);
            }
        }
    }
});


/* xcp_application/content/xcp/data/model/NamespaceConfigModel.js */

/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.data.model.NamespaceConfigModel", {
    extend: 'Ext.data.Model',
    fields: [
        {name: "config_description", type: "string"},
        {name: "config_label", type: "string" },
        {name: "config_name", type: "string" },
        {name: "config_type", type: "string" },
        {name: "id", type: "string" },
        {name: "namespace", type: "string" },
        {name: "property_datatype"},
        {name: "property_name"},
        {name: "property_value"}
    ]
});

/* xcp_application/content/xcp/core/ApplicationParameterManager.js */

/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */


Ext.define("xcp.core.ApplicationParameterManager", {
    singleton: true,

    /**
     * Loads application parameter data, assumes that xcp.appContext.namespace is defined
     *
     * @param callback
     * @param scope
     */
    initAppParameters: function(callback, scope) {
        // Load application parameters localization data, then if that's successful, load the actual values
        // Note:  The localization data needs to be loaded first since that determines sort order of values
        var url = xcp.util.Utils.buildResourceUrl("ui/appParam", true);
        Ext.Ajax.request({
            url: url,
            async: true,
            scope: this,
            disableCaching: false,
            success: function(response, options) {
                var responseText = response.responseText;
                this.appParametersLocalizationData = Ext.JSON.decode(responseText);
                var proxyUrl = "application/" + xcp.appContext.namespace + "/parameters";
                this.appParametersStore = Ext.create("Ext.data.Store", {
                    autoLoad: true,
                    model: "xcp.data.model.NamespaceConfigModel",
                    proxy: {
                        type: 'rest',
                        url: proxyUrl
                    },
                    listeners: {
                        load: {
                            scope: this,
                            fn:  function(store, records, successful, eOpts) {
                                if (successful) {
                                    xcp.Logger.debug("Loaded application parameters");
                                } else {
                                    xcp.Logger.log("Failed to load application parameters");
                                }

                                if (callback) {
                                    callback.call(scope);
                                }
                            }
                        }
                    },
                    sorters: {
                        sorterFn: function(paramRecord1, paramRecord2) {
                            // Sort the list of parameters by label, name, and namespace
                            var strCmp = function(a, b) {
                                var la = a.toLocaleLowerCase();
                                var lb = b.toLocaleLowerCase();
                                var lc = la.localeCompare(lb);
                                return lc;
                            };
                            var namespace1 = paramRecord1.get("namespace");
                            var namespace2 = paramRecord2.get("namespace");
                            var name1 = paramRecord1.get("config_name");
                            var name2 = paramRecord2.get("config_name");
                            var label1 = xcp.core.ApplicationParameterManager.getAppParameterLabel(namespace1, name1);
                            var label2 = xcp.core.ApplicationParameterManager.getAppParameterLabel(namespace2, name2);
                            var cmpRet = strCmp(label1, label2);
                            if (cmpRet != 0) {
                                return cmpRet;
                            }
                            cmpRet = strCmp(name1, name2);
                            if (cmpRet != 0) {
                                return cmpRet;
                            }
                            return strCmp(namespace1, namespace2);
                        }
                    },
                    filters: [{
            					property: "config_type",
            					value   : "PARAMETER"
        			}]
                });
            },
            failure: function(response, options) {
                xcp.Logger.log("Failed to load application parameter localization data");
                if (callback) {
                    callback.call(scope);
                }
            }
        });
    },

    getAppParameter: function(namespace, param) {
        if (this.appParametersStore) {
            var record = this.getMatchingRecord(namespace, param);
            if (record) {
                var paramValue = record.get("property_value")[0];
                var paramType = record.get("property_datatype")[0];
                switch (paramType) {
                    case "int":
                        return parseInt(paramValue);
                    case "string":
                        return paramValue;
                    case "float":
                        return parseFloat(paramValue);
                    case "boolean":
                        return paramValue == "true";
                    case "Datetime":
                    case "dm_user":
                    case "dm_group":
                    case "dm_folder":
                    case "dmc_workqueue":
                    case "dmc_calendar":
                        return paramValue;
                }
                return paramValue;
            }
        }
        return "";
    },

    getAppParameterDescription: function(namespace, param) {
        // Look up description based on namespace and param for I18N support
        var namespaceEntry = this.appParametersLocalizationData[namespace];
        if (namespaceEntry) {
            var paramEntry = namespaceEntry[param];
            if (paramEntry) {
                return paramEntry.description;
            }
        }

        // Fallback to whatever was entered in builder
        var record = this.getMatchingRecord(namespace, param);
        return record.get("config_description");
    },

    getAppParameterLabel: function(namespace, param) {
        // Look up label based on namespace and param for I18N support
        var namespaceEntry = this.appParametersLocalizationData[namespace];
        if (namespaceEntry) {
            var paramEntry = namespaceEntry[param];
            if (paramEntry) {
                return paramEntry.label;
            }
        }

        // Fallback to whatever was entered in builder
        var record = this.getMatchingRecord(namespace, param);
        return record.get("config_label");
    },

    getMatchingRecord: function(namespace, param) {
        var cmpFunc = function(record, id) {
            return ((record.get("namespace") == namespace) &&
                (record.get("config_name") == param));
        };
        var index = this.appParametersStore.findBy(cmpFunc, this);
        if (index != -1) {
            return this.appParametersStore.getAt(index);
        }
        return null;
    },

    getParameters: function() {
        return this.appParametersStore;
    }
});/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.override(Ext.form.field.Base, {
    labelSeparator: ":"
});

Ext.override(Ext.form.FieldContainer, {
    labelSeparator: ":"
});

Ext.apply(Ext.form.field.Date.prototype, {
	invalidText:"{0} is not a valid date - it must be in the format {1}"
});

Ext.apply(Ext.form.field.Time.prototype, {
	invalidText:"{0} is not a valid time"
});

Ext.apply(Ext.picker.Month.prototype, {
    okText: "OK"
});

Ext.apply(Ext.picker.Date.prototype,{
	ariaTitle: "Date Picker {0}"
});
/* xcp_extjs_patch/content/xcp/ExtjsPatch.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Codes to patch extjs for whatever reasons.
 */

/**
 * Patch extjs to allow more rounds of layout cycle.
 */
(function() {
    // the old run() which could be an override from the diagnostics Context.js
    var run = Ext.layout.Context.prototype.run;

    Ext.layout.Context.override({

        /**
         * Copied from Ext.layout.Context.run() except that the "watchDog" is passed as a parameter.
         * watchDog is hard-coded to start from 100 for the counting down in the original implementation.
         *
         * Added codes at the end of the function to log errors when the maximum number of cycles is reached.
         * @param watchDog  {Number} maximum layout cycles.
         */
        runWithMaxCycle: function (watchDog) {
            var me = this,
                flushed = false;

            me.flushInvalidates();

            me.state = 1;
            me.totalCount = me.layoutQueue.getCount();

            // We may start with unflushed data placed by beginLayout calls. Since layouts may
            // use setProp as a convenience, even in a write phase, we don't want to transition
            // to a read phase with unflushed data since we can write it now "cheaply". Also,
            // these value could easily be needed in the DOM in order to really get going with
            // the calculations. In particular, fixed (configured) dimensions fall into this
            // category.
            me.flush();

            // While we have layouts that have not completed...
            while ((me.remainingLayouts || me.invalidQueue.length) && watchDog--) {
                if (me.invalidQueue.length) {
                    me.flushInvalidates();
                }

                // if any of them can run right now, run them
                if (me.runCycle()) {
                    flushed = false; // progress means we probably need to flush something
                    // but not all progress appears in the flushQueue (e.g. 'contentHeight')
                } else if (!flushed) {
                    // as long as we are making progress, flush updates to the DOM and see if
                    // that triggers or unblocks any layouts...
                    me.flush();
                    flushed = true; // all flushed now, so more progress is required

                    me.flushLayouts('completionQueue', 'completeLayout');
                } else {
                    // after a flush, we must make progress or something is WRONG
                    me.state = 2;
                    break;
                }

                if (!(me.remainingLayouts || me.invalidQueue.length)) {
                    me.flush();
                    me.flushLayouts('completionQueue', 'completeLayout');
                    me.flushLayouts('finalizeQueue', 'finalizeLayout');
                }
            }

            var ret = me.runComplete();

            // added for diagnostics
            if (!ret && watchDog < 0) {
                Ext.log({
                    msg: "The maximum number of layout cycles has been reached before the page is laid out",
                    level: 'error',
                    stack: false
                });
            }

            return ret;
        },

        run : function() {
            var me = this;
            var maxCycle = xcp.core.NavigationManager ? 300 : 200;
            if (!me.logOn) {
                // there is no override from diagnostics Context.js
                return me.runWithMaxCycle(maxCycle);
            } else {
                // diagnostics Context.js is included, call the override.
                var callParent = me.callParent;
                me.callParent = function () {
                    me.callParent = callParent;
                    return me.runWithMaxCycle(maxCycle);
                };
                return run.apply(this, arguments);
            }
        }
    });
})();


Ext.data.TreeStore.override({
    fillNode:function () {
        Ext.suspendLayouts();
        var ret = this.callParent(arguments);
        Ext.resumeLayouts(true);
        return ret;
    }
});


/**
 * Don't allow exception being throw when ext-all-dev.js is used for diagnostic
 */
(function() {
    var oldErrorHandle = Ext.Error.handle;
    Ext.Error.handle = function(err) {
        if (err && err.sourceClass == "Ext.layout.ContextItem" && err.sourceMethod	== "checkAuthority") {
            // this will be raised only when ext-all-dev.js is used.
            // relax the extjs's implementation which raises an exception.
            var msg = Ext.Error.prototype.toString.call(err);
            Ext.log({
                msg: msg,
                level: 'error',
                dump: err,
                stack: true
            });
           return true;
        } else {
            return oldErrorHandle.apply(this, arguments);
        }
    };
})();

Ext.override(Ext.data.Store, {

    /**
     * Performance: Batch the timers from multiple stores into a single timer.
     * @param config
     */
     constructor: function(config) {
         config = config || {};
         var autoLoad = config.autoLoad;
         if (autoLoad) {
             config.autoLoad = false;
         }

         var data = config.data;
         this.callParent(arguments);
         if (autoLoad) {
             this.autoLoad = autoLoad;
             if (!data) {
                 // The base Store starts a timer, which can kick off multiple rounds of layout caused by load masks etc.
                 // We batch them into one for performances of page containing multiple grids.
                 xcp.util.PageLayoutUtils.defer(
                     Ext.bind(this.load, this, [ typeof autoLoad === 'object' ? autoLoad : undefined ])
                 );
             }
         }
     },

     doSort: function(){ // override default; send to first page on sort
		this.currentPage = 1;
		this.callParent(arguments);
	}
});

// ExtJS localization of strings doesn't work correctly (http://www.sencha.com/forum/showthread.php?132919-Ext-JS-4.0-Locale-not-loading-as-it-should...&p=601150)
// This is a workaround for XCPBLD-2344 based on that information.  Note that, this is put in an Ext.onReady block
// because the localized version of Ext strings don't get setup until Ext.onReady.
Ext.onReady(function() {
    if (Ext.MessageBox) {
        Ext.MessageBox.msgButtons['ok'].text = Ext.MessageBox.buttonText.ok;
        Ext.MessageBox.msgButtons['cancel'].text = Ext.MessageBox.buttonText.cancel;
        Ext.MessageBox.msgButtons['yes'].text = Ext.MessageBox.buttonText.yes;
        Ext.MessageBox.msgButtons['no'].text = Ext.MessageBox.buttonText.no;
    }
});

// This patches extjs locale file using String.substr() with negative start index that doesn't work in IE.
// It should have been in the Chinese versions of ExtJsPatch-strings.js but it would break the translation process.
// The fix codes are copied from Extjs 4.1.1. Remove it when extjs is upgraded.
if (xcp.extLangFileSuffix === "zh_CN" || xcp.extLangFileSuffix === "zh_TW") {
    Ext.define("Ext.locale.zh.picker.DatePatch", {
        override: "Ext.picker.Date",
        getDayInitial: function (value) {
            // Grab the last character
            return value.substr(value.length - 1);    // value.substr(-1, 1)
        }
    });
}

// ------------------------------------------------------ patch for xcp requirements.  These are not related to extjs bugs.

/**
 * Make the collapsible buttons on the left
 */
(function() {
    var collapseToolTypeTop = "collapse-" + Ext.Component.DIRECTION_TOP;
    var collapseToolTypeBottom = "collapse-" + Ext.Component.DIRECTION_BOTTOM;
    var expandToolTypeBottom = "expand-" + Ext.Component.DIRECTION_BOTTOM;
    Ext.panel.Header.override({
        initItems : function() {
            var tools = this.tools;
            if (tools && tools.length > 0 && this.items) {
                var panel = tools[0].scope;
                if (panel && panel.collapseTool) {
                    var collapseTool = panel.collapseTool;

                    // invoked as part of the panel creation. The panel has not got a header yet
                    if (!panel.header && (collapseTool.type === collapseToolTypeTop || collapseTool.type === collapseToolTypeBottom || collapseTool.type === expandToolTypeBottom)) {
                        Ext.Array.remove(this.items, collapseTool);
                        this.items.unshift(collapseTool);
                        if (collapseTool.type === collapseToolTypeTop) {
                            collapseTool.addCls("xcp-panel-collapse-left");
                        } else {
                            collapseTool.addCls("xcp-panel-collapse-bottom");
                        }
                        if (typeof panel.onInitHeaderItems === "function") {
                            panel.onInitHeaderItems(this, false);
                        }
                    }

                    // the place holder header
                    if (panel.collapseFirst && this.items.length > 1 && this.getId() === panel.getId() + "-placeholder" && collapseTool.type === collapseToolTypeBottom) {
                        collapseTool = this.items[1];
                        var heading = this.items[0];
                        this.items[0] = collapseTool;
                        this.items[1] = heading;
                        collapseTool.cls = "xcp-panel-collapse-bottom";
                        if (typeof panel.onInitHeaderItems === "function") {
                            panel.onInitHeaderItems(this, true);
                        }
                    }
                }
            }
            return this.callOverridden(arguments);
        }
    });
})();

//temporary solution, moved from EventManager.js due to XCPUIC-1331
//This override has to be in front of all other constructor related override.
Ext.Component.mixin('xcppublisher', xcp.event.Publisher);
Ext.Component.mixin('xcpsubscriber', xcp.event.Subscriber);
Ext.override(Ext.Component, {
    constructor: function() {
        this.callOverridden(arguments);
        this.mixins.xcppublisher.initMixin.call(this);
        this.mixins.xcpsubscriber.initMixin.call(this);
    },

    //get Page ContextID of the component
    getPageContextID: function(){
        return this.pageContextID;
    },

    // get Page Context from PageContextID
    getPageContext: function(){
        if (this.pageContextID && xcp.core.PageContextManager) {
            return xcp.core.PageContextManager.get(this.getPageContextID());
        }
        return undefined;

    },

    // Get the object Id set on the page which contains this component
    getPageObjectId: function() {
        var pageContext = this.getPageContext();
        if (pageContext && !Ext.isEmpty(pageContext.getObjectId()))
            return pageContext.getObjectId();
        else
            return xcp.navigationManager.currentNavigationContext.objectId;
    },
    getPage: function() {
        var pageContext = this.getPageContext();
        if (pageContext && pageContext.getPage()) {
            xcp.Logger.debug("Got the page container from page context for widget : "+ (this.xcpId || this.id));
            return pageContext.getPage();
        }
        else {
            xcp.Logger.debug("Could not get the page container from page context for widget : "+ (this.xcpId || this.id));
            return undefined;
        }

    },
    isInsideWizard:function() {
        var pageContext = this.getPageContext();
        if (pageContext) {
            return pageContext.isInsideWizard();
        } else if (Ext.isEmpty(this.insideWizard)) {
            xcp.Logger.debug("Querying for wizard on own, as could not get the page context for widget : "+ (this.xcpId || this.id));
            var wizard = this.up("xcp_wizard");
            this.insideWizard = wizard ? true: false;
        }
        return this.insideWizard;

    },

    /**
     * Override floatParent to enforce ExtJs to calculate the correct page position
     */
    isContainedFloater: function() {
        var _containedFloater = this.callParent(arguments);
        if (!xcp.isDesignMode && !_containedFloater && !Ext.isIE && this.floating && !this.floatParent) {
            var xtype = this.getXType() || '';
            if (/quicktip/.test(xtype)) {
                var fp = Ext.getCmp('_topPageContainer');
                if (fp) {
                    this.floatParent = fp;
                    _containedFloater = true;
                }
            }
        }
        return _containedFloater;
    }
});

/**
 * Override to allow action attributes with xtype
 */
Ext.menu.Item.override({
    constructor : function(config) {
        config = config || {};
        if (config.action)
        {
            var action = xcp.core.ActionManager.getActionInst(config);
            return this.callOverridden([action]);
        }else
            return this.callOverridden(arguments);
    }
});

Ext.button.Button.override({
    constructor : function(config) {
        config = config || {};
        if (config.action)
        {
            var action = xcp.core.ActionManager.getActionInst(config);
            return this.callOverridden([action]);
        }else
            return this.callOverridden(arguments);
    }
});

Ext.data.Model.override({
    /**
     * Returns true if the field is defined in the model, otherwise false.
     * @param fieldName
     */
    isValidField: function(fieldName) {
        var fields = this.fields;
        var field = undefined;
        if (fieldName && Ext.isString(fieldName)) {
                return fields.getByKey(fieldName);
        }
        return false;
    }
});
Ext.data.Types.ARRAY = {
    convert: function (value, record) {
        if (value === null || value === undefined  || Ext.isArray(value)) return value;
        return [value];
    },
    type: 'array'
};

(function() {
    var extLangFileSuffix = xcp.extLangFileSuffix;
    if (extLangFileSuffix === "de" || extLangFileSuffix === "es" || extLangFileSuffix === "fr" || extLangFileSuffix === "it") {
        Ext.form.field.Date.prototype.startDay = 1;
    }
})();

(function(){

    function overrideShadow() {
        if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
            this.shadow = 'frame';
        } else {
            //don't use overlay, use css class instead
            this.shadow = false;
        }
    }

    Ext.window.Window.override({
        initComponent: function() {
            overrideShadow.call(this);
            return this.callParent(arguments);
        }
    });

    //override Ext.MessageBox instance
    Ext.override(Ext.MessageBox, {
        doAutoSize: function() {
            if(this.cfg)
                this.cfg.minWidth = this.cfg.minWidth || 325;
            return this.callParent(arguments);
        },
        beforeRender: function() {
           overrideShadow.call(this);
           return this.callParent(arguments);
        }
    });

    Ext.menu.Menu.override({
        initComponent: function() {
           overrideShadow.call(this);
           return this.callParent(arguments);
        }
    });

    Ext.picker.Date.override({
        initComponent: function() {
            overrideShadow.call(this);
            return this.callParent(arguments);
        },

        /**
         * Get around date picker positioning issue in IE and Firefox.
         */
        isContainedFloater: function() {
            var ret = this.callParent(arguments);
            if (ret && this.floatParent) {
                ret = false;
            }

            return ret;
        }
    });

    Ext.view.BoundList.override({
        initComponent: function() {
            overrideShadow.call(this);
            return this.callParent(arguments);
        }
    });

    Ext.window.Window.override({
        afterRender: function() {
            this.callParent(arguments);

            if (this.modal && this.mixins.floating) {
                Ext.override(this.el, {
                    sync: function() {
                        this.callParent(arguments);
                        //add extra space in shim to get around the issue where the dialog is on top of an applet
                        //and because the dialog closer icon is partially outside of the dialog, we need the shim to cover it
                        var shim = this.getShim();
                        if (shim) {
                            var l = this.getLeft(true),
                                t = this.getTop(true),
                                w = this.dom.offsetWidth,
                                h = this.dom.offsetHeight;

                            shim.setSize(w + 26, h + 22);
                            shim.setLeftTop(l - 13, t - 11)
                        }

                        return this;
                    }
                })
            }
        }
    });

    /**
     * Increase the server proxy timeout to 2 minute. XCPUIC-3288
     */
    Ext.apply(Ext.data.proxy.Server.prototype, {
        timeout: 120000
    });

})();

Ext.menu.Menu.override({
	showAt: function(x, y, animate) {
		if (Ext.isArray(x)) {
			// have to set y before x gets replaced
			y = x[1];
			x = x[0];
		}

		if (Ext.isIE) {
            var initialConfig = this.initialConfig;
            var compensate = true;
            if (initialConfig && initialConfig.id && initialConfig.id.indexOf("xcp_viewer") == 0) {
                compensate = false;
            }

            if (compensate) {
                // some browsers (IE) add in the scroll coordinate to the event.
                // this has the effect of misplacing the location of menu.
                var s = Ext.getBody().getScroll();

                x -= s.left;
                y -= s.top;
            }
		}
		this.callParent([x,y,animate]);
	}
});

Ext.override(Ext.data.Types.INT, {
		convert: function(v) {
			return v !== undefined && v !== null && v !== '' ?
				Ext.Number.toFixed(parseFloat(String(v).replace(Ext.data.Types.stripRe, ''), 10),0)*1 : (this.useNull ? null : 0); 
		}
	}
)

/* xcp_extjs_patch/content/xcp/ExtjsChartsPatch.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.override(Ext.chart.series.Bar,{
	
    getBounds: function() {
        var me = this,
            chart = me.chart,
            store = chart.getChartStore(),
            data = store.data.items,
            i, ln, record,
            bars = [].concat(me.yField),
            barsLen = bars.length,
            groupBarsLen = barsLen,
            groupGutter = me.groupGutter / 100,
            column = me.column,
            xPadding = me.xPadding,
            yPadding = me.yPadding,
            stacked = me.stacked,
            barWidth = me.getBarGirth(),
            barWidthProperty = column ? 'width' : 'height',
            math = Math,
            mmin = math.min,
            mmax = math.max,
            mabs = math.abs,
            shrunkBarWidth, groupBarWidth, bbox, minY, maxY, axis, out,
            scale, zero, total, rec, j, plus, minus;

        me.setBBox(true);
        bbox = me.bbox;

        //Skip excluded series
        if (me.__excludes) {
            for (j = 0, total = me.__excludes.length; j < total; j++) {
                if (me.__excludes[j]) {
                    groupBarsLen--;
                }
            }
        }

        if (me.axis) {
            axis = chart.axes.get(me.axis);
            if (axis) {
                out = axis.calcEnds();
                minY = out.from;
                maxY = out.to;
            }
        }

        if (me.yField && !Ext.isNumber(minY)) {
            axis = new Ext.chart.axis.Axis({
                chart: chart,
                fields: [].concat(me.yField)
            });
            out = axis.calcEnds();
            minY = out.from;
            maxY = out.to;
        }

        if (!Ext.isNumber(minY)) {
            minY = 0;
        }
        if (!Ext.isNumber(maxY)) {
            maxY = 0;
        }
        scale = (column ? bbox.height - yPadding * 2 : bbox.width - xPadding * 2) / (maxY - minY);
        shrunkBarWidth = barWidth;
        groupBarWidth = (barWidth / ((stacked ? 1 : groupBarsLen) * (groupGutter + 1) - groupGutter));
        
        if (barWidthProperty in me.style) {
            groupBarWidth = mmin(groupBarWidth, me.style[barWidthProperty]);
            shrunkBarWidth = groupBarWidth * ((stacked ? 1 : groupBarsLen) * (groupGutter + 1) - groupGutter);
        }
        zero = (column) ? bbox.y + bbox.height - yPadding : bbox.x + xPadding;

        if (stacked) {
            total = [[], []];
            for (i = 0, ln = data.length; i < ln; i++) {
                record = data[i];
                total[0][i] = total[0][i] || 0;
                total[1][i] = total[1][i] || 0;
                for (j = 0; j < barsLen; j++) {
                    if (me.__excludes && me.__excludes[j]) {
                        continue;
                    }
                    rec = record.get(bars[j]);
                    total[+(rec > 0)][i] += mabs(rec);
                }
            }
            total[+(maxY > 0)].push(mabs(maxY));
            total[+(minY > 0)].push(mabs(minY));
            minus = mmax.apply(math, total[0]);
            plus = mmax.apply(math, total[1]);
            scale = (column ? bbox.height - yPadding * 2 : bbox.width - xPadding * 2) / (plus + minus);
            zero = zero + minus * scale * (column ? -1 : 1);
        }
        else if (minY / maxY < 0) {
            zero = zero - minY * scale * (column ? -1 : 1);
        }
        return {
            bars: bars,
            bbox: bbox,
            shrunkBarWidth: shrunkBarWidth,
            barsLen: barsLen,
            groupBarsLen: groupBarsLen,
            barWidth: barWidth,
            groupBarWidth: groupBarWidth,
            scale: scale,
            zero: zero,
            xPadding: xPadding,
            yPadding: yPadding,
            signed: minY / maxY < 0,
            minY: minY,
            maxY: maxY
        };
    },

    getPaths: function() {
        var me = this,
            chart = me.chart,
            store = chart.getChartStore(),
            data = store.data.items,
            i, total, record,
            bounds = me.bounds = me.getBounds(),
            items = me.items = [],
            yFields = me.yField,
            gutter = me.gutter / 100,
            groupGutter = me.groupGutter / 100,
            animate = chart.animate,
            column = me.column,
            group = me.group,
            enableShadows = chart.shadow,
            shadowGroups = me.shadowGroups,
            shadowAttributes = me.shadowAttributes,
            shadowGroupsLn = shadowGroups.length,
            bbox = bounds.bbox,
            barWidth = bounds.barWidth,
            shrunkBarWidth = bounds.shrunkBarWidth,
            xPadding = me.xPadding,
            yPadding = me.yPadding,
            stacked = me.stacked,
            barsLen = bounds.barsLen,
            colors = me.colorArrayStyle,
            colorLength = colors && colors.length || 0,
            math = Math,
            mmax = math.max,
            mmin = math.min,
            mabs = math.abs,
            j, yValue, height, totalDim, totalNegDim, bottom, top, hasShadow, barAttr, attrs, counter,
            shadowIndex, shadow, sprite, offset, floorY;

        for (i = 0, total = data.length; i < total; i++) {
            record = data[i];
            bottom = bounds.zero;
            top = bounds.zero;
            totalDim = 0;
            totalNegDim = 0;
            hasShadow = false;
            for (j = 0, counter = 0; j < barsLen; j++) {
                // Excluded series
                if (me.__excludes && me.__excludes[j]) {
                    continue;
                }
                yValue = record.get(bounds.bars[j]);
                height = Math.round((yValue - mmax(bounds.minY, 0)) * bounds.scale);
                barAttr = {
                    fill: colors[(barsLen > 1 ? j : 0) % colorLength]
                };
                if (column) {
                    Ext.apply(barAttr, {
                        height: height,
                        width: mmax(bounds.groupBarWidth, 0),
                        x: (bbox.x + xPadding + (barWidth - shrunkBarWidth) * 0.5 + i * barWidth * (1 + gutter) + counter * bounds.groupBarWidth * (1 + groupGutter) * !stacked),
                        y: bottom - height
                    });
                }
                else {
                    // draw in reverse order
                    offset = (total - 1) - i;
                    Ext.apply(barAttr, {
                        height: mmax(bounds.groupBarWidth, 0),
                        width: height + (bottom == bounds.zero),
                        x: bottom + (bottom != bounds.zero),
                        y: (bbox.y + yPadding + (barWidth - shrunkBarWidth) * 0.5 + offset * barWidth * (1 + gutter) + counter * bounds.groupBarWidth * (1 + groupGutter) * !stacked + 1)
                    });
                }
                if (height < 0) {
                    if (column) {
                        barAttr.y = top;
                        barAttr.height = mabs(height);
                    } else {
                        barAttr.x = top + height;
                        barAttr.width = mabs(height);
                    }
                }
                if (stacked) {
                    if (height < 0) {
                        top += height * (column ? -1 : 1);
                    } else {
                        bottom += height * (column ? -1 : 1);
                    }
                    totalDim += mabs(height);
                    if (height < 0) {
                        totalNegDim += mabs(height);
                    }
                }
                barAttr.x = Math.floor(barAttr.x) + 1;
                floorY = Math.floor(barAttr.y);
                if (!Ext.isIE9 && barAttr.y > floorY) {
                    floorY--;
                }
                barAttr.y = floorY;
                barAttr.width = Math.floor(barAttr.width);
                barAttr.height = Math.floor(barAttr.height);
                items.push({
                    series: me,
                    yField: yFields[j],
                    storeItem: record,
                    value: [record.get(me.xField), yValue],
                    attr: barAttr,
                    point: column ? [barAttr.x + barAttr.width / 2, yValue >= 0 ? barAttr.y : barAttr.y + barAttr.height] :
                                    [yValue >= 0 ? barAttr.x + barAttr.width : barAttr.x, barAttr.y + barAttr.height / 2]
                });
                // When resizing, reset before animating
                if (animate && chart.resizing) {
                    attrs = column ? {
                        x: barAttr.x,
                        y: bounds.zero,
                        width: barAttr.width,
                        height: 0
                    } : {
                        x: bounds.zero,
                        y: barAttr.y,
                        width: 0,
                        height: barAttr.height
                    };
                    if (enableShadows && (stacked && !hasShadow || !stacked)) {
                        hasShadow = true;
                        //update shadows
                        for (shadowIndex = 0; shadowIndex < shadowGroupsLn; shadowIndex++) {
                            shadow = shadowGroups[shadowIndex].getAt(stacked ? i : (i * barsLen + j));
                            if (shadow) {
                                shadow.setAttributes(attrs, true);
                            }
                        }
                    }
                    //update sprite position and width/height
                    sprite = group.getAt(i * barsLen + j);
                    if (sprite) {
                        sprite.setAttributes(attrs, true);
                    }
                }
                counter++;
            }
            if (stacked && items.length) {
                items[i * counter].totalDim = totalDim;
                items[i * counter].totalNegDim = totalNegDim;
            }
        }
    },

    drawSeries: function() {
        var me = this,
            chart = me.chart,
            store = chart.getChartStore(),
            surface = chart.surface,
            animate = chart.animate,
            stacked = me.stacked,
            column = me.column,
            enableShadows = chart.shadow,
            shadowGroups = me.shadowGroups,
            shadowGroupsLn = shadowGroups.length,
            group = me.group,
            seriesStyle = me.seriesStyle,
            items, ln, i, j, baseAttrs, sprite, rendererAttributes, shadowIndex, shadowGroup,
            bounds, endSeriesStyle, barAttr, attrs, anim;

        if (!store || !store.getCount() || me.seriesIsHidden) {
            me.hide();
            me.items = [];
            return;
        }

        //fill colors are taken from the colors array.
        endSeriesStyle = Ext.apply({}, this.style, seriesStyle);
        delete endSeriesStyle.fill;
        delete endSeriesStyle.x;
        delete endSeriesStyle.y;
        delete endSeriesStyle.width;
        delete endSeriesStyle.height;
        
        me.unHighlightItem();
        me.cleanHighlights();
        
        me.getPaths();
        bounds = me.bounds;
        items = me.items;

        baseAttrs = column ? {
            y: bounds.zero,
            height: 0
        } : {
            x: bounds.zero,
            width: 0
        };
        ln = items.length;
        // Create new or reuse sprites and animate/display
        for (i = 0; i < ln; i++) {
            sprite = group.getAt(i);
            barAttr = items[i].attr;

            if (enableShadows) {
                items[i].shadows = me.renderShadows(i, barAttr, baseAttrs, bounds);
            }

            // Create a new sprite if needed (no height)
            if (!sprite) {
                attrs = Ext.apply({}, baseAttrs, barAttr);
                attrs = Ext.apply(attrs, endSeriesStyle || {});
                sprite = surface.add(Ext.apply({}, {
                    type: 'rect',
                    group: group
                }, attrs));
            }
            if (animate) {
                rendererAttributes = me.renderer(sprite, store.getAt(i), barAttr, i, store);
                sprite._to = rendererAttributes;
                anim = me.onAnimate(sprite, { to: Ext.apply(rendererAttributes, endSeriesStyle) });
                if (enableShadows && stacked && (i % bounds.barsLen === 0)) {
                    j = i / bounds.barsLen;
                    for (shadowIndex = 0; shadowIndex < shadowGroupsLn; shadowIndex++) {
                        anim.on('afteranimate', function() {
                            this.show(true);
                        }, shadowGroups[shadowIndex].getAt(j));
                    }
                }
            }
            else {
                rendererAttributes = me.renderer(sprite, store.getAt(i), Ext.apply(barAttr, { hidden: false }), i, store);
                sprite.setAttributes(Ext.apply(rendererAttributes, endSeriesStyle), true);
            }
            items[i].sprite = sprite;
        }

        // Hide unused sprites
        ln = group.getCount();
        for (j = i; j < ln; j++) {
            group.getAt(j).hide(true);
        }
        // Hide unused shadows
        if (enableShadows) {
            for (shadowIndex = 0; shadowIndex < shadowGroupsLn; shadowIndex++) {
                shadowGroup = shadowGroups[shadowIndex];
                ln = shadowGroup.getCount();
                for (j = i; j < ln; j++) {
                    shadowGroup.getAt(j).hide(true);
                }
            }
        }
        me.renderLabels();
    }

});

/*
* Fix for defect# BAM-6056
* First pie of the Pie Chart not getting highlighted.
* This issue will be fixed in the EXTJS 4.1.2
* @appliedBy: shawb2
* @date: 09/11/2012 [>=> |TT| |TT|]
* */
Ext.define('Ext.overrides.chart.series.Series', {
    override: 'Ext.chart.series.Series',

    // @private set the animation for the sprite
    onAnimate: function(sprite, attr) {
        var me = this;
        sprite.stopAnimation();
        if (me.animating) {
            return sprite.animate(Ext.applyIf(attr, me.chart.animate));
        } else {
            me.animating = true;
            return sprite.animate(Ext.apply(Ext.applyIf(attr, me.chart.animate), {
                // use callback, don't overwrite listeners
                callback: function() {
                    me.animating = false;
                    me.fireEvent('afterrender');
                }
            }));
        }
    }
});


/*
* Fix for defect# BAM-6976
* X axis data  not shown in IE9 and onwards
* This issue is  fixed in the EXTJS 4.1.2 as per Sencha
* @appliedBy: kejria
* */

 Ext.define('Ext.overrides.draw.Draw', {
    override: 'Ext.draw.Draw',

    pathDimensions: function (path) {
        if (!path || !(path + "")) {
            return {x: 0, y: 0, width: 0, height: 0};
        }
        path = this.path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            i = 0,
            ln = path.length,
            p, xmin, ymin, xmax, ymax, dim;
        for (; i < ln; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            }
            else {
                dim = this.curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X.concat(dim.min.x, dim.max.x);
                Y = Y.concat(dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        xmin = Math.min.apply(0, X);
        ymin = Math.min.apply(0, Y);
        xmax = Math.max.apply(0, X);
        ymax = Math.max.apply(0, Y);
        return {
            x: Math.round(xmin),
            y: Math.round(ymin),
            path: path,
            width: Math.round(xmax - xmin),
            height: Math.round(ymax - ymin)
        };
    }
});


Ext.chart.Chart.override({
    getEventXY: function() {
        var ret = this.callParent(arguments);
        var scroll = Ext.getBody().getScroll();
        ret[0] += scroll.left;
        ret[1] += scroll.top;

        return ret;
    }
});

Ext.chart.Tip.override({
    constructor: function() {
        this.callParent(arguments);
        if (this.tooltip) {
            Ext.override(this.tooltip, {
                getTargetXY: function() {
                    var ret = this.callParent(arguments);
                    var s = Ext.getBody().getScroll();
                    ret[0] += s.left;
                    ret[1] += s.top;

                    return ret;
                }
            });
        }
    }
});

/* xcp_extjs_patch/content/xcp/core/ExtAjaxEx.js */

Ext.Ajax.request = Ext.Function.createInterceptor(Ext.Ajax.request, function(options) {
    var pub = this;
    var CONTENTTYPE = 'Content-Type';

    function getAppPathName() {
        var pathname = window.location.pathname;
        if (pathname.charAt(0) == '/') {
            pathname = pathname.substr(1);
        }
        var idx = pathname.indexOf("/");
        if (idx > -1) {
            pathname = pathname.substr(0, idx);
        }
        return pathname;
    };

    if (options.failure) {
        options.failure = Ext.Function.createInterceptor(options.failure, function(responseObject, options) {
            if (responseObject.status == 401) {
                // Handle authentication error. Remember the # in a cookie. Then, redirect.
                Ext.util.Cookies.set("xcp-login-hash", escape(window.location.hash), null, "/" + getAppPathName());
                window.location = "/" + getAppPathName();
                return false;
            }
            return true;
        });
    }

    function createXMLHttpRequest() {
        try { return new XMLHttpRequest(); } catch(e) {}
        try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch (e) {}
        try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch (e) {}
        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e) {}
        return null;
    };

    function initHeader(label, value) {
        (pub.headers = pub.headers || {})[label] = value;
    };

    function setHeader(xhr) {
        var prop,
            headers = {};

        function setTheHeaders(conn, headers){
            for (prop in headers) {
                if (headers.hasOwnProperty(prop)) {
                    conn.setRequestHeader(prop, headers[prop]);
                }
            }
        }

        Ext.apply(headers, pub.headers, pub.defaultHeaders);
        setTheHeaders(xhr, headers);
        delete pub.headers;
    };

    function syncRequest(method, uri, postData) {
        var xhr = createXMLHttpRequest() || null;

        if (xhr) {
            xhr.open(method, uri, false);

            if (pub.useDefaultXhrHeader) {
                initHeader('X-Requested-With', pub.defaultXhrHeader);
            }

            if(postData && pub.useDefaultHeader && (!pub.headers || !pub.headers[CONTENTTYPE])){
                initHeader(CONTENTTYPE, pub.defaultPostHeader);
            }

            if (pub.defaultHeaders || pub.headers) {
                setHeader(xhr);
            }

            xhr.send(postData || null);
        }
        return xhr;
    };

    function createResponseObject(xhr) {
        return {
            // TODO: Need to handle the headers, etc.
            // Normalize the status and statusText when IE returns 1223, see the above link.
//            status : isBrokenStatus ? 204 : conn.status,
//            statusText : isBrokenStatus ? 'No Content' : conn.statusText,
//            getResponseHeader : function(header){return headerObj[header.toLowerCase()];},
//            getAllResponseHeaders : function(){return headerStr;},
            responseText : xhr.responseText,
            responseXML : xhr.responseXML,
            argument : cb.argument
        };
    };

    if(options && options.async === false){
        var xmlData = options.xmlData;
        var jsonData = options.jsonData;
        var hs;

        Ext.applyIf(pub, options);

        if(xmlData || jsonData){
            hs = pub.headers;
            if(!hs || !hs[CONTENTTYPE]){
                initHeader(CONTENTTYPE, xmlData ? 'text/xml' : 'application/json');
            }
            data = xmlData || (!Ext.isPrimitive(jsonData) ? Ext.encode(jsonData) : jsonData);
        }

        var method = options.method || (xmlData || jsonData) ? 'POST' : 'GET';

        var xhr = syncRequest(method, uri, data);
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                if (typeof cb.success == "function") {
                    var responseObj = createResponseObject(xhr);
                    cb.success.call(cb.scope || window, responseObj, options);
                }
            }
            else {
                if (typeof cb.failure == "function") {
                    var responseObj = createResponseObject(xhr);
                    cb.failure.call(cb.scope || window, responseObj, options);
                }
            }
        }
        else {
            if (typeof cb.failure == "function") {
                var responseObj = createResponseObject(xhr);
                cb.failure.call(cb.scope || window, responseObj, options);
            }
        }
        return false;
    }
    return true;
});
/* xcp_utils/content/xcp/util/Utils.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * Utility functions
 */
Ext.define("xcp.util.Utils", {
    statics : {
        /**
         * Returns the app path name.
         */
        getAppPathName: function () {
            var pathname = window.location.pathname;
            if (pathname.charAt(0) == '/') {
                pathname = pathname.substr(1);
            }
            var idx = pathname.indexOf("/");
            if (idx > -1) {
                pathname = pathname.substr(0, idx);
            }
            return pathname;
        },
        /**
         * Build version aware resource URL.
         * @param url The input url.
         */
        buildResourceUrl : function(url, appendLangParam) {
            if (!url) {
                return null;
            }

            if (!xcp.resourceUrlPrefix) {
                var appPath = document.location.pathname;
                if (appPath.charAt(appPath.length - 1) == '/') {
                    appPath = appPath.substr(0, appPath.length - 1);
                }
                xcp.resourceURlPrefix = appPath + "/resources/"+xcp.appContext.version;
            }
            var resourceUrl = xcp.resourceURlPrefix;
            if (url.indexOf("/") != 0){
                resourceUrl += "/";
            }
            resourceUrl += url;
            if (appendLangParam) {
                return xcp.util.Utils.appendLangQueryParam(resourceUrl);
            }
            return resourceUrl;
        },
        appendLangQueryParam: function(url) {
            if (url) {
                var langQueryParam = "lang="+xcp.language;
                if (url.indexOf("?") > 0) {
                    url += "&";
                } else {
                    url += "?";
                }
                url +=langQueryParam;
            }
            return url;
        },

        /**
         * Build version aware resource URL for Artifacts
         * @param url The input url.
         */
        buildArtifactsUrl : function(url) {
            if (url) {
            	//build URL from artifact URN
            	//e.g. URN: "urn:ns:com.emc.xcp.artifact.resource.image:Artifacts/Resources/folder/image.jpg" > URL:"Artifacts/Resources/ns/folder/image.jpg",
            	var urns = url.split(":");
            	if(urns.length == 4){
            		var path = urns[3];
            		var paths = path.split("/");
            		paths.splice(2, 0, urns[1]);
            		url = paths.join("/");
            	}
                if (url.indexOf("/") != 0){
                    url = "/" + url;
                }
                if (xcp.core.NavigationManager) {
                    var prefix = "/Artifacts",
                        appPath = this.getAppPathName(),
                        appVersion = xcp.appContext ?  xcp.appContext.version : null;
                    if (!appVersion || url.indexOf(prefix + "/") !== 0) {
                        url = "/" + appPath + url;
                    } else {
                        url = "/" + appPath + prefix + "/" + appVersion + url.substring(prefix.length);
                    }
                }
            }

            return url;
        },

        buildComponentUrl : function(ext, comp, resolveDependencyAtServer, nominify) {
            var url = "component";  // $NON-NLS-1$ 
            if (comp) {
                url +="/"+comp.bundle + "/" + comp.id;
            }
            url+="/contents";  // $NON-NLS-1$ 
            if (comp) {
                url+= "-"+comp.id;
            }
            url+="-"+xcp.componentVersion+"."+ext;

            var appendQ = true;
            if (resolveDependencyAtServer != undefined && resolveDependencyAtServer != null) {
                url+="?resolveDependency=" + resolveDependencyAtServer;
                appendQ = false;
            }
            if (nominify === true) {
                if (appendQ) {
                    url+="?";
                    appendQ = false;
                }
                url+="nominify=true";
            }
            if (appendQ) {
                url +="?"
                appendQ = false;
            } else {
                url +="&"
            }
            url +="locale="+xcp.language;

            return url;
        },
        /**
         * Given an r_object_type value, and optionally an r_object_id value, return the
         * corresponding model.
         * @param objTypeName
         * @param id
         */
        getModelFromObjectType: function(objTypeName, id) {
            var modelName = objTypeName;
            if (modelName == "dm_cabinet")
                modelName = "xcp_dm_folder";

            // If we don't find the model for the type, then get the base type based on the object id
            if (!Ext.ModelManager.getModel(modelName)) {
                if (!id) {
                    xcp.Logger.debug("error: can't get model from object type " + objTypeName);
                }
                else {
                    if ((id.indexOf("0b") == 0) || (id.indexOf("0c") == 0))
                        modelName = "xcp_dm_folder";
                    else if (id.indexOf("09") == 0)
                        modelName = "xcp_dm_document";
                    else if (id.indexOf("08") == 0)
                        modelName = "xcp_RootBO";
                    else
                        xcp.Logger.debug("error: can't get model from object type " + objTypeName);
                }
            }

            return modelName;
        },

        isSupportedType: function(r_object_type){
            var modelName=this.getModelFromObjectType(r_object_type);
            return this.isSupportedModel(modelName);
        },
        isSupportedModel: function(modelName){
            var modelMap = xcp.appConfiguration.modelsConfig;
            return (modelName && modelMap[modelName]!=undefined);
        },
        isPageExist: function(modelName, pageUrlName) {
            var modelMap = xcp.appConfiguration.modelsConfig;
            if (modelName && modelMap && modelMap[modelName] != undefined) {
                if (pageUrlName) {
                    var pages = modelMap[modelName]['pages'];
                    if (pages && pages.length > 0) {
                        for (var index=0; index < pages.length; index++) {
                            if (pages[index] == pageUrlName) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        },

        /* This function will check if the record belong to a relationship realtime query. All those queries have
        * attributes like parent_ or child_ except the id and the effectivePermissions attributes.*/
        isRelationshipQuery: function(record) {
            var name;
            for (var i = 0; i < record.fields.items.length; i++) {
                name = record.fields.items[i].name;

                if (name === "id" || name === "effectivePermissions" ||
                                name.indexOf("child_") != -1 || name.indexOf("parent_") !== -1) {
                    continue;
                } else{
                    return false;
                }
            }
            return true;
        },

        /**
         * Get a model instance as a specific model type. Returns same model if same or missing modelName
         * @param model
         * @param modelName
         */
        getAsModel: function(model, modelName) {
            if (!model || !modelName)
                return model;
            if (Ext.ClassManager.getName(model)==modelName)
                return model;
            var xmodel = Ext.create(modelName, model.data);
            xmodel = xcp.action.form.DataAction.copyModelInstance(model, xmodel);

            return xmodel;
        },

        // Utility method to build the URL used for navigation.
        //
        //    model         name of the model (e.g. 'folder')
        //    objectId      r_object_id of target object page
        //    page          name of xcp page
        //    src           component user used to invoke navigation
        //    version       flag indicating URL should have version parameter
        makePageUrl: function(model, objectId, page, src, version) {
            return xcp.util.Utils.buildPageUrl(model, objectId, page, xcp.util.Utils.getNavigationAppPage(src), version);
        },

        // Utility method to build the URL used for given info.
        //
        //    model         name of the model (e.g. 'folder')
        //    objectId      r_object_id of target object page
        //    page          name of xcp page
        //    appPage       appPage string
        //    version       flag indicating URL should have version parameter
        buildPageUrl: function(model, objectId, page, appPage, version) {
            var url;

            if (!page)
                page = xcp.defaultPages[model];

            if ((objectId != null) && (objectId != ""))
            {
                url = [model, objectId, page].join("/");
                if(version == true)
                    url = url + "?version=" + version;
            }
            else
            {
                url = [model, page].join("/");
            }
            if (appPage)
                url = [appPage, url].join("/");

            return url;
        },
        /**
         * Utility method to build the URL used by FolderView to setPage and not navigate.
         * @param model   name of the model (e.g. 'folder')
         * @param objectId  r_object_id of target object page
         * @param page   name of xcp page
         * @param role
         * @returns pageUrl
         */
        frameUrl:function (model, objectId, page, role) {
            if (!page)
                page = xcp.util.Utils.getDefaultPageFromContextMenu(model);

            var appPath = document.location.pathname;
            if (appPath.charAt(appPath.length - 1) == '/') {
                appPath = appPath.substr(0, appPath.length - 1);
            }
            var pagePath = ["/ui/pages", model, page].join("/");
            var pageUrl = xcp.util.Utils.buildResourceUrl(pagePath);
            //add role or objectId which ever is available first
            if (role) {
                pageUrl += '?role=' + role;
            } else if (objectId) {
                this.objectId = objectId;
                pageUrl += '?objectId=' + objectId;
            }
            return pageUrl;
        },

        /**
         * Returns the default page to use when rendering a link for a row in a grid or tree node.
         * @param modelName
         */
        getDefaultPageFromContextMenu: function(modelName, record)
        {
            if (modelName == "xcp_task") {
                return xcp.util.Utils.getTaskPageName(record);
            }
            var menu = xcp.core.ActionManager.getContextMenuDefByName(modelName + "-ItemContextMenu");
            var pageUrl = xcp.defaultPages[modelName];

            for (var action in menu)
            {
                var menuItem = menu[action];
                if (menuItem.isDefaultLink == true)
                {
                    pageUrl = menuItem.action.page;
                    break;
                }
            }
            return pageUrl;
        } ,

        // Given a component, return either an empty string ("") or currentNavigationContext.appPage
        // (the name of the current application page), depending on whether the current application
        // page (if any) meets the following:
        //
        //   (1) the given source component is contained (either directly or by a contained page) by
        //       the current application page, and
        //   (2) the current application page has a content area
        //
        getNavigationAppPage: function(src) {
            var appPage = "";
            if (src) {
                // find the page that contains the source widget
                var containingPage = undefined;
                if (src.parentPage) {
                    containingPage = src.parentPage;
                } else if (!src instanceof xcp.widget.Page && Ext.isFunction(src.getPage)) {
                    containingPage = src.getPage();
                }else {
                    containingPage = src.up('xcp_page');
                }
                /*Without this, clicking on an item from the content area of folderview will not navigate the entire page.*/
                if (containingPage && containingPage.insideFolderView)
                    return "";

                // if it's found, and it's not the top page, look for a contained content area
                // ignore content area inside folderview widget
                if (containingPage && (containingPage.id != "_topPageContainer")) {
                    var contentArea = containingPage.getComponentByXType("xcp_page");
                    if (contentArea && !contentArea.insideFolderView  && xcp.navigationManager) {
                        appPage = xcp.navigationManager.currentNavigationContext.appPage;
                    }
                }
                // if no appPage at this point, check one more level up. This handles the case where
                // the source component resides on an object page contained by the current application
                // page.
                if (!appPage && containingPage) {
                    var grandParentPage = containingPage.parentPage;
                    if (!grandParentPage) {
                        grandParentPage = containingPage.up('xcp_page');
                    }

                    if (grandParentPage && (grandParentPage.id != "_topPageContainer") && xcp.navigationManager)
                        appPage = xcp.navigationManager.currentNavigationContext.appPage;
                }
            }
            return appPage;
        },
        /**
         * Replace {vars} in template from model or js object.
         * @param str
         * @param data
         */
        formatTemplateString: function(str, data) {
            if (data){
                if (Ext.isFunction(data.get))
                    data = data.data;
                for (var name in data)
                {
                    var value = data[name];
                    str = str.replace("{"+name+"}", value);
                }
            }
            return str;
        },

        /**
         * Finds if it is an empty object
         * @param obj
         */
        isEmptyObject : function(obj) {
            for(var prop in obj) {
                if(obj.hasOwnProperty(prop))
                    return false;
            }
            return true;
        },

        /**
         * Shallow merge of two object properties
         * @param obj1
         * @param obj2
         */
        merge : function(obj1, obj2) {
            for(var prop in obj2) {
                if(obj2.hasOwnProperty(prop)) {
                    obj1[prop] = obj2[prop];
                }
            }
        },
        deepCopy: function(source, target) {
            target = target || (source.constructor === Array ? [] : {});
            for (var i in source) {
                if (typeof source[i] === 'object') {
                    target[i] = source[i].constructor === Array ? [] : {};
                    xcp.util.Utils.deepCopy(source[i], target[i]);
                } else {
                    target[i] = source[i];
                }
            }
            return target;
        },
        /**
         * Update browser window title with:
         * [app title] - [page title]
         */
        updateBrowserTitle : function(title) {
            var separator = ' - ',
                title = title || {},
                appTitle = title.appTitle || xcp.appContext.name || '',
                pageTitle = title.pageTitle || '';

            if (!Ext.isEmpty(appTitle)) {
                title = Ext.isEmpty(pageTitle) ? appTitle : appTitle + separator + pageTitle;
            } else if (!Ext.isEmpty(pageTitle)) {
                title = pageTitle;
            } else {
                //empty string can't override the current title
                //mimick default browser behavior when no title is present, it just display the url
                title = window.location.href;
            }

            document.title = title;
        },
        isSubTypeOf: function(subClass, superClass) {
            if (subClass && superClass) {
                var superClassName = superClass.$className;
                var parentClass = subClass.superclass;
                //Check for ExtJs Based class
                if (superClassName && parentClass) {
                    var parentClassName = parentClass.$className;
                    if (parentClassName == superClassName) {
                        return true;
                    }
                    else {
                        return xcp.util.Utils.isSubTypeOf(parentClass, superClass);
                    }
                } else {
                    //May not be ExtJs generated classes
                    if (subClass.prototype && superClass.prototype) {
                        if (subClass.prototype.constructor == superClass.prototype.constructor) {
                            return true;
                        }
                    }

                }
            }
            return false;
        },
        getTaskPageName: function(record) {
            if (record) {
                var processName = record.get("process_system_name");
                var activityName = record.get("activity_system_name");
                if (xcp.util.Utils.isPageExist(processName, activityName)) {
                    return activityName;
                }
            }
            return undefined;
        },
        isTaskModel: function(modelName, record) {
            if (modelName && modelName == "xcp_task") {
                return true;
            } else if (!Ext.isEmpty(record.get("process_system_name"))) {
                return true;
            }
            return false;
        },
        getProcessName: function(record) {
            if (!Ext.isEmpty(record.get("process_system_name"))) {
                return record.get("process_system_name");
            } else {
                return undefined;
            }
        },
        queryComponentByXCPIdOrName: function(scope, xcpIdOrName) {
            var componentQueryStr = "component[xcpId='" + xcpIdOrName + "']";
            var component = scope.query(componentQueryStr);
            if (!component || component.length == 0) {
                //fallback to name property
                componentQueryStr = "component[name='" + xcpIdOrName + "']";
                component = scope.query(componentQueryStr);
            }
            return component;

        },
        queryComponentByModelName: function(scope, modelNameOrAlias) {
            var componentQueryStr = "component[modelName='" + modelNameOrAlias + "']";
            var components = scope.query(componentQueryStr);
            if (components && components.length != 0) {
                return components[0];
            }

            //component is a form which contains multiple model instances
            componentQueryStr = "component[modelNames]";  // $NON-NLS-1$
            components = scope.query(componentQueryStr);
            if (components && components.length != 0) {
                for (i = 0; i < components.length; i++) {
                    if (components[i].modelNames[modelNameOrAlias]) {
                        return components[i];
                    }
                }
            }
            //Fallback to look for modelAlias
            componentQueryStr = "component[modelAlias='" + modelNameOrAlias + "']";
            components = scope.query(componentQueryStr);
            if (components && components.length != 0) {
                return components[0];
            }
            return null;
        },
        queryComponentByXType: function(scope, xtype) {
            if (scope && xtype && Ext.isFunction(scope.down)) {
                return scope.down(xtype);
            }
            return undefined;
        }
    }
});




/* xcp_page/content/xcp/widget/Page.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// Page.js

/**
 * @class xcp.widget.Page
 * @extends Ext.container.Container
 * A specialized Ext container component, responsible for rendering given page configuration as child. 
 * @constructor
 * Creates a new page container.
 * @param {Object} config Configuration options.
 * @xtype xcp_page
 */
Ext.define('xcp.widget.Page', {
    extend: 'Ext.container.Container',
    alias: 'widget.xcp_page',
    mixins: {
        feedbackContainer: 'xcp.util.mixin.FeedbackContainer'
    },

    /**
     * Replaces the child component (page) with new config.
     * @param compConfig
     */
    replaceChild : function(compConfig) {
        //update browser title
        if (compConfig) {
            xcp.util.Utils.updateBrowserTitle({pageTitle: compConfig.pageTitle || ""});
        }

        var ret;
        try {
            Ext.suspendLayouts();
            this.removeAll(true);
            ret = this.add(compConfig);
        } finally {
            Ext.resumeLayouts(true);
        }

        return ret;
    },

    /**
     * Sets pagecontext ID on a page and its children.
     * @param pageConfig page object
     * @param targetId Object Id
     */
    setPageContext:function (pageConfig, targetId) {
        // set on page first
        var me = this;
        this.clearPageContext();
        var pageContextId = xcp.core.PageContextManager.register(targetId, me);
        this.pageContextID = pageContextId;

        function setPageContextId(cmp, pageCtxID) {
            if (!pageCtxID || cmp.xtype == "xcp_page") {
                pageCtxID = xcp.core.PageContextManager.register(targetId, me);
            }
            cmp.pageContextID = pageCtxID;

            // iterate through the object and set pagecontextID
            for (var i in cmp) {
                if (cmp[i] === undefined || cmp[i] === null)
                    continue;
                if (typeof cmp[i] === 'object') {
                    setPageContextId(cmp[i], pageCtxID);
                }
            }
        }
        //iteratively set on all children on the page
        setPageContextId(pageConfig, pageContextId);
    },
    getComponentByXCPId: function(xcpIdOrName) {
       var me = this;
       if (me.pageContextID) {
           var pageContext = me.getPageContext();
           if (pageContext) {
            return pageContext.getComponentByXCPId(xcpIdOrName);
           }
       }
       return xcp.util.Utils.queryComponentByXCPIdOrName(me, xcpIdOrName);
    },
    getComponentByModelName: function(modelNameOrAlias) {
       var me = this;
       if (me.pageContextID) {
           var pageContext = me.getPageContext();
           if (pageContext) {
            return pageContext.getComponentByModelName(modelNameOrAlias);
           }
       }
       return xcp.util.Utils.queryComponentByModelName(me, modelNameOrAlias);
    },
    getComponentByXType: function(xtype) {
        var me = this;
        if (me.pageContextID) {
            var pageContext = me.getPageContext();
            if (pageContext) {
             return pageContext.getComponentByXType(xtype);
            }
        }
        return xcp.util.Utils.queryComponentByXType(me, xtype);
    },
    clearPageContext: function() {
        if (Ext.isFunction(this.getPageContextID) && this.getPageContextID()) {
            xcp.core.PageContextManager.remove(this.getPageContextID());
        }
    },
    destroy: function(){
        this.callParent(arguments);
        this.clearPageContext();
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.core.NavigationManager");

Ext.apply(xcp.Strings.core.NavigationManager, {
    pageFetchError:           "Error while retrieving configuration for page '{0}'"
});
/* xcp_navigation_lib/content/xcp/core/NavigationManager.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.core");
(function(){

    var modelsConfig = {};
    /**
     * @class xcp.core.NavigationContext
     * @extends Object
     * <p>The NavigationContext Object, used to store last navigation path and list of page urls.
     */
    xcp.core.NavigationContext = Ext.extend(Object, {
        constructor : function(path) {
            xcp.Logger.debug("Constructing Navigation Context with path", path);
            //To over come the issue of # being appended to navigation path in IE.
            if (path && path.indexOf("#") == 0) {
                path = path.substring(1);
            }

            this.navigationPath = path;
            this.pages = [];
            this.objectId = null;
            this.appPage = null;

            checkVersionParam.call(this,path);

            addNavigationPage.call(this, "application", "master", null, xcp.core.UserProfile.getRole());  // $NON-NLS-1$  $NON-NLS-2$ 

            var elements = path.split("/");
            if (elements.length) {
                var curElem = elements.shift();
                if (isModel(curElem) && !isApplicationLiteral(curElem))
                    parseModelUrl.call(this, curElem, elements);
                else
                    parseApplicationUrl.call(this, curElem, elements);
            }
        }
    });

    function checkVersionParam(path)
    {
        if(path.indexOf("?") != -1)  //we have a query string
            {
                var queryStr = path.substring(path.indexOf("?") + 1);
                var vars = queryStr.split("&");
                for(var i = 0; i < vars.length; i ++){
                    var pair = vars[i].split("=");
                    if(pair[0] == "version") {
                        this.versionRequested = true;
                        break;
                    }
                }
            }
    }

    // private to xcp.core.NavigationContext
    function addNavigationPage(modelName, pageUrlName, objectId, role) {
        var appPath = document.location.pathname;
        if (appPath.charAt(appPath.length - 1) == '/') {
            appPath = appPath.substr(0, appPath.length - 1);
        }
		var pagePath = ["/ui/pages", modelName, pageUrlName].join("/");
        var pageUrl = xcp.util.Utils.buildResourceUrl(pagePath);
        //add role or objectId which ever is available first
        var page = {};

        if (role) {
            pageUrl += '?role=' + role;
        }
        //Should not add objectId to page URL as it is not used in page controller also it causes page
        //caching issue
        /*else if (objectId) {
            this.objectId = objectId;
            pageUrl += '?objectId=' + objectId;
        }*/
        pageUrl = xcp.util.Utils.appendLangQueryParam(pageUrl);

        page.url = pageUrl;
        //build a resource url if objectId is not null
        if (objectId) {
            var resourceName = modelsConfig[modelName].resourceName;
            page.resourceUrl = appPath + "/application/"
                    + resourceName + "/" + objectId;
        }
        this.pages.push(page);
    }

    // private to xcp.core.NavigationContext
    function parseModelUrl(modelName, elements) {
        var elem = elements.shift();
        var role = xcp.core.UserProfile.getRole();
        if(isObjectId(elem) || isAdminRoleModel(modelName)){
            this.objectId = elem;
            elem = elements.shift();
        }
        addNavigationPage.call(this, modelName, elem  || xcp.defaultPages[modelName], this.objectId, role);
    }

    // private to xcp.core.NavigationContext
    function parseApplicationUrl(pageId, elements) {
        if (isApplicationLiteral(pageId))
            pageId = elements.shift();
        addNavigationPage.call(this, "application", pageId, null, xcp.core.UserProfile.getRole());  // $NON-NLS-1$
        this.appPage = pageId;
        if (elements.length) {
            var model = elements.shift();
            parseModelUrl.call(this, model, elements);
        }
    }

    function isModel(id) {
        return !!Ext.ModelManager.getModel(id) || (modelsConfig && modelsConfig[id]);
    }

    function isApplicationLiteral(id) {
        return id === "application";  // $NON-NLS-1$ 
    }

    function isAdminRoleModel(id){
        return id === "role";  // $NON-NLS-1$ 
    }

    var objectIdRE= new RegExp("^[0-9a-f]{16}$", "i");
    function isObjectId(s) {
        return objectIdRE.test(s);
    }

    /**
     * @class xcp.core.NavigationManager
     * @extends Ext.util.Observable
     * <p>The NavigationManager class is responsible for handling the page navigation and history management.
     */
    xcp.core.NavigationManager = Ext.extend(Ext.util.Observable, {
        constructor: function(config) {
            this.callParent();
            xcp.Logger.debug("NavigationManager constructor with config", config);
            // delay setting modelsConfig for unit testing of NavigationManager
            modelsConfig = xcp.appConfiguration['modelsConfig'];

            this.addEvents(
                /**
                 * @event navigationcomplete
                 * Fires when the navigation is completed.
                 */
                    'navigationcomplete');

            //Create a history-form required for ExtJs History management
            var formId = "history-form";
            if (!Ext.get(formId)) {
                Ext.getBody().createChild({
                    tag:    'form',
                    action: '#',
                    cls:    'x-hidden',
                    id:     formId,
                    children: [
                        {
                            tag: 'div',
                            children: [
                                {
                                    tag:  'input',
                                    id:   Ext.History.fieldId,
                                    type: 'hidden'
                                },
                                {
                                    tag:  'iframe',
                                    id:   Ext.History.iframeId
                                }
                            ]
                        }
                    ]
                });

                //initialize History management
                Ext.util.History.init();

                // ExtJs 4 bug: the event queue wasn't set.
                if (!Ext.util.History.events) {
                    Ext.util.History.events = [];
                }
            }

            Ext.util.History.on('change', this.loadPage, this);

            this.currentNavigationContext = null;
            xcp.core.NavigationManager.superclass.constructor.call(this, config);
            var navUrl = window.location.hash;
            if (navUrl == "#" || navUrl.length == 0) {

                navUrl = modelsConfig["application"].homePageUrlName;
                //Update the application home page as window location hash
                window.location.hash = "#" + navUrl;
            } else {
                //Load the initial page
                if (navUrl && navUrl.indexOf("#") == 0) {
                    navUrl = navUrl.substring(1);
                }
                this.loadPage(navUrl);
            }
        },

        destroy : function() {
             Ext.util.History.un('change', this.loadPage, this);  // $NON-NLS-1$ 
            return this.callParent(arguments);
        },

        navigate : function(navUrl) {
            Ext.util.History.add(navUrl);
        },

        loadPage : function(navUrl) {
            xcp.Logger.info("Loading Page with url", navUrl);

            //Check if the path is null or empty in that case don't do any thing
            if (!navUrl || navUrl.length == 0) {
                xcp.Logger.warn("Passed navigation url is empty or null ignoring the navigation request");
                return;
            }
            //TODO Get role somehow
            var currentContext = new xcp.core.NavigationContext(navUrl);
            //First get the previous context and compare what is changed
            var previousContext = this.currentNavigationContext;
            var currentPages = currentContext.pages;
            var currentPageCount = currentPages.length;

            var refreshStartLevel = 0;
            //Compare with the previous context pages and findout from which level in page tree require fresh.
            if (previousContext) {
                var previousPages = previousContext.pages;
                for (; refreshStartLevel < currentPageCount; refreshStartLevel++) {
                    if (refreshStartLevel >= previousPages.length ||
                        currentPages[refreshStartLevel].url != previousPages[refreshStartLevel].url) {
                        break;
                    }
                }
            }

            //In case user navigate back to same page (by clicking the link), refresh last visited page
            if (refreshStartLevel >= currentPageCount) {
                refreshStartLevel = currentPageCount - 1;
            }
            this.currentNavigationContext = currentContext;

            //Find a right xcp_page container for refresh
            //Start the refresh page search from the top xcp_page container
            var currentPageContainer = Ext.ComponentMgr.get("_topPageContainer");
            //Get the xcp_page which needs to be refreshed.
            for (var curPageLevel = 0; curPageLevel < refreshStartLevel; curPageLevel++) {
                if (Ext.isArray(currentPageContainer)) {
                    //Pick up the first element in array as we are only intrested in first descendent
                    currentPageContainer = currentPageContainer[0];
                }
                currentPageContainer = currentPageContainer.getComponentByXType("xcp_page");
                if (!currentPageContainer) {
                    throw "Cannot find page container at level : " + refreshStartLevel;  // $NON-NLS-1$ 
                }
            }

            var me = this;
            var renderChildPage = function(currentRefreshLevel, currentPageContainer) {
                var pageUrl = currentContext.pages[currentRefreshLevel].url;

                Ext.Ajax.request({
                    url: pageUrl,
                    scope: me,
                    disableCaching : false,
                    support404Redirect: true,
                    success: function(response) {
                        var responseText = response.responseText;
                        var pageConfig = Ext.JSON.decode(responseText);
                        if (pageConfig) {
                            //Set the resource url if required on the page context
                            if (pageConfig.pageContext && currentContext.pages[currentRefreshLevel].resourceUrl) {
                                pageConfig.pageContext.url = currentContext.pages[currentRefreshLevel].resourceUrl;
                            }
                            if (currentContext.objectId) {
                                pageConfig.objectId = currentContext.objectId;
                            }
                            if (Ext.isArray(currentPageContainer)) {
                                //Pick up the first element in array as we are only intrested in first descendent
                                currentPageContainer = currentPageContainer[0];
                            }
                            var pageObjectId = undefined;
                            if (currentRefreshLevel > 0) {
                                pageObjectId = pageConfig.objectId;
                            }
                            currentPageContainer.setPageContext(pageConfig, pageObjectId);
                            var newComp = currentPageContainer.replaceChild(pageConfig);
                            currentRefreshLevel++;
                            if (currentRefreshLevel <  currentContext.pages.length) {
                                var parentPage = currentPageContainer;
                                currentPageContainer = currentPageContainer.getComponentByXType("xcp_page");
                                currentPageContainer.parentPage = parentPage;
                                renderChildPage(currentRefreshLevel, currentPageContainer);
                            } else {
                                //Fire the navigationcomplete event, do we need to return the navUrl as a event data?
                                xcp.Logger.debug("Navigation complete event is fired");
                                this.fireEvent('navigationcomplete', this);

                                //If the found page was inside a tab, activate the tab
                                var tab = currentPageContainer.up("xcp_tab");
                                if(tab)
                                    tab.show();
                                }
                        }
                    },
                    failure: function(response, options) {
                        var message = Ext.String.format(xcp.Strings.core.NavigationManager.pageFetchError, navUrl);
                        xcp.core.FeedbackManager.showFeedback(null, "", message, "systemErrors", false);
                    }
                });
            };
            //Perform the refresh from top to bottom page.
            renderChildPage(refreshStartLevel, currentPageContainer);
        },

        /**
         * Returns a fully qualified URL to the page passed in.
         *
         * @param page page name/path
         */
        getPageURL : function(page) {
            // we'll take care of "#" below, so remove it
            if (page) {
                page = page.replace("#", "");
            }
            var loc = window.location;
            var href = loc.href;
            if (loc.hash) {
                href = href.replace(loc.hash, "#" + page);
            } else {
                href += "#" + page;
            }
            return href;
        },

        adjustLocation: function(newUrl) {
            var currentContext = new xcp.core.NavigationContext(newUrl);
            this.currentNavigationContext = currentContext;
            var protocol = window.location.protocol;
            var hash = window.location.hash;
            var pathname =  window.location.pathname;
            var host = window.location.host;
            var adjustedUrl = protocol + "//" + host + pathname + "#" + newUrl;
            return  adjustedUrl;
        }
    });
})();

/* xcp_navigation_lib/content/xcp/plugin/NavigationBehavior.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function(){
    var PTYPE = "plugin.xcp_nav_on_event";

    Ext.define('xcp.plugin.NavigationBehavior', {
        extend: 'Ext.AbstractPlugin',
        alias: 'plugin.xcp_nav_on_event',

        constructor : function() {
            /**
             * Navigation targets
             * <li>NONE - navigates in the same window
             * <li>NEW_WINDOW - navigates in a new browser window
             */
            this.NAV_TYPE = {
                NONE : "none",
                NEW_WINDOW : "new_window",
                PAGE : "page"
            };
            /**
             * Event name to register for on the target component.
             */
            this.event = null;
            /**
             * Navigation type to perform
             */
            this.navType = this.NAV_TYPE.NONE;
            /**
             * Navigation URL.
             */
            this.url = null;

            this.callParent(arguments);
        },

        init : function(btn) {
            // if configuration available
            if (btn.initialConfig) {
                // xcp_nav_on_event config object present
                if (btn.initialConfig[PTYPE]) {
                    var conf = btn.initialConfig[PTYPE];
                    this.event = conf["event"] || "click";
                    this.navType = conf["navtype"] || this.NAV_TYPE.NONE;
                    this.url = conf["url"];
                }
                else {
                    var conf = btn.initialConfig;
                    this.event = conf["xcp_nav_event"] || "click";
                    this.navType = conf["xcp_nav_type"] || this.NAV_TYPE.NONE;
                    this.url = conf["xcp_nav_url"];
                }

                // no navigation if no url
                if (this.url) {
                    var url = this.navType === this.NAV_TYPE.PAGE && Ext.isDefined(xcp.navigationManager)?
                              xcp.navigationManager.getPageURL(this.url) : this.url;
                    // TODO only link buttons should have this set
                    btn.on("beforerender", function() {
                        btn.href = url;
                    });
                    
                    btn.on(this.event, this.handleNavigation, this);
                }
            }
        },

        handleNavigation : function(src, e) {
            switch (this.navType) {
                case this.NAV_TYPE.NONE: {
                    window.location = this.url;
                    break;
                }
                case this.NAV_TYPE.NEW_WINDOW : {
                    e.stopEvent();
                    window.open(this.url);
                    break;
                }
                case this.NAV_TYPE.PAGE : {
                    e.stopEvent();
                    if(Ext.isDefined(xcp.navigationManager)) {
                        //Should not call navigate with #, it creates problem with IE browser back button
                        var url = this.url.replace("#", "");
                        // if the new url is not an app page, check to see if we should stay on the same app page
                        if (url.indexOf("/") != -1) {
                            var appPage = xcp.util.Utils.getNavigationAppPage(src);
                            if (appPage)
                                url  = appPage.concat("/", url);
                        }
                        if (this.cmp) {
                            this.cmp.fireEvent("beforepagenavigate", this.cmp);
                        }
                    	xcp.navigationManager.navigate(url);
					}
                }
            }
        }
    });
})();
/* xcp_preference_lib/content/xcp/data/model/UserProfileModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.data.model.UserProfileModel", {
    extend: 'Ext.data.Model',
    proxy: {
        type: 'rest',
        url: 'application/currentUser/preferences',
        extraParams : {
            fields : "theme,role"
        }
    },
    fields: ['theme', 'role']
});


/* xcp_preference_lib/content/xcp/core/UserProfile.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.core.UserProfile", {
    singleton: true,

    /**
     * Constructor for the class
     */
    constructor: function() {
        this._userProfile = Ext.ModelManager.create({}, 'xcp.data.model.UserProfileModel');
    },

    /**
     * Initialize current logged in user's profile
     * @param callback  Function to call after user profile is loaded.
     */
    initProfile: function(callback, scope) {
        var UserProfile = Ext.ModelManager.getModel('xcp.data.model.UserProfileModel');
        var me = this;
        UserProfile.load(null, {
            success: function(record, operation) {
                me._userProfile = record;
                me._createCurrentRoleStore();
                me._autoAssignDefaultRole();
                if (callback) {
                    callback.call(scope);
                }
            },
            failure: function(record, operation) {
                if (callback) {
                    callback.call(scope);
                }
            }
        });
    },

    /**
     * Get current user's role
     */
    getRole: function() {
        return this._userProfile.get('role');
    },

    /**
     * Set current user's role
     * @param role     Preferred role
     */
    setRole: function(role) {
        this._userProfile.set('role', role);  // $NON-NLS-1$
        this._save();
    },

    /**
     * Get current user's preferred theme
     */
    getTheme: function() {
        return this._userProfile.get('theme');
    },

    /**
     * Set current user's preferred theme
     * @param theme     Preferred theme
     */
    setTheme: function(theme) {
        this._userProfile.set('theme', theme);  // $NON-NLS-1$ 
        this._save();
    },

    /**
     * Save the changes.
     */
    _save: function() {
        var userProfileCopy = this._userProfile.copy();
        this._userProfile.phantom = false;
        this._userProfile.save({
            scope: this,
            success: function() {
                // Ext.Data.Model.save() wipes out the data if the service returns nothing for PUT.
                // Workaround: Set the data back to the local copy if update is sucessful.
                this._userProfile.set(userProfileCopy.data);
            }
        })
    },

    /**
     * Assign the default role for the current user if his role is never set before. The selected
     * role will be the first role that current user has in the alphabetical order.
     */
    _autoAssignDefaultRole: function() {
        //no role set in the user preference
        if (Ext.isEmpty(this.getRole())){
            if (Ext.isArray(xcp.currentUser.userRoles) && xcp.currentUser.userRoles.length > 0
                    && !Ext.isEmpty(xcp.currentUser.userRoles[0].value)){
                this.setRole(xcp.currentUser.userRoles[0].value);
            }
        }
        else {
            var i = 0, isRealRole = false;
            for (i = 0; !Ext.isEmpty(xcp.currentUser.userRoles)&& i < xcp.currentUser.userRoles.length; i++) {
                if (xcp.currentUser.userRoles[i].value == this.getRole()) {
                    isRealRole = true;
                    break;
                }
            }

            //the current user is no longer a member of the role in the user preference, but he has other roles
            if (!Ext.isEmpty(xcp.currentUser.userRoles) && !isRealRole){
                this.setRole(xcp.currentUser.userRoles[0].value);
            }
            else if (!isRealRole) {
                //the current user is no longer a member of the role in the user preference and he does not have any other roles
                this.setRole("");
            }
        }

        if (xcp.currentUser) {
            // Update the user context with the valid role information
            xcp.currentUser.currentUserRole = this.getRole();
            if (xcp.currentUser.currentUserRole == "") {
                xcp.currentUser.currentUserRoleLabel = "";
            } else {
                var roleStore = Ext.data.StoreManager.lookup("xcp.picklist.RoleStore");
                if (roleStore) {
                    var roleData = roleStore.getById(xcp.currentUser.currentUserRole);
                    if (roleData) {
                        xcp.currentUser.currentUserRoleLabel = roleData.get("label");
                    }
                }
            }
        }
    },

    /**
     * Create a user role store for the current user based on the userRoleNames in the userInfo.
     */
    _createCurrentRoleStore: function() {
        if (Ext.isArray(xcp.currentUser.userRoles) && xcp.currentUser.userRoles.length > 0){
            Ext.create('Ext.data.Store', {
                storeId: 'xcp.picklist.RoleStore',
                data: xcp.currentUser.userRoles,
                model: 'xcp.picklist.models.StringModel'
            });
        }
    }
});


/* xcp_theme_lib/content/xcp/core/CSSManager.js */

// xcp/CSSManager.js
/**
 * Copyright (c) 2011 EMC Corporation. All Rights Reserved.
 *
 * This class is responsible for loading and unloading css dynamically
 */

Ext.define("xcp.core.CSSManager", {

    singleton: true,

    constructor: function() {
        //private
        this._loadedCSS = {};
        this._loadedTheme = null;
    },
    /**
     * Load styleSheets
     * @param cssFiles - list of css file url
     */
    loadStyleSheets: function(cssFiles, callback, scope) {
        for (var i = 0, len = cssFiles.length; i < len; i++) {
            var id = this._makeId(cssFiles[i]);
            if (typeof(this._loadedCSS[id]) == 'undefined') {
                //css has not been loaded
                this.loadStyleSheet(cssFiles[i], id, false, callback, scope);
                this._loadedCSS[id] = {enabled : true};
            }
            else if (!this._loadedCSS[id].enabled) {
                //css loaded but not enabled
                var css = document.getElementById(id);
                css.disabled = false;
                this._loadedCSS[id] = {enabled : true};
            }
        }
    },

    /**
     * Unload styleSheets
     * @param cssFiles - list of css file url
     */
    unloadStyleSheets: function(cssFiles) {
        for (var i = 0, len = cssFiles.length; i < len; i++) {
            var id = this._makeId(cssFiles[i]);
            var cssObj = this._loadedCSS[id];
            if (cssObj && cssObj.enabled) {
                //disable css
                var cssEl = document.getElementById(id);
                if (cssEl) {
                    cssEl.disabled = true;
                    cssObj.enabled = false;
                } else {
                    //link element not found
                    delete this._loadedCSS[id];
                }
            }
        }
    },

    /**
     * Create an id based on the path
     * @param path
     */
    _makeId : function (path) {
        var f = path.replace(/\//g, "_");
        f = f.replace(/-/g, "_");
        f = f.replace(/\./g, "_");
        return f.toLowerCase();
    },

    /**
     * Load stylesheet.
     */
    loadStyleSheet : function(path, id, disabled, fn, scope) {
        var head = document.getElementsByTagName('head')[0], // reference to document.head for appending/ removing link nodes
                link = document.createElement('link');           // create the link node
        link.setAttribute('href', path);
        link.setAttribute('rel', 'stylesheet');
        link.setAttribute('type', 'text/css');
        if (id)
            link.setAttribute("id", id);
        if (disabled)
            link.setAttribute("disabled", true);

        var sheet, cssRules;
        // get the correct properties to check for depending on the browser
        if ('sheet' in link) {  // $NON-NLS-1$
            sheet = 'sheet';  // $NON-NLS-1$
            cssRules = 'cssRules';
        }
        else {
            sheet = 'styleSheet';
            cssRules = 'rules';  // $NON-NLS-1$
        }

        head.appendChild(link);  // insert the link node into the DOM and start loading the style sheet

        if (!fn) {
            return;
        }

        var timeout_id = setInterval(function() {                     // start checking whether the style sheet has successfully loaded
            try {
                if (link[sheet] && link[sheet][cssRules].length) { // SUCCESS! our style sheet has loaded
                    clearInterval(timeout_id);                      // clear the counters
                    clearTimeout(timeout_id);
                    timeout_id = null;
                    fn.call(scope || window, true, link);           // fire the callback with success == true
                }
            } catch(e) {
            } finally {
            }
        }, 10);

         // how often to check if the stylesheet is loaded
        setTimeout(function() {       // start counting down till fail
            if (timeout_id) {
                clearInterval(timeout_id);             // clear the counters
                clearTimeout(timeout_id);
                fn.call(scope || window, false, link); // fire the callback with success == false
            }
        }, 200);


        return link; // return the link node;
    }

});


/* xcp_theme_lib/content/xcp/core/Theme.js */

/*
 * Copyright (c) 2011 EMC Corporation. All Rights Reserved.
 */
(function(){
    Ext.define("xcp.core.Theme",  {
        constructor: function(config) {
            Ext.applyIf(config, {isDefaultTheme: false, isCustomTheme: false, isAccessibilityTheme: false});
            this.config = config;
        },

        getName : function(){
            return this.config.name;
        },

        isDefaultTheme : function(){
            return this.config.isDefaultTheme;
        },

        isCustomTheme: function() {
             return this.config.isCustomTheme;
        },

        isAccessibilityTheme : function(){
            return this.config.isAccessibilityTheme;
        },

        getStyleSheets : function() {
            var cssFile = this.config.cssFile || this.config.name;
            if (cssFile) {
                if (cssFile.match(/.scss$/)) {
                    cssFile = cssFile.replace(/.scss$/, ".css");
                } else if (!cssFile.match(/.css$/)) {
                    cssFile = cssFile + ".css";
                }
            }
            return cssFile;
        }
    });
})();




/* xcp_theme_lib/content/xcp/core/ThemeManager.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.core.ThemeManager",  {

    singleton: true,

    requires: ["xcp.core.Theme", "xcp.core.CSSManager"],

    constructor: function() {
        /**
         * Private
         */
        //list of all the supported themes
        this._supportedThemes = new Array();
        //default theme, configured from design time
        this._defaultTheme = null;
        //default theme, configured from design time
        this._customTheme = null;
        //path to css
        this._cssPath = '';
        this.NULL_THEME = new xcp.core.Theme({name: 'NULL'});

        this._currentTheme = this.NULL_THEME;
    },


    /**
     * Return default theme
     */
    getDefaultTheme: function() {
        return this._defaultTheme;
    },

    /**
     * Return the current theme
     */
    getCurrentTheme: function() {
        return this._currentTheme;
    },

    /**
     * Set current theme for the application.
     * It does not load the stylesheets. To load stylesheets, see @loadTheme
     * @param theme
     */
    setCurrentTheme: function(theme) {
        this._currentTheme = theme;
    },

    /**
     * Return the list of all the supported themes in the application
     */
    getSupportedThemes: function() {
        return this._supportedThemes;
    },

    /**
     * Load the theme and the styleSheets
     * @param theme
     */
    loadTheme: function(theme, callback, scope){
        var curTheme = this.getCurrentTheme();
        if (curTheme.getName() != theme.getName()) {
            if (curTheme != this.NULL_THEME) {
                xcp.core.CSSManager.unloadStyleSheets(this.buildCSSPath(curTheme.getStyleSheets()));
            }
            this.setCurrentTheme(theme);
            xcp.core.CSSManager.loadStyleSheets(this.buildCSSPath(theme.getStyleSheets()), callback, scope);
        }
    },

    /**
     * Load the theme preferred by current logged in user.
     * If user has no preferred theme, load the default theme.
     * @param callback
     */
    loadPreferredTheme: function(callback, scope) {
        var themeName = xcp.core.UserProfile.getTheme();
        var theme = null;
        if (themeName) {
            for (var i = 0; i < this._supportedThemes.length; i++) {
                if (this._supportedThemes[i].getName() == themeName) {
                    theme = this._supportedThemes[i];
                    break;
                }
            }
        }
        if (theme) {
            this.loadTheme(theme, callback, scope);
        }
    },

    loadCustomTheme: function(callback, scope) {
        if (this._customTheme) {
            xcp.core.CSSManager.loadStyleSheets(this.buildCSSPath(this._customTheme.getStyleSheets()), callback, scope);
        } else if (callback) {
            callback.call(scope || window, false);
        }
    },

    /**
     * Load application's default theme
     */
    loadDefaultTheme : function(callback, scope){
        if (this._defaultTheme) {
            this.loadTheme(this._defaultTheme, callback, scope)
        }
    },

    /**
     * Load application's accessibility theme
     */
    loadAccessibilityTheme: function(callback, scope){
        if (this._accessibilityTheme) {
            this.loadTheme(this._accessibilityTheme, callback, scope)
        }
    },

    /**
     * Initialize all the available themes
     */
    initThemes: function(){
        this._currentTheme = this.NULL_THEME;
        this._cssPath = xcp.theme.path;
        if (Ext.isArray(xcp.theme.supportedThemes)) {
            Ext.each(xcp.theme.supportedThemes, function(themeCfg){
                var theme = new xcp.core.Theme(themeCfg);
                if (theme.isDefaultTheme()) {
                    this._defaultTheme = theme;
                } else if(theme.isCustomTheme()) {
                    this._customTheme = theme;
                } else if (theme.isAccessibilityTheme()) {
                    this._accessibilityTheme = theme;
                }
                this._supportedThemes.push(theme);
            }, this);
        }
    },

    buildCSSPath: function(css){
        var cssPathPrefix = this._cssPathPrefix;
        if (!cssPathPrefix) {
            cssPathPrefix = this._cssPathPrefix = "resources/" + xcp.appContext.version + "/";
        }
        var retPaths = new Array();
        if (Ext.isArray(css)) {
            Ext.each(css, function(item){
                retPaths.push(cssPathPrefix + this._cssPath + item);
            }, this);
        } else {
            retPaths.push(cssPathPrefix + this._cssPath + css);
        }
        return retPaths;
    }

});

/* xcp_data_lib/content/xcp/data/proxy/PagingMemoryProxy.js */

Ext.ns('Ext.ux.data');
/**
 * @class Ext.ux.data.PagingMemoryProxy
 * @extends Ext.data.proxy.Memory
 * <p>Paging Memory Proxy, allows to use paging grid with in memory dataset</p>
 */
Ext.define('Ext.ux.data.PagingMemoryProxy', {
    extend: 'Ext.data.proxy.Memory',
    alias: 'proxy.pagingmemory',
    read : function(operation, callback, scope){
        var reader = this.getReader(),
            result = reader.read(this.data),
            sorters, filters, sorterFn, records;

        // filtering
        filters = operation.filters;
        if (filters.length > 0) {
            //at this point we have an array of  Ext.util.Filter objects to filter with,
            //so here we construct a function that combines these filters by ANDing them together
            records = [];

            Ext.each(result.records, function(record) {
                var isMatch = true,
                    length = filters.length,
                    i;

                for (i = 0; i < length; i++) {
                    var filter = filters[i],
                        fn     = filter.filterFn,
                        scope  = filter.scope;

                    isMatch = isMatch && fn.call(scope, record);
                }
                if (isMatch) {
                    records.push(record);
                }
            }, this);

            result.records = records;
            result.total = records.length;
        }
        
        // sorting
        sorters = operation.sorters;
        if (sorters.length > 0) {
            //construct an amalgamated sorter function which combines all of the Sorters passed
            sorterFn = function(r1, r2) {
                var result = sorters[0].sort(r1, r2),
                    length = sorters.length,
                    i;
                
                    //if we have more than one sorter, OR any additional sorter functions together
                    for (i = 1; i < length; i++) {
                        result = result || sorters[i].sort.call(this, r1, r2);
                    }                
               
                return result;
            };
    
            result.records.sort(sorterFn);
        }
        
        // paging (use undefined cause start can also be 0 (thus false))
        if (operation.start !== undefined && operation.limit !== undefined) {
            result.records = result.records.slice(operation.start, operation.start + operation.limit);
        }

        Ext.apply(operation, {
            resultSet: result
        });
        
        operation.setCompleted();
        operation.setSuccessful();

        Ext.callback(callback, scope || me, [operation]);
    }
});

//backwards compat.
Ext.data.PagingMemoryProxy = Ext.ux.data.PagingMemoryProxy;

/* xcp_data_lib/content/xcp/data/proxy/RestProxy.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
// RestProxy.js

/**
 * Created by zhaoy.
 * User: zhaoy
 * Date: 4/21/11
 * Time: 10:15 AM
 * Override the buildUrl method to append the id in the proper position.
 */

Ext.define('xcp.data.proxy.RestProxy', {
    extend: 'Ext.data.proxy.Rest',
    alias: 'proxy.xcp_rest',

    constructor: function(config) {
        this.callParent([config]);
        if (!this.initExtraParams) {
            this.initExtraParams = this.extraParams;
        }
    },


    /**
     * Append the id to the proper position if appendId is true and url contains additional parameters.
     * @param {Ext.data.Request} request The request object
     */
    buildUrl: function(request) {
        var operation = request.operation,
            records   = operation.records || [],
            record    = records[0],
            url       = request.url || this.url,
            id        = record ? record.getId() : operation.id;
        if (url.indexOf("{id}") > -1) {  // $NON-NLS-1$ 
            this.appendId = false;
        }
        if (this.appendId && url.indexOf('?') != -1 && !url.match(/\/$/) && id != '') {
            //set appendId to false
            this.appendId = false;

            //ask parent to build url
            url = this.callParent(arguments);

            //then insert id to proper position
            url = url.replace('?', ('/' + id + '?'));

            //finally, set appendId back to true
            this.appendId = true;

            return url;

        } else {

            url = this.callParent(arguments);
            if (id) {
                if (url.indexOf("{id}") > -1) {  // $NON-NLS-1$ 
                    url = url.replace("{id}",id);  // $NON-NLS-1$ 
                }
            }
            return url;
        }
    },

    /**
     * Includes the detailed error message from response.
     * @private
     * @param {Ext.data.Operation} operation The operation
     * @param {Object} response The response
     */
    setException: function(operation, response) {
        this.callParent(arguments);
        Ext.apply(operation.getError(), {detailedMessage: response.responseText});
    },
    
    /**
     * Update extraParams based on the given data. Only the none empty value will
     * be added into extraParams.
     *
     * @param {Object} data model instance
     */
    updateExtraParams : function(data) {
        var newExtraParams = {},
            oldExtraParams = this.extraParams || {};

        //get non updateable properties from existing extraParams
        var nonUpdateable = {};
        for (var param in this.initExtraParams) {
            if (Ext.isEmpty(data[param]))
                nonUpdateable[param] = this.initExtraParams[param];
        }

        Ext.apply(newExtraParams, nonUpdateable, oldExtraParams);

        for (var name in data) {
            //filter out the boolean value "false" since based on the BRB "false" will not be
            //sent to the server
            if (!Ext.isEmpty(data[name]) && data[name] !== false){
                //Add value into the extraParams if the value is boolean and equals to true
                // or the value is not boolean and not empty.
                newExtraParams[name] = data[name];
            } else if (!Ext.isEmpty(newExtraParams[name])) {
                //remove params if value is empty
                delete newExtraParams[name];
            }
        }

        this.extraParams = newExtraParams;
    }

});
/* xcp_data_lib/content/xcp/data/writer/RelationJsonWriter.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.data.writer.RelationJsonWriter",{
    extend:"Ext.data.writer.Json",
    alias:"writer.xcp_relation_writer",
    /**
     * Prepare json request object for relation ship 
     * @param request
     * @param data
     */
    writeRecords: function(request, data) {
        if (data && Ext.isArray(data)) {
            for (var i=0; i < data.length; i++) {
                delete data[i].id;
            }
        } else{
            delete data.id;
        }
        return this.callParent([request, data]);
    }
});
/* xcp_data_lib/content/xcp/data/writer/XCPJsonWriter.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// JsonWriter.js

Ext.namespace("xcp");

/**
 * @author Yuhui Zhao
 * @class xcp.data.JsonWriter
 * Overrides getRecordData() to support compound json format. The ExtJS default json writer only supports flat json format.
 * @extends Ext.data.writer.Json
 *
 * <p>Writer that outputs model data in JSON format</p>
 */
Ext.define('xcp.data.writer.xcpJson', {
    extend: 'Ext.data.writer.Json',
    alias: 'writer.xcpjson',

    /**
     * Formats the data into JSON for each record before sending it to the server.
     * @param {Object} record The record that we are writing to the server.
     * @return {Object} An structured JSON object to be written to the server.
     *
     */
    getRecordData: function(record) {
        var retVal = {};
        this.constructJson(retVal, this.root, record);
        return retVal;
    },

    /**
     * Gets the data in json format for given instance
     * @param data json data
     * @param root root defined in proxy
     * @param instance instance
     */
    constructJson: function(data, root, instance) {
        var path, mapping, name;
        //iterate all fields
        for (var i = 0; i < instance.fields.items.length; i++) {
            name = instance.fields.items[i].name;
            // do not write fields which have not been set
            if (instance.get(name) === undefined) {
                continue;
            }

            mapping = instance.fields.items[i].mapping;
            //construct full path
            path = ((root && root != '') ? (root + ".") : '') + ((mapping) ? mapping : name);

            this.getCompoundJsonData(data, path, instance.get(name));
        }
    },

    /**
     * Get model instance data in structured JSON format.
     *
     * @param parent parent object
     * @param path   path
     * @param value  value
     */
    getCompoundJsonData : function(parent, path, value) {
        var key, paths;
        if (path) {
            paths = path.split('.');
            key = paths[0];
            if (paths.length == 1) {
                //value is an array
                if (Ext.isArray(value)) {
                    parent[key] = new Array();
                    for (var i=0; i < value.length; i++) {
                        if (typeof value[i].isModel != 'undefined') {
                            // associated model instance
                            var newNode = {};
                            this.constructJson(newNode, key, value[i]);
                            parent[key].push(newNode);
                        } else {
                            // other type of value
                            parent[key].push(value[i]);
                        }
                    }
                } else if (!Ext.isEmpty(value) && !Ext.isEmpty(value.isModel)){
                    // associated model instance
                    this.constructJson(parent, key, value);
                } else {
                    // other type of value
                    parent[key] = value;
                }

            } else {

                if (typeof parent[key] === 'undefined') {
                    parent[key] = {};
                }

                //continue to get json data for the path one level lower
                this.getCompoundJsonData(parent[key], path.substring(path.indexOf('.')+1), value);

            }
        }
    }

});



/* xcp_data_lib/content/xcp/data/reader/XCPJsonReader.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// XCPJsonReader.js

/**
 * Created by lakhas.
 * User: lakhas
 * Date: 7/7/11
 * Time: 10:15 AM
 * Override the readRecords method to look for servics which return total = "null"
 */

Ext.define('xcp.data.reader.xcpJson', {
    extend: 'Ext.data.reader.Json',
    alias : 'reader.xcpjson',

    /**
     * Most of the work is done for us by JsonReader, but we need to overwrite this method to check if our service
     * send in "null" result as total to distinguish unknown or infinate totals.
     */
    readRecords: function(data) {
        var me  = this;

        /*
         * We check here whether the number of fields has changed since the last read.
         * This works around an issue when a Model is used for both a Tree and another
         * source, because the tree decorates the model with extra fields and it causes
         * issues because the readers aren't notified.
         */
        if (me.fieldCount !== me.getFields().length) {
            me.buildExtractors(true);
        }

        /**
         * The raw data object that was last passed to readRecords. Stored for further processing if needed
         * @property rawData
         * @type Mixed
         */
        me.rawData = data;

        data = me.getData(data);

        // If we pass an array as the data, we dont use getRoot on the data.
        // Instead the root equals to the data.
        var root    = Ext.isArray(data) ? data : me.getRoot(data),
            success = true,
            recordCount = 0,
            totalCount = 0,
            total, value, records, message;

        if (root) {
            total = root.length;
        }

        if (me.totalProperty) {
            value = parseInt(me.getTotal(data), 10);
            if (!isNaN(value)) {
                total = value;
            }
        }

        if (me.successProperty) {
            value = me.getSuccess(data);
            if (value === false || value === 'false') {
                success = false;
            }
        }

        if (me.messageProperty) {
            message = me.getMessage(data);
        }

        if (root) {
            records = me.extractData(root);
            recordCount = records.length;
        } else {
            recordCount = 0;
            records = [];
        }
        /*
            If Service doesn't return the total (Real Time Query) we consider it "null"
           If Service returns total, total is passed (Full Text Query)
        */
         if (!data.total)
            totalCount = "null"; // removing this hack should also removing the code "Ext.grid.PagingScroller.override" in this file.
        else
            totalCount = total || recordCount;

        return Ext.create('Ext.data.ResultSet', {
            total  : totalCount,
            count  : recordCount,
            records: records,
            success: success,
            message: message
        });
    }

});

/**
 * due to totalCount = "null" hack in the above code, getScrollHeight from the extjs base class will return NAN. IE8 doesn't like a NaN to be set to the height.
 */
Ext.grid.PagingScroller.override({
    getScrollHeight: function() {
        var ret = this.callOverridden();
        if (!Ext.isNumber(ret)) {
            ret = 0;
        }
        return ret;
    }
});
/* xcp_data_lib/content/xcp/data/proxy/FolderProxy.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.reader.Folder", {
    extend: "xcp.data.reader.xcpJson",
    alias: "reader.xcp_folder",
    readRecords: function(data) {
        if (data.id && !data.items)
            data = {items: [data], total: 1};

        return this.callParent([data]);
    }
});

// This is the proxy for accessing folder contents via the application content services

Ext.define("xcp.proxy.FolderProxy",
{
    extend: "Ext.data.proxy.Rest",
    alias: "proxy.xcp_rest_folder",
    reader: {
        "type": "xcp_folder",
        "root": "items"
    },

    constructor: function(config) {
        this.callParent(arguments);
        this.reader.proxy = this;
        this.reader.model  = this.model;
        this.useContents(false);
    },

    // override the method used by the store to build the URL that invokes the
    // RESTful service.
    getUrl: function(request) {
        var url, id;
        if (request.params)
            id = request.params.id || request.params.node;
        if (!id)
            id = xcp.navigationManager.currentNavigationContext.objectId;
        this.objectId = id;  // save to make available to grid
        if ((id != 'root') && (id != null)) {
            if ((id.indexOf('0b') == 0) || (id.indexOf('0c') == 0)) {
                url = this.url + "/" + id;
                if (this._bUseContents) {
                    //url += "/contents";
                    url = "application/sysobject/?type=folderQuery&sort=object_name&folder_id=" + id;
                }
                if(this._showOnlyFolders) {
                    url = "application/foldersonly/?type=folderOnlyQuery&sort=object_name&folder_id=" + id;
                }
            }
            else {
                url = "application/dm_documents/" + id;
            }
        }
        else { //the root node is requested
            url = request.url || this.api[request.action] || "application/sysobject/?type=cabinetQuery&sort=object_name";
        }
        return url;
    },

    useContents: function(state) {
        this._bUseContents = state;
    },

    // Used to show only folders in content tree
    showOnlyFolders: function(state) {
        this._showOnlyFolders = state;
    }
});


/* xcp_data_lib/content/xcp/data/model/Model.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * The xcp.data.Model class is design to support hierarchical data. The model field can be of type model.
 */
Ext.define("xcp.data.Model", {
    "extend" : "Ext.data.Model",
    /**
     * Override to handle the definition of model type fields.
     * @param cls
     * @param data
     */
    onClassExtended: function(cls, data) {
        var fields = data.fields || [];
        var resolvedFields = [];
        //Process model type fields
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            if (field.type) {
                var types = Ext.data.Types;
                if (Ext.isString(field.type)) {
                    var extType = types[field.type.toUpperCase()];
                    if (!extType) {
                        field.modelName = field.type;
                        field.type = Ext.data.Types.AUTO;
                        // fix the default for an array, we tried changing the array definition but no luck.
                    } else if (field.type == "array") {
                    	field.defaultValue = [];
                    }
                }
            }
            
            
            resolvedFields.push(field);
        }
        data.fields = resolvedFields;
    },
    /**
     * Constructor
     * @param data
     * @param id
     */
    constructor: function(data, id, raw, convertedData) {
        var tempData = raw || data;
        if (!tempData) {
            tempData = {};
        }
        data = data || {};
        raw= raw || {};
        this.nestModelInstances = {};
        var fields = this.fields;


        for (var prop in tempData) {
            var field = fields.getByKey(prop);
            if (field && this.isNestedModelField(field)) {
                var name = field.name;
                var childRaw = raw[name] || undefined;
                var childData = (tempData) ? tempData[name] : undefined

                //May be we need to find out the idProperty of child model
                var childConvertedData = convertedData ? convertedData[name] : undefined;
                var instance = this.initNestedModel(field, childData, childRaw, childConvertedData);
                if (instance) {
                    if (data) {
                        if (!Ext.isArray(data)){
                            data[name] = instance.data;
                        }
                    }
                    if (raw) {
                        if (!Ext.isArray(raw)) {
                            raw[name] = instance.data;
                        }
                    }
                }
            }
        }
        this.callParent(arguments);


    },
    /**
     * @private
     * Add the nested model to the list.
     * @param name
     * @param instance
     */
    addNestedModelInstance: function(name, instance) {
        this.nestModelInstances[name] = instance;
    },
    removeNestedModelInstance: function(name) {
        if (this.nestModelInstances[name] !== undefined && this.nestModelInstances[name] !== null) {
            delete this.nestModelInstances[name]
        }

    },
    /**
     * Returns the instance of the nested model field
     * @param name
     * @param autoCreate : true creates a nested model instance,
     */
    getNestedModelInstance: function(name, autoCreate) {
        var props = name.split(".");
        if (autoCreate === undefined || autoCreate === null) {
            autoCreate = true;
        }
        var parent=this;
        var modelInstance = null;
        for (var i=0; i < props.length; i++) {
            modelInstance = parent.nestModelInstances[props[i]];
            if (!modelInstance) {
                if (autoCreate) {
                    var field = parent.getField(props[i], false);
                    if (parent.isNestedModelField(field)) {
                        modelInstance = parent.initNestedModel(field, {});
                    }
                }
                if (!modelInstance) {
                    return null;
                }
            }
            parent = modelInstance;
        }
        return modelInstance;
    },
    /**
     * @private
     * Initialize nested model instance
     * @param field: The nested model field
     * @param data: Initialization data
     * @param raw: Raw data
     * @param convertedData: converted data
     */
    initNestedModel: function(field, data, raw, convertedData) {
        var modelName = field.modelName;
        //Check if it is a valid model
        var modelClass = Ext.ModelManager.getModel(modelName);
        var instance = null;
        if (modelClass && Ext.isFunction(modelClass)) {
            field.idProperty = modelClass.prototype.idProperty;
            //May be we need to find out the idProperty of child model
            var childIdProp = modelClass.prototype.idProperty;
            //In case of relation the id is not a separate property
            if (Ext.isString(data)) {
                var temp = data;
                data = {};
                data[childIdProp] = temp;
            }
            if (Ext.isString(raw)) {
                var temp = raw;
                raw = {};
                raw[childIdProp] = temp;
            }

            var orgData = (raw) ? raw : (data) ? data : {};
            var modelData = xcp.util.Utils.deepCopy(orgData, {});

            var childId = orgData && childIdProp ? orgData[childIdProp] : undefined;

            instance = new modelClass(modelData, childId, raw, convertedData);

            //Remove the id property if it is not defined
            //Clear fields which are created by default
            if (instance.data) {
                for (var prop in instance.data) {
                    if (orgData[prop] === undefined || orgData[prop] === null) {
                        delete instance.data[prop];
                    }
                }
            }
            instance.updateLoadMarker();

            this.addNestedModelInstance(field.name, instance);

            //No need to register the nested model instances
            Ext.ModelManager.unregister(instance);
        }
        return instance;

    },
    isNestedModelField: function(field) {
        if (Ext.isString(field)) {
            field = this.getField(field);
        }
        if (field.modelName) {
            return true;
        }
        return false;
    },
    /**
     * Return whether the model can be loaded dynamically
     * The model can be loaded dynamically if it has id and links attributes in the data
     * @param data
     */
    canLoadModel : function() {
        var proxy = this.proxy;
        if (proxy ) {
            if (proxy.url) {
                return true;
            }
        }
        return false;
    },
    updateLoadMarker: function() {
        var loaded = false;
        var data = this.data;
        if (!this.canLoadModel())  {
            loaded=true;
        } else {
            var idProperty = this.idProperty;
            var count = 0;
            for(var prop in data) {
                if(data.hasOwnProperty(prop) && !(prop === idProperty || prop === "links")) {
                    loaded = true;
                    break;
                }
            }
        }
        this.loaded = loaded;

    },
    /**
     * Return whether the moadel is already loaded completely.
     * If the data contails attributes other than id and links, then it is considered as loaded.
     * @param data
     */
    isDataLoaded : function() {
        return this.loaded;
    },
    /**
     * Return the current value of the model field. The nested model field name is qualified by the parent
     * model field name using dot notation.
     * Example
     * package0.customer.state
     * @param fieldName
     */
    get: function(fieldName) {
        if (this.isValidField(fieldName, false)) {
            return this[this.persistenceProperty][fieldName];
        }
        else if (this.isValidField(fieldName, true)) {
            //Get the first level nested model field name
            var props = fieldName.split(".");
            var modelFieldName = props.shift();
            //Get the field and model instance associated with the field
            var instance = this.getNestedModelInstance(modelFieldName);
            if (instance) {
                var nestedFieldName = props.join(".");
                return instance.get(nestedFieldName);
            }
        }
        return undefined;
    },
    /**
     * A field object for the given field, can recursively search for the field in nested model.
     * @param fieldName
     * @param recursive: If true search for field in nested model.
     */
    getField : function(fieldName, recursive) {
        if (recursive === undefined || recursive === null) {
            recursive = true;
        }
        var fields = this.fields;
        var field = undefined;
        if (fieldName && Ext.isString(fieldName)) {
            if (!recursive) {
                return fields.getByKey(fieldName);
            }

            var props = fieldName.split(".");
            field=fields;
            var modelInstance=this;
            for (var i=0, len=props.length; i < len; ++i) {
                field=undefined;
                if (fields) {
                    field = fields.getByKey(props[i]);
                }
                if (!field)
                    break;
                if (field.modelName) {
                    if (modelInstance) {
                        modelInstance = modelInstance.getNestedModelInstance(props[i]);
                    }
                    if (modelInstance) {
                        fields = modelInstance ? modelInstance.fields : undefined;
                    } else {
                        var modelClass = Ext.ModelManager.getModel(field.modelName);
                        if (modelClass) {
                            fields = modelClass.prototype.fields;
                        }
                    }
                }
            }
            return field;
        }
    },
    /**
     * Check if the given field name is defined in this model.
     * @param fieldName
     * @param recursive : If true check for validity of field recursively.
     */
    isValidField: function(fieldName, recursive) {
        return this.getField(fieldName, recursive) ? true : false;
    },
    hasIdProperty: function() {
        return this.getField(this.idProperty, false) !== undefined;
    },

    /**
     * Clears the empty id property of the nested model. When nested model is not used
     * having an id set to "" creates an issue during submitting the composite model
     * data.
     * @param nestedModel: Nested model instance.
     */
    clearEmptyId: function () {
        var nestedModel = this;
        if (nestedModel.data) {
            var idValue = nestedModel.data[nestedModel.idProperty];
            if (idValue !== undefined && idValue !== null && idValue.length == 0) {
                delete nestedModel.data[nestedModel.idProperty];
            }
        }

   },
    /**
     * Set the model field value. Can set the value of the nested model fields.
     * @param fieldName
     * @param value
     */
    set :function(fieldName, value) {
        var me = this,
            fields = me.fields,
            modified = me.modified,
            convertFields = [],
            field, key, i, currentValue;

        if (fieldName && Ext.isString(fieldName)) {
            field = me.getField(fieldName, false);
            if (!field) {
                var props = fieldName.split(".");
                if (props.length > 1) {
                    //Get first nesting model field
                    var firstFieldName = props.shift();
                    field = me.getField(firstFieldName, false);
                    //Invalid field;
                    if (!field) {
                        return;
                    }
                    //Check if the model field is initialized
                    var instance = this.getNestedModelInstance(firstFieldName);

                    if (field && instance) {
                        currentValue = me.get(field.name);
                        if (currentValue === undefined || currentValue===null) {
                            //Initialize model field
                            currentValue = instance.data;
                            me.data[field.name] = currentValue;
                        }
                        //Set value of the first nested field, which will set values for further nested field
                        var subFieldName = props.join(".");
                        instance.set(subFieldName, value);
                        //Mark the model as dirty
                        me.dirty = true;
                        var updatedValue = instance.data;
						me.data[field.name] = updatedValue;
                        if (field.persist && !me.isEqual(currentValue, updatedValue)) {
                            me.modified[field.name] = currentValue;
                        }
                        return;
                    }
                }
            } else if (field && field.modelName) {   // Set multiple properties of model objecting
                if (value === undefined || value === null) {
                    //Clear nested model instance
                    this.removeNestedModelInstance(fieldName);
                    updatedValue = value;
                } else {
                    var instance = this.getNestedModelInstance(fieldName);
                    //Invalid data
                    if (!instance) {
                        return;
                    }
                    instance.set(value);
                    instance.updateLoadMarker();
                    updatedValue = instance.data;
                }
                currentValue = me.get(field.name);
                //Mark the model as dirty
                me.dirty = true;
                me.data[field.name] = updatedValue;
                if (field.persist && !me.isEqual(currentValue, updatedValue)) {
                    me.modified[field.name] = currentValue;
                }
                return;
            }
        }
        this.callParent(arguments);
    },
    useParentId: function(){
        return false
    }
});

/* xcp_data_lib/content/xcp/data/model/IdLessModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.data.IdLessModel",
    {
      "extend" : "xcp.data.Model",
      "hasIdProperty": function(){
            return false
       }
    }
);

/* xcp_data_lib/content/xcp/data/model/BaseRelationModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.data.BaseRelationModel",
    {
      "extend" : "xcp.data.Model",
      useParentId: function(){
            return true
       }
    }
);


/* xcp_data_lib/content/xcp/data/model/MetaDataAwareModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.data.MetaDataAwareModel", {
    "extend" : "xcp.data.Model",

    constructor: function(orgModel) {
        this.orgModel = orgModel;
        this.reqAttributes=[];
    },
    get: function(fieldName) {
       // Populate the object with missing attributes for expressions used in Context Menu actions
        // or if missing metadata is already loaded, return the value
       var value = this.orgModel.data[fieldName];
       if (value === undefined || value === null) {
            Ext.Array.include(this.reqAttributes, fieldName)
           return null;
       }
       return value;
    }
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.core.FormatManager");

Ext.apply(xcp.Strings.core.FormatManager, {
    invalidFormatter:           "Invalid formatter type '{0}'"
});
/* xcp_formatter_lib/content/xcp/core/FormatManager.js */

/**
 * @class xcp.core.FormatManager
 * <p>The FormatManager class is responsible for managing registered formatter and creating the formatter instance.
 * </p>
 * @singleton
 */
Ext.define("xcp.core.FormatManager", {
    statics : {
        /**
         * Creates a new formatter from the specified config object using the config object's xtype to determine the class to instantiate.
         * @param formatConfig : A configuration object for the Plugin you wish to create.
         */
        create : function(formatConfig) {
            //Lookup the format registry.
            var zlass = Ext.ClassManager.getByAlias("formatter."+formatConfig.xtype);
            if (zlass) {
                //Found the formatter, create a instance of it.
                return new zlass(formatConfig);

            } else {
                //TODO show error notification
                console.error(Ext.String.format(xcp.Strings.core.FormatManager.invalidFormatter, formatConfig.xtype));
            }
            //Return a base formatter object.
            return new xcp.formatter.BaseFormatter(formatConfig);

        }
    }
})


/* xcp_formatter_lib/content/xcp/formatter/BaseFormatter.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
// BaseFormatter.js

/**
 * @class xcp.formatter.BaseFormatter
 * @extends Object
 * A Abstract Formatter class, all formatter should extend this base class (or one of its sub-class).
 *
 */
Ext.define("xcp.formatter.BaseFormatter", {
    extend:"Object",
    /**
     * Return the formatted value.
     * @param value
     */
    format: function(value) {
        return value;
    },
    /**
     * Return the applicable css class for the formatted value, if no css class is applicable then return null.
     * @param value
     */
    getCls : function(value) {
        return null;
    }
});

/* xcp_type_lib/content/xcp/core/TypeManager.js */

// TypeManager.js

/**
 * @class xcp.core.TypeManager
 * <p>The TypeManager class fetches and holds information about all business object, document, and folder types.
 * </p>
 * @singleton
 */

(function() {

// private trace function
function logIt(s){
    console.debug("TM: "+s);
}

Ext.define("xcp.core.TypeManager",
{
    singleton: true,
    namespace: undefined,
    typesReg : undefined,

    initTypeManager: function(callback, scope)
    {
        var url = xcp.util.Utils.buildResourceUrl("ui/types", true);
        Ext.Ajax.request(
        {
            url: url,
            async: true,
            scope: this,
            disableCaching: false,
            success: function(response, options)
            {
                logIt("Got types");  // $NON-NLS-1$ 
                var responseText = response.responseText;
                this.typesReg = Ext.JSON.decode(responseText);
                if (callback)
                    callback.call(scope);
            },
            failure: function(response, options)
            {
                this.typesReg = {};
                xcp.Logger.log("Failed to load type info");
                if (callback)
                    callback.call(scope);
            }
        });

        if (xcp && xcp.appContext && xcp.appContext.namespace)
            this.namespace = xcp.appContext.namespace;
    },

    getTypeLabel: function(modelName)
    {
        var info = this.typesReg[modelName];
        return (info) ? info.label : modelName;
    }
});

})();

/* xcp_pagecontext_lib/content/xcp/core/PageContextManager.js */

// PageContextManager.js

/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

(function () {

// private trace function
    function logIt(s) {
        xcp.Logger.debug("PageContextManager: " + s);
    }

    //Page Context
    Ext.define("xcp.core.PageContext", {
        constructor:function (id, page) {
            logIt("Creating Page Context with ObjectId " + id);
            this.pageObjectID = id;
            this.page = page;
            this.xcpIdBasedComponentCache = {};
            this.modelNameBasedComponentCache = {};
            this.xTypeBasedComponentCache = {};
        },

        getObjectId:function () {
            return this.pageObjectID;
        },
        getPage: function() {
            return this.page;
        },
        getComponentByXCPId: function(xcpIdOrName) {
            if (this.xcpIdBasedComponentCache && this.xcpIdBasedComponentCache[xcpIdOrName]) {
                logIt("Found component with xcpId in page context cache : " + xcpIdOrName);
                return this.xcpIdBasedComponentCache[xcpIdOrName];
            } else {
                logIt("Could not find component with xcpId in page context cache : " + xcpIdOrName);
                var component = xcp.util.Utils.queryComponentByXCPIdOrName(this.page, xcpIdOrName);
                if (component && this.xcpIdBasedComponentCache ) {
                    this.xcpIdBasedComponentCache[xcpIdOrName] = component;
                }
                return component;
            }
        },
        getComponentByModelName: function(modelNameOrAlias) {
            if (this.modelNameBasedComponentCache && this.modelNameBasedComponentCache[modelNameOrAlias]) {
                logIt("Found component with model name in page context cache : " + modelNameOrAlias);
                return this.modelNameBasedComponentCache[modelNameOrAlias];
            } else {
                logIt("Could not find component with model name in page context cache : " + modelNameOrAlias);
                var component = xcp.util.Utils.queryComponentByModelName(this.page, modelNameOrAlias);
                if (component && this.modelNameBasedComponentCache ) {
                    this.modelNameBasedComponentCache[modelNameOrAlias] = component;
                }
                return component;
            }
        },
        getComponentByXType: function(xtype) {
            if (this.xTypeBasedComponentCache && this.xTypeBasedComponentCache[xtype]) {
                logIt("Found component with xtype in page context cache : " + xtype);
                return this.xTypeBasedComponentCache[xtype];
            } else {
                logIt("Could not find component with xtype in page context cache : " + xtype);
                var component = xcp.util.Utils.queryComponentByXType(this.page, xtype);
                if (component && this.xTypeBasedComponentCache ) {
                    this.xTypeBasedComponentCache[xtype] = component;
                }
                return component;
            }
        },
        isInsideWizard: function() {
            if (Ext.isEmpty(this.insideWizard)) {
                var wizard = this.page.up("xcp_wizard");
                this.insideWizard = wizard ? true: false;
                logIt("Setting insideWizard flag to" +this.insideWizard +" on page Context on page : "+this.page.Id);
            }
            return this.insideWizard;
        },

        cleanUp: function() {
            this.page = undefined;
            this.pageObjectId = undefined;
            this.xcpIdBasedComponentCache = undefined;
            this.modelNameBasedComponentCache = undefined;
            this.xTypeBasedComponentCache = undefined;
            this.insideWizard = undefined;
        }
    });
    Ext.define("xcp.core.PageContextManager", {
        singleton:true,

        /**
         * Initializes Page Context for each xCP Widget/Component
         */
        constructor:function () {
            this.pageContextMap = new Ext.util.HashMap();
        },

        remove:function (pageCtxID) {
            var pageContext = this.get(pageCtxID);
            if (pageContext) {
                pageContext.cleanUp();
            }
            this.pageContextMap.removeAtKey(pageCtxID);
        },

        register:function (objID, page) {
            if (objID == "root")
                objID = null;
            var pageCtxID = Ext.Date.now();
            this.pageContextMap.add(pageCtxID, new xcp.core.PageContext(objID, page));
            return pageCtxID;
        },

        get:function (key) {
            return this.pageContextMap.get(key);
        }
    });
})();


/* xcp_bootstrap/content/xcp/Empty.js */


/* xcp_button_menu_onhover/content/xcp/plugin/ButtonMenuOnHover.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */


Ext.define('xcp.plugin.ButtonMenuOnHover', {
    extend: 'Ext.AbstractPlugin',
    alias: 'plugin.xcp_button_menu_onhover',

    constructor : function() {
        var me = this;
        /**
         * Holds the button instance.
         */
        me.button = null;
        /**
         * Menu show delay.
         */
        me.showDelay = 200;
        /**
         * Menu hide delay.
         */
        me.hideDelay = 200;
        /**
         * Document events are used for tracking mouse over open menu state.
         */
        me.doc = Ext.getDoc();
        me.callParent(arguments);
    },

    /**
     * plugin initialization.
     * @param btn parent component
     */
    init : function(btn) {
        // show menu when we mouse over the menu trigger
        btn.on("mouseover", this.showMenu, this);
    },

    /**
     * True if menu on hover is enabled in the parent component.
     */
    isOnHoverEnabled: function() {
        var getNumber = function(num, deflt) {
            return Ext.isNumber(num) ? num : deflt
        }
        return function() {
            var me = this;
            if (me.onHoverEnabled === undefined) {
                var btn = me.getCmp(),
                    cfgKey = "xcp_menu_onhover",
                    conf, tbar;

                me.onHoverEnabled = false;

                // determine init config - it can be here or a parent toolbar
                if (btn.initialConfig && Ext.isDefined(btn.initialConfig[cfgKey])) {
                    conf = btn.initialConfig[cfgKey];
                }
                else if ((tbar = btn.up("toolbar")) && tbar.initialConfig &&  Ext.isDefined(tbar.initialConfig[cfgKey])) {
                    conf = tbar.initialConfig[cfgKey];
                }

                if (conf) {
                    if (Ext.isObject(conf)) {
                        me.showDelay = getNumber(conf["showDelay"], me.showDelay);
                        me.hideDelay = getNumber(conf["hideDelay"], me.hideDelay);
                    }
                    else {
                        conf = btn.initialConfig;
                        me.showDelay = getNumber(conf["xcp_menu_onhover_showDelay"], me.showDelay);
                        me.hideDelay = getNumber(conf["xcp_menu_onhover_hideDelay"], me.hideDelay);
                    }
                    me.onHoverEnabled = true;
                }
            }
            return me.onHoverEnabled;
        }
    }(),

    /**
     * Starts show menu procedure with a delay.
     */
    showMenu : function() {
        var me = this,
            btn = me.getCmp();
        if (!me.isOnHoverEnabled()) {
            return;
        }
        clearTimeout(me.hideTimer);
        delete me.hideTimer;
        if (btn.menu && !btn.menu.isVisible() && !me.showTimer) {
            me.showTimer = Ext.Function.defer(me.showMenuDefer, me.showDelay, me);
        }
    },

    /**
     * Implements show menu procedure.
     */
    showMenuDefer : function() {
        var me = this,
            btn = me.getCmp();
        delete me.showTimer;
        btn.showMenu();

        if (!me.mouseover) {
            btn.menu.on("mouseover", me.onMouseOverMenu, me);
            me.mouseover = true;
        }
    },

    /**
     * Starts hide menu procedure with a delay.
     */
    hideMenu : function() {
        var me = this,
            btn = me.getCmp();
        clearTimeout(me.showTimer);
        delete me.showTimer;
        if (!me.hideTimer && btn.menu && btn.menu.isVisible()) {
            me.hideTimer = Ext.Function.defer(me.hideMenuDefer, me.hideDelay, me);
        }
    },

    /**
     * Implements hide menu procedure.
     */
    hideMenuDefer : function() {
        this.getCmp().hideMenu();
    },

    /**
     * Triggers start of monitoring the whole dom for mouseover events.
     * @param t target
     * @param e event
     */
    onMouseOverMenu : function(t, item, e) {
        var me = this,
            btn = me.getCmp();
        if (!btn.disabled) {
            var internal = e.within(btn.menu.el, true);
            if (!internal) {
                if (!me.monitoringMouseOver) {
                    me.doc.on("mouseover", me.monitorMouseOver, me);
                    me.monitoringMouseOver = true;
                }
            }
        }
    },

    /**
     * Monitors mouse movement. Triggers menu hide when appropriate.
     * @param e event
     */
    monitorMouseOver : function(e) {
        var me = this,
            btn = me.getCmp();
        if (e.target != btn.menu.el.dom && !me.withinMenu(btn.menu, e)) {
            if (me.monitoringMouseOver) {
                me.doc.un("mouseover", me.monitorMouseOver, me);
                me.monitoringMouseOver = false;
            }
            me.hideMenu();
        }
    },

    /**
     * Checks if an event occured within a menu or child menu region.
     * @param m menu component
     * @param e event
     */
    withinMenu : function(m, e) {
        if (m.el && m.el.getRegion().contains(e.getPoint())) {
            return true;
        }
        if (m.activeItem && m.activeItem.menu && m.activeItem.parentMenu && m === m.activeItem.parentMenu) {
            return this.withinMenu(m.activeItem.menu, e);
        }
        return false;
    }
});
/* xcp_component_lib/content/xcp/core/ComponentConfig.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * A Configuration object to store required meta data info for component. The component config object is capable of
 * loading the component content.
 */
Ext.define("xcp.core.ComponentConfig", {
    extend:"Object",

    /**
     * Constructor
     */
    constructor : function() {
        this.id = null;
        this.loaded = false;
        this.bundle = null;
        this.dependencies = [];
        this.failLoad = false;
        this.loading = false;
    },
    /**
     * Load the component content
     * @param resolveDependencyAtClient : True resolve componenet dependency
     * @param synchronous : True - load componenet content synchronously.
     * @param callBack : Callback function
     * @param scope - Callback scope
     */
    load : function(resolveDependencyAtClient, synchronous, callBack, scope) {
        if (!(this.loading || this.loaded) && !this.failLoad) {
            if (resolveDependencyAtClient) {
                var dependencies = this.dependencies;
                if (dependencies) {
                    for (var i = 0; i < dependencies.length; i++) {
                        var dependencyComp = xcp.core.ComponentManager.getComponentConfig(dependencies[i].componentId);
                        if (dependencyComp && !dependencyComp.loaded) {
                            //Don't need to pass callback to dependency load
                            dependencyComp.load(resolveDependencyAtClient, synchronous);
                        } else if (!dependencyComp) {
                            xcp.Logger.warn("For component [" + this.id + " ] - invalid dependency component id specified : " + dependencies[i]);
                        }
                    }
                }
            }
            var successCallBack = this.onLoad;
            if (callBack) {
                successCallBack = function() {
                    this.onLoad();
                    if (!scope) {
                        scope = new Object();
                    }
                    callBack.call(scope);
                };
            }
            this.loading = true;
            if (!synchronous) {
                synchronous = false;
            }
            var componentURL = this.getComponentUrl(false);
            Ext.Loader.loadScriptFile(componentURL, successCallBack, this.onError, this, synchronous);
        } else if (this.failLoad) {
            xcp.Logger.error("Ignore loading of component as the load was failed previously : " + this.id);
        } else {
            if (callBack) {
                if (!scope) {
                    scope = new Object();
                }
                callBack.call(scope);
            }
        }
    },
    /**
     * Get a component content load URL.
     * @param resolveDependencyAtServer
     */
    getComponentUrl : function(resolveDependencyAtServer) {
        return xcp.util.Utils.buildComponentUrl("js", this, resolveDependencyAtServer);
    },
    /**
     * Success handler for component content load 
     * @param applyToDependencyComp
     */
    onLoad : function(applyToDependencyComp) {
        xcp.Logger.debug("Loaded the component["+this.id+"] successfully");
        this.loaded = true;
        this.loading = false;
        if (applyToDependencyComp) {
            var dependencies = this.dependencies;
            if (dependencies) {
                for (var i = 0; i < dependencies.length; i++) {
                    var dependencyComp = xcp.core.ComponentManager.getComponentConfig(dependencies[i]);
                    if (dependencyComp) {
                        dependencyComp.onLoad(true);
                    }
                }
            }
        }
    },
    /**
     * Error handler for component content load
     * @param error
     */
    onError : function(error) {
        this.failLoad = true;
        xcp.Logger.error("Error loading component[" + this.id + "] : " + error);
    }
});

/* xcp_component_lib/content/xcp/core/ComponentManager.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * A manager responsible for loading & mananging component config. The component manager support two mode
 * for loading the components, namely
 * development : Load all components individually during application startup.
 * ondemand : Load xcp bootstrap (as specified in xcp_bootstrap library definition) components during
 * application startup, and there after load components and require components just in time.
 */
Ext.define("xcp.core.ComponentManager", {
    extend:'Ext.util.Observable',
    singleton:true,
    componenetsList : new Object(),
    /**
     * Initialize Component Manager.
     * @param componentLoadMode
     * @param callback
     * @param scope
     */
    init : function(componentLoadMode, callback, scope) {
        //Go and get the component definition
        Ext.Ajax.request({
            url:  "component/definitions.json",
            async: false,
            scope: this,
            success: function(response, options) {
                xcp.Logger.debug("Loaded component defintion configuration");
                var object = Ext.JSON.decode(response.responseText);
                var definitions = object.definitions;

                if (definitions) {
                    var resolvedComponentIdList = new Array();
                    for (var i = 0; i < definitions.length; i++) {
                        var def = definitions[i];
                        var comp = new xcp.core.ComponentConfig();
                        comp.id = def.id;
                        comp.bundle = def.bundle;
                        if (def.dependencies) {
                            var dependencyList = def.dependencies.dependency;
                            for (var j = 0; j < dependencyList.length; j++) {
                                comp.dependencies[comp.dependencies.length] = dependencyList[j];
                            }
                        }
                        resolvedComponentIdList[resolvedComponentIdList.length] = def.id;
                        this.componenetsList[def.id] = comp;
                    }
                    //Do not reload the already loaded components
                    this.componenetsList["xcp_startup"].onLoad(true);
                    if (componentLoadMode == 'development') {  // $NON-NLS-1$ 
                        var cmp = null;
                        var cmpId = null;

                        for (var j = 0; j < resolvedComponentIdList.length; j++) {

                            cmp = this.componenetsList[resolvedComponentIdList[j]];
                            if (cmp instanceof xcp.core.ComponentConfig) {
                                if (j == resolvedComponentIdList.length - 1) {
                                    cmp.load(false, false, callback, scope);
                                } else {
                                    cmp.load(false, false);
                                }

                            }
                        }
                    } else {
                        var _getNameByAlias = function(alias) {
                            if (alias && alias.length != 0) {
                                var comp = xcp.core.ComponentManager.getComponentConfig(alias);
                                if (!comp) {
                                    if (alias.indexOf(".") != -1) {
                                        comp = xcp.core.ComponentManager.getComponentConfig(alias.substring(alias.indexOf(".") + 1));
                                    }
                                }
                                if (comp) {
                                    comp.load(true, true);
                                }
                            }
                            return this._getNameByAlias(alias);
                        };
                        //Ext.Loader.disableCaching=false;
                        Ext.ClassManager._getNameByAlias = Ext.ClassManager.getNameByAlias;
                        Ext.ClassManager.getNameByAlias = _getNameByAlias;
                        var bootstrapComp = this.getComponentConfig("xcp_bootstrap");
                        if (bootstrapComp) {
                            bootstrapComp.load(true, false, callback, scope);
                        }
                        else {
                             xcp.Logger.error("Could not find the xcp_bootstrap component def");
                        }
                    }
                }
            },
            failure: function(response, options) {
                // todo:  change this to follow standard app service error pattern once that's defined
                 xcp.Logger.error("Error during component defintions loading, cannot complete application initializtion", response);
            }

        });
    },
    /**
     * Get component config object
     * @param id : component Id
     */
    getComponentConfig: function(id) {
        if (id && id.length > 0) {
            return this.componenetsList[id];
        } else {
            return null;
        }
    },
    /**
     * Error handler
     */
    onError : function() {
    }
});
/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.dialog.CreateFolder");

Ext.apply(xcp.Strings.dialog.CreateFolder, {
    dialogTitle: "New Folder",
    dialogTitleSingleType: "New {0}",
    submitBtnText: "Finish",
    cancelBtnText: "Cancel",
    folderTypeLabel: "Folder Type",
    selectTypeMsg: "Select a folder type ...",
    createFolderSucceededMsg: "Successfully created folder",
    createFolderFailedMsg: "Failed to create folder"
});

/* xcp_create_folder/content/xcp/dialog/CreateFolder.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.dialog.CreateFolder
 * @extends Ext.window.Window
 * Dialog for create folder action
 * @xtype xcp_create_folder
 */

(function() {

var testSingleType = false;

//////////////////////////////////////////////////////////////////////////////////////////////////////
//  CreateFolder dialog implementation
//
//  This dialog consists of a panel with a type selector and an action step panel beneath it
//
//  When a folder type is selected from the type selector, the associated create action flow
//  step page is displayed, allowing the user to specify metadata for the folder to be created.
//////////////////////////////////////////////////////////////////////////////////////////////////////
Ext.define("xcp.dialog.CreateFolder",
{
    extend: 'Ext.window.Window',
    alias: 'xcp_create_folder',
    plain: true,
    mixins: {
         feedbackContainer: 'xcp.util.mixin.FeedbackContainer'
     },
     includeFeedbackTypes: ['validationErrors'],

    statics:
    {
        //  Cache of actionStepConfigs indexed by createaction names:  the action step config for
        //  an create action is requested from the server just once during the browser session.
        actionStepConfigCache: {},

        //  Reference to localized strings used by this class
        uistrings: xcp.Strings.dialog.CreateFolder
    },

    constructor: function(config)
    {
        config = config || {};
        Ext.applyIf(config,
        {
            frame: false,
            frameHeader: false,
            modal: true
        });

        var statics = this.statics();
        this.actionStepConfigCache = statics.actionStepConfigCache;
        this.uistrings = statics.uistrings;

        this.callParent(arguments);
    },

    initComponent: function()
    {
        var typeData = this.getTypeData();
        if (testSingleType)
            typeData = [typeData[0]];

        if (typeData && typeData.length == 1)
            this.initialType = typeData[0].value;

        //  Initialize store for type selector
        this.typeStore = Ext.create('Ext.data.Store',
        {
            model: 'xcp.dialog.CreateFolder.typeModel',
            data: typeData
        });

        var title = this.uistrings.dialogTitle;
        if (this.initialType)
            title = Ext.String.format(this.uistrings.dialogTitleSingleType, typeData[0].label);

        Ext.applyIf(this,
        {
            title: title,
            height: 450,
            width: 700,
            resizable: true
        });

        this.refs =
        {
            actionFlowPanelId: Ext.id(undefined, 'panel-'),
            createBtnId: Ext.id(undefined, 'button-'),
            typeSelectorId: Ext.id(undefined, 'combo-')
        };

        //  Define config for dialog buttons
        var dialogButtons = [
        {
            text: this.uistrings.submitBtnText,
            listeners: {click: {fn: this.submit, scope: this}},
            id: this.refs.createBtnId,
            disabled: true
        },
        {
            text: this.uistrings.cancelBtnText,
            listeners: {click: {fn: this.close, scope: this}}
        }];

        var typeSelectorConfig =
        {
            xtype: 'combo',
            id: this.refs.typeSelectorId,
            fieldLabel: '<span class="label">' + this.uistrings.folderTypeLabel + '</span>',
            name: 'type',
            editable: false,
            emptyText: this.uistrings.selectTypeMsg,
            valueNotFoundText: this.uistrings.selectTypeMsg,
            store: this.typeStore,
            queryMode: 'local',
            displayField: 'label',
            readOnly: (this.initialType && this.initialType.length > 0),
            valueField: 'value',
            value: this.initialType,
            anchor: '100%',
            grow: true,
            listeners:
            {
                select: {fn: this.onTypeSelection, scope: this},
                change: {fn: this.onTypeSelectorValueChanged, scope: this},
                //afterrender: {fn: this.onTypeSelectorAfterRender, scope: this},
                focus: {fn: this.onTypeSelectorFocus, scope: this},
                collapse: {fn: this.onTypeSelectorCollapse, scope: this},
                expand: {fn: this.onTypeSelectorExpand, scope: this}
            }
        };

        //  Define items for folder info panel
        var typeSelectorPanel =
        {
            //  Form panel with type selector combo field
            xtype: 'form',
            cls: 'create-folder-typeselector-panel',
            submitEmptyText: false,
            region: 'north',
            height: 40,
            items: [typeSelectorConfig]
        };

        var actionFlowPanel =
        {
            //  Container for action flow step page
            xtype: 'xcp_page',
            id: this.refs.actionFlowPanelId,
            autoScroll: true,
            region: 'center',
            items: [],
            cls: 'action-flow-panel'
        };

        //  Define dialog items
        var dialogItems = [
        {
            xtype: 'panel',
            region: 'center',
            cls: 'center',
            layout: 'border',
            items: [typeSelectorPanel, actionFlowPanel],
            listeners: {afterrender: {fn: this.onAfterRender, scope: this}}
        }];

        //  Define dialog
        Ext.apply(this,
        {
            cls: 'xcp-create-folder-dialog',
            iconCls: 'create-folder-icon',
            bodyCls: 'body',
            layout: {type: "vbox", align:"stretch"},
             buttons: dialogButtons,
             items: [{
                 xtype:'container',
                 layout: 'border',
                 flex: 1,
                 items: dialogItems
             }],
            //After render, display the action flow panel for only one folder subtype.
            listeners:{afterrender: {fn: this.onTypeSelectorAfterRender, scope: this}}
        });

        this.callParent(arguments);
    },

    getTypeInfo: function(modelName)
    {
        var typeValue = modelName;
        var typeLabel = xcp.core.TypeManager.getTypeLabel(typeValue);
        return {typeValue: typeValue, typeLabel: typeLabel};
    },

    //  Get type data from ActionManager to be used to initialize type selector combo.
    //  Returns an array of type objects, each object consisting of a typeName, typeValue, and actionId
    //  If allowedTypeValues is defined, the returned array is filtered accordingly.
    getTypeData: function()
    {
        var typeData = [];
        var allowedTypeValues = this.allowedTypeValues;

        var userActionsDefReg = xcp.core.ActionManager.userActionsDefReg;
        for (var model in userActionsDefReg)
        {
            var typeRecord = userActionsDefReg[model];
            //  Find the create folder action flow for this type
            for (var actionId in typeRecord)
            {
                var actionFlowRecord = typeRecord[actionId];
                if (actionFlowRecord.flowDef['action-type'] == 'Create')  // $NON-NLS-L$
                {
                    var typeInfo = this.getTypeInfo(model);
                    // XCPECM-697 encode type string so HTML characters don't mess up the dropdown
                    var typeLabel = Ext.String.htmlEncode(typeInfo.typeLabel);
                    typeData.push({label: typeLabel, value: typeInfo.typeValue, actionId: actionId});
                    break;
                }
            }
        }

        if (!allowedTypeValues)
            return this.sortTypeData(typeData);

        var allowedTypeData = [];
        for (var i = 0; i < typeData.length; i++)
        {
            for (var j = 0; j < allowedTypeValues.length; j++)
            {
                var typeDatum = typeData[i];
                if (typeDatum.value == allowedTypeValues[j])
                {
                    allowedTypeData.push(typeDatum);
                    break;
                }
            }
        }
        return this.sortTypeData(allowedTypeData);
    },

    sortTypeData: function (types)
    {
        types.sort(function(a, b)
        {
            var label1 = a.label.toLocaleLowerCase();
            var label2 = b.label.toLocaleLowerCase();
            return label1.localeCompare(label2);
        });
        return types;
    },

    onAfterRender: function()
    {
        //  Initialize component references from associated ids
        for (var name in this.refs)
        {
            var refname = name.substr(0,name.length-2);
            this[refname] = Ext.getCmp(this.refs[name]);
        }
    },

    //Decode the value on selection made
    onTypeSelection: function(field) {
        var decodedRawValue = Ext.String.htmlDecode(field.getRawValue());
        field.setRawValue(decodedRawValue);
    },

    //  Handler for type selector value changes
    onTypeSelectorValueChanged: function(field, newValue, oldValue, opts)
    {
        //  Work around ext-4.0.0 problem
        if (newValue == null && oldValue != null)
            return;

        this.updateCreateActionFlowStepPage(newValue);

        //  Work around ext-4.0.0 problem
        //var extVersion = Ext.getVersion();
        //if (extVersion.major == 4 && extVersion.minor == 0 && extVersion.patch == 0)
        //    field.setValue(newValue);
    },

    //  Handler for type selector collapse event
    onTypeSelectorCollapse: function(field, opts)
    {
        var value = field.getRawValue();
        if (!value || value.length == 0)
            field.setRawValue(this.uistrings.selectTypeMsg);
    },

    //  Handler for type selector expand event
    onTypeSelectorExpand: function(field, opts)
    {
        var value = field.getRawValue();
        if (!value || value.length == 0)
            field.setRawValue(this.uistrings.selectTypeMsg);
    },

    //  Handler for type selector focus event
    onTypeSelectorFocus: function(field, opts)
    {
        if (!this.initialType)
        {
            var value = field.getRawValue();
            if (!value || value.length == 0)
                field.setRawValue(this.uistrings.selectTypeMsg);
        }
    },


   // As soon as rendering window,shows the action flow panel if only one folder action flow created.
    onTypeSelectorAfterRender: function()
    {
        if (this.initialType)
            this.updateCreateActionFlowStepPage(this.initialType);
    },

    findTypeRecord : function(prop, value) {
           var record;
           if ( this.typeStore.getCount() > 0) {
                this.typeStore.each(function(r) {
                   if (r.data[prop] == value) {
                       record = r;
                       return false;
                   }
               });
           }
           return record;
    },

    updateCreateActionFlowStepPage: function(newType)
    {
        //  Get action step config according to create action associated with newType
        var typeRecord = this.findTypeRecord('value', newType);
        if (!typeRecord) {
            console.log('Unable to find type record from type store: ' + newType);
            return;
        }
        var actionId = typeRecord.get('actionId');
        if (!actionId) {
            console.log('Unable to get the create folder action flow id for type: ' + newType);
            return;
        }

        function renderCreateActionFlowStepPage(stepConfig,newType)
        {
            if (!this.actionStepConfigCache[actionId])
                this.actionStepConfigCache[actionId] = stepConfig;

            //Root folders do not have
            if(newType == 'dm_folder')
               stepConfig.loadModel = false;
            else
               stepConfig.loadModel = true;

            var xcpPage = this.actionFlowPanel;

            //  Avoid unnecessary doLayout done by xcpPage.replaceChild
            var rendered = xcpPage.ownerCt.rendered;
            xcpPage.ownerCt.rendered = false;

            //  Update action step container by removing any previous child component and adding a new one
            //  specified by stepConfig.  The new child component is an instance of xcp_form.
            xcpPage.replaceChild(stepConfig);
            xcpPage.ownerCt.rendered = rendered;

            var formPanel = xcpPage.getComponent(0);

            /* We are going to fix the model to only include the attributes that are on the step page. Attributes
            * in the model and not on the page are not going to be submitted to allow the expression associated with
            * those attributes to run.
            * */
            var inputAttributesNames = getInputAttributesFromPage(formPanel.getForm());
            inputAttributesNames = Ext.Array.merge(inputAttributesNames, [ 'content_id', 'folder_id' ]);

            var modelName = stepConfig.models[0];
            var actionRecord = Ext.create(modelName,
            {
                folder_id: this.targetFolderId || '',
                object_name: (this.actionRecord ? this.actionRecord.get('object_name') : '')
            });

            /* Remove the attributes that are not included on the step page. */
            var fieldsToRemove = [];
            for (var i=0; i < actionRecord.fields.getCount(); i++) {
                var field = actionRecord.fields.getAt(i);
                if (!Ext.Array.contains(inputAttributesNames, field.name))
                    fieldsToRemove.push(field);
            }

            if (fieldsToRemove.length > 0){
                actionRecord.fields.removeAll(fieldsToRemove);
            }

           /* make sure the repeating attributes are initialized to Array */
            var repeatingAttributeNames = getRepeatingAttributesFromPage(stepConfig);
            if (actionRecord.data) {
                for (var attributeName in actionRecord.data) {
                    if (actionRecord.data[attributeName ] === "") {
                        if (Ext.Array.contains(repeatingAttributeNames,attributeName)) {
                            actionRecord.data[attributeName] = [];
                        }
                    }
                }
            }

            this.actionRecord = actionRecord;

            var form = formPanel.getForm();
            form.loadRecord(actionRecord);
            formPanel.doLayout();

            var thisDialog = this;

            // Set up event handling so that changing the value of a form field automatically updates actionRecord.
            // Do this by mimicing xcp.widget.form.Form._registerToFieldChangeEvent.
            form.getFields().each(function(f)
            {
                if (f.isFormField)
                {
                    f.on("change", function(field, newValue, oldValue, options)
                    {
                        thisDialog.onChangeFieldValue(this, field, newValue, oldValue, options);
                    }, actionRecord);
                }
            }, formPanel);

            function getRepeatingAttributesFromPage(object){
                var repeatingAttributes = [];

                function isRepeatingAttribute(item){
                    if (item && item.xtype && item.xtype.indexOf("xcp_multivalue")!=-1){
                        return true;
                    }
                    return false;
                }

                if (object){
                    if (isRepeatingAttribute(object)){
                       repeatingAttributes.push(object.xcpId);
                    }

                    if (object.items){
                        for (var i=0;i<object.items.length;i++){
                            if (object.items[i])
                                repeatingAttributes = repeatingAttributes.concat(getRepeatingAttributesFromPage(object.items[i]));
                        }
                    }
                }

                return repeatingAttributes;
            }

            function getInputAttributesFromPage(form){
                var inputAttributesNames = [];
                form.getFields().each(function(field) {
                    if (field.isFormField)
                        inputAttributesNames.push(field.name);
                });
                return inputAttributesNames;
            }

        }

        //  Get action step config according to create action associated with newType
        var stepConfig = this.actionStepConfigCache[actionId];
        if (!stepConfig)
        {
            // Get stepConfig from server
            var actionDefConfig = xcp.core.ActionManager.getUserActionDefConfig(newType, actionId);
            if(!actionDefConfig) {
                console.log('Unable to get the create folder action flow config for: '+actionId);
                return;
            }
            var stepUrl = actionDefConfig.flowDef['view-state'][0].pageUrl;  //  this.flow.getCurrentViewPageUrl();
            xcp.widget.window.Wizard.getStepJson(stepUrl, renderCreateActionFlowStepPage, this);
            return;
        }

        // Use stepConfig from cache
        renderCreateActionFlowStepPage.call(this,stepConfig,newType);
    },

    onChangeFieldValue: function(actionRecord, field, newValue, oldValue, options)
    {
        /* Do not convert the empty array to a string.*/
        if (Ext.isArray(oldValue) && newValue===""){
            newValue=[];
        }

        actionRecord.set(field.name, newValue);
        if (field.xcpId != 'object_name')
            return;

        if (newValue && newValue.length > 0)
        {
            if (this.createBtn.isDisabled())
                this.createBtn.enable();
        }
        else
        {
            this.createBtn.disable();
        }
    },

    onSubmitSuccess: function()
    {
        var targetFolderId = this.targetFolderId;

        //  Close dialog
        this.close();

        //  Notify user
        var msg = this.uistrings.createFolderSucceededMsg;
        if (xcp && xcp.core && xcp.core.FeedbackManager)
            xcp.core.FeedbackManager.showFeedback(null, '', msg, "notifications", false);

        //  Refresh target folder grid to show created folder
        if (xcp && xcp.event && xcp.event.EventBus && targetFolderId && targetFolderId.length > 0)
            xcp.event.EventBus.publish(xcp.event.ContainerChangedEvent.CONTAINER_CHANGED_EVENT, targetFolderId);
            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, targetFolderId);
    },

    submit: function()
    {
        function onActionRecordSaved(savedRecord, operation)
        {
            if (operation.success)
                Ext.Function.defer(this.onSubmitSuccess, 500, this);
            else
                console.log('Create folder failed');
        }
        this.actionRecord.save({callback: onActionRecordSaved, scope: this, feedbackContainer: this})
    }
});

//////////////////////////////////////////////////////////////////////////////////////////////////////
//  Model for type selector
//////////////////////////////////////////////////////////////////////////////////////////////////////
Ext.define('xcp.dialog.CreateFolder.typeModel',
{
    extend: 'Ext.data.Model',
    fields:
    [
        {name: 'label', type: 'string'},   // e.g. 'Acme Folder'
        {name: 'value', type: 'string'},   // e.g. 'app_acme_folder'
        {name: 'actionId', type: 'string'} // e.g. 'create_acme_folder'
    ]
});

})();

/* xcp_dropdown_mixin/content/xcp/util/mixin/DropdownMixin.js */

/**
 * Mixin to provide our special drop down functionality
 */
Ext.define("xcp.util.mixin.DropdownMixin", {
    /**
     * Expression support
     **/
    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {
            return newValue;
        }
    }],

    statics : {
        /**
         * Returns the label of the selected option.
         * @param context
         * @param compId
         */
        getLabel : function(context, compId) {
            var comp = context.getComponent(compId);
            var value = "";
            if (!comp) {
                xcp.Logger.warn("Could not find the component with id : " + compId);
            } else {
                //Drop down store the displayfield as a raw value;
                value =  comp.getRawValue();
            }
            return xcp.core.expr.BaseExpression.checkValue(value);
        }
    },

    constructor : function(config) {
        config = config || {};

        // XCPUIC-801:  Make sure there is a valid store, so that a misconfiguration doesn't prevent a page from showing
        var configuredStore = config.store;
        if(!config.valueField){
            config.valueField = "value";
        }
        if(!config.displayField){
            config.displayField = "label";  // $NON-NLS-1$ 
        }

        var isValidStore = false;
        if (configuredStore) {
            var store = Ext.data.StoreManager.lookup(configuredStore);
            if (store) {
                if (Ext.isString(configuredStore) && (configuredStore.indexOf("xcp.picklist.") == 0)) {
                    isValidStore = true;

                    // Create a new store which copies the data in the default picklist store.  Don't reuse the existing
                    // picklist store since keypress filtering can be messed up if multiple instances referencing the
                    // same store are on the same page (XCPUIC-1906).  In the case of picklists, there's no reason to
                    // actually share the same store
                    var data = [];
                    var modelCount = store.getCount();
                    for (var i = 0; i < modelCount; i++) {
                        var modelInstance = store.getAt(i);
                        data[i] = modelInstance;
                    }
                    var storeConfig = { autoLoad: true, model: store.model.getName(), data: data };
                    config.store = Ext.create("Ext.data.Store", storeConfig);
                    this.isPicklist = true;
                } else {
                    // If we're here, we're dealing with a data source
                    isValidStore = true;
                    store.pageSize = 1000;
                    config.store = store;
                    // XCPUIC-3422:  If the data store isn't loaded yet, the call to the parent version of setValue will do a
                    // comparison against an empty store.  Since we have the forceSelection flag set, this will cause
                    // the value to be thrown out as it doesn't match any existing value.  We add a handler for the load
                    // event so that we can give the widget the previously saved initialization value.
                    store.on("load",
                        function (store, records, successful, eOpts) {
                            // Set a flag to indicate that the data source store has now been loaded so we don't save
                            // any more values for initialization
                            this.dataSourceStoreLoaded = true;

                            if (this.initialXcpValue) {
                                // We have a previously set initialization value, reapply that value by calling
                                // setValue now that we have a value store to compare against
                                this.setValue(this.initialXcpValue);

                                // Clear initial xcp value since it's already been used
                                delete this.initialXcpValue;
                            }
                        },
                        this,
                        {
                            scope: this,
                            single: true // Only run this initialization code for the first load of the store
                        }
                    );
                }
            }
        }
        if (!isValidStore) {
            config.store = Ext.create('Ext.data.Store', {
                model: 'xcp.picklist.models.StringModel',
                data: []
            })
        }

        xcp.widget.form.Form.encodeFieldLabel(config);

        Ext.apply(config, {
            queryMode: "local",
            forceSelection: true
        });
    },

    // Overriding assertValue based on http://www.sencha.com/forum/showthread.php?146473-ExtJS-4-Combo-Box-autocomplete-issues
    // So that users can choose to NOT set a picklist value after one has been previously selected.  (XCPUIC-1815)
    assertValue: function() {
        var me = this,
            value = me.getRawValue(),
            rec;

        if (!me.picker) {
            return;
        }

        if (me.forceSelection) {
            if (me.multiSelect) {
                // For multiselect, check that the current displayed value matches the current
                // selection, if it does not then revert to the most recent selection.
                if (value !== me.getDisplayValue()) {
                    me.setValue(me.lastSelection);
                }
            } else {
                // For single-select, match the displayed value to a record and select it,
                // if it does not match a record then revert to the most recent selection.
                rec = me.findRecordByDisplay(value);
                if (rec) {
                    me.select(rec);
                } else {
                    // !!! Start code modification !!!
                    // !!! Original code only has "me.setValue(me.lastSelection);" in this else block !!!

                    if (!value) {
                        me.setValue('');
                        me.select(value);

                        me.ignoreSelection++;
                        // Call clearSelections to force lastSelection of the selection model to be nullified
                        // If we don't, our "autoSelect" configuration will cause that value to be visible shown as
                        // selected which is a ton more confusing that the first item being selected.
                        me.picker.getSelectionModel().clearSelections();
                        me.ignoreSelection--;
                    } else {
                        me.setValue(me.lastSelection);
                    }
                    // !!! End code modification !!!
                }
            }
        }
        me.collapse();
    }
});

/* xcp_logger/content/xcp/Logger.js */

/**
 * @class xcp.Logger
 * @extends Ext.util.Observable
 * Logger API wraps the firebug lite console to provide dynamic logging enablement and abstraction
 */
if (!xcp.Logger) {
    Ext.define("xcp.Logger", {
        extend: "Ext.util.Observable",
        singleton: true,
        enablement: false,
        fireBugLoaded:false,
        constructor : function() {
            this.callParent(arguments);
            var loggingParam = window.location.search.indexOf("logging=true") != -1; 
            this.addEvents("enablelogging", "disablelogging");

            if(loggingParam) {
                this.enable();
            }

            var loggingKeyMap = new Ext.KeyMap(Ext.getDoc(), [{
                key: Ext.EventObject.X,
                alt: true,
                fn: function() {
                    if (xcp.Logger.enablement) {
                        xcp.Logger.fireEvent("disablelogging");
                    }
                    else {
                        if(loggingParam) {
                            xcp.Logger.fireEvent("enablelogging");
                        } else {
                            var loc = window.location;
                            var url = loc.protocol + "//" + loc.host + xcp.util.Utils.buildResourceUrl("/js/firebug-lite/dist/xcp-firebug-lite.js");
                            var scripts = document.getElementsByTagName('script');
                            for (var i = 0, len = scripts.length; i < len; i++) {
                                if (scripts[i].src === url) {
                                    break;
                                }
                            }
                            if (i < len) {
                                xcp.Logger.fireEvent("enablelogging");
                            } else {
                                Ext.Loader.injectScriptElement(url, function() {
                                    xcp.Logger.fireEvent("enablelogging");
                                });
                            }
                        }
                    }
                },
                stopEvent: true
            }]);

            window.enableLogging = function() {
                xcp.Logger.fireEvent("enablelogging");
            };
            window.disableLogging = function() {
                xcp.Logger.fireEvent("disablelogging");
            };
        },

        log : Ext.emptyFn,
        debug: Ext.emptyFn,
        info: Ext.emptyFn,
        warn: Ext.emptyFn,
        error: Ext.emptyFn,

        //private method
        /**
         * Adds timestamp, logging level and originating function
         */
        getLoggerPrefix : function(level, fnName) {
            var currentTime = new Date();
            var currentTimeStr = Ext.Date.format(currentTime, 'Y-m-d H:i:s.u T');
            var timestamp = "[" + currentTimeStr + " ]";
            return new Array(timestamp, level, fnName);
        },

        //private method
        /**
         * Calls the Firebug lite console API dynamically based on the invoked log function
         * @param arguments
         * @param logFunction
         * @param originatingFunction
         */
        callConsole : function(arguments, logFunction, originatingFunction)
        {
            var args = Array.prototype.slice.call(arguments);
            var prefix = this.getLoggerPrefix("[" + logFunction + "]", originatingFunction);
            args = prefix.concat(args);
            console[logFunction].apply(console, args);
        },

        /**
         * Enables logging. Will be called as part of the enablelogging event.
         * Assigns concrete functions to respective logging methods
         */
        enable : function() {
            this.enablement = true;
            this.log = function() {
                this.callConsole(arguments, "log", arguments.callee.caller);
            };
            this.debug = function() {
                this.callConsole(arguments, "debug", arguments.callee.caller);
            };
            this.info = function() {
                this.callConsole(arguments, "info", arguments.callee.caller);
            };
            this.warn = function() {
                this.callConsole(arguments, "warn", arguments.callee.caller);
            };
            this.error = function () {
                this.callConsole(arguments, "error", arguments.callee.caller);
            };
        },

        /**
         * Disables logging. Will be called as part of the disablelogging event.
         * Assigns empty functions to respective logging methods
         */
        disable : function() {
            this.enablement = false;
            this.log = Ext.emptyFn;
            this.debug = Ext.emptyFn;
            this.info = Ext.emptyFn;
            this.warn = Ext.emptyFn;
            this.error = Ext.emptyFn
        },
        initLogging : function() {
            xcp.Logger.on("enablelogging", function() {
                xcp.Logger.enable();
                xcp.Logger.log("Started logging...");
            });
            xcp.Logger.on("disablelogging", function() {
                xcp.Logger.log("Stopped logging...");
                xcp.Logger.disable();
            });
        },
        onError : function(error) {
            console.error("Could not load the firebug : " + error);
        }
    });
}
/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.facets.FacetManager");

Ext.apply(xcp.Strings.facets.FacetManager, {
    firstQuarterFormatString: "Q1 {0}",
    secondQuarterFormatString: "Q2 {0}",
    thirdQuarterFormatString: "Q3 {0}",
    fourthQuarterFormatString: "Q4 {0}"
});
/* xcp_facet_manager/content/xcp/facets/FacetManager.js */

/*
 * Copyright (c) 2012. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.facets.FacetManager", {
    singleton: true,
    /*requires: [
        "xcp.util.Utils",
        "xcp.Logger"
    ],*/
    /**
     * Loads facet related data
     * @param {Function} [callback] The callback function invoked after facet data has been initialized
     * @param {Object} [scope] The scope (<code>this</code> reference) in which the callback is executed.
     */
    initializeFacets: function(callback, scope) {
        var url = xcp.util.Utils.buildResourceUrl("ui/facets", true);
        Ext.Ajax.request({
            url: url,
            async: true,
            scope: true,
            disableCaching: false,
            success: function(response, options) {
                xcp.Logger.debug("Got facets data");
                var responseText = response.responseText;
                var data = Ext.JSON.decode(responseText);
                xcp.facets.FacetManager.localizationData = data;
                if (callback) {
                    callback.call(scope);
                }
            },
            failure: function(response, options) {
                xcp.Logger.log("Failed to load facets data");
                if (callback) {
                    callback.call(scope);
                }
            }
        });
    },
    /**
     * Returns facet label given the search id and facet id
     * @param {String} searchId id of the search
     * @param {String} facetId id of the facet
     * @return {String} facet label
     */
    getFacetLabel: function(searchId, facetId) {
        var label = facetId;

        // JSON Format:
        // {
        // 		searchName: {
        //			facetName:  {
        //				label: "${localized label key}"
        //				values: {
        //					valueId1: "${localized label key}"
        //					valueId2: "${localized label key}"
        //				}
        //				dateFrequency:  {number corresponding to Frequency value}
        //			}
        //		}
        // }
        if (this.localizationData) {
            var searchData = this.localizationData[searchId];
            if (searchData) {
                var facetData = searchData[facetId];
                label = facetData.label;
            }
        }

        return label;
    },
    /**
     * Returns facet label given the search id and facet id
     * @param {String} searchId id of the search
     * @param {String} facetId id of the facet
     * @param {String} value facet value
     * @return {String} facet value label
     */
    getFacetValueLabel: function(searchId, facetId, value) {
        var label = value;  // Initialize to the value, since there may not be a mapping defined

        // JSON Format:
        // {
        // 		searchName: {
        //			facetName:  {
        //				label: "${localized label key}"
        //				values: {
        //					valueId1: "${localized label key}"
        //					valueId2: "${localized label key}"
        //				}
        //				dateFrequency:  {number corresponding to Frequency value}
        //			}
        //		}
        // }
        if (this.localizationData) {
            var searchData = this.localizationData[searchId];
            if (searchData) {
                var facetData = searchData[facetId];
                if (facetData) {
                    if (facetData.values) {
                        var v = facetData.values[value];
                        if (v) {
                            label = v;
                        }
                    } else if (facetData.picklist) {
                        var picklistStore = Ext.data.StoreManager.lookup(facetData.picklist);
                        if (picklistStore) {
                            var index = picklistStore.find("value", value, 0, false, true, true);
                            if (index != -1) {
                                var record = picklistStore.getAt(index);
                                label = record.get("label");
                            }
                        }
                    } else if (Ext.isDefined(facetData.dateFrequency)) {
                        // Facet returns ISO 8601 date without timezone information, add "Z" to make it UTC time
                        // or else ExtJS will interpret the date using the local time zone
                        var dateValue = Ext.Date.parse(value + "Z", "c");
                        switch (facetData.dateFrequency) {
                            case 0:
                            {
                                // Day
                                label = Ext.Date.format(dateValue, xcp.Formats.dateFormats["long"]);
                                break;
                            }
                            case 1:
                            {
                                // Week
                                var endDate = Ext.Date.add(dateValue, Ext.Date.DAY, 6);
                                var shortFormat = xcp.Formats.dateFormats["short"];
                                label = Ext.Date.format(dateValue, shortFormat) + " - " + Ext.Date.format(endDate, shortFormat);
                                break;
                            }
                            case 2:
                            {
                                // Month
                                label = Ext.Date.format(dateValue, "F Y");  // $NON-NLS-1$ 
                                break;
                            }
                            case 3:
                            {
                                // Quarter
                                var month = dateValue.getMonth() + 1;
                                var year = dateValue.getFullYear();
                                switch (month) {
                                    case 1:
                                    {
                                        label = Ext.String.format(xcp.Strings.facets.FacetManager.firstQuarterFormatString, year);
                                        break;
                                    }
                                    case 4:
                                    {
                                        label = Ext.String.format(xcp.Strings.facets.FacetManager.secondQuarterFormatString, year);
                                        break;
                                    }
                                    case 7:
                                    {
                                        label = Ext.String.format(xcp.Strings.facets.FacetManager.thirdQuarterFormatString, year);
                                        break;
                                    }
                                    case 10:
                                    {
                                        label = Ext.String.format(xcp.Strings.facets.FacetManager.fourthQuarterFormatString, year);
                                        break;
                                    }
                                }
                                break;
                            }
                            case 4:
                            {
                                // Year
                                label = Ext.Date.format(dateValue, "Y");
                                break;
                            }
                        }
                    }
                }
            }
        }

        return label;
    }
});
/* xcp_fileupload_button/content/xcp/widget/button/FileUploadButton.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function() {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//  Form with File field that looks and behaves like a button.
//  Clicking this "button" on the ImportFile dialog causes the browser's file picker dialog
//  to appear.  Closing the latter causes the selected file (if any) to be uploaded to the
//  app server and the corresponding file record in the dialog to be updated with a content_id.
//  The content_id serves to locate the uploaded file on the app server when the import action
//  flow associated with the file is executed.
//////////////////////////////////////////////////////////////////////////////////////////////////////
Ext.define('xcp.widget.FileUploadButton',
{
    extend: 'Ext.form.Panel',
    alias: 'widget.xcp_fileupload_button',

    // @cfg Function that is called when the user has selected a file via the browser's file picker dialog.
    // This function is called with callbackScope and a single name argument which is the basename of the
    // newly selected file.
    onFileChangedCallback: null,

    // @cfg Scope for onFileChangedCallback
    callbackScope: null,

    /**
     * Constructor
     * @param config {onFileChangedCallback: callback, callbackScope: scope}
     */
    constructor: function(config)
    {
        Ext.apply(config,
        {
            cls: 'xcp-upload-file-btn',
            bodyBorder: false,
            items: [
            {
                xtype: 'filefield',
                name: 'file',
                allowBlank: false,
                height: 16,
                width: 20,
                buttonOnly: true,
                buttonText: '',
                errorReader: new Ext.data.reader.Xml({
                    record : 'field',
                    success: '@success'
                }, [ 'id', 'msg']),

                buttonConfig:
                {
                    xtype: 'button',
                    iconCls: 'add'
                },
                listeners:
                {
                    change: {fn: this.onFileFieldChanged, scope: this},
                    afterrender: {fn: this.onFileFieldAfterRender, scope: this}
                }
            }]
        });
        this.callParent(arguments);
    },

    getBasename: function(value)
    {
        var name = value;
        var key = '\\';
        var i0 = name.lastIndexOf(key);
        if (i0 != -1)
            name = name.substr(i0+1);
        return name;
    },

    onFileFieldAfterRender: function(cmp, opts)
    {
         Ext.create('Ext.tip.ToolTip',
         {
             target: this.getId(),
             html: this.tooltip
         });
    },

    onFileFieldChanged: function(field, value, opts)
    {
        if (this.onFileChangedCallback)
            this.onFileChangedCallback.call(this.callbackScope, this.getBasename(value));
    },

    /**
     *  Upload file selected by this control
     *
     *  @param scope for callbacks
     *  @param onSuccessCallback will be called with two arguments, name and result where name is the basename
     *         the file and result is the service method result object
     *  @param onFailureCallback will be called with two arguments, name and action where name is the basename
     *         the file and action is an Ext.form.action.Action. instance.
     */
    upload: function(scope, onSuccessCallback, onFailureCallback)
    {
        var form  = this.getForm();
        var field = form.findField('file');
        var name  = this.getBasename(field.getValue());

        if (!name || name.length == 0)
            return;

        function onUploadSuccess(form, action)
        {
            var result;

            field.reset();

            console.log('Uploaded  "' + name + '"');

            var response = action.response;
            if (!response || !response.responseText)
            {
                console.log('Could not find responseText');
            }
            else
            {
                console.log('responseText="' + response.responseText + '"');
                result = Ext.JSON.decode(response.responseText);
            }

            onSuccessCallback.call(scope, name, result);
        }

        function onUploadFailure(form, action)
        {
            field.reset();
            onFailureCallback.call(scope, name, action);
        }

        console.log('Uploading "' + name + '"');

        var form = this.getForm();

        var submitOptions =
        {
            url: 'application/fileupload.html',
            headers: {Accept: 'text/html'},
            success: onUploadSuccess,
            failure: onUploadFailure
        };

        try
        {
            form.submit(submitOptions);
        }
        catch (ex)
        {
            onUploadFailure.call(form, form, {response: undefined, exception: ex});
        }
    }
});

})();

/* xcp_fixed_field_width_model_mixin/content/xcp/util/mixin/FixedFieldWidthModelMixin.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Mixin to set a fixed width for a form field
 */
Ext.define("xcp.util.mixin.FixedFieldWidthModelMixin", {

    statics: {
        xcpDefaultBodyPxSize : 325     // default body size in pixels.
    },

    /**
     * @constructor
     * All the hooks are setup within the constructor.
     *
     * @sizePropname The property name for the body size; Its value will only be looked up in the initialConfig
     *               as this won't clash with extjs's default value such as "size" etc.
     */
    constructor: function(sizePropName) {
        if (sizePropName && this.isFormField) {
            this.bodySizeProp = sizePropName;
            this._origOnAdded = this.onAdded;
            this.onAdded = this.onAddedHook;
        }
    },

    /**
     * @override
     * Sets hooks for default fixed width handling. Delayed until it is being added to a container.
     */
    onAddedHook: function() {
        var ret = this._origOnAdded.apply(this, arguments);
        var ownerCt = this.ownerCt; // can be null for inline editing.
        if (!Ext.isNumber(this.width) && ownerCt && ownerCt.xtype != "editor") {
            var bodyPxSize = this.initialConfig[this.bodySizeProp];
            if (typeof bodyPxSize !== "number" && !ownerCt.isXType("xcp_columnvbox")) {
                bodyPxSize = this.statics().xcpDefaultBodyPxSize;
            }
            if (typeof bodyPxSize === "number") {
                // see implementation in Ext.layout.component.field.Field.beginLayout
                this.size = this.xcpBodySize = (bodyPxSize - 20) / 6.5;
                this.hstretch = false;
                this._origGetSizeModel = this.getSizeModel;
                this.getSizeModel = this.getSizeModelHook;
            }
        }

        return ret;
    },

    /**
     * Returns a size model that can force extjs Field layout to set a fixed body size when it is required.
     */
    getSizeModelHook: function () {
        var ret = this._origGetSizeModel.apply(this, arguments);
        if (ret && typeof this.xcpBodySize === "number") {
            ret.width = Ext.layout.Layout.prototype.sizeModels.natural;
        }

        return ret;
    }
});
/* xcp_formatter_util/content/xcp/formatter/Util.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Utility functions for formatter
 */
Ext.define("xcp.formatter.Util", {
    statics : {
        /**
         * resolve the picklist labels for the given value(s)
         * @param store  picklist store
         * @param value  picklist value
         * @return picklist label array for the corresponding given values
         */
        resolvePickListLabel: function(store, value) {
            if (store && !Ext.isEmpty(value)) {
                var values = Ext.Array.from(value);
                var labels = new Array(values.length);
                for (var i = 0; i < values.length; i++) {
                    var index = store.find("value", values[i], 0, false, true, true);
                    if (index != -1) {
                        var record = store.getAt(index);
                        labels[i] = record.get("label");
                    }
                    else {
                        labels[i] = values[i];
                    }
                }
                if (Ext.isArray(value))
                    value = labels;
                else
                    value = labels[0];
            }
            return value;
        },

        /**
         * Format the values for the given widget.
         * @param widget  widget
         * @param value   value
         * @param booleanTrueString default boolean true string
         * @param booleanFalseString  default boolean false string
         * @return formatted value
         */
        formatWidgetValues: function(widget, value, booleanTrueString, booleanFalseString) {
            //resolve picklist label
            var formattedValue = widget.resolvePickListValue(value);
            if (Ext.isBoolean(value)) {
                if (value) {
                    formattedValue = booleanTrueString;
                } else {
                    formattedValue = booleanFalseString;
                }
            }
            // Don't run the value through formatters if it's showing picklist labels
            if (!Ext.isEmpty(value) && value == formattedValue) {
                //only format non picklist value
                if(widget._formatter && (Ext.isEmpty(widget.valueType) || widget.valueType.indexOf('xcp.picklist')==-1)) {
                    formattedValue = widget._formatter.format(formattedValue);
                }
            }
            var encodedValue = formattedValue;
            //repeating values, do html encoding first
            if (Ext.isArray(formattedValue) && widget._repeatingAttributeFormatter) {
                var limit = value.length;
                var encodedValueArray = new Array();
                for(var i = 0; i < limit; i++) {
                    if (widget.valueType == "STRING") {
                        //only encode value for string type
                        encodedValueArray.push(Ext.String.htmlEncode(formattedValue[i]));
                    } else {
                        encodedValueArray.push(formattedValue[i]);
                    }
                }
                encodedValue = widget._repeatingAttributeFormatter.format(encodedValueArray);
            }
            else {
                //format using repeating formatter if it exists
                if(widget._repeatingAttributeFormatter) {
                    formattedValue = widget._repeatingAttributeFormatter.format(formattedValue);
                }

                //for single string value, do encoding now
                if (widget.valueType == "STRING") {
                    encodedValue = Ext.String.htmlEncode(formattedValue);
                } else {
                    //keep original value
                    encodedValue = formattedValue;
                }
            }

            return encodedValue;
        }
    }
});

/* xcp_hidden_mixin/content/xcp/util/mixin/SetHiddenMixin.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Mixin to add a setHidden method to a class which has a setVisible method
 */
Ext.define("xcp.util.mixin.SetHiddenMixin", {
    extend: "Ext.Base",

    /**
     * Sets whether an object is hidden or not
     * @param {Boolean} hidden true if the object should not be visible, false if the object should be visible
     */
    setHidden: function(hidden) {
        this.setVisible(!hidden);
    }
});/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.dialog.ImportFile");

Ext.apply(xcp.Strings.dialog.ImportFile, {
    dialogTitle: "Import Files",
    dialogTitleSingleType: "Import {0}",
    submitBtnText: "Finish",
    cancelBtnText: "Cancel",
    importListToolbarLabel: "Files to import",
    emptyFileListMsg: "No files to import",
    documentTypeLabel: "Content Type",
    formatLabel: "Format",
    selectTypeMsg: "Select a content type ...",
    noFileSelectedMsg: "(No file to import selected)",
    noContentTypesMsg: "(No types defined for importing)",
    naFormatMsg: "(Not Applicable)",
    multipleTypesMsg: "(Multiple content types)",
    selectFormatMsg: "Select a format ...",
    multipleExtensionsMsg: "(Multiple file extensions)",
    cannotImportFileMsg: "An error occurred uploading this file:  file will not be imported",
    addFileTooltip: "Add a file to import",
    removeFileTooltip: "Remove selected file",
    duplicateFileName: "Cannot import two files with the same name",
    importFileSucceededMsg: "Successfully imported file",
    importFilesSucceededMsg: "Successfully imported {0} files",
    importFileFailedMsg: "Failed to import file",
    importFilesFailed1Msg: "Successfully imported {0} files, failed to import {1} file",
    importFilesFailedMsg: "Successfully imported {0} files, failed to import {1} files",
    uploadingFile: "Uploading {0}",
    uploadedFile: "Ready to import {0}",
    needsInfoFile: "Select a content type for {0}",
    uploadErrorFile: "Could not upload {0}",
    importErrorFile: "Could not import {0}",
    importingFile: "Importing {0}",
    importedFile: "Imported {0}"
});

/* xcp_import_file/content/xcp/dialog/ImportFile.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.dialog.ImportFile
 * @extends Ext.window.Window
 * Dialog for import file action
 * @xtype xcp_import_file
 */

(function() {

var testSingleType = false;

//////////////////////////////////////////////////////////////////////////////////////////////////////
//  ImportFile dialog implementation
//
//  This dialog consists of a list of files on the left and a file info panel on the right.
//
//  When a file is added to the list of files to be imported, it is uploaded to the app server
//  immediately.  The upload response contains a 'content_id' that is used to locate the uploaded
//  file on the app server when the import action flow associated with the file is executed.
//
//  When a file is selected from the list of files to be imported, the file info panel displays
//  the type that has been selected for the file in the type selector combo and the associated
//  import action flow step page.  This page will have input controls defined by the step page
//  of the import action flow associated with the type.
//
//  When all files have been assigned a type, the 'Finish' button becomes enabled, and clicking
//  this button causes the import action flow associated with each file to be executed, one by one.
//  If all files are imported successfully, the dialog automatically closes as soon as the last
//  file has been imported.  If some files were not imported successfully, the dialog remains open
//  with all of the successfully imported files removed.  In any case, the target folder list
//  is refreshed after each file has been processed.
//////////////////////////////////////////////////////////////////////////////////////////////////////
Ext.define("xcp.dialog.ImportFile",
{
    extend: 'Ext.window.Window',
    alias: 'xcp_import_file',
    plain: true,
    //system error message should display on top of dialog.
    mixins: {
        feedbackContainer: 'xcp.util.mixin.FeedbackContainer'
    },
    includeFeedbackTypes: ['systemErrors','validationErrors'],

    statics:
    {
        //  Cache of actionStepConfigs indexed by importaction names:  the action step config for
        //  an import action is requested from the server just once during the browser session.
        actionStepConfigCache: {},

        //  Cache of formatData keyed by file extension.
        //  Each formatDatum is requested from the server just once during the browser session.
        formatDataCache: {},

        //  Cache of default format values keyed by file extension.
        //  This is updated whenever user selects a format for a file extension
        formatDefaults: {},

        //  File status constants.  Note that these are used as CSS class
        //  names to control which status icon is rendered for a file.
        filestates:
        {
            UPLOADING:    'uploading',
            UPLOADED:     'uploaded',
            NEEDSINFO:    'needsinfo',
            IMPORTING:    'importing',
            IMPORTED:     'imported',
            UPLOAD_ERROR: 'uploaderror',
            IMPORT_ERROR: 'importerror'
        },

        //  Reference to localized strings used by this class
        uistrings: xcp.Strings.dialog.ImportFile
    },

    constructor: function(config) {
        config = config || {};
        Ext.applyIf(config,
            {
                frame: false,
                frameHeader: false,
                modal: true,
                maxTipWidth: 500
            });

        var statics = this.statics();
        this.actionStepConfigCache = statics.actionStepConfigCache;
        this.formatDefaults = statics.formatDefaults;
        this.formatDataCache = statics.formatDataCache;
        this.uistrings = statics.uistrings;
        this.filestates = statics.filestates;

        var filestateMsgFormats = {};
        filestateMsgFormats[this.filestates.UPLOADING] = this.uistrings.uploadingFile;
        filestateMsgFormats[this.filestates.UPLOADED] = this.uistrings.uploadedFile;
        filestateMsgFormats[this.filestates.UPLOAD_ERROR] = this.uistrings.uploadErrorFile;
        filestateMsgFormats[this.filestates.IMPORT_ERROR] = this.uistrings.importErrorFile;
        filestateMsgFormats[this.filestates.NEEDSINFO] = this.uistrings.needsInfoFile;
        filestateMsgFormats[this.filestates.IMPORTING] = this.uistrings.importingFile;
        filestateMsgFormats[this.filestates.IMPORTED] = this.uistrings.importedFile;
        this.filestateMsgFormats = filestateMsgFormats;

        var assignedType = "";
        this.assignedType = assignedType;

        this.callParent(arguments);
    },

    initComponent: function() {
        var typeData = this.getTypeData();
        if (testSingleType)
            typeData = [typeData[0]];

        if (typeData && typeData.length == 1)
            this.onlyOneContentType = typeData[0].value;

        //  Initialize store for type selector
        this.typeStore = Ext.create('Ext.data.Store',
            {
                model: 'xcp.dialog.ImportFile.typeModel',
                data: typeData
            });

        //  Initialize store for list of files to be imported
        this.importFileStore = Ext.create('Ext.data.Store',
            {
                id: 'importFileStore',
                model: 'xcp.dialog.ImportFile.fileModel',
                data: []
            });

        this.uploadCounter = 0;

        var title = this.uistrings.dialogTitle;
        if (this.onlyOneContentType)
            title = Ext.String.format(this.uistrings.dialogTitleSingleType, typeData[0].label);

        Ext.applyIf(this,
            {
                title: title,
                height: 450,
                width: 700,
                resizable: true
            });

        this.refs =
        {
            dialogPageId: Ext.id(undefined, 'xcp_page-'),
            actionFlowsPanelId: Ext.id(undefined, 'panel-'),
            fileListViewId: Ext.id(undefined, 'dataview-'),
            importBtnId: Ext.id(undefined, 'button-'),
            addFileBtnId: Ext.id(undefined, 'button-'),
            removeBtnId: Ext.id(undefined, 'button-remove-'),
            typeSelectorId: Ext.id(undefined, 'combo-'),
            formatSelectorComboId: Ext.id(undefined, 'combo-')
        };

        //  Define config for dialog buttons
        var dialogButtons = [
            {
                text: this.uistrings.submitBtnText,
                listeners: {click: {fn: this.submit, scope: this}},
                id: this.refs.importBtnId,
                disabled: true
            },
            {
                text: this.uistrings.cancelBtnText,
                listeners: {click: {fn: this.close, scope: this}}
            }
        ];

        //  Define items for file list panel
        var fileListPanelItems = [
            {
                xtype: 'xcp_toolbar',
                region: 'north',
                items:
                    [
                        { xtype: 'tbtext', text: '<span class="label">' + this.uistrings.importListToolbarLabel + '</span>'},
                        { xtype: 'tbfill' },
                        {
                            xtype: 'xcp_fileupload_button',
                            id: this.refs.addFileBtnId,
                            tooltip: this.uistrings.addFileTooltip,
                            tooltipType: 'qtip',
                            onFileChangedCallback: this.onSelectFileToUpload,
                            callbackScope: this
                        },
                        {
                            xtype: 'button',
                            iconCls: 'remove',
                            id: this.refs.removeBtnId,
                            tooltip: this.uistrings.removeFileTooltip,
                            tooltipType: 'qtip',
                            listeners: {click: {fn: this.onRemoveSelectedFiles, scope: this}}
                        }
                    ]
            },
            {
                xtype: 'dataview',
                id: this.refs.fileListViewId,
                cls: 'import-file-list-dataview',
                region: 'center',
                store: this.importFileStore,
                tpl: new Ext.XTemplate('<tpl for="."><div name="{name}" class="import-file-item"><span class="import-file-item-status-img {status}"></span><span class="import-file-item-format-img"></span><span class="import-file-item-filename">{name}</span></div></tpl>'),  // $NON-NLS-L$
                name: 'import-filelist',
                itemSelector: 'div.import-file-item',
                multiSelect: true,
                autoScroll: true,
                selectedItemCls: 'import-file-item-selected',
                emptyText: '<div class="import-file-item-empty">' + this.uistrings.emptyFileListMsg + '</div>',
                deferEmptyText: false,
                listeners:
                {
                    selectionchange: {fn: this.onFileSelectionChange, scope: this},
                    render: {fn: this.onRenderFileListView, scope: this}
                }
            }
        ];

        //  Define config for file list panel
        var fileListPanelConfig =
        {
            xtype: 'panel',
            name: 'fileinfo',
            cls: 'filelist-panel',
            flex: 1,
//            width: 120,
            minWidth: 0,
            layout: 'border',
            collapsible: true,
            collapseMode: 'mini',
            preventHeader: true,
            items: fileListPanelItems,
            listeners:
            {
                collapse: {fn: this.onCollapseFileListPanel, scope: this},
                expand: {fn: this.onExpandFileListPanel, scope: this}
            }
        };

        //  Define config for splitter separating file list panel from file info panel
        var splitterConfig =
        {
            xtype: 'splitter',
            collapsible: true,
            collapsedCls: 'collapsed',
            collapseOnDblClick: true,
            collapseTarget: 'prev',
            width: 5,
            defaultSplitMin: 100
        };

        var typeSelectorConfig =
        {
            xtype: 'combo',
            id: this.refs.typeSelectorId,
            fieldLabel: '<span class="label">' + this.uistrings.documentTypeLabel + '</span>',
            name: 'type',
            editable: false,
            emptyText: this.uistrings.selectTypeMsg,
            valueNotFoundText: this.uistrings.selectTypeMsg,
            store: this.typeStore,
            queryMode: 'local',
            displayField: 'label',
            readOnly: (this.onlyOneContentType && this.onlyOneContentType.length > 0),
            valueField: 'value',
            value: this.onlyOneContentType,
            anchor: '100%',
            grow: true,
            listeners:
            {
                select: {fn: this.onTypeSelection, scope: this},
                change: {fn: this.onTypeSelectorValueChanged, scope: this},
                focus: {fn: this.onTypeSelectorFocus, scope: this},
                collapse: {fn: this.onTypeSelectorCollapse, scope: this},
                expand: {fn: this.onTypeSelectorExpand, scope: this}
            }
        };

        var formatSelectorConfig =
        {
            xtype: 'combo',
            id: this.refs.formatSelectorComboId,
            fieldLabel: '<span class="label">' + this.uistrings.formatLabel + '</span>',
            name: 'format',
            editable: false,
            emptyText: this.uistrings.selectFormatMsg,
            valueNotFoundText: this.uistrings.selectFormatMsg,
            queryMode: 'local',
            displayField: 'description',
            readOnly: true,
            store: Ext.create('Ext.data.Store', {model: 'xcp.dialog.ImportFile.formatModel', data: []}),
            extension: undefined,  //Extension to track the previous
            valueField: 'value',
            value: '',
            anchor: '100%',
            grow: true,
            listeners:
            {
                change: {fn: this.onFormatSelectorValueChanged, scope: this},
                focus: {fn: this.onFormatSelectorFocus, scope: this},
                collapse: {fn: this.onFormatSelectorCollapse, scope: this},
                expand: {fn: this.onFormatSelectorExpand, scope: this}
            }
        };

        //  Define items for file info panel
        var fileInfoPanelItems = [
            {
                //  Form panel with type selector and format selector combo fields
                xtype: 'form',
                cls: 'import-file-type-and-format-selector-panel',
                submitEmptyText: false,
                region: 'north',
                fieldDefaults: {
                    labelAlign: 'left',
                    labelWidth: 110
                },
                items: [typeSelectorConfig, formatSelectorConfig]
            },
            {
                //  Action flows panel with card layout.  Child panels display the action flow
                //  step page for the import action flow associated with corresponding uploaded file.
                //  Card layout means only one of these child panels at a time is visible.
                xtype: 'panel',
                layout: 'card',
                id: this.refs.actionFlowsPanelId,
                region: 'center',
                items: [],
                cls: 'action-flows-panel'
            }
        ];

        //  Define config for file info panel
        var fileInfoPanelConfig =
        {
            xtype: 'panel',
            name: 'fileinfo',
            cls: 'fileinfo-panel',
            flex: 2,
            layout: 'border',
            maintainFlex: true,
            resizeable: true,
//            width: 280,
            items: fileInfoPanelItems
        };

        //  Define dialog items
        var dialogItems = [
            {
                xtype: 'panel',
                region: 'center',
                cls: 'center',
                layout: {type: 'hbox', align: 'stretch'},
                items:
                    [
                        fileListPanelConfig,  //  List of files to be imported
                        splitterConfig,       //  Splitter
                        fileInfoPanelConfig   //  Shows type selector and import action flow step page for
                        //    currently selected file in list of files to be imported.
                    ]
            }
        ];

        var dialogPage =
        {
            xtype: 'xcp_page',
            id: this.refs.dialogPageId,
            includeFeedbackTypes: ['validationErrors'],
            region: 'center',
            layout: 'border',
            items: dialogItems,
            listeners: {afterrender: {fn: this.onAfterRender, scope: this}}
        };

        //  Define dialog
        Ext.apply(this,
            {
                cls: 'xcp-import-file-dialog',
                iconCls: 'import-dialog-icon',
                bodyCls: 'body',
                //border layout does not allow system error panel being added dynamically
                layout: {type: "vbox", align:"stretch"},
                buttons: dialogButtons,
                items: [{
                    xtype:'container',
                    layout: 'border',
                    flex: 1,
                    items: [dialogPage]
                }]
            });

        this.callParent(arguments);
    },

    getTypeInfo: function(modelName) {
        var typeValue = modelName;
        var typeLabel = xcp.core.TypeManager.getTypeLabel(typeValue);
        return {typeValue: typeValue, typeLabel: typeLabel};
    },

    getModelNameFromTypeName: function(typeName) {
        //  Get action step config according to import action associated with newType
        var modelName = typeName;

        var prefix = '';
        if (xcp && xcp.appContext && xcp.appContext.namespace)
            prefix = xcp.appContext.namespace + '_';
        else
            prefix = 'tst_';

        var index = modelName.indexOf(prefix);
        if (index == 0)
            modelName = modelName.substr(prefix.length);  // Strip off application prefix to get modelName associated with type

        return modelName;
    },

    //  Get type data from ActionManager to be used to initialize type selector combo.
    //  Returns an array of type objects, each object consisting of a typeName, typeValue, and import action flow id.
    getTypeData: function() {
        var typeData = [];

        var userActionsDefReg = xcp.core.ActionManager.userActionsDefReg;
        for (var model in userActionsDefReg) {
            var typeRecord = userActionsDefReg[model];
            //  Find the import action flow for this type
            for (var actionId in typeRecord) {
                var actionFlowRecord = typeRecord[actionId];
                if (actionFlowRecord.flowDef['action-type'] == 'Import')  // $NON-NLS-L$
                {
                    var typeInfo = this.getTypeInfo(model);
                    //xcpecm-1070 encode type string so HTML characters don't mess up the dropdown
                    var typeLabel = Ext.String.htmlEncode(typeInfo.typeLabel);
                    typeData.push({label: typeLabel, value: typeInfo.typeValue, actionId: actionId});
                    break;
                }
            }
        }

        var allowedTypeValues = this.allowedTypeValues;
        if (!allowedTypeValues)
        {
            return this.sortTypeData(typeData);
        }


        var allowedTypeData = [];
        for (var i = 0; i < typeData.length; i++)
        {
            for (var j = 0; j < allowedTypeValues.length; j++)
            {
                var typeDatum = typeData[i];
                if (typeDatum.value == allowedTypeValues[j])
                {
                    allowedTypeData.push(typeDatum);
                    break;
                }
            }
        }
        return this.sortTypeData(allowedTypeData);
    },

    sortTypeData: function (types)
    {
        types.sort(function(a, b)
        {
            var label1 = a.label.toLocaleLowerCase();
            var label2 = b.label.toLocaleLowerCase();
            return label1.localeCompare(label2);
        });
        return types;
    },

    onCollapseFileListPanel: function(panel, options) {
        panel.suspendEvents();
        panel.setSize(0);  // Set width to zero, otherwise ugly and unwanted header bar appears that cannot be eliminated via Ext configuration
        panel.resumeEvents();
    },

    onExpandFileListPanel: function(panel, options) {
        panel.doLayout();
    },

    onAfterRender: function() {
        //  Initialize component references from associated ids
        for (var name in this.refs) {
            var refname = name.substr(0, name.length - 2);
            this[refname] = Ext.getCmp(this.refs[name]);
        }

        //  If more than one type can be chosen, set initial message in type selector accordingly
        if (!this.onlyOneContentType)
            this.typeSelector.setRawValue(this.uistrings.noFileSelectedMsg);

        //  Type selector is initially readOnly and becomes not readOnly as soon as there is a file to import
        this.typeSelector.setReadOnly(true);

        //  Set initial message in format selector
        this.formatSelectorCombo.setRawValue(this.uistrings.noFileSelectedMsg);

        //  Format selector is initially readOnly and becomes not readOnly as soon as there is a file to import
        this.formatSelectorCombo.setReadOnly(true);

        var typeData = this.getTypeData();
        if (typeData && typeData.length == 0)
        {
            this.typeSelector.setRawValue(this.uistrings.noContentTypesMsg);
            this.formatSelectorCombo.setRawValue(this.uistrings.naFormatMsg);
            this.addFileBtn.disable();
            this.removeBtn.disable();
        }

        this.textMetrics = new Ext.util.TextMetrics(this.getEl());
    },

    updateFileListTip: function(tip) {
        var name;
        var status = '';
        var statusMsg = '';
        var record = this.fileListView.getRecord(tip.triggerElement.parentNode);
        if (record) {
            name = record.get('name');
            status = record.get('status');
            statusMsg = record.get('statusMsg');
        }

        var maxWidth = this.maxTipWidth - 10;

        var msg;
        if (!statusMsg || statusMsg.length == 0) {
            var fmt = this.filestateMsgFormats[status];
            msg = lineBreakString(Ext.String.format(fmt, name), this.textMetrics, maxWidth);
        }
        else {
            msg = lineBreakString(statusMsg, this.textMetrics, maxWidth);
        }

        tip.update(msg);
    },

    onRenderFileListView: function(view) {
        view.tip = Ext.create('Ext.tip.ToolTip',
            {
                target: view.el,
                delegate: 'span.import-file-item-status-img',
                dismissDelay: 0,
                bodyCls: 'import-file-list-tooltip-body',
                trackMouse: true,
                maxWidth: this.maxTipWidth,
                maxHeight: 500,
                renderTo: Ext.getBody(),
                listeners: {beforeshow: {fn: this.updateFileListTip, scope: this}}
            });
    },

    updateFormatSelectorComboData: function(extension, data) {
        var formatSelectorComboCtrl = this.formatSelectorCombo;
        formatSelectorComboCtrl.clearValue();
        // Newer versions of Ext 4.x implement getStore(), older ones expose store property
        var formatStore = (formatSelectorComboCtrl.getStore) ? formatSelectorComboCtrl.getStore() : formatSelectorComboCtrl.store;
        formatStore.removeAll();
        if (data)
            formatStore.add(data);
        else
            formatSelectorComboCtrl.setReadOnly(true);
        formatSelectorComboCtrl.extension = (extension && extension.length > 0) ? extension : undefined;
    },


    updateFormatSelectorCombo: function(extension, format) {
        if (!Ext.isString(extension) && !Ext.isString(format)) {
            this.updateFormatSelectorComboData();
            return undefined;
        }
        var formatDefaults = this.formatDefaults;
        var defaultFormat = formatDefaults[extension];
        var formatSelectorComboCtrl = this.formatSelectorCombo;
        if (Ext.isString(extension) && extension != formatSelectorComboCtrl.extension) {
            var formatData = this.formatDataCache[extension];
            if (formatData) {
                // Must pass deep copy here because Ext.data.Store.add() updates its argument to a model record :-(
                var data = [];
                for (var i = 0; i < formatData.length; i++) {
                    var info = {};
                    Ext.apply(info, formatData[i]);
                    data.push(info);
                }
                this.updateFormatSelectorComboData(extension, data);
                formatSelectorComboCtrl.setReadOnly(formatData.length == 1);
                if (formatData.length == 1)
                    defaultFormat = formatData[0].value;
            }
        }

        if (Ext.isString(format) || Ext.isString(defaultFormat)) {
            var formatToUse = (Ext.isString(format) && format.length > 0) ? format : defaultFormat;
            formatSelectorComboCtrl.select(formatToUse);
            if (Ext.isString(extension) && Ext.isString(formatToUse))
                formatDefaults[extension] = formatToUse;
        }

        return defaultFormat;
    },

    /**
     * This method will get called as soon as file upload success.
     * @param name
     * @param result
     */
    onUploadSuccess: function(name, result) {
        var uploadedFilerecord = this.getFileRecord(name);
        if (!uploadedFilerecord)
            return;

        var status = this.filestates.UPLOAD_ERROR;
        if (result && result.id) {
            status = this.filestates.NEEDSINFO;
            uploadedFilerecord.set('content_id', result.id);
        }
        this.selectUploadedFile(uploadedFilerecord, status);  // removing spinning progress icon next to filename in left hand panel

        var extension = '';
        var i0 = name.lastIndexOf('.');
        if (i0 != -1)
            extension = name.substr(i0 + 1);
        if (extension != null && extension != '')
            extension = extension.toLowerCase();

        uploadedFilerecord.set('extension', extension);   // $NON-NLS-1$

        //Check formats for newly uploaded file in cache or not.
        if (this.formatDataCache[extension]) {
            setFormat.call(this);
            return;
        }

        function setFormat() {
            var defaultFormat = this.updateFormatSelectorCombo(extension);
            if (defaultFormat) {
                uploadedFilerecord.set('format', defaultFormat);  // $NON-NLS-1$
                var actionRecord = uploadedFilerecord.get('actionRecord');
                if (actionRecord != null && Ext.isObject(actionRecord)) {
                    actionRecord.set('a_content_type', defaultFormat);
                     console.log("setFormat: Setting content type for file extension=" + extension + ", content type=" + defaultFormat);
                }
            }
        }

        //  Query server for formats associated with this file extension
        Ext.Ajax.request(
            {
                method: 'GET', url: 'application/formats?extensions=' + extension, scope: this,
                success: function(response, options) {
                    //  result will be a map of arrays keyed by extension, with each array
                    //  consisting of all of the formats for the associated extension
                    var result = Ext.JSON.decode(response.responseText);
                    var formatData = result[extension];
                    this.formatDataCache[extension] = formatData;
                    if (formatData.length == 1)
                        this.formatDefaults[extension] = formatData[0].value;
                    setFormat.call(this);
                },
                failure: function(response, options) {
                    Ext.MessageBox.alert('Server Error', response.responseText);
                }
            });
    },

    onUploadFailure: function(name, action) {
        var msg = Ext.String.format(this.uistrings.uploadErrorFile, name);

        if (xcp && xcp.core && xcp.core.FeedbackManager)
            xcp.core.FeedbackManager.showFeedback(null, '', msg, "systemErrors", false);

        if (action && action.result) {
            console.log("onUploadFailure: name=" + name + ", errorId=" + action.result.errorId);
            msg += ': ' + action.result.errorMsg;
        }

        var store = this.importFileStore;
        var record = store.findRecord('name', name);  // $NON-NLS-1$
        record.set('statusMsg', msg);

        this.selectUploadedFile(record, this.filestates.UPLOAD_ERROR);
    },

    onSelectFileToUpload: function(name) {
        var store = this.importFileStore;
        if (store.findRecord('name', name))  // $NON-NLS-1$
        {
            console.log('Duplicate name: ' + name);
            Ext.Msg.show(
                {
                    buttons: Ext.MessageBox.OK,
                    icon: Ext.MessageBox.WARNING,
                    msg: this.uistrings.duplicateFileName
                });

            return;
        }

        // In IE8 the callback is done twice the second time with an empty string
        if (name != "") {
            store.add({name: name, status: this.filestates.UPLOADING, data: {}});

            //  Upload file now
            this.addFileBtn.upload(this, this.onUploadSuccess, this.onUploadFailure);
        }
    },

    //Method get called when user select a uploaded file from file panel list
    selectUploadedFile: function(record, status) {
        this.fileListView.getSelectionModel().select([record], false, true);

        if (!this.onlyOneContentType)
            this.typeSelector.clearValue();

        record.set('status', status);  // $NON-NLS-1$

        var cardId = Ext.id(undefined, 'panel-');
        record.set('cardId', cardId);

        this.actionFlowsPanel.add(
            {
                xtype: 'xcp_page',
                id: cardId,
                autoScroll: true,
                cls: 'action-step-container'
            });

        console.log('Added card with cardId=' + cardId);

        var layout = this.actionFlowsPanel.getLayout();
        layout.setActiveItem(cardId);

        if (!this.onlyOneContentType) {
            this.importBtn.disable();
            this.typeSelector.setReadOnly(false);
        }
        else {
            this.onTypeSelectorValueChanged(this.typeSelector, this.onlyOneContentType, null);
        }
    },

    //  Handler that is called when the selection in the list of files to import changes
    onFileSelectionChange: function(model, selectedRecords, opts) {
        this.updateSelection(selectedRecords, true);

        var enableActionFlowsPanel = (selectedRecords.length > 0);
        for (var i = 1; i < selectedRecords.length; i++)
        {
            var type = selectedRecords[i].get('type');
            if (!type || type.length == 0)
            {
                enableActionFlowsPanel = false;
                break;
            }
        }
        displayPanel(this.actionFlowsPanel, enableActionFlowsPanel);
    },

    removeFiles: function(records) {
        //  Remove associated cards in action flows panel
        for (var i = 0; i < records.length; i++) {
            var cardId = records[i].get('cardId');
            this.actionFlowsPanel.remove(cardId);
            console.log('Removed card with cardId=' + cardId);
        }

        //  Remove records from file list store
        var store = this.importFileStore;
        store.suspendEvents();
        store.remove(records);
        console.log('Removed ' + records.length + ' file record(s)');
        store.resumeEvents();
        store.fireEvent('refresh');

        //  Update selection in list of files to import
        var count = store.getCount();
        if (count > 0) {
            var index = count - 1;
            this.fileListView.getSelectionModel().select(index);
            this.updateSelection([store.getAt(index)], true);
        }
    },

    //  Handler for removing file from list of files to be imported
    onRemoveSelectedFiles: function (btn, event, options) {
        var view = this.fileListView;
        var nodes = view.getSelectedNodes();
        if (nodes && nodes.length > 0)
            this.removeFiles(view.getRecords(nodes));

        if (!this.onlyOneContentType) {
            var records = this.getUploadedFileRecords();
            if (!records || records.length == 0) {
                this.typeSelector.clearValue();
                this.typeSelector.setReadOnly(true);
            }
        }
    },

    //  Utility that returns the records associated with given list of nodes,
    //  filtering out those corresponding to files that were not successfully uploaded.
    getUploadedFileRecords : function(nodes) {
        var result = [];
        var view = this.fileListView;
        nodes = nodes || view.getNodes();
        if(!nodes)
             return result;
        var records = view.getRecords(nodes);
        if (!records)
            return result;
        for (var i = 0; i < records.length; i++) {
            var record = records[i];
            if (record && record.get('status') != this.filestates.UPLOAD_ERROR)
                result.push(record);
        }
        return result;
    },

    //  Utility that returns the count of records associated with given list of nodes,
    //  filtering out those corresponding to files that were not successfully uploaded.
    countUploadedFileRecords: function(nodes) {
        var count = 0;
        var view = this.fileListView;
        nodes = nodes || view.getNodes();
        var records = view.getRecords(nodes);
        if (!records)
            return count;
        for (var i = 0; i < records.length; i++) {
            var record = records[i];
            if (record && record.get('status') != this.filestates.UPLOAD_ERROR)
                count += 1;
        }
        return count;
    },

    //Decode the content type  on selection made
    onTypeSelection: function(field) {
        var decodedRawValue = Ext.String.htmlDecode(field.getRawValue());
        field.setRawValue(decodedRawValue);
    },

    //  Handler for type selector value changes
    //  Called when uses chooses the content type from type combo or  user select a uploaded file
    onTypeSelectorValueChanged: function(field, newValue, oldValue, opts) {
        //  Work around ext-4.0.0 problem
        if ((newValue == null || newValue.length == 0) && oldValue != null)
            return;

        if (newValue == this.uistrings.multipleTypesMsg)
            return;

        var record, records;
        var view = this.fileListView;

        var selectedFileNodes = view.getSelectedNodes(); //List of selected nodes in file list.
        //Do not do anything if the selected records are empty or new selected type value is not same as old content type.
        if (!selectedFileNodes || selectedFileNodes.length == 0 || newValue == oldValue)
            return;

        var records = this.getUploadedFileRecords(selectedFileNodes);

        //Shows the acton flow step page for new type.
        this.updateImportActionFlowStepPageForType(records, newValue);

        //this.updateSelection(records, false);

        //  Work around ext-4.0.0 problem
        var extVersion = Ext.getVersion();
        if (extVersion.major == 4 && extVersion.minor == 0 && extVersion.patch == 0)
            field.setValue(newValue);

        if (selectedFileNodes.length > 1) {
            var selectionModel = view.getSelectionModel();
            var lastSelected = selectionModel.getLastSelected();
            lastSelected.set('type', newValue);  //  Make sure it has a type $NON-NLS-1$
            //selectionModel.select([lastSelected], false);
        }

        this.updateSelection(records, false);

        this.updateImportBtnEnablement();

        displayPanel(this.actionFlowsPanel, true);
    },

    multipleTypesSelected: function() {
        var view = this.fileListView;
        var nodes = view.getSelectedNodes();
        if (nodes && nodes.length > 0) {
            var selectedRecords = view.getRecords(nodes);
            var record = selectedRecords[0];
            var type0 = record.get('type');
            this.assignedType = type0;
            for (var i = 1; i < selectedRecords.length; i++) {
                record = selectedRecords[i];
                if (record.get('type') != type0)
                    return true;
            }
        }
        return false;
    },

    //  Handler for type selector collapse event
    onTypeSelectorCollapse: function(field, opts) {
        var value = field.getRawValue();
        if (!value || value.length == 0) {
            if (this.countUploadedFileRecords() == 0)
                value = this.uistrings.noFileSelectedMsg;
            else if (this.multipleTypesSelected())
                value = this.uistrings.multipleTypesMsg;
            else
                value = this.assignedType;

            field.setRawValue(value);
        }
    },

    //  Handler for type selector expand event
    onTypeSelectorExpand: function(field, opts) {
        var value = field.getRawValue();
        if (!value || value.length == 0)
            field.setRawValue(this.uistrings.selectTypeMsg);
    },

    //  Handler for type selector focus event
    onTypeSelectorFocus: function(field, opts) {
        if (!this.onlyOneContentType) {
            var value = (this.countUploadedFileRecords() == 0) ? this.uistrings.noFileSelectedMsg : this.uistrings.selectTypeMsg;
            field.setRawValue(value);
        }
    },

    getFileRecord: function(name) {
        var store = this.importFileStore;
        for (var i = 0; i < store.getCount(); i++) {
            var record = store.getAt(i);
            if (record.data.name == name)
                return record;
        }
        return null;
    },

    getTypeRecord: function(value) {
        var store = this.typeStore;
        for (var i = 0; i < store.getCount(); i++) {
            var record = store.getAt(i);
            if (record.data.value == value)
                return record;
        }
        return null;
    },

    //  Handler for format selector value changes
    onFormatSelectorValueChanged: function(field, newValue, oldValue, opts) {
        //  Work around ext-4.0.0 problem
        if (newValue == null && oldValue != null)
            return;

        this.formatDefaults[field.extension] = newValue;

        var record, records;
        var view = this.fileListView;
        var nodes = view.getSelectedNodes();
        if (nodes && nodes.length > 0 && newValue != oldValue) {
            var records = this.getUploadedFileRecords(nodes);
            this.updateActionStepFormat(records, newValue, field.extension);

            //  Work around ext-4.0.0 problem
            var extVersion = Ext.getVersion();
            if (extVersion.major == 4 && extVersion.minor == 0 && extVersion.patch == 0 && field.getValue() != newValue)
                field.setValue(newValue);

            if (nodes.length > 1) {
                var selectionModel = view.getSelectionModel();
                var lastSelected = selectionModel.getLastSelected();
                if (lastSelected.get('extension') == field.extension) {
                    lastSelected.set('format', newValue);  //  Make sure it has a format $NON-NLS-1$
                    //selectionModel.select([lastSelected],false);
                }
            }
        }

        this.updateImportBtnEnablement();
    },

    //  Handler for format selector collapse event
    onFormatSelectorCollapse: function(field, opts) {
        var value = field.getRawValue();
        if (!value || value.length == 0)
            field.setRawValue(this.uistrings.selectFormatMsg);
    },

    //  Handler for format selector expand event
    onFormatSelectorExpand: function(field, opts) {
        var value = field.getRawValue();
        if (!value || value.length == 0)
            field.setRawValue(this.uistrings.selectFormatMsg);
    },

    //  Handler for format selector focus event
    onFormatSelectorFocus: function(field, opts) {
        if (this.countUploadedFileRecords() == 0)
            field.setRawValue(this.uistrings.noFileSelectedMsg);
    },

    updateImportActionFlowStepPageForType: function(selectedRecords, newType) {
    if (!selectedRecords || !newType)
            return;

        var recordsToUpdate = [];

        //  Find all the file records that need to be updated.
        //  These are file records whose type has not yet been set
        //  or differs from newType.
        for (var i = 0; i < selectedRecords.length; i++) {
            var record = selectedRecords[i];
            var name = record.get('name');
            var type = record.get('type');  // internal type name
            if (type == newType)
                continue;
            recordsToUpdate.push(record);
        }

        if (recordsToUpdate.length == 0)
            return;

        var nextRecord;
        var currentIndex = 0;
        var actionId;

        function updateNextRecord() {
            nextRecord = recordsToUpdate[currentIndex];
            nextRecord.set('type', newType);  // $NON-NLS-1$

            var format = nextRecord.get('format');
            if (Ext.isString(format) && (format != this.uistrings.selectFormatMsg) && (format != "") && (format != this.uistrings.multipleExtensionsMsg))
                nextRecord.set('status', this.filestates.UPLOADED);  // $NON-NLS-1$

            //  Get action step config according to import action associated with newType
            var typeRecord = this.getTypeRecord(newType);
            if (!typeRecord) {
                console.log('Unable to find type record from type store: ' + newType);
                return;
            }
            actionId = typeRecord.get('actionId');
            if (!actionId) {
                console.log('Unable to get the import action flow id for type: ' + newType);
                return;
            }

            var stepConfig = this.actionStepConfigCache[actionId];
            if (!stepConfig) {
                // Get stepConfig from server
                //var modelName = this.getModelNameFromTypeName(newType);
                var actionDefConfig = xcp.core.ActionManager.getUserActionDefConfig(newType, actionId);
                var stepUrl = actionDefConfig.flowDef['view-state'][0].pageUrl;  //  this.flow.getCurrentViewPageUrl();
                xcp.widget.window.Wizard.getStepJson(stepUrl, renderImportFlowActionStepPage, this);
                return;
            }

            // Use stepConfig from cache
            renderImportFlowActionStepPage.call(this, stepConfig);
        }

        function renderImportFlowActionStepPage(stepConfig) {
           // The htmlEncoding happens on the page every time it gets added to the container.
           // If you enable the cache please test with bug XCPECM-1023.
           // if (!this.actionStepConfigCache[actionId])
           //     this.actionStepConfigCache[actionId] = stepConfig;

            stepConfig.loadModel = true;

            //  Find associated action step container
            var cardId = nextRecord.get('cardId');
            var xcpPage = Ext.getCmp(cardId);

            //  Avoid unnecessary doLayout done by xcpPage.replaceChild
            var rendered = xcpPage.ownerCt.rendered;
            xcpPage.ownerCt.rendered = false;

           //Calculate max form labels width.
            if (!stepConfig.fieldDefaults)
            {
                var getDefaultWidthContext = {numRemoved: 0, defaultWidth: 150};
                visitNodes(stepConfig, removeLabelWidthAction, getDefaultWidthContext);
               console.log("Number of nodes for which 'labelWidth' field was removed: "+getDefaultWidthContext.numRemoved)

                var collectLabelsContext = {fields: []};
                visitNodes(stepConfig, collectFieldLabelsAction, collectLabelsContext );
                console.log("Number of nodes with an 'fieldLabel' field : " + collectLabelsContext.fields.length);
                var maxLabelWidth= 250; //This is maximum width can set to form panel.
                var calculatedLabelWidth = calculateMaxLabelWidth(xcpPage, stepConfig, collectLabelsContext.fields );
                if (getDefaultWidthContext.defaultWidth > calculatedLabelWidth) {
                    calculatedLabelWidth = getDefaultWidthContext.defaultWidth;
                } else if (calculatedLabelWidth > maxLabelWidth) {
                    calculatedLabelWidth = maxLabelWidth;
                }

                stepConfig.fieldDefaults = {
                    labelWidth: calculatedLabelWidth
                };
            }

            //  Update action step container by removing any previous child component and adding a new one
            //  specified by stepConfig.  The new child component is an instance of xcp_form.
            xcpPage.replaceChild(stepConfig);
            xcpPage.ownerCt.rendered = rendered;

            var formPanel = xcpPage.getComponent(0);

             /* We are going to fix the model to only include the attributes that are on the step page. Attributes
            * in the model and not on the page are not going to be submitted to allow the expression associated with
            * those attributes to run.
            * */
            var inputAttributesNames = getInputAttributesFromPage(formPanel.getForm());
            inputAttributesNames = Ext.Array.merge(inputAttributesNames,
                                    ['content_id', 'a_content_type', 'folder_id', 'object_name', 'subject', 'title']);

            var modelName = stepConfig.models[0];
            var actionRecord = Ext.create(modelName,
                {
                    content_id: nextRecord.get('content_id'),
                    a_content_type: nextRecord.get('format'),
                    folder_id: this.targetFolderId || '',
                    object_name: nextRecord.get('name')
                });

            /* Remove the attributes that are not included on the step page. */
            var fieldsToRemove = [];
            for (var i=0; i < actionRecord.fields.getCount(); i++) {
                var field = actionRecord.fields.getAt(i);
                if (!Ext.Array.contains(inputAttributesNames, field.name))
                    fieldsToRemove.push(field);
            }

            if (fieldsToRemove.length > 0){
                actionRecord.fields.removeAll(fieldsToRemove);
            }

            /* make sure the repeating attributes are initialized to Array */
            var repeatingAttributeNames = getRepeatingAttributesFromPage(stepConfig);
            if (actionRecord.data) {
                for (var attributeName in actionRecord.data) {
                    if (actionRecord.data[attributeName ] === "") {
                        if (Ext.Array.contains(repeatingAttributeNames, attributeName)) {
                            actionRecord.data[attributeName] = [];
                        }
                    }
                }
            }

            nextRecord.set('actionRecord', actionRecord);
            actionRecord.owner = nextRecord;

            var form = formPanel.getForm();
            form.loadRecord(actionRecord);
            formPanel.doLayout();

            var thisDialog = this;

            // Set up event handling so that changing the value of a form field automatically updates actionRecord.
            // Do this by mimicing xcp.widget.form.Form._registerToFieldChangeEvent.
            var nameSetBySelection=true;
            form.getFields().each(function(f) {

                if (f.isFormField)
                    f.on("change", function(field, newValue, oldValue, options) {
                        // in order to avoid having the object name reset when the default
                        // values are returned we check here to see if if name has been set already
                        // and then reset it and the nameSetbySelection flag. The flag gets
                        // reverted every time a new type is selected.
                        if ((typeof field.name) == "undefined")
                               return;

                        if (oldValue != "" && nameSetBySelection && field.getName()=="object_name" && newValue =="")
                        {
                            nameSetBySelection=false;
                            field.suspendEvents();
                            field.setValue(oldValue);
                            field.resumeEvents();
                        }
                        else if (Ext.Array.contains(repeatingAttributeNames, field.getName() )&& newValue == "") {
                            // work around for flaw in how dialog returns an uninitialized repeating attribute.
                            // the value should be an empty array but is "" instead. Thus we have to correctly initialize
                            // if single empty string is being set instead.
                           field.suspendEvents();
                           field.setValue([]);
                           field.resumeEvents();
                        }
                        else
                        {
                            thisDialog.onChangeFieldValue(this, field, newValue, oldValue, options);
                        }
                    }, actionRecord);
            }, formPanel);

            //  Return if there are no more file records to be updated
            if (++currentIndex >= recordsToUpdate.length)
                return;

            //  Process next file record to be updated
            updateNextRecord.call(this);
        }


        //  For each field in the given node object, call the given action function, passing to
        //  it the value of the field, the name of the field, and the given context.  For each
        //  field that is itself an object or an array, this function is recursively called on
        //  the field object or on each object valued array member respectively.  If the given
        //  action function does not reference the context passed to it, there is no need to
        //  pass a context to this function.  Passing a context allows the action function to
        //  collect or count all descendant objects that match given criteria encoded by the
        //  action function itelf.
        function visitNodes(node, action, context)
        {
            for (var fieldname in node)
            {
                var childNode = node[fieldname];
                if (childNode == undefined)
                    continue;

                action(node, fieldname, context);
                if (typeof(childNode) != 'object')
                    continue;

                if (childNode instanceof Array)
                {
                    for (var i = 0; i < childNode.length; i++)
                    {
                        if (typeof(childNode[i]) == 'object')
                            visitNodes(childNode[i], action, context);
                    }
                }
                else
                {
                    visitNodes(childNode, action, context);
                }
            }
        }

        //  Node action function that removes 'labelWidth'
        //  field from given node and increments counter in context.
        function removeLabelWidthAction(node, fieldname, context)
        {
            if (fieldname == 'labelWidth')
            {
                context.defaultWidth = node[fieldname];
                delete node[fieldname];
                context.numRemoved += 1;
            }
        }

        //  Collects all field which has fieldLabels property.
        function collectFieldLabelsAction(node, fieldname, context)
        {
            if (node == undefined || typeof(node) != 'object' || fieldname != 'fieldLabel' || node[fieldname] == undefined)
                return;

            if(node[fieldname])
               context.fields.push(node[fieldname]);
        }

        // Calculates the maximum form label width using TextMetrics method.
        function calculateMaxLabelWidth(xcpPage, stepConfig, fieldLables) {
            var labelWidth = 0;  //Default label width.
            var el = xcpPage.getEl();
            var textMetrics = new Ext.util.TextMetrics(el);
            textMetrics.measure.addCls("x-form-item-label");

            var width;
            for (var i = 0; i < fieldLables.length; i++) {
                //Calculate label width in pixels.
                width = textMetrics.getWidth(fieldLables[i]);
                if (width > labelWidth)
                    labelWidth = width;
            }
            console.log("Calculated max label width: "+labelWidth);
            textMetrics.measure.removeCls("x-form-item-label");
            textMetrics.destroy();
            return labelWidth;
        }

        function getRepeatingAttributesFromPage(object) {
            var repeatingAttributes = [];

            function isRepeatingAttribute(item) {
                if (item && item.xtype && item.xtype.indexOf("xcp_multivalue") != -1) {
                    return true;
                }
                return false;
            }

            if (object) {
                if (isRepeatingAttribute(object)) {
                    repeatingAttributes.push(object.xcpId);
                }

                if (object.items) {
                    for (var i = 0; i < object.items.length; i++) {
                        if (object.items[i])
                            repeatingAttributes = repeatingAttributes.concat(getRepeatingAttributesFromPage(object.items[i]));
                    }
                }
            }
            return repeatingAttributes;
        }

        function getInputAttributesFromPage(form){
            var inputAttributesNames = [];
            form.getFields().each(function(field) {
                if (field.isFormField)
                    inputAttributesNames.push(field.name);
            });
            return inputAttributesNames;
        }

        updateNextRecord.call(this);
    },

    updateActionStepFormat: function(selectedRecords, newFormat, fileExtension)
    {
        if (!selectedRecords || !newFormat)
            return;

        var record;
        var recordsToUpdate = [];

        //  Update all the file records that need to be updated.
        //  These are the ones with the same fileExtension whose
        //  format has not yet been set or differs from newFormat
        //  Also update corresponding actionRecords.
        for (var i = 0; i < selectedRecords.length; i++)
        {
            var selectedFileRecord = selectedRecords[i];
            var extension = selectedFileRecord.get('extension');
            if (fileExtension && extension != fileExtension)
                continue;
            var format = selectedFileRecord.get('format');
            if (format == newFormat)
                continue;
            if (format == "" || format == this.uistrings.multipleExtensionsMsg)
                selectedFileRecord.set('format', newFormat);  // $NON-NLS-1$
            var actionRecord = selectedFileRecord.get('actionRecord');
            if (Ext.isObject(actionRecord) && newFormat != this.uistrings.multipleExtensionsMsg){
                console.log("File Import: Setting content type for extension=" + extension + ", content type=" + newFormat);
                actionRecord.set('a_content_type', newFormat);
            }
        }
    },

    onChangeFieldValue: function(actionRecord, field, newValue, oldValue, options)
    {
        actionRecord.set(field.name, newValue);

        if (field.name != 'object_name')
        {
            var view = this.fileListView;
            var nodes = view.getSelectedNodes();
            if (!nodes)
                return;

            var selectedRecords = view.getRecords(nodes);
            var type = actionRecord.owner.get('type');
            for (var i = 0; i < selectedRecords.length; i++)
            {
                var selectedRecord = selectedRecords[i];
//                if (selectedRecord.get('type') != type)
//                    continue;

                var selectedActionRecord = selectedRecord.get('actionRecord');
                if (!selectedActionRecord)
                    continue;

                if (selectedActionRecord.owner == actionRecord.owner)
                    continue;

                //  Update field value in selected actionRecord
                selectedActionRecord.set(field.name, newValue);
                //  Update field value on selected step page
                var stepPage = Ext.getCmp(selectedRecord.get('cardId'));
                if (!stepPage)
                    continue;

                var formPanel = stepPage.getComponent(0);
                var form = formPanel.getForm();
                var selectedField = form.findField(field.name);
                if (selectedField)
                    selectedField.setRawValue(newValue);
            }
            return;
        }
    },

    //  Update import button enablement:  enable if there is atleast one file to
    //  import and all files have a type, format, and nonempty name, otherwise disable
    updateImportBtnEnablement: function() {
        var uploadedFilerecords = this.getUploadedFileRecords();
        if (!uploadedFilerecords || uploadedFilerecords.length == 0) {
            if (!this.importBtn.isDisabled())
                this.importBtn.disable();
            return;
        }

        var enableImport = (uploadedFilerecords.length > 0);
        for (var i = 0; i < uploadedFilerecords.length; i++) {
            var uploadedFileRecord = uploadedFilerecords[i];
            var type = uploadedFileRecord.get('type');
            if (!type || type.length == 0) {
                enableImport = false;
                break;
            }
            var format = uploadedFileRecord.get('format');
            if (!Ext.isString(format) || (format == this.uistrings.noFileSelectedMsg)
                || (format == this.uistrings.selectFormatMsg) || format == "" || (format == this.uistrings.multipleExtensionsMsg)) {
                enableImport = false;
                break;
            }else if (Ext.isString(format) && (format != this.uistrings.selectFormatMsg) && format != "") {
               enableImport = true;
               uploadedFileRecord.set('status', this.filestates.UPLOADED);  // $NON-NLS-1$
            }

            var status = uploadedFileRecord.get('status');
            if (status == this.filestates.NEEDSINFO) {
                enableImport = false;
                break;
            }
        }
        if (enableImport) {
            if (this.importBtn.isDisabled())
                this.importBtn.enable();
        }
        else {
            this.importBtn.disable();
        }
    },

    updateSelection: function(selectedRecords, doUpdateFormat)
    {
        var noSelectedRecords = (!selectedRecords || selectedRecords.length == 0);
        var typeSelector = this.typeSelector;

        if (noSelectedRecords)
        {
            if (!this.initialType)
                typeSelector.setRawValue(this.uistrings.noFileSelectedMsg);
            typeSelector.setReadOnly(true);
        }
        else
        if (!this.initialType)
        {
            var record = selectedRecords[0];
            var type0  = record.get('type');
            var commonType = type0;
            var numUndefined = (type0 && type0.length > 0)  ?  0 : 1;
            for (var i = 1; i < selectedRecords.length; i++)
            {
                record = selectedRecords[i];
                var type = record.get('type');
                if (!type)
                    numUndefined += 1;
                if (type != type0)
                    commonType = undefined;
            }

            if (commonType && commonType.length > 0)
            {
                typeSelector.setValue(commonType);
            }
            else
            {
                if (selectedRecords.length > 1 && numUndefined == 0)
                    typeSelector.setRawValue(this.uistrings.multipleTypesMsg);
                else
                    typeSelector.clearValue();
            }

            typeSelector.setReadOnly(false);
        }

        if (doUpdateFormat)
        {
            var readOnlyFormatSelector = true;
            var formatSelectorCtrl = this.formatSelectorCombo;
            if (noSelectedRecords)
            {
                this.updateFormatSelectorCombo();
                formatSelectorCtrl.setRawValue(this.uistrings.noFileSelectedMsg);
            }
            else
            {
                var extension0 = selectedRecords[0].get('extension');
                var extension = extension0;
                var format = selectedRecords[0].get('format');
                var multipleExtensions = false;
                for (var i = 1; i < selectedRecords.length; i++)
                {
                    if (selectedRecords[i].get('extension') != extension0)
                    {
                        multipleExtensions = true;
                        extension = undefined;
                        format = undefined;
                    }
                }
                this.updateFormatSelectorCombo(extension, format);

                if (selectedRecords.length > 1 && multipleExtensions)
                    formatSelectorCtrl.setRawValue(this.uistrings.multipleExtensionsMsg);
                else
                {
                    readOnlyFormatSelector = false;
                    if(format == "" || (format == this.uistrings.multipleExtensionsMsg))
                        formatSelectorCtrl.setRawValue(this.uistrings.selectFormatMsg);
                }
            }
            formatSelectorCtrl.setReadOnly(readOnlyFormatSelector);
        }

        this.updateImportBtnEnablement();
        var actionFlowsPanel = this.actionFlowsPanel;

        if (noSelectedRecords)
        {
            displayPanel(actionFlowsPanel, false);
            return;
        }

        //  Update active card according to current selection
        var lastSelectedIndex = selectedRecords.length-1;
        var cardId = selectedRecords[lastSelectedIndex].get('cardId');
        if (!cardId)
            return;

        displayPanel(actionFlowsPanel, true);

        var layout = actionFlowsPanel.getLayout();
        layout.setActiveItem(cardId);
        var card = layout.getActiveItem();
        card.show();
    },

    onSubmitSuccess: function() {
        var records = this.getUploadedFileRecords();
        var numRecords = records.length;
        var targetFolderId = this.targetFolderId;

        //  Close dialog
        this.close();

        //  Notify user
        var msg = this.uistrings.importFileSucceededMsg;
        if (numRecords > 1)
            msg = Ext.String.format(this.uistrings.importFilesSucceededMsg, numRecords);

        if (xcp && xcp.core && xcp.core.FeedbackManager)
            xcp.core.FeedbackManager.showFeedback(null, '', msg, "notifications", false);

        //  Refresh target folder grid to show imported files
        if (xcp && xcp.event && xcp.event.EventBus && targetFolderId && targetFolderId.length > 0){
            xcp.event.EventBus.publish(xcp.event.ContainerChangedEvent.CONTAINER_CHANGED_EVENT, targetFolderId);
            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, targetFolderId);
        }
    },

    onSubmitFailure: function() {
        var records = this.getUploadedFileRecords();
        var numRecords = records.length;

        //  Collect successfully imported file records
        var importedRecords = [];
        for (var i = 0; i < numRecords; i++) {
            var record = records[i];
            if (record.get('status') == this.filestates.IMPORTED)
                importedRecords.push(record);
        }

        //  Remove successfully imported file records
        var numSucceeded = importedRecords.length;
        if (numSucceeded > 0)
            this.removeFiles(importedRecords);

        //  Notify user
        var numFailed = numRecords - numSucceeded;
        var msg = this.uistrings.importFileFailedMsg;
        if (numRecords > 1 && numFailed == 1)
            msg = Ext.String.format(this.uistrings.importFilesFailed1Msg, numSucceeded, numFailed);
        else
        if (numRecords > 1 && numFailed > 1)
            msg = Ext.String.format(this.uistrings.importFilesFailedMsg, numSucceeded, numFailed);

        if (xcp && xcp.core && xcp.core.FeedbackManager)
            xcp.core.FeedbackManager.showFeedback(null, '', msg, "systemErrors", false);

        //  Refresh target folder grid to show imported files
        if (xcp && xcp.event && xcp.event.EventBus && numSucceeded > 0)
            xcp.event.EventBus.publish(xcp.event.ContainerChangedEvent.CONTAINER_CHANGED_EVENT, this.targetFolderId);
    },

    submit: function()
    {
        var actionRecord, record, xcpPage;
        var records = this.getUploadedFileRecords();
        var actionRecords = [];
        for (var i = 0; i < records.length; i++)
        {
            record = records[i];
            actionRecord = record.get('actionRecord');
            if (actionRecord)
            {
                actionRecord.owner = record;
                actionRecords.push(actionRecord);
            }
            else
            {
                console.log('Skipping file that has no actionRecord, name=' + record.get('name'));
            }
        }

        if (actionRecords.length == 0)
            return;

        var currentIndex = 0;
        var numImported = 0;

        function saveNextActionRecord()
        {
            actionRecord = actionRecords[currentIndex];
            actionRecord.owner.set('status', this.filestates.IMPORTING);  // $NON-NLS-1$
            var stepPage = Ext.getCmp(actionRecord.owner.get('cardId'));
            actionRecord.save({callback: onActionRecordSaved, scope: this, feedbackContainer: this});
        }

        function onActionRecordSaved(savedRecord, operation)
        {
            var msg;
            var status;
            if (operation.success)
            {
                numImported += 1;
                status = this.filestates.IMPORTED;  // import successful
            }
            else
            {
                status = this.filestates.IMPORT_ERROR;
                console.log(Ext.String.format(this.filestateMsgFormats[status], actionRecord.owner.get('name')));
            }

            actionRecord.owner.set('status', status);  // $NON-NLS-1$

            if (++currentIndex < actionRecords.length)
            {
                saveNextActionRecord.call(this);
            }
            else
            {
                if (numImported == actionRecords.length)
                    Ext.Function.defer(this.onSubmitSuccess, 500, this);
                else
                    this.onSubmitFailure();
            }
        }

        saveNextActionRecord.call(this);
    }
});


//////////////////////////////////////////////////////////////////////////////////////////////////////
//  Model for list of files to be imported
//////////////////////////////////////////////////////////////////////////////////////////////////////
Ext.define('xcp.dialog.ImportFile.fileModel',
{
    extend: 'Ext.data.Model',
    fields:
    [
        {name: 'name', type: 'string'},
        {name: 'status', type: 'string'},
        {name: 'statusMsg', type: 'string'},
        {name: 'data', type: 'object'},
        {name: 'type', type: 'string'},
        {name: 'content_id', type: 'string'},
        {name: 'cardId', type: 'string'},
        {name: 'extension', type: 'string'},
        {name: 'format', type: 'string'},
        {name: 'actionRecord', type: 'object'}
    ]
});

//////////////////////////////////////////////////////////////////////////////////////////////////////
//  Model for type selector
//////////////////////////////////////////////////////////////////////////////////////////////////////
Ext.define('xcp.dialog.ImportFile.typeModel',
{
    extend: 'Ext.data.Model',
    fields:
    [
        {name: 'label', type: 'string'},   // e.g. 'ACME Contract'
        {name: 'value', type: 'string'},   // e.g. 'acme_contract'
        {name: 'actionId', type: 'string'} // e.g. 'import_acme_contrac'
    ]
});

//////////////////////////////////////////////////////////////////////////////////////////////////////
//  Model for format selector
//////////////////////////////////////////////////////////////////////////////////////////////////////

Ext.define('xcp.dialog.ImportFile.formatModel',
{
    extend: 'Ext.data.Model',
    fields:
    [
        {name: 'value', type: 'string'},      // e.g. 'msw8'
        {name: 'description', type: 'string'} // e.g. 'MS Word Document 8.0-2003 (Windows)'
    ]
});


function displayPanel(panel, show)
{
    if (show)
        panel.show();
    else
        panel.hide();
}

//  Insert lineDelimiters into a string so that each line has width less than the given maxWidth.
//  If lineDelimiter is missing, then '\n' is assumed.  The width of a string is measured in pixels
//  using the supplied Ext.util.TextMetrics object.  Note that this function could be slow for very
//  long strings but seems to perform well enough for dynamic tooltip messages with length < 1000.
function lineBreakString(str, metrics, maxWidth, lineDelimiter)
{
    if (!lineDelimiter)
        lineDelimiter = '\n';

    var width = metrics.getWidth(str);
    if (width < maxWidth)
        return str;

    var rb = [];
    var sp = 0;
    var sb = [str.charAt(0)];
    var wordFragment;

    for (var i = 1; i < str.length; i++)
    {
        var c = str.charAt(i);
        sb.push(c);
        if (c == ' ')
            sp = i;

        if (metrics.getWidth(sb.join('')) < maxWidth)
            continue;

        if (c != ' ' && sp > 0)
        {
            //  Don't put a line break in the middle of a word
            var i1 = i+1;
            if (i1 > str.length)
                i1 = str.length;
            wordFragment = str.substring(sp+1,i1);
            sb = sb.slice(0,sp);
        }
        else
        {
            wordFragment = sb.pop();
        }

        rb.push(sb.join(''));
        sp = 0;
        sb = [];
        sb.push(wordFragment);
    }

    if (sb.length > 0)
        rb.push(sb.join(''));

    return rb.join(lineDelimiter);
}

})();
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.dialog.ImportNewVersion");

Ext.apply(xcp.Strings.dialog.ImportNewVersion, {
    dialogTitle: "Import New Version",
    submitBtnText: "OK",
    cancelBtnText: "Cancel",
    importListToolbarLabel: "File to import",
    emptyFileListMsg: "No file to import as new version",
    formatMismatchErrorMsg: "Can not add a version with a format that's different from the original file.",
    cannotImportFileMsg: "An error occurred uploading this file:  file will not be imported as new version.",
    targetDocumentIDEmptyMsg: "An error occurred uploading this file:  Target document ID is empty.",
    addFileTooltip: "Add a file to import",
    importNewVersionSucceededMsg1: "A new version of {0} was successfully imported.",
    importNewVersionSucceededMsg2: "A new version was successfully imported",
    validateLoadingMsg: "Validating content format...",
    importFileFailedMsg: "Failed to import file",
    uploadingFile: "Uploading {0}",
    uploadedFile: "Ready to import {0}",
    needsInfoFile: "Select a content type for {0}",
    uploadErrorFile: "Could not upload {0}",
    importErrorFile: "Could not import {0}",
    importingFile: "Importing {0}",
    importedFile: "Imported {0}"
});

/* xcp_import_newversion/content/xcp/dialog/ImportNewVersion.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.dialog.ImportNewVersion
 * @extends Ext.window.Window
 * Dialog for import new version of a file
 * @xtype xcp_import_newversion
 */

(function() {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//  Import new version  dialog implementation
//////////////////////////////////////////////////////////////////////////////////////////////////////
Ext.define("xcp.dialog.ImportNewVersion",
{
    extend: 'Ext.window.Window',
    alias: 'xcp_import_newversion',
    mixins: {
        feedbackContainer: 'xcp.util.mixin.FeedbackContainer'
    },
    includeFeedbackTypes: ['systemErrors','validationErrors'],

    statics:
    {
        //  Cache of formatData keyed by file extension.
        //  Each formatDatum is requested from the server just once during the browser session.
        formatDataCache: {},
        //  File status constants.  Note that these are used as CSS class
        //  names to control which status icon is rendered for a file.
        filestates:
        {
            UPLOADING:    'uploading',
            UPLOADED:     'uploaded',
            NEEDSINFO:    'needsinfo',
            IMPORTING:    'importing',
            IMPORTED:     'imported',
            UPLOAD_ERROR: 'uploaderror',
            IMPORT_ERROR: 'importerror'
        },

        //  Reference to localized strings used by this class
        uistrings: xcp.Strings.dialog.ImportNewVersion
    },

    constructor: function(config) {
        config = config || {};
        Ext.applyIf(config,
            {
                frame: false,
                frameHeader: false,
                modal: true
            });

        var statics = this.statics();
        this.uistrings = statics.uistrings;
        this.filestates = statics.filestates;

        this.formatDataCache = statics.formatDataCache;

        var filestateMsgFormats = {};
        filestateMsgFormats[this.filestates.UPLOADING] = this.uistrings.uploadingFile;
        filestateMsgFormats[this.filestates.UPLOADED] = this.uistrings.uploadedFile;
        filestateMsgFormats[this.filestates.UPLOAD_ERROR] = this.uistrings.uploadErrorFile;
        filestateMsgFormats[this.filestates.IMPORT_ERROR] = this.uistrings.importErrorFile;
        filestateMsgFormats[this.filestates.NEEDSINFO] = this.uistrings.needsInfoFile;
        filestateMsgFormats[this.filestates.IMPORTED] = this.uistrings.importedFile;
        this.filestateMsgFormats = filestateMsgFormats;

        this.callParent(arguments);
    },

    initComponent: function() {
        //  Initialize store to store file needed to be imported as new version.
        this.importFileStore = Ext.create('Ext.data.Store',
            {
                id: 'importFileStore',
                model: 'xcp.dialog.ImportNewVersion.fileModel',
                data: []
            });

        var title = this.uistrings.dialogTitle;

        Ext.applyIf(this, {title: title,  height: 450,  width: 350,  resizable: true});

        this.refs = {
            dialogPageId: Ext.id(undefined, 'xcp_page-'),
            fileListViewId: Ext.id(undefined, 'dataview-'),
            importBtnId: Ext.id(undefined, 'button-'),
            addFileBtnId: Ext.id(undefined, 'button-')
        };

        //  Define config for dialog buttons
        var dialogButtons = [
            {
                text: this.uistrings.submitBtnText,
                listeners: {click: {fn: this.onSubmitDialog, scope: this}},
                id: this.refs.importBtnId,
                disabled: true
            },
            {
                text: this.uistrings.cancelBtnText,
                listeners: {click: {fn: this.close, scope: this}}
            }
        ];

        //  Define dialog items
        var dialogItems = [
            {
                xtype: 'panel',
                region: 'center',
                cls: 'center',
                layout: {type: 'hbox', align: 'stretch'},
                items:    this.getFileListPanelItemsAndConfig()
            }
        ];

        var dialogPage =
        {
            xtype: 'xcp_page',
            id: this.refs.dialogPageId,
            region: 'center',
            layout: 'border',
            items: dialogItems,
            listeners: {afterrender: {fn: this.onAfterRender, scope: this}}
        };

        //  Define dialog
        Ext.apply(this,
            {
                cls: 'xcp-import-newversion-dialog',
                iconCls: 'import-dialog-icon',
                bodyCls: 'body',
                layout: {type: "vbox", align:"stretch"},
                buttons: dialogButtons,
                items: [{
                    xtype:'container',
                    layout: 'border',
                    flex: 1,
                    items: [dialogPage]
                }]

            });

        this.callParent(arguments);

        if ((this.targetContentType == undefined) || (this.targetContentType == ""))
            this.getTargetObjectProps(); //get document original format.
    },

    getTargetObjectProps : function() {
        //Getting document content type using REST call.
        Ext.Ajax.request(
            {
                method: 'GET', url: Ext.String.format('application/xcp_dm_documents/{0}', this.targetObjectId),
                scope: this,
                success: function(response, options) {
                    var result = Ext.JSON.decode(response.responseText);
                    if (result != null) {
                        this.targetContentType = result.a_content_type;
                    }
                },
                failure: function(response, options) {
                    Ext.MessageBox.alert('Server Error', response.responseText);
                }
            });
    },

    //Called when user select a file to import as new version.
    onSelectFileInFileDialog: function(name) {
        // In IE8 the callback is done twice the second time with an empty string
        if(!name || name == "")
          return;

        this.importBtn.disable();
        var contentType = this.targetContentType;
        var store = this.importFileStore;
        store.suspendEvents();
        store.removeAll(true); //Remove previous selected file record from import new version file store.
        store.resumeEvents();
        store.fireEvent('refresh');

        var newFileExt = '';
        var i1 = name.lastIndexOf('.');
        if (i1 != -1)
            newFileExt = name.substr(i1 + 1);

        var isNewFileFormatSame = false;

        if (Ext.isString(newFileExt)) {
            var formatData = this.formatDataCache[newFileExt];
            if (formatData) {
                validateFormatData(formatData);
                this.enableOKButtonOrShowErrorMsg(name, newFileExt, isNewFileFormatSame);
            } else {
                var mask = new Ext.LoadMask(this, {msg: this.uistrings.validateLoadingMsg});
                mask.show();

                // Query server for formats associated with this file extension
                Ext.Ajax.request(
                    {
                        method: 'GET', url: 'application/formats?extensions=' + newFileExt, scope: this,
                        success: function(response, options) {
                            if (mask.rendered) {
                                mask.hide();
                            }
                            mask.destroy();
                            mask = undefined;
                            //  result will be a map of arrays keyed by extension, with each array
                            //  consisting of all of the formats for the associated extension
                            var result = Ext.JSON.decode(response.responseText);
                            var formatData = result[newFileExt] || result[newFileExt.toLowerCase()];
                            this.formatDataCache[newFileExt] = formatData;
                            validateFormatData(formatData);
                            this.enableOKButtonOrShowErrorMsg(name, newFileExt, isNewFileFormatSame);
                        },

                        failure: function(response, options) {
                            if (mask.rendered) {
                                mask.hide();
                            }
                            mask.destroy();
                            mask = undefined;
                            if (xcp && xcp.core && xcp.core.FeedbackManager)
                                xcp.core.FeedbackManager.showFeedback(null, '', response.responseText, "systemErrors", false);
                        }
                    });
            }
        }

        function validateFormatData(formatData) {
            if (Ext.isString(newFileExt)) {
                if (formatData) {
                    var data = [];
                    for (var i = 0; i < formatData.length; i++) {
                        if (formatData[i] && formatData[i].value == contentType) {
                            isNewFileFormatSame = true;
                            break;
                        }
                    }
                }
            }
        }
    },

    enableOKButtonOrShowErrorMsg : function(name, extension, isFormatSame) {
        if (extension != null && !isFormatSame) {
            this.importBtn.disable();
            var msg = this.uistrings.formatMismatchErrorMsg;
            if (xcp && xcp.core && xcp.core.FeedbackManager)
                xcp.core.FeedbackManager.showFeedback(this, '', msg, "validationErrors", false);
        } else {
            if (xcp && xcp.core && xcp.core.FeedbackManager){
                xcp.core.FeedbackManager.clearFeedback(this, 'xcp_validation_error_window', false);
            }
            //Add new selected file to file store.
            this.importFileStore.add({name: name, status: this.filestates.UPLOADED, data: {}});
            //Enable ok button as soon as user select a new file.
            this.updateOKBtnEnablement();
        }
    },

    getDialogConfig : function () {       //  Define dialog items
        var dialogItems = [
            {
                xtype: 'panel',
                region: 'center',
                cls: 'center',
                layout: {type: 'hbox', align: 'stretch'},
                items:    this.getFileListPanelItemsAndConfig()
            }
        ];

        var dialogPage =
        {
            xtype: 'xcp_page',
            id: this.refs.dialogPageId,
            region: 'center',
            layout: 'border',
            items: dialogItems,
            listeners: {afterrender: {fn: this.onAfterRender, scope: this}}
        };
        return dialogPage;
    },

    getFileListPanelItemsAndConfig : function() {
        //  Define items for file list panel
        var fileListPanelItems = [
            {
                xtype: 'xcp_toolbar',
                region: 'north',
                items:
                    [
                        { xtype: 'tbtext', text: '<span class="label">' + this.uistrings.importListToolbarLabel + '</span>'},
                        { xtype: 'tbfill' },
                        {
                            xtype: 'xcp_fileupload_button',
                            id: this.refs.addFileBtnId,
                            tooltip: this.uistrings.addFileTooltip,
                            tooltipType: 'qtip',
                            onFileChangedCallback: this.onSelectFileInFileDialog,
                            callbackScope: this
                        }
                    ]
            },
            {
                xtype: 'dataview',
                id: this.refs.fileListViewId,
                cls: 'import-file-list-dataview',
                region: 'center',
                store: this.importFileStore,
                tpl: new Ext.XTemplate('<tpl for=".">' +
                    '<div name="{name}" class="import-file-item">' +
                    '<span class="import-file-item-status-img {status}"></span>' +
                    '<span class="import-file-item-format-img"></span>' +
                    '<span class="import-file-item-filename">{name}</span>' +
                    '</div></tpl>'),  // $NON-NLS-L$
                name: 'import-filelist',
                itemSelector: 'div.import-file-item',
                multiSelect: false,
                autoScroll: false,
                emptyText: '<div class="import-file-item-empty">' + this.uistrings.emptyFileListMsg + '</div>',
                deferEmptyText: false
            }
        ];

        //  Define config for file list panel
        var fileListPanelConfig =
        {
            xtype: 'panel',
            name: 'fileinfo',
            cls: 'filelist-panel',
            flex: 1,
            minWidth: 0,
            layout: 'border',
            collapsible: false,
            collapseMode: 'mini',
            preventHeader: true,
            items: fileListPanelItems
        };

        return fileListPanelConfig;
    },


    onAfterRender: function() {
        //  Initialize component references from associated ids
        for (var name in this.refs) {
            var refname = name.substr(0, name.length - 2);
            this[refname] = Ext.getCmp(this.refs[name]);
        }
    },

    // Final submit of import new version file dialog.
    onSubmitDialog: function() {
        //Upload new file and submit the form with new content id.
        this.addFileBtn.upload(this, this.onUploadSuccess, this.onUploadFailure);
    },

    /**
     * This method will called after uplaoding file to app server.
     *
     * @param name - Name of file uploaded to app server.
     * @param result - upload file status status.
     */
    onUploadSuccess: function(name, result) {
        var record = this.getSelectedFileRecord(name);
        if (!record)
            return;

        this.hide();
        var status = this.filestates.UPLOAD_ERROR;
        if (result && result.id) {
            status = this.filestates.UPLOADED;
        }

        function onSubmitSuccess(response, options) {
            var result = Ext.JSON.decode(response.responseText);
            var targetContainerId = this.targetObjectId;
            var targetObjectName = this.targetObjectName;
            var sourceType = this.targetObjectType;
            var model = this.typeName;

            //  Close dialog
            this.close();

            //  Notify user
            var msg = this.uistrings.importNewVersionSucceededMsg2;
            if (targetObjectName) {
                msg = Ext.String.format(this.uistrings.importNewVersionSucceededMsg1, Ext.util.Format.trim(targetObjectName));
            } else if (result && result.name) {
                msg = Ext.String.format(this.uistrings.importNewVersionSucceededMsg1, Ext.util.Format.trim(result.name));
            }

            if (xcp && xcp.core && xcp.core.FeedbackManager) {
                xcp.core.FeedbackManager.showFeedback(null, ' ', msg, "notifications");
            }

            //  Refresh target folder grid to show imported files
            if (xcp && xcp.event && xcp.event.EventBus && (targetContainerId && targetContainerId.length > 0)) {
                xcp.event.EventBus.publish(xcp.event.ContainerChangedEvent.CONTAINER_CHANGED_EVENT, targetContainerId);
                xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, targetContainerId);
            }

            if (model != null && !xcp.util.Utils.isSupportedModel(model))
                model = "dm_document";

            if (model != null && sourceType != null && sourceType.indexOf("xcp_button") != -1) {
                url = xcp.util.Utils.makePageUrl(model, result.id, null, this);
                xcp.navigationManager.navigate(url);
            }
        }

        function onSubmitFailure(response, options) {
            var targetDocumetId = this.targetObjectId;
            var msg = this.uistrings.importFileFailedMsg;
            //Show import new dialog with system errors.
            this.show();
            if (xcp && xcp.core && xcp.core.FeedbackManager)
                xcp.core.FeedbackManager.showFeedback(null, '', msg, "systemErrors");
        }

        if (!this.targetObjectId) {
            this.show();
            xcp.core.FeedbackManager.showFeedback(null, '', this.uistrings.targetDocumentIDEmptyMsg, "systemErrors");
            return;
        }

        Ext.Ajax.request(
            {
                method: 'POST', url: Ext.String.format('application/document/{0}/content?contentToken={1}',
                this.targetObjectId, result.id),
                scope: this,
                success: onSubmitSuccess,
                failure: onSubmitFailure
            });
    },

    //On upload file fails then close the dialog and show
    onUploadFailure: function(name, action) {
        //  show dialog
        this.show();
        var msg = Ext.String.format(this.uistrings.uploadErrorFile, name);
        msg += ': ' + action.result.errorMsg;
        if (xcp && xcp.core && xcp.core.FeedbackManager)
            xcp.core.FeedbackManager.showFeedback(null, '', msg, "systemErrors", false);
    },

    //  Utility that returns the records associated with given list of nodes,
    //  filtering out those corresponding to files that were not successfully uploaded.
    getUploadedFileRecord : function(nodes) {
        var result = [];
        var view = this.fileListView;
        nodes = nodes || view.getNodes();
        var records = view.getRecords(nodes);
        if (!records)
            return result;

        return records[0];
    },

    /**
     * Returns the selected file record from import file store.
     * Import new version file store will always contains the one file.
     *
     * @param name - user selected file name.
     */
    getSelectedFileRecord: function(name) {
        var store = this.importFileStore;
        //Get the Record at the specified index.
        var record = store.getAt(0);
        if(record && record.data && record.data.name) {
          if (record.data.name == name)
            return record;
        }
        return null;
    },

    //Unable ok button as soon as user selected new file.
    updateOKBtnEnablement: function() {
        var selectedFile = this.getUploadedFileRecord();
        if (!selectedFile || selectedFile.length == 0) {
            if (!this.importBtn.isDisabled())
                this.importBtn.disable();
            return;
        }

        if (selectedFile || selectedFile.length == 1) {
            if (this.importBtn.isDisabled())
                this.importBtn.enable();
        }
    }
 });


//////////////////////////////////////////////////////////////////////////////////////////////////////
//  Model for list of files to be imported
//////////////////////////////////////////////////////////////////////////////////////////////////////
Ext.define('xcp.dialog.ImportNewVersion.fileModel',
{
    extend: 'Ext.data.Model',
    fields:
        [
            {name: 'name', type: 'string'},
            {name: 'status', type: 'string'},
            {name: 'statusMsg', type: 'string'}
        ]
});
})();

/* xcp_multivalue/content/xcp/widget/form/MultiValueInput.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

/**
 * The static model used by the child grid of MultiValueInput. 
 * Should not be used by other widgets.
 **/
Ext.define("xcp.widget.form.MultiValueInputModel", {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'value', type: "string"}
    ]
});

/*
 * The generic multi value input widget from which all other standard multi value 
 * input widgets extend. Using it without extending should not be done but will work
 * like the repeating text attribute.
 * 
 * Note: Refactor this.down to a member reference
 */
Ext.define("xcp.widget.form.MultiValueInput", {
	// Its a field container
    extend: 'Ext.form.FieldContainer',
    // it needs to function like a field
    mixins: {
        field: 'Ext.form.field.Field',
        xcpFixedFieldWidthModelMixin : 'xcp.util.mixin.FixedFieldWidthModelMixin'
    },
    alias: 'widget.xcp_multivalue_input',
    layout : "fit",
    componentCls: "xcp_multivalueinput",
    // capture the change event so data updates correctly
    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {return newValue;}
    }],

    constructor : function(config) {
		if (config) {
			 config = Ext.clone(config);
		}
        config = config || {};
        // Defaults to a text multi with a height of 150
        config.editor = config.editor || {xtype:"xcp_text_input"};
		// change a string to an object so other defaults can be set right.
		if (typeof config.editor == "string") {
			var xType = config.editor;
			config.editor = {xtype:xType};
		}
		
        config.height = config.height || 150;
        // add in the child grid and copy some of the config to the child grid
        config.items = {
            xtype : "xcp_multivalue_input_grid",
            height: config.height,
            editor: config.editor,
            columnRenderer : config.columnRenderer
        };
		
        // invoke all the super stuff
        this.callParent([config]);
        this.mixins.xcpFixedFieldWidthModelMixin.constructor.call(this, "fieldWidth");
    },
    /**
     * Sets the read-only state of this field. 
     * @param {Boolean} readOnly True to prevent the user changing the field and click the trigger.
     */
    setReadOnly: function(readOnly) {
        if (readOnly)
    	    this.bodyEl.mask();
        else
            this.bodyEl.unmask();
    },
    /*
     * Marks the widget as invalid
     * 
     * Note: even though FieldContainer has this property it has no documented way of 
     * flagging its self as invalid.
     */
    markInvalid: function () {
    	this.addCls("invalidMultiValueInput");
    },
    
    /*
     * Clear the invalid flag
     */
    clearInvalid: function() {
    	this.removeCls("invalidMultiValueInput");
    },
    /*
     * Go into the child grid, get its store, and return it as an array of values
     */
	getValue : function() {
		var store = this.down("xcp_multivalue_input_grid").getStore();
		var data = [];
		store.each(function(record){data.push(record.data.value)});
		
		return data;
	},
	/**
	 * Takes an array and translates it into the data model.
	 **/
	setValue : function(value) {
		var me = this;
		var oldValue = me.getValue();
		me.reloadData(value);
		me.fireEvent('change', me.ownerCt,value,oldValue);
	},	
	/*
	 * grabs the store and replaces its old data with the new data
	 */
	reloadData : function(value){
		var grid = this.down("xcp_multivalue_input_grid");
		grid.reloadData(value);
	},
	/**
	 * for the mixin
	 */
    initComponent: function() {
        var me = this;
        me.callParent();
        me.initField();
    },

    /**
     * Returns the {@link Ext.form.field.Field#name name} attribute of the field. This is used as the parameter name
     * when including the field value in a {@link Ext.form.Basic#submit form submit()}.
     * @return {String} name The field {@link Ext.form.field.Field#name name}
     */
	getName: function() {
		var name = this.name;
		if (Ext.isEmpty(name)) {
			name = this.getInputId();
			if (Ext.isEmpty(name)) {
				name = this.id + "-inputEl";
			}
		}
		return name;
	}
});
/**
 * The child grid, should not be used outside of the MultiValueInput widget
 */
Ext.define("xcp.widget.form.MultiValueInputGrid", {
    extend: 'Ext.grid.Panel',
    alias: 'widget.xcp_multivalue_input_grid',
    // xcpSubCmp is used within builder so that it knows this widget shouldn't be directly selectable.
    // Should be done in a different manner but it works for now, I need to review it with John
    xcpSubCmp: true,
    hideHeaders: true,

    frame: false,
    // more of sub cmp investigation
    viewConfig: {xcpSubCmp: true},
	listeners: {
		select: function () {
			var items = this.getDockedItems()[0].items;
			items.get(1).enable();
			items.get(2).enable();
			items.get(3).enable();
		},
		afterLayout: function() {
			// always disable the buttons after layout since pre user interaction no row can be selected
			var items = this.getDockedItems()[0].items;
			items.get(1).disable();		
			items.get(2).disable();
			items.get(3).disable();
		}
	},
    /*
     * Override the grids default constructor to handle the editor, column renderer, and plugins.
     */
    constructor : function(config) {
		var me = this;
		
        var column = {
            header: 'Value',
            dataIndex: 'value',
            flex: 1,
            field : config.editor
        };
        if (config.columnRenderer) {
        	column.renderer = config.columnRenderer;
        }
        me.columns = [column];

        if (!config.plugins) {
            config.plugins = [];
        }
        
		me.getStore();
        config.plugins.push(me.getCellEditing());
        config.dockedItems = me.getToolBarConfig();

        me.callParent(arguments);
		me.on("edit",me.onEdit);
    },
    /*
     * Return the grids store if it exists or create it if it doesnt 
     */
    getStore : function() {
        if (!this.store) {
            this.store = Ext.create('Ext.data.Store', {
                // autoDestroy: false,
				model: "xcp.widget.form.MultiValueInputModel",
                proxy: {
                    type: 'memory',
                    reader: {
                        type: 'json'
                    }
                }
            });
        }

        return this.store;
    },
    /*
     * Get the grids cell editor if it exists else create it.
     */
    getCellEditing : function() {
    	var editing = this.cellEditing;
    	var grid = this;
    	
        if (!editing) {
            var clicksToEdit = 2;
            if (Ext.is.iPad) {
                clicksToEdit = 1;
            }
			
			var me = this;
			var closeEdit = function () {
				me.getCellEditing().completeEdit();
			};
			
            editing = this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {
                clicksToEdit: clicksToEdit,
				listeners: {
					beforeedit: {
						fn: function() {
							Ext.getBody().addListener("scroll",closeEdit,me);
						}
					},
					edit:  {
						fn: function() {
							Ext.getBody().removeListener("scroll",closeEdit,me)
						}
					}
				},
				/* Override, most is coppied from the ext code with a few noted exceptions*/
				initCancelTriggers: function() {
					var me = this,
					grid = me.grid,
					view = grid.view;
					// changed me.cancelEdit to me.completeEdit
					view.addElListener('mousewheel', me.completeEdit, me);
					// instead of calling me.onBodyScroll we call me.completeEdit
					me.mon(view, 'bodyscroll', me.completeEdit, me);
					me.mon(grid, {
					columnresize: me.cancelEdit,
					columnmove: me.cancelEdit,
					scope: me
					}); 
				}
				/* End of copy */
			});
		}

        editing.getEditor = function() {
        	var ed = Ext.grid.plugin.CellEditing.prototype.getEditor.apply(editing, arguments);
            ed.offsets = 
            	[Ext.getBody().getScroll().left*-1,Ext.getBody().getScroll().top*-1];
            
            ed.setWidth(grid.getWidth());
			ed.field.setWidth(grid.getWidth());
        
            return ed;
        } 
        
        return editing;
    },
	/*
	 * The function to call when the user clicks the add button. It adds a new 
	 * record to the store and updates the grid.
	 */
    onAddClicked : function() {
    	// Reset the invalid state
    	this.ownerCt.clearInvalid();
    	// Complete any existing edits
    	this.getCellEditing().completeEdit();
		var store = this.getStore();
		// Create an empty record
		var rec = Ext.ModelManager.create({value:""}, "xcp.widget.form.MultiValueInputModel");
		// The function that opens up the editor for the new recored we just added.
		var addClickedFunc = function() {
			this.getEl().scrollIntoView();
			this.getCellEditing().startEditByPosition({
				row: store.getCount()-1,
				column: 0
			});
		}
		// Wrapper that uses the delay function incase it gets fired multiple times
		if (!this.addClickedTask) {
			this.addClickedTask = new Ext.util.DelayedTask(addClickedFunc, this);
		}
		this.on("afterlayout", function() {
			this.addClickedTask.delay(0);
		}, this, {single:true});
		// Add the record into the story
		store.add(rec);			
		// Invoke the wrapper now. 
		this.addClickedTask.delay(0);
    },
    /*
     * Function to invoke when the delete button is clicked. Clears the 
     * invalid flag, clears all selections, and deletes the previously 
     * selected row
     */
    onDeleteClicked : function() {
		var me = this;
    	// Clear the invalid flag whenever we delete a record
    	me.ownerCt.clearInvalid();
    	
        var selection = me.getSelectionModel();
		var store = me.getStore();
        // If we have anything selectable
        if (selection.getCount()) {
        	// Get the current selection
            var row = selection.getSelection()[0];
            // unselect everything
            selection.deselectAll();
            // remove the row from the store
            store.remove(row);
			// Fire the event so the widgets know they have a new value
			me.ownerCt.fireEvent('change', me.ownerCt);
        }
        
        var items = this.getDockedItems()[0].items;
		// special disable for firefox bug.
		items.get(1).disable();
		items.get(1).removeCls("over x-focus x-btn-focus x-btn-default-toolbar-small-focus");
		
		items.get(2).disable();
		items.get(3).disable();
    },
    /*
     * Fired when the user moves an entry up. It manipulates the store and selection state.
     */
    onUpClicked : function() {
		var me = this;
    	me.ownerCt.clearInvalid();
    	
        var selection = me.getSelectionModel();
        var store = me.getStore();
        if (selection.getCount() && store.getCount() > 1) {
            var row = Ext.clone(selection.getSelection()[0]);
            var idx = store.indexOf(row);
			// If we are on a row that can be moved up, move the row up and reselect it.
			if (idx > 0) {
				// use removeAt, remove calls removeAt(this.indexOf(o)) which is more overhead
				// we do the try catch to prevent an ext bug from crashing everything
				try {store.removeAt(idx);} catch (e) {}//do nothing
				store.insert(idx-1, row);
				selection.select(idx-1);
				// Fire the event so the widgets know they have a new value
				me.ownerCt.fireEvent('change', me.ownerCt);
			}
        } 
    },
	/*
	 * FIred when the user moves an entry down. It manipulates the store and selection state.
	 */
    onDownClicked : function() {
		var me = this;
		// Clear the invalid flag on any changes
    	me.ownerCt.clearInvalid();
    	
		var selection = me.getSelectionModel();
        var store = me.getStore();
        if (selection.getCount() && store.getCount() > 1) {
            var row = Ext.clone(selection.getSelection()[0]);
            var idx = store.indexOf(row);
			// If the selected row can be moved down do so and reset the selection
			if (idx + 1< store.getCount()) {
				// use removeAt, remove calls removeAt(this.indexOf(o)) which is more overhead
				store.removeAt(idx);
				store.insert(idx+1, row);
				selection.select(idx+1);
				me.ownerCt.fireEvent('change', me.ownerCt)
			}
        } 
    },
	/*
	 * Private function that holds the toolbar config
	 */
    getToolBarConfig : function() {
		return [{
			xtype: 'xcp_toolbar',
			dock: 'top',
			border: 0,
			componentCls : "xcp_multivalueinput_toolbar",
			items: [{
				xtype: 'button',
				text: xcp.Strings.widget.form.MultiValue.add,
				scope: this,
				cls: 'x-btn-text-icon',
				iconCls: 'multivalue-add-icon',
				handler : this.onAddClicked
			 }, {
				xtype: 'button',
				text: xcp.Strings.widget.form.MultiValue.remove,
				scope: this,
				cls: 'x-btn-text-icon',
				iconCls: 'multivalue-remove-icon',
				handler : this.onDeleteClicked
			}, {
				xtype: 'button',
				text: xcp.Strings.widget.form.MultiValue.up,
				scope: this,
				cls: 'x-btn-text-icon',
				iconCls: 'multivalue-up-icon',
				handler : this.onUpClicked
			}, {
				xtype: 'button',
				text: xcp.Strings.widget.form.MultiValue.down,
				scope: this,
				cls: 'x-btn-text-icon',
				iconCls: 'multivalue-down-icon',
				handler : this.onDownClicked
			}]
		}]
    },
	/*
	 * Reloads the stores data from an array of primative values
	 */
	reloadData: function(value){
		var data = [];

		if (null != value) {
			for (var i=0;i<value.length;i++) {
				data.push({
					value : value[i]
				});
			}
		}
		
        this.store.loadData(data);
    },
	/*
	 * Invoked when an edit to a row is completed
	 */
	onEdit: function(editor, e) {
		this.ownerCt.clearInvalid();
		
		e.record.commit();
		
		root = this.ownerCt;
		root.fireEvent("change",root,root.getValue());
	}
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.formatter.NumberFormatter");

Ext.apply(xcp.Strings.formatter.NumberFormatter, {
    invalidValue:                "The given value '{0}' is not a valid number"
});
/* xcp_number_formatter_lib/content/xcp/formatter/NumberFormatter.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
// NumberFormatter.js

(function() {
    //RegEx for the supported separator styles
    var SEPARATOR_STYLE_REGEX = "LOCALE|THSEP_COMMA_DECSEP_PERIOD|THSEP_PERIOD_DECSEP_COMMA|THSEP_SPACE_DECSEP_PERIOD";
    //RegEx for the supported negative number styles
    var NEGNUM_STYLE_REGEX = "FORMAT_MINUS_SIGN_STYLE_NONE|FORMAT_NO_SIGN_STYLE_RED|FORMAT_BRACKETS_STYLE_NONE|FORMAT_BRACKETS_STYLE_RED";
    //Mapping of separator style to thousand and decimal spearator
    var SeparatorStyleMap = {
        LOCALE : {thSep : Ext.util.Format.thousandSeparator, decSep : Ext.util.Format.decimalSeparator},
        THSEP_COMMA_DECSEP_PERIOD : {thSep : ",", decSep : "."},
        THSEP_PERIOD_DECSEP_COMMA : {thSep : ".", decSep : ","},
        THSEP_SPACE_DECSEP_PERIOD : {thSep : " ", decSep : "."}
    };
    //Mapping of negative number style to format and cls class
    var NegNumStyleMap = {
        FORMAT_MINUS_SIGN_STYLE_NONE : {format : "MINUS_SIGN", style : ""},
        FORMAT_NO_SIGN_STYLE_RED : {format : "NO_SIGN", style : "xcp-negative-number"},
        FORMAT_BRACKETS_STYLE_NONE : {format : "BRACKETS", style : ""},
        FORMAT_BRACKETS_STYLE_RED : {format : "BRACKETS", style : "xcp-negative-number"}
    };

    /**
     * Get the ext number format pattern based on the useThousandSeparator flag and decimalPrecision
     * E.g: 0,0.00
     * @param formatConfig
     */
    var getNumberFormatPattern = function(formatConfig){
        var numFormatPattern = "0";
        var useThSep = formatConfig.useThousandSeparator;
        if(useThSep !== undefined && useThSep !== null && useThSep == true){
            numFormatPattern += ',0';
        }
        var decPrecision = Ext.num(formatConfig.decimalPrecision, NaN);
        if(!isNaN(decPrecision) && decPrecision > 0){
           var decPrecisionPattern = ".";
            for(i = 0; i < decPrecision; i++){
                decPrecisionPattern += '0';
            }
            numFormatPattern += decPrecisionPattern;
        }
        return numFormatPattern;
    };

    /**
     * Resolve the separator style and map it to the thousand and decimal separators
     * @param formatConfig
     */
    var getSeparatorStyle = function(formatConfig) {
        var sepStyle = formatConfig.separatorStyle;
        if(sepStyle && sepStyle.match(SEPARATOR_STYLE_REGEX)) {
            sepStyle = SeparatorStyleMap[sepStyle];
        }
        return sepStyle;
    }

    /**
     * Resolve the negative number style and map it to the format and cls class
     * @param formatConfig
     */
    var getNegativeNumberStyle = function(formatConfig) {
        var negNumStyle = formatConfig.negativeNumberStyle;
        if(negNumStyle && negNumStyle.match(NEGNUM_STYLE_REGEX)) {
            negNumStyle = NegNumStyleMap[negNumStyle];
        }
        return negNumStyle;
    }

    /**
     * Formats the negative number based on the negative number format
     * @param value, formatConfig
     */
    var formatNegNumber = function(value, formatConfig) {
        var negNumStyle = getNegativeNumberStyle(formatConfig);
        if(negNumStyle.format == "MINUS_SIGN") {
            value = "-" + value;
        } else if (negNumStyle.format == "BRACKETS") {
            value = "(" + value + ")";
        }
        return value;
    };

    /**
     * Checks whether the given value is a valid number type.
     * @param value
     */
    var isValidNumber = function(value) {
        value = Ext.num(value, NaN);
        if(!isNaN(value)) {
            return "true";
        }
    };

    /**
     * @class xcp.formatter.NumberFormatter
     * @extends xcp.formatter.BaseFormatter
     * Number formatter.
     * This class formats a raw integer/float number based on the supplied format. The format configuration
     * includes xtype, decimal precision, separator style and negative number style properties.
     * E.g 1: 123456.789
     * Format Config: xtype : integer, decimalPrecision : 0, Separator Style: 1,000.00 Negative Number Style : (100)
     * Result: 123,456
     *
     * E.g 2: 123456.789
     * Format Config: xtype: float, decimalPrecision : 2, Separator Style: 1,000.00 Negative Number Style : (100)
     * Result: 123,456.79
     *
     * E.g 3: 123456.789
     * Format Config: xtype: percent, decimalPrecision : 0, Separator Style: 1,000.00 Negative Number Style : (100)
     * Result: 123,456%
     * @xtype xcp_number_formatter
    */
    Ext.define("xcp.formatter.NumberFormatter", {
        extend:"xcp.formatter.BaseFormatter",
        alias: ["formatter.xcp_integer_formatter", "formatter.xcp_float_formatter", "formatter.xcp_percent_formatter"],
        requires: ["Ext.util.Format"],
        config : {
            xtype:"",
            decimalPrecision:"",
            useThousandSeparator:"",
            separatorStyle: "",
            negativeNumberStyle: ""
        },

        /**
         * A Config object used for creating the instance.
         */
        initialConfig : null,

        /**
         * Constructor.
         * @param initialConfig : Number format config object, like
             "format" : {
                 "xtype" : "xcp_number_formatter",
                 "decimalPrecision" : "2",
                 "useThousandSeparator" : "true",
                 "separatorStyle" : "",
                 "negativeNumberStyle" : ""
             }
         */
        constructor: function(initialConfig) {

            this.initialConfig = initialConfig;
        },

        /**
          * Returns a formatted value.
          * @param value Input number value/Array of numbers, the number value can be integer or float
          */

        format : function(value) {
            if (value == undefined)
                return;
            var formattedNum = new Array();
            if(Ext.isArray(value)) {
                for(var i = 0; i < value.length; i++) {
                    formattedNum.push(this.formatValue(value[i]));
                }
            } else {
                formattedNum = this.formatValue(value);
            }
            return formattedNum;
        },

        /**
         * Returns a formatted value.
         * @param value Input number value, the number value can be integer or float
         */
        formatValue : function(value) {
            var formattedNum = value, orgValue = value;
            if(isValidNumber(value)) {
                var sepStyle = getSeparatorStyle(this.initialConfig);
                var thSepStr, decSepStr;
                if(sepStyle){
                    thSepStr = sepStyle.thSep;
                    decSepStr = sepStyle.decSep;
                }
                var isNegativeNum = value < 0;
                value = Math.abs(value);

                //generate the number format pattern based on useThousandSeparator and decimalPrecision
                var numFormatPattern = getNumberFormatPattern(this.initialConfig);
                //format the raw number using Ext Format.number
                var formattedNum = Ext.util.Format.number(value, numFormatPattern);

                //replace the locale based thousand separator with supplied thousandSeparator
                var numSplit = formattedNum.split(Ext.util.Format.decimalSeparator);
                var regExStr = Ext.util.Format.thousandSeparator;
                if(regExStr === ".") {
                    regExStr = '\\.';
                }                
                var findRegEx = new RegExp(regExStr, "g");
                numSplit[0] = numSplit[0].replace(findRegEx, thSepStr);
                //add supplied decimalSeparator if required
                if(1 < numSplit.length){
                    formattedNum = numSplit[0] + decSepStr + numSplit[1];
                } else {
                    formattedNum = numSplit[0];
                }

                if(isNegativeNum) {
                    formattedNum = formatNegNumber(formattedNum, this.initialConfig);
                }
                if(this.initialConfig.xtype.indexOf("xcp_percent_formatter") != -1) {
                    formattedNum = formattedNum + "%"
                }
                //add span for the cls
                var formatCls = this.getCls(orgValue);
                if(formatCls) {
                    formattedNum ='<span class="'+formatCls+'">'+ formattedNum +'</span>';  // $NON-NLS-L$ 
                }
            } else {
                console.error(Ext.String.format(xcp.Strings.formatter.NumberFormatter.invalidValue, value));
            }

            return formattedNum;
        },

        /**
         * Return the applicable css class for the formatted value, if no css class is applicable then return null.
         * @param value Input number value, the number value can be integer or float
         */
        getCls : function(value) {
            if(isValidNumber(value)) {
                if (value < 0) {
                    var negNumStyle = getNegativeNumberStyle(this.initialConfig);
                    return negNumStyle.style;
                }
            } else {
                console.error(Ext.String.format(xcp.Strings.formatter.NumberFormatter.invalidValue, value));
            }
        }

    });
})();

/* xcp_picklist/content/xcp/picklist/models/StringModel.js */

/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.picklist.models.StringModel
 * @extends Ext.data.Model
 * The model used for stores representing string picklists
 */
Ext.define("xcp.picklist.models.StringModel", {
    "extend": "Ext.data.Model",
    "idProperty": "value",
    "fields":[{
        "name":"value",
        "type":"string"
     },{
        "name":"label",
        "type":"string"
    }]
});
/* xcp_picklist/content/xcp/picklist/models/IntegerModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.picklist.models.IntegerModel
 * @extends Ext.data.Model
 * The model used for stores representing integer picklists
 */
Ext.define("xcp.picklist.models.IntegerModel", {
    "extend": "Ext.data.Model",
    "idProperty": "value",
    "fields":[{
        "name":"value",
        "type":"int"
     },{
        "name":"label",
        "type":"string"
    }]
});
/* xcp_picklist/content/xcp/picklist/models/FloatModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * @class xcp.picklist.models.FloatModel
 * @extends Ext.data.Model
 * The model used for stores representing float picklists
 */

Ext.define("xcp.picklist.models.FloatModel", {
    "extend": "Ext.data.Model",
    "idProperty": "value",
    "fields":[{
        "name":"value",
        "type":"float"
     },{
        "name":"label",
        "type":"string"
    }]
});
/* xcp_picklist/content/xcp/picklist/PicklistManager.js */

/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.picklist.PicklistManager", {
    singleton: true,
    requires: [
        "xcp.picklist.models.StringModel",
        "xcp.picklist.models.IntegerModel",
        "xcp.picklist.models.FloatModel"
    ],
    /**
     * Loads picklist data and creates actual picklist instances
     * @param {Function} [callback] The callback function invoked after picklist data has been initialized
     * @param {Object} [scope] The scope (<code>this</code> reference) in which the callback is executed.
     */
    initializePicklists: function(callback, scope) {
        var url = xcp.util.Utils.buildResourceUrl("ui/picklist", true);
        Ext.Ajax.request({
            url: url,
            async: true,
            scope: this,
            disableCaching: false,
            success: function(response, options) {
                xcp.Logger.debug("Got picklist data");
                var responseText = response.responseText;
                var data = Ext.JSON.decode(responseText);
                var gridConfig;
                var picklistData;
                var store;
                var storeId;
                for (var picklistName in data) {
                    if (data.hasOwnProperty(picklistName)) {
                        storeId = "xcp.picklist." + picklistName;
                        picklistData = data[picklistName];
                        gridConfig = Ext.apply(picklistData, {
                            autoLoad: true,
                            storeId: storeId
                        });
                        Ext.create('Ext.data.Store', gridConfig);
                    }
                }
                if (callback) {
                    callback.call(scope);
                }
            },
            failure: function(response, options) {
                xcp.Logger.log("Failed to load picklist data");
                if (callback) {
                    callback.call(scope);
                }
            }
        });
    }
});
/* xcp_report_common_library/content/xcp/widget/report/ChartReportUtil.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: Safadm
 * Date: 11/17/11
 * Time: 7:06 AM
 * To change this template use File | Settings | File Templates.
 */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.widget.report.ChartReportUtil",
{

     statics : {

        /**
         * Populates the selectedRowData object with all the fields from the selected row on the chart.
         * @param item The selected series item.
         * @param chartParent The panel which contains the ExtJS Chart,
         */
        populateSelectedRowData: function(item, chartParent){

            var fields = item.storeItem.fields;
            var keys = fields.keys;
            for( var i = 0; i < keys.length; i++ )
            {
                chartParent.selectedRowData[keys[i]] = item.storeItem.get( keys[i]);
            }
            chartParent.fireEvent("seriesselected");
        },

        // This is used for decoding the ISO unicode chars, refer to bug BAM-4712
        ENCODER: {

            isEmpty : function(val){
                if(val){
                    return ((val===null) || val.length==0 || /^\s+$/.test(val));
                }else{
                    return true;
                }
            },

            // arrays for conversion from HTML Entities to Numerical values
            arr1: ['&nbsp;','&iexcl;','&cent;','&pound;','&curren;','&yen;','&brvbar;','&sect;','&uml;','&copy;','&ordf;','&laquo;','&not;','&shy;','&reg;','&macr;','&deg;','&plusmn;','&sup2;','&sup3;','&acute;','&micro;','&para;','&middot;','&cedil;','&sup1;','&ordm;','&raquo;','&frac14;','&frac12;','&frac34;','&iquest;','&Agrave;','&Aacute;','&Acirc;','&Atilde;','&Auml;','&Aring;','&AElig;','&Ccedil;','&Egrave;','&Eacute;','&Ecirc;','&Euml;','&Igrave;','&Iacute;','&Icirc;','&Iuml;','&ETH;','&Ntilde;','&Ograve;','&Oacute;','&Ocirc;','&Otilde;','&Ouml;','&times;','&Oslash;','&Ugrave;','&Uacute;','&Ucirc;','&Uuml;','&Yacute;','&THORN;','&szlig;','&agrave;','&aacute;','&acirc;','&atilde;','&auml;','&aring;','&aelig;','&ccedil;','&egrave;','&eacute;','&ecirc;','&euml;','&igrave;','&iacute;','&icirc;','&iuml;','&eth;','&ntilde;','&ograve;','&oacute;','&ocirc;','&otilde;','&ouml;','&divide;','&oslash;','&ugrave;','&uacute;','&ucirc;','&uuml;','&yacute;','&thorn;','&yuml;','&quot;','&amp;','&lt;','&gt;','&OElig;','&oelig;','&Scaron;','&scaron;','&Yuml;','&circ;','&tilde;','&ensp;','&emsp;','&thinsp;','&zwnj;','&zwj;','&lrm;','&rlm;','&ndash;','&mdash;','&lsquo;','&rsquo;','&sbquo;','&ldquo;','&rdquo;','&bdquo;','&dagger;','&Dagger;','&permil;','&lsaquo;','&rsaquo;','&euro;','&fnof;','&Alpha;','&Beta;','&Gamma;','&Delta;','&Epsilon;','&Zeta;','&Eta;','&Theta;','&Iota;','&Kappa;','&Lambda;','&Mu;','&Nu;','&Xi;','&Omicron;','&Pi;','&Rho;','&Sigma;','&Tau;','&Upsilon;','&Phi;','&Chi;','&Psi;','&Omega;','&alpha;','&beta;','&gamma;','&delta;','&epsilon;','&zeta;','&eta;','&theta;','&iota;','&kappa;','&lambda;','&mu;','&nu;','&xi;','&omicron;','&pi;','&rho;','&sigmaf;','&sigma;','&tau;','&upsilon;','&phi;','&chi;','&psi;','&omega;','&thetasym;','&upsih;','&piv;','&bull;','&hellip;','&prime;','&Prime;','&oline;','&frasl;','&weierp;','&image;','&real;','&trade;','&alefsym;','&larr;','&uarr;','&rarr;','&darr;','&harr;','&crarr;','&lArr;','&uArr;','&rArr;','&dArr;','&hArr;','&forall;','&part;','&exist;','&empty;','&nabla;','&isin;','&notin;','&ni;','&prod;','&sum;','&minus;','&lowast;','&radic;','&prop;','&infin;','&ang;','&and;','&or;','&cap;','&cup;','&int;','&there4;','&sim;','&cong;','&asymp;','&ne;','&equiv;','&le;','&ge;','&sub;','&sup;','&nsub;','&sube;','&supe;','&oplus;','&otimes;','&perp;','&sdot;','&lceil;','&rceil;','&lfloor;','&rfloor;','&lang;','&rang;','&loz;','&spades;','&clubs;','&hearts;','&diams;'],
            arr2: ['&#160;','&#161;','&#162;','&#163;','&#164;','&#165;','&#166;','&#167;','&#168;','&#169;','&#170;','&#171;','&#172;','&#173;','&#174;','&#175;','&#176;','&#177;','&#178;','&#179;','&#180;','&#181;','&#182;','&#183;','&#184;','&#185;','&#186;','&#187;','&#188;','&#189;','&#190;','&#191;','&#192;','&#193;','&#194;','&#195;','&#196;','&#197;','&#198;','&#199;','&#200;','&#201;','&#202;','&#203;','&#204;','&#205;','&#206;','&#207;','&#208;','&#209;','&#210;','&#211;','&#212;','&#213;','&#214;','&#215;','&#216;','&#217;','&#218;','&#219;','&#220;','&#221;','&#222;','&#223;','&#224;','&#225;','&#226;','&#227;','&#228;','&#229;','&#230;','&#231;','&#232;','&#233;','&#234;','&#235;','&#236;','&#237;','&#238;','&#239;','&#240;','&#241;','&#242;','&#243;','&#244;','&#245;','&#246;','&#247;','&#248;','&#249;','&#250;','&#251;','&#252;','&#253;','&#254;','&#255;','&#34;','&#38;','&#60;','&#62;','&#338;','&#339;','&#352;','&#353;','&#376;','&#710;','&#732;','&#8194;','&#8195;','&#8201;','&#8204;','&#8205;','&#8206;','&#8207;','&#8211;','&#8212;','&#8216;','&#8217;','&#8218;','&#8220;','&#8221;','&#8222;','&#8224;','&#8225;','&#8240;','&#8249;','&#8250;','&#8364;','&#402;','&#913;','&#914;','&#915;','&#916;','&#917;','&#918;','&#919;','&#920;','&#921;','&#922;','&#923;','&#924;','&#925;','&#926;','&#927;','&#928;','&#929;','&#931;','&#932;','&#933;','&#934;','&#935;','&#936;','&#937;','&#945;','&#946;','&#947;','&#948;','&#949;','&#950;','&#951;','&#952;','&#953;','&#954;','&#955;','&#956;','&#957;','&#958;','&#959;','&#960;','&#961;','&#962;','&#963;','&#964;','&#965;','&#966;','&#967;','&#968;','&#969;','&#977;','&#978;','&#982;','&#8226;','&#8230;','&#8242;','&#8243;','&#8254;','&#8260;','&#8472;','&#8465;','&#8476;','&#8482;','&#8501;','&#8592;','&#8593;','&#8594;','&#8595;','&#8596;','&#8629;','&#8656;','&#8657;','&#8658;','&#8659;','&#8660;','&#8704;','&#8706;','&#8707;','&#8709;','&#8711;','&#8712;','&#8713;','&#8715;','&#8719;','&#8721;','&#8722;','&#8727;','&#8730;','&#8733;','&#8734;','&#8736;','&#8743;','&#8744;','&#8745;','&#8746;','&#8747;','&#8756;','&#8764;','&#8773;','&#8776;','&#8800;','&#8801;','&#8804;','&#8805;','&#8834;','&#8835;','&#8836;','&#8838;','&#8839;','&#8853;','&#8855;','&#8869;','&#8901;','&#8968;','&#8969;','&#8970;','&#8971;','&#9001;','&#9002;','&#9674;','&#9824;','&#9827;','&#9829;','&#9830;'],

            // Convert HTML entities into numerical entities
            HTML2Numerical : function(s){
                return this.swapArrayVals(s,this.arr1,this.arr2);
            },

            // HTML Decode numerical and HTML entities back to original values
            htmlDecode : function(s){

                 var c,m,d = s;

                 if(this.isEmpty(d)) return "";

                 // convert HTML entites back to numerical entites first
                 d = this.HTML2Numerical(d);

                 // look for numerical entities &#34;
                 arr=d.match(/&#[0-9]{1,5};/g);

                 // if no matches found in string then skip
                 if(arr!=null){
                     for(var x=0;x<arr.length;x++){
                         m = arr[x];
                         c = m.substring(2,m.length-1); //get numeric part which is refernce to unicode character
                         // if its a valid number we can decode
                         if(c >= -32768 && c <= 65535){
                             // decode every single match within string
                             d = d.replace(m, String.fromCharCode(c));
                         }else{
                             d = d.replace(m, ""); //invalid so replace with nada
                         }
                     }
                 }

                 return d;
            },

            // Function to loop through an array swaping each item with the value from another array e.g swap HTML entities with Numericals
            swapArrayVals : function(s,arr1,arr2){
                if(this.isEmpty(s)) return "";
                var re;
                if(arr1 && arr2){

                    // array lengths must match
                    if(arr1.length == arr2.length){
                        for(var x=0,i=arr1.length;x<i;x++){
                            re = new RegExp(arr1[x], 'g');
                            s = s.replace(re,arr2[x]); //swap arr1 item with matching item from arr2
                        }
                    }
                }
                return s;
            },

            addCharEntities : function(){

                Ext.String.resetCharacterEntities();
                var entities = {};
                for(var x =0;x<this.arr1.length;x++){
                    var m = this.arr1[x] ;
                    entities[m] = this.htmlDecode(m) ;
                }
                Ext.String.addCharacterEntities(entities);
            }
        }
    },

    getDesignTimeStore:function(config)
    {
        var xFields = config.xAxisSelectedFields || [];
        var yFields = config.yAxisSelectedFields || [];

        var slaFields = config.slaAllValues || [];
        var slaLabels = config.slaAllLabels;

        var allFields = [];
        allFields.push({name: xFields[0]});

        for (var i=0;i<yFields.length;i++)
            allFields.push({name: yFields[i], type: 'int'});

        var whereToAdd = yFields.length+1;
        for(var i=0;i<slaFields.length;i++){
            var slaName = "sla_"+(i+1);
            allFields.push({name:slaName, type: 'int'});
        }


        for (var i=allFields.length;i<10;i++)
            allFields.push({name: 'anyname'+i, type: 'int'});


        var designTimeDummyData = [
            [xcp.Strings.widget.report.Reports.sampleDataC1, xcp.Strings.widget.report.Reports.dataC11, xcp.Strings.widget.report.Reports.dataC12, xcp.Strings.widget.report.Reports.dataC13, xcp.Strings.widget.report.Reports.dataC14, xcp.Strings.widget.report.Reports.dataC15, xcp.Strings.widget.report.Reports.dataC16, xcp.Strings.widget.report.Reports.dataC17, xcp.Strings.widget.report.Reports.dataC18, xcp.Strings.widget.report.Reports.dataC19, xcp.Strings.widget.report.Reports.dataC110],
            [xcp.Strings.widget.report.Reports.sampleDataC2, xcp.Strings.widget.report.Reports.dataC21, xcp.Strings.widget.report.Reports.dataC22, xcp.Strings.widget.report.Reports.dataC23, xcp.Strings.widget.report.Reports.dataC24, xcp.Strings.widget.report.Reports.dataC25, xcp.Strings.widget.report.Reports.dataC26, xcp.Strings.widget.report.Reports.dataC27, xcp.Strings.widget.report.Reports.dataC28, xcp.Strings.widget.report.Reports.dataC29, xcp.Strings.widget.report.Reports.dataC210],
            [xcp.Strings.widget.report.Reports.sampleDataC3, xcp.Strings.widget.report.Reports.dataC31, xcp.Strings.widget.report.Reports.dataC32, xcp.Strings.widget.report.Reports.dataC33, xcp.Strings.widget.report.Reports.dataC34, xcp.Strings.widget.report.Reports.dataC35, xcp.Strings.widget.report.Reports.dataC36, xcp.Strings.widget.report.Reports.dataC37, xcp.Strings.widget.report.Reports.dataC38, xcp.Strings.widget.report.Reports.dataC39, xcp.Strings.widget.report.Reports.dataC310],
            [xcp.Strings.widget.report.Reports.sampleDataC4, xcp.Strings.widget.report.Reports.dataC41, xcp.Strings.widget.report.Reports.dataC42, xcp.Strings.widget.report.Reports.dataC43, xcp.Strings.widget.report.Reports.dataC44, xcp.Strings.widget.report.Reports.dataC45, xcp.Strings.widget.report.Reports.dataC46, xcp.Strings.widget.report.Reports.dataC47, xcp.Strings.widget.report.Reports.dataC48, xcp.Strings.widget.report.Reports.dataC49, xcp.Strings.widget.report.Reports.dataC410],
            [xcp.Strings.widget.report.Reports.sampleDataC5, xcp.Strings.widget.report.Reports.dataC51, xcp.Strings.widget.report.Reports.dataC52, xcp.Strings.widget.report.Reports.dataC53, xcp.Strings.widget.report.Reports.dataC54, xcp.Strings.widget.report.Reports.dataC55, xcp.Strings.widget.report.Reports.dataC56, xcp.Strings.widget.report.Reports.dataC57, xcp.Strings.widget.report.Reports.dataC58, xcp.Strings.widget.report.Reports.dataC59, xcp.Strings.widget.report.Reports.dataC510],
            [xcp.Strings.widget.report.Reports.sampleDataC6, xcp.Strings.widget.report.Reports.dataC61, xcp.Strings.widget.report.Reports.dataC62, xcp.Strings.widget.report.Reports.dataC63, xcp.Strings.widget.report.Reports.dataC64, xcp.Strings.widget.report.Reports.dataC65, xcp.Strings.widget.report.Reports.dataC66, xcp.Strings.widget.report.Reports.dataC67, xcp.Strings.widget.report.Reports.dataC68, xcp.Strings.widget.report.Reports.dataC69, xcp.Strings.widget.report.Reports.dataC610],
            [xcp.Strings.widget.report.Reports.sampleDataC7, xcp.Strings.widget.report.Reports.dataC71, xcp.Strings.widget.report.Reports.dataC72, xcp.Strings.widget.report.Reports.dataC73, xcp.Strings.widget.report.Reports.dataC74, xcp.Strings.widget.report.Reports.dataC75, xcp.Strings.widget.report.Reports.dataC76, xcp.Strings.widget.report.Reports.dataC77, xcp.Strings.widget.report.Reports.dataC78, xcp.Strings.widget.report.Reports.dataC79, xcp.Strings.widget.report.Reports.dataC710]
        ];

        var currentValue,newValue;
        for(var k=0;k<slaFields.length;k++){
            for(var i=0;i<designTimeDummyData.length;i++){
                currentValue = designTimeDummyData[i];
                newValue = [];
                for(var j=0;j<whereToAdd;j++){
                    newValue.push(currentValue[j]);
                }
                for(var j=0;j<slaFields.length;j++){
                    newValue.push(slaFields[j] != ""? slaFields[j] : "160");
                }
                designTimeDummyData[i] = newValue;
            }
        }

        var chartStore  = Ext.create('Ext.data.Store', {
            autoDestroy: true,
            fields: allFields,
            data:designTimeDummyData,
            proxy: {
                type: 'memory',
                reader: 'array'
            },
            sorters: [{
                property: config.sortingFieldName,
                direction: config.sortingOrder
            }]

        });

        return chartStore;
    },
    getRunTimeStore:function(config)
    {
        var storeConfig = config.store;
        var emptyStore = false;
        var columnChartStore = null;

        storeConfig = Ext.apply(storeConfig, {
                autoLoad: true,
                type: "store",
                buffered: true,
                model: config.modelName,
                storeId: config.storeId
            });

        var runtimeEmptyChartData = [[xcp.Strings.widget.report.Reports.chartHasNoData,1]];


        if (config.storeId) {

            var store = Ext.data.StoreManager.lookup(config.storeId);
            if (store)  {
               //buffered should be false in order to invoke store on load event
               store.buffered = false;
               columnChartStore = store;

            } else {

                var proxy = Ext.Object.merge({}, Ext.ModelMgr.getModel(config.modelName).getProxy());
                columnChartStore  = Ext.create('Ext.data.Store', {
                model: config.modelName,
                storeId: config.storeId,
                autoLoad: true,
                proxy: proxy
                });
            }
        }

        var currentModel = Ext.ModelMgr.getModel(columnChartStore.model);
        columnChartStore.proxy.extraParams.tg = config.timeGranularity;
        columnChartStore.proxy.extraParams.appNamespace = config.appNamespace;
        columnChartStore.proxy.extraParams.relative_last_time = config.timeFilter;
        columnChartStore.pageSize=100;


        var slaValues =config.slaAllValues;

        if(slaValues)
            for(var i=0;i<slaValues.length;i++){
                var slaParam = 'sla_'+(i+1);
                columnChartStore.proxy.extraParams[slaParam] = slaValues[i];
                currentModel.prototype.fields.add(Ext.create("Ext.data.Field", {name: 'sla_'+(i+1), type: 'int'}));
            }


        return columnChartStore;
    },
    resolvePickListValue: function(field, value, config) {

        var xFields = config.xAxisFields?config.xAxisFields:[];
        var yFields =  config.yAxisFields?config.yAxisFields:[];
        var xFieldTypes = config.xAxisFieldsValueType?config.xAxisFieldsValueType:[];
        var yFieldTypes = config.yAxisFieldsValueType?config.yAxisFieldsValueType:[];
        var allFields =   xFields.concat(yFields);
        var allFieldTypes =  xFieldTypes.concat(yFieldTypes);

        var  index = Ext.Array.indexOf(allFields, field);
        if (index >-1){

            if ( allFieldTypes.length > index ){

                var fieldType =  allFieldTypes[index];

                if (fieldType && fieldType.length) {
                    var store = Ext.data.StoreManager.lookup(fieldType);
                    if (store) {
                        var index = store.find("value", value, 0, false, true, true);
                        if (index != -1) {
                            var record = store.getAt(index);
                            value = record.get("label");
                        }
                    }
                }
            }
        }
        return value;
    },

    formatValue: function(config, field, value) {
        var me = this;
        var config = me.config;
        var formatter = null;
        var fieldFormat = null;
        if (value !== undefined && value !== null && value !== "") {

            fieldFormat = config[field + '_format'];

            if(fieldFormat) {
                formatter = xcp.core.FormatManager.create(fieldFormat);
            }
            if (formatter) {
                return formatter.format(value);
            }
        }
        return value;
    },

    /**
     * Apply formatting if configured
     * @param value value to resolve
     */
    formatValue: function(config, field, value) {
        var formatter = null;
        var fieldFormat = null;
        if (value !== undefined && value !== null && value !== "") {

            fieldFormat = config[field + '_format'];

            if(fieldFormat) {
                formatter = xcp.core.FormatManager.create(fieldFormat);
            }
            if (formatter) {
                return formatter.format(value);
            }
        }
        return value;
    },

    loadDummyStore: function(xFields, yFields, store, defaultValue) {
        for(var xFieldsIndex in xFields) {
            store.data.items[0].data[xFields[xFieldsIndex]]  =  xcp.Strings.widget.report.Reports.chartHasNoData;
        }
        for(var yFieldsIndex in yFields) {
           store.data.items[0].data[yFields[yFieldsIndex]]  = defaultValue;
        }
    },

    onPlaceLabelForColumnChart: function(me, label, storeItem, item, i, display, animate, j, index) {
         // Determine the label's final position. Starts with the configured preferred value but
        // may get flipped from inside to outside or vice-versa depending on space.
        var opt = me.bounds,
            groupBarWidth = opt.groupBarWidth,
            column = me.column,
            chart = me.chart,
            chartBBox = chart.chartBBox,
            resizing = chart.resizing,
            xValue = item.value[0],
            yValue = item.value[1],
            attr = item.attr,
            config = me.label,
            rotate = config.orientation == 'vertical',
            field = [].concat(config.field),
            format = config.renderer,
            text = format(field[index], storeItem.get(field[index])),
            size = me.getLabelSize(text),
            width = size.width,
            height = size.height,
            zero = opt.zero,
            outside = 'outside',
            insideStart = 'insideStart',
            insideEnd = 'insideEnd',
            offsetX = 10,
            offsetY = 6,
            signed = opt.signed,
            x, y, finalAttr;

        label.setAttributes({
            text: text
        });

        label.isOutside = false;
        if (column) {
            if (display == outside) {
                if (height + offsetY + attr.height > (yValue >= 0 ? zero - chartBBox.y : chartBBox.y + chartBBox.height - zero)) {
                    display = insideEnd;
                }
            } else {
                if (height + offsetY > attr.height) {
                    display = outside;
                    label.isOutside = true;
                }
            }
            x = attr.x + groupBarWidth / 2;
            y = display == insideStart ?
                    (zero + ((height / 2 + 3) * (yValue >= 0 ? -1 : 1))) :
                    (yValue >= 0 ? (attr.y + ((height / 2 + 3) * (display == outside ? -1 : 1))) :
                                   (attr.y + attr.height + ((height / 2 + 3) * (display === outside ? 1 : -1))));
        }
        else {
            if (display == outside) {
                if (width + offsetX + attr.width > (yValue >= 0 ? chartBBox.x + chartBBox.width - zero : zero - chartBBox.x)) {
                    display = insideEnd;
                }
            }
            else {
                if (width + offsetX > attr.width) {
                    display = outside;
                    label.isOutside = true;
                }
            }
            x = display == insideStart ?
                (zero + ((width / 2 + 5) * (yValue >= 0 ? 1 : -1))) :
                (yValue >= 0 ? (attr.x + attr.width + ((width / 2 + 5) * (display === outside ? 1 : -1))) :
                (attr.x + ((width / 2 + 5) * (display === outside ? -1 : 1))));
            y = attr.y + groupBarWidth / 2;
        }
        //set position
        finalAttr = {
            x: x,
            y: y
        };
        //rotate
        if (rotate) {
            finalAttr.rotate = {
                x: x,
                y: y,
                degrees: 270
            };
        }
        //check for resizing
        if (animate && resizing) {
            if (column) {
                x = attr.x + attr.width / 2;
                y = zero;
            } else {
                x = zero;
                y = attr.y + attr.height / 2;
            }
            label.setAttributes({
                x: x,
                y: y
            }, true);
            if (rotate) {
                label.setAttributes({
                    rotate: {
                        x: x,
                        y: y,
                        degrees: 270
                    }
                }, true);
            }
        }
        //handle animation
        if (animate) {
            me.onAnimate(label, { to: finalAttr });
        }
        else {
            label.setAttributes(Ext.apply(finalAttr, {
                hidden: false
            }), true);
        }
    },

    createEmptyStore: function(modelName, runtimeEmptyChartData, xFields, yFields, defaultValue) {
        var newStore = null
        newStore = Ext.create('Ext.data.Store', {
        model: modelName,
        storeId: 'empty_store',
         autoLoad: false,
         proxy: Ext.apply({}, Ext.ModelMgr.getModel(modelName).getProxy())
        });

        newStore.loadData(runtimeEmptyChartData);

        this.loadDummyStore(xFields, yFields, newStore, defaultValue);

        return newStore;
    }
});





/* xcp_report_common_library/content/xcp/widget/report/ChartLegendUtil.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: docadmin
 * Date: 3/25/12
 * Time: 4:15 PM
 * To change this template use File | Settings | File Templates.
 */

Ext.define("xcp.widget.report.ChartLegendUtil",
    {
        getSeriesProp:function(series, idx) {
            var val = series['yField'];
            return (Ext.isArray(val) ? val[idx] : val);
        } ,

        getLegendPanel:function(chartsItems, legendLabels, legendColors, hasListeners){
            var allLabelsLength = 0;
            for(var i = 0; i < legendLabels.length; i++){
                allLabelsLength += legendLabels[i].length * 5;
                allLabelsLength += 35;
            }
            var legendItems = [];

            var relY = 5;
            var totalHeight = legendColors.length * 25 + relY;

            var drawComponent = Ext.create('Ext.draw.Component', {
                viewBox: false,
                width: 120,
                height: totalHeight,
                align:'center',
                border: false,
                xcpSubCmp: true,
                cls: 'xcp-chart-subcmp',
                renderTo: document.body
            }), surface = drawComponent.surface;


            for(var i=0;i<legendColors.length;i++){
                legendItems.push(this.getRect(i,legendColors[i],chartsItems,relY,hasListeners));
                var legendLabel = this.getText(i,legendLabels[i],chartsItems,(relY),hasListeners);
                relY += 25;
                legendItems.push(legendLabel);
            }
            surface.add(legendItems);

// Get references to my groups
            rectangles = surface.getGroup('rectangles');
            labels = surface.getGroup('labels');
// Animate the rectangles across
            rectangles.animate({});
            labels.animate({});

            var legendPanel = Ext.create('Ext.panel.Panel', {
                width: 130,
                height: totalHeight + 5,
                border: false,
                xcpSubCmp: true,
                cls: 'xcp-chart-legend-panel',
                layout: {
                    type: 'hbox',
                    align: 'middle'
                },
                items: drawComponent
            });
            return legendPanel;
        } ,

        getText:function(idx,legendLabel,chartsItems,relY,hasListeners) {
            var me = this;

            var subStrLegendLabel = legendLabel;
            if(legendLabel.length > 10)
                subStrLegendLabel = legendLabel.substr(0,10);
            return {
                index:idx,
                type:'text',
                text: subStrLegendLabel,
                width: subStrLegendLabel * 50,
                height: 12,
                font:'10px Helvetica, Arial, Sans-serif',
                fill: '#707070',
                x:25,
                y: (relY + 5),
                group: 'labels',
                toggle: false,
                listeners: me.getTextFunctions(chartsItems,hasListeners,idx)
            };
        } ,

        getTextFunctions:function(chartsItems,hasListeners,idx){
            if(!hasListeners){
                return {};
            }
            else{
                return {
                click: {
                    fn: function(){
                        for(var i=0;i<chartsItems.length;i++){
                            var series = chartsItems[i].series.items[0];
                            var val = series['yField'];
                            series._index = this.index;

                            if (!this.toggle) {
                                series.hideAll();
                            } else {
                                series.showAll();
                            }
                        }
                        if (!this.toggle) {
                            this.setStyle({
                                opacity: 0.5
                            });
                        } else {
                            this.setStyle({
                                opacity: 1.0
                            });
                        }
                        this.toggle = !this.toggle;
                    }
                },
                mouseover: {
                    fn: function(){
                        this.setStyle('font-weight','bolder');
                        for(var i=0;i<chartsItems.length;i++){
                            var series = chartsItems[i].series.items[0];
                            var val = series['yField'];
                            series._index = this.index;
                            series.highlightItem();
                        }
                    }
                },
                mouseout: {
                    fn: function(){
                        this.setStyle('font-weight','normal');
                        for(var i=0;i<chartsItems.length;i++){
                            var series = chartsItems[i].series.items[0];
                            var val = series['yField'];
                            series._index = this.index;
                            series.unHighlightItem();
                        }
                    }
                }
            };
            }
        } ,

        getRect:function(idx,legendColor,chartsItems,relY,hasListeners) {
            var me = this;
            return {
                index:idx,
                type: 'rect',
                width: 12,
                height: 12,
                fill: legendColor,
                x: 10,
                y: relY,
                group: 'rectangles',
                listeners: me.getRectFunctions(chartsItems,hasListeners,idx)
            };
        } ,

        getRectFunctions:function(chartsItems,hasListeners,idx){
            if(!hasListeners){
                return {};
            }
            else{
                return {
                click: {
                    fn: function(){
                        var myLabel = this.surface.getGroup('labels').items[idx];
                        for(var i=0;i<chartsItems.length;i++){
                            var series = chartsItems[i].series.items[0];
                            series._index = this.index;
                            if (!myLabel.toggle) {
                                series.hideAll();
                            } else {
                                series.showAll();
                            }
                        }
                        if (!myLabel.toggle) {
                            myLabel.setStyle({
                                opacity: 0.5
                            });
                        } else {
                            myLabel.setStyle({
                                opacity: 1.0
                            });
                        }
                        myLabel.toggle = !myLabel.toggle;
                    }
                },
                mouseover: {
                    fn: function(){
                        this.setStyle('cursor','pointer');
                        this.surface.getGroup('labels').items[idx].setStyle('font-weight','bolder');
                        for(var i=0;i<chartsItems.length;i++){
                            var series = chartsItems[i].series.items[0];
                            series._index = this.index;
                            series.highlightItem();
                        }
                    }
                },
                mouseout: {
                    fn: function(){
                        this.setStyle('cursor','default');
                        this.surface.getGroup('labels').items[idx].setStyle('font-weight','normal');
                        for(var i=0;i<chartsItems.length;i++){
                            var series = chartsItems[i].series.items[0];
                            series._index = this.index;
                            series.unHighlightItem();
                        }

                    }
                }
            };
            }
        }


    });/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.override(Ext.form.field.Base, {
    labelSeparator: ":"
});

Ext.override(Ext.form.FieldContainer, {
    labelSeparator: ":"
});

Ext.apply(Ext.form.field.Date.prototype, {
	invalidText:"{0} is not a valid date - it must be in the format {1}"
});

Ext.apply(Ext.form.field.Time.prototype, {
	invalidText:"{0} is not a valid time"
});

Ext.apply(Ext.picker.Month.prototype, {
    okText: "OK"
});

Ext.apply(Ext.picker.Date.prototype,{
	ariaTitle: "Date Picker {0}"
});
/* xcp_signin/content/xcp/util/SignInNlsUtil.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// Placeholder for handling sign-in locale patching of extjs in JavaScript.
// The NLS file is ExtjsPatch-strings.js
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.util.SignInUtil");

Ext.apply(xcp.Strings.util.SignInUtil, {
    authenticationFailed: "Sign in failed. Check your user name and password.",
    badRoleConfiguration: "To access this application you must first be assigned to a role. Please contact your administrator.",
    userPasswordRequired: "Both user name and password are required.",
    dialogTitle: "Sign In",
    submitButton: "Sign In",
    userName: "User name",
    password: "Password",
    helpLink: "Problems Signing In?"
});

/* xcp_signin/content/xcp/util/SignInUtil.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.util");

/**
 * @class xcp.util.SignInUtil
 * Utility class for managing the Sign In page.
 * @singleton
 */
xcp.util.SignInUtil = function() {
    
    return {
        /**
         * Initializes the state of the Sign In panel.
         * @param signInPanel {Object} The Sign In panel.
         */
        initUI: function(signInPanel) {
            // Register entry key handler
            new Ext.KeyNav(signInPanel.getEl(), {
                enter: xcp.util.SignInUtil.signIn
            });

            // Auto populate the user name if there is one.
            var userNameField = Ext.getCmp("j_username");
            var userName = Ext.util.Cookies.get("xcp-username");
            if (userName != null) {
                userNameField.setValue(userName);
            }

            // Set the focus accordingly.
            if (userNameField.getValue().length == 0) {
                userNameField.focus('', 10);
            }
            else {
                Ext.getCmp("j_password").focus('', 10);
            }

            // Check if the page is loaded after an authentication failure
            if (xcp.util.SignInUtil.hasAuthenticationError()) {
                this.updateMessage(xcp.Strings.util.SignInUtil.authenticationFailed);
            }
            else if (xcp.util.SignInUtil.hasRoleError()) {
                this.updateMessage(xcp.Strings.util.SignInUtil.badRoleConfiguration);
            }
            else {
                this.updateMessage(null);
            }
        },

        /**
         * Checks if there is an authentication error.
         * @return {Boolean} True if there is an authentication error. False, otherwise.
         */
        hasAuthenticationError: function() {
            return (xcp.util.SignInUtil.getWindow().location.search.indexOf("auth-error") != -1);
        },

        /**
         * Checks if there is a role authorization error.
         * @return {Boolean} True if there is a role authorization error.
         */
        hasRoleError: function() {
            return (xcp.util.SignInUtil.getWindow().location.search.indexOf("role-error") != -1);
        },

        /**
         * Update the message area on this page with the message.
         * This method hides the message are if the message is null or empty string.
         * @param msg {String} The message to show in the message area.
         */
        updateMessage: function(msg) {
            var msgDiv = Ext.get("msg-area");
            if (msg != null && msg.length > 0) {
                msgDiv.update(msg);
                msgDiv.show();
            } else {
                msgDiv.update("");
                msgDiv.hide();
            }
        },

        /**
         * Submits the form containing user name and password to Spring Security for authentication
         * if both user name and password are supplied. Otherwise, show a message informing user
         * that user name and password are required.
         */
        signIn: function() {
            var userNameField = Ext.getCmp("j_username");
            var passwordField = Ext.getCmp("j_password");

            if (userNameField.getValue().length > 0 && passwordField.getValue().length > 0) {
                Ext.util.Cookies.set("xcp-username", userNameField.getValue());
                var queryString = window.location.search;
                if (!queryString) {
                    queryString = "";
                }
                //Remove auth-error or role-error from the query string
                queryString = queryString.replace("?auth-error","");
                queryString = queryString.replace("?role-error","");

                var signInForm = document.forms[0];
                var loginHash = Ext.util.Cookies.get("xcp-login-hash");
                if (!loginHash || loginHash.length==0) {
                    loginHash="#";
                }
                //XCPUIC-1930, the cookie value of xcp-login-hash changes to
                //%2523application/customer_view from %23application/customer_view.
                //It is unclear when and where this happens. Usually, the browser has
                // to be continuously used for server days. In order to avoid 404 error
                // here, change %23 to # if the loginHash starts with '%23'. Ugly.
                else if (loginHash.indexOf('%23') == 0) {
                    loginHash = loginHash.replace('%23', '#');
                }
                Ext.core.DomHelper.append(signInForm, {
                    tag: "input",
                    type: "hidden",
                    name: "spring-security-redirect",
                    value: "/" +queryString+ loginHash
                });
                signInForm.action="j_spring_security_check";
                signInForm.submit();
            }
            else {
                xcp.util.SignInUtil.updateMessage(xcp.Strings.util.SignInUtil.userPasswordRequired);
            }
        },

        getWindow: function() {
            return window;
        }
    }
}();



/* xcp_startup/content/xcp/Startup.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp");
/**
 * Provide a dummy console API for browsers that don't have one.
 */
if (typeof window.console == "undefined") {
    window.console = {
        log: Ext.emptyFn,
        error: Ext.emptyFn,
        warn: Ext.emptyFn,
        info: Ext.emptyFn,
        debug: Ext.emptyFn
    };
}
else if (!window.console.debug && window.console.log) {
    window.console.debug = window.console.log;
}

/**
 * A application startup class, responsible for loading
 * - Component configuration and content
 * - Initializing User profile, themes, event and navigation manager.
 *
 */
if (!xcp.Startup) {
(function() {
    // the application is going to start when the counter reaches zero during the initialization stage
    var readyCounter = 0;
    function decCounter() {
        readyCounter--;
    }

    Ext.define("xcp.Startup", {
        singleton: true,
        appConfig: null,

        /**
         * This method gets called as a response to Ext.onReady and so it is a entry point for xcp application
         * initialization.
         * @param appConfig
         */
        start : function(appConfig) {
            xcp.Logger.initLogging();
            xcp.Logger.debug("Starting application config with ", appConfig);
            this.appConfig = appConfig || {};
            this.loadUserDetails();
        },
        /**
         * Load Current user details
         */
        loadUserDetails: function() {
            Ext.Ajax.request({
                url: "application/currentUser",
                async: true,
                scope: this,
                success: function(response, options) {
                    xcp.Logger.debug("Got current user details");
                    var responseText = response.responseText;
                    xcp.currentUser = Ext.JSON.decode(responseText);
                    this.loadComponents();
                },
                failure: function(response, options) {
                    console.log("Failed to load current user details");
                    this.loadComponents();
                }
            });
        },
        /**
         * Load component configuration and content.
         */
        loadComponents : function() {
            var componentLoadMode = null;
            if (this.appConfig && this.appConfig.componentLoadMode) {
                componentLoadMode = this.appConfig.componentLoadMode;
            }
            xcp.Logger.debug("Loading components with mode", componentLoadMode);
            //Ext messes up the namespace if we try to reload the same component def.
            Ext.ClassManager.enableNamespaceParseCache = false;
            //Check if it is a development mode, then load all widgets one by one
            if (componentLoadMode && (componentLoadMode == 'development' || componentLoadMode == 'ondemand')) {  // $NON-NLS-L$ 
                xcp.core.ComponentManager.init(componentLoadMode, this.onComponentsLoad, this);
            } else {
                var url = xcp.util.Utils.buildComponentUrl("js", null, null, this.appConfig.nominify);
                Ext.Loader.injectScriptElement(url, this.onComponentsLoad, this.onError, this);
            }
        },
        /**
         * Component content load handler.
         */
        onComponentsLoad: function() {
            xcp.Logger.debug("Components load completed...");
            Ext.ClassManager.enableNamespaceParseCache = true;
            Ext.Component.mixin('xcphidden', xcp.util.mixin.SetHiddenMixin);
            xcp.event.EventManager.init();
            this.initModels();
            this.initExpressions();
            this.initUserProfile();
        },
        /**
         * Application models loader.
         */
        initModels : function() {
            var modelsUrl = xcp.util.Utils.buildResourceUrl("/js/Models.js");
            Ext.Loader.injectScriptElement(modelsUrl, this.onModelsLoad, this.onError, this);
        },
        /**
         * Application expressions loader.
         */
        initExpressions : function() {
            var expressionUrl = xcp.util.Utils.buildResourceUrl("/js/Expressions.js");
            Ext.Loader.injectScriptElement(expressionUrl, this.onExpressionsLoad, this.onError, this);
        },

        /**
         * User profile initializer
         */
        initUserProfile : function() {

            xcp.core.UserProfile.initProfile(this.initUserPreferences, this);
        },

        initUserPreferences : function() {
            readyCounter++;

            var me = this;
            function setUserPreferences() {
                if (!Ext.isDefined(xcp.data.model.UserPreferences)) {
                    // wait for Models.js to be loaded.
                    return setTimeout(setUserPreferences, 10);
                }

                var userPreferencesModel = Ext.ModelManager.getModel("xcp.data.model.UserPreferences");
                userPreferencesModel.load("", {
                    callback : decCounter,
                    success: function(instance)  {
                        xcp.UserPreferences = instance;
                    },
                    error: me.onError
                });
            }

            setUserPreferences();
            this.initPicklists();
        },

        /*
         * Picklist initializer
         */
        initPicklists : function() {
            readyCounter++;
            xcp.picklist.PicklistManager.initializePicklists(decCounter, this);
            this.initFacets();
        },
        /**
         * Facet initializer
         */
        initFacets: function() {
            readyCounter++;
            xcp.facets.FacetManager.initializeFacets(decCounter, this);
            this.initApplicationParameters();
        },
        /**
         * Initialize application parameters cache
         */
        initApplicationParameters: function() {
            readyCounter++;
            xcp.core.ApplicationParameterManager.initAppParameters(decCounter, this);
            this.initActionManager();
        },
        /*
         * ActionManager initializer
         */
        initActionManager : function() {
            readyCounter++;
            xcp.core.ActionManager.init(decCounter, this);
            this.initTypeManager();
        },
        /*
         * TypeManager initializer
         */
        initTypeManager : function() {
            readyCounter++;
            xcp.core.TypeManager.initTypeManager(decCounter, this);
            this.initTheme();
        },
        /**
         * Theme initializer
         */
        initTheme : function() {
            xcp.Logger.debug("User profile initializtion completed");
            xcp.core.ThemeManager.initThemes();
            xcp.core.ThemeManager.loadDefaultTheme(this.loadCustomTheme, this);
        },

        loadCustomTheme: function() {
             xcp.core.ThemeManager.loadCustomTheme(this.loadComponentCss, this);
        },
        /**
         * Load component Css
         */
        loadComponentCss : function() {
            xcp.Logger.debug("Loading components css");
            var url = xcp.util.Utils.buildComponentUrl("css");

            readyCounter++;
            xcp.core.CSSManager.loadStyleSheet(url, null, false, decCounter, this);
            this.initView();
        },
        /**
         * XCP application view port and navigation initializer.
         */
        initView : function() {
            var me = this;
            function start() {
                if (readyCounter > 0) {
                    setTimeout(start, 5);
                    return;
                }
                xcp.Logger.debug("Theme initialization completed.");
                xcp.Logger.debug("Initializing application view...");
                var appMaster = new xcp.widget.Page({
                    id:'_topPageContainer',

                    // force overflow styling for size measurement
                    autoScroll: false,
                    overflowX: "visible",
                    overflowY: "visible",

                    includeFeedbackTypes: [
                        'systemErrors',
                        'notifications',
                        'validationErrors'
                    ]
                });

                new Ext.Viewport({
                    cls:'xcp-viewport',

                    // enable vertical scrolling.
                    overflowY: "auto",

                    // force overflow-x styling to support miniWidth
                    overflowX: "auto",
                    xcpMinWidth: 1024, // internal constant for min width; extjs won't enforce minWidth at this container level

                    items: [{
                        xtype: 'container',
                        id: '_scrollContainer',

                        // force overflow styling for size measurement
                        autoScroll:false,
                        overflowX: "visible",
                        overflowY: "visible",

                        items: appMaster
                    }],

                     xhooks: {
                        beforeLayout: function() {
                            // Need to hook this to fix the problem which once the scrollbar is shown
                            // it never go away regardless of the the browser size
                            var xcpMinWidth = this.xcpMinWidth;
                            if (xcpMinWidth) {
                                var scrollContainer = Ext.getCmp('_scrollContainer'),
                                    el = scrollContainer.el;
                                if (scrollContainer.rendered) {
                                    // always clear the width followed by a read to force a browser re-flow for accurate width measurement.
                                    el.dom.style.width = '';  // write
                                    if (el.getWidth() < xcpMinWidth) { // read
                                        el.setWidth(xcpMinWidth);  // force minWidth
                                    }
                                }
                            }

                            return this.callParent(arguments);
                        }
                    }

                });

                me.initNavigation();
            }
            start();
        },
        initNavigation : function() {
            xcp.navigationManager = new xcp.core.NavigationManager();
        },
        onError : function(error) {
            xcp.Logger.error(error);
        },
        onModelsLoad : function() {
             xcp.Logger.debug("Models.js loaded");
        },
        onExpressionsLoad : function() {
             xcp.Logger.debug("Expressions.js loaded");
        }
    });
})();
}


/* xcp_test_utility/content/xcp/util/TestUtility.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
(function() {

    // the pattern for xtype
    var xTypeMatchPattern = /^xcp_/;

    // the suffix for the css class that will be appended to the xtype.
    var cssSuffix = "-cls";

    Ext.ComponentMgr.all.on("add", function(map, key, component) {
        if (component) {
            var xtype = component.getXType();
            if (xtype && xTypeMatchPattern.test(xtype)) {
                component.addCls(xtype + cssSuffix);
            }
        }
    });
})();
/* JSFunction-absFloat/content/xcp/core/mathematical/abs.js */

// absFloat.js
Ext.namespace ('xcp.functions');

/*
 * Returns the absolute value of the number supplied as an argument.
 * 
 * Example:
 * 		abs (-1.36) 
 * 		returns 1.36
 * 
 * 		abs (-100)
 * 		return 100
 */
xcp.functions.abs = function (num) {
	return num > 0 ? num : num * -1;
}
/* JSFunction-absInteger/content/xcp/core/mathematical/abs.js */

// absFloat.js
Ext.namespace ('xcp.functions');

/*
 * Returns the absolute value of the number supplied as an argument.
 * 
 * Example:
 * 		abs (-1.36) 
 * 		returns 1.36
 * 
 * 		abs (-100)
 * 		return 100
 */
xcp.functions.abs = function (num) {
	return num > 0 ? num : num * -1;
}
/* JSFunction-addDays/content/xcp/core/date/addDays.js */

// addDays.js
Ext.namespace ('xcp.functions');

/*
 * Returns the DateTime produced after adding the number of days specified by days.
 *
 * Note: The argument days can be a negative number which indicates subtraction.
 * 
 * Example:
 * 		Get the DateTime 10 days prior to today.
 * 
 *		Assume now() returns the DateTime representation of January 30, 2012 11:56:57 PM
 * 
 * 		addDays (now(), -10) 
 *		returns the DateTime representation of January 20, 2012 11:56:57 PM
 */
xcp.functions.addDays = function (date, days) {
	if (!date)
		return '';
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
		date = new Date(date); // In case the variable date is not a Date object
		date.setDate(date.getDate() + days);
		return date;
	} catch (e) {
		xcp.Logger.error('Unable to perform addDays function - ' + date);
		return '';
	}
}
/* JSFunction-addHours/content/xcp/core/date/addHours.js */

// addHours.js
Ext.namespace ('xcp.functions');

/*
 * Returns the DateTime produced after adding the number of hours specified by hours.
 *
 * Note: The argument hours can be a negative number which indicates subtraction.
 * 
 * Example:
 * 		Get the DateTime 3 hours from now.
 * 
 *		Assume now() returns the DateTime representation of January 30, 2012 11:56:57 PM
 * 
 * 		addHours (now(), 3) 
 *		returns the DateTime representation of January 31, 2012 2:56:57 AM
 */
xcp.functions.addHours = function (date, hours) {
	if (!date)
		return '';
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
		date = new Date(date); // In case the variable date is not a Date object
		date.setHours(date.getHours() + hours);
		return date;
	} catch (e) {
		xcp.Logger.error('Unable to perform addHours function - ' + date);
		return '';
	}
}
/* JSFunction-addMinutes/content/xcp/core/date/addMinutes.js */

// addMinutes.js
Ext.namespace ('xcp.functions');

/*
 * Returns the DateTime produced after adding the number of minutes specified by minutes. 
 *
 * Note: The argument minutes can be a negative number which indicates subtraction.
 * 
 * Example:
 * 		Get the DateTime 30 minutes from now.
 * 
 *		Assume now() returns the DateTime representation of January 31, 2012 12:02:23 AM
 * 
 * 		addMinutes (now(), 30)
 *		returns the DateTime representation of January 31, 2012 12:32:23 AM
 */
xcp.functions.addMinutes = function (date, minutes) {
	if (!date)
		return '';
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
		date = new Date(date); // In case the variable date is not a Date object
		date.setMinutes(date.getMinutes() + minutes);
		return date;
	} catch (e) {
		xcp.Logger.error('Unable to perform addMinutes function - ' + date);
		return '';
	}
}
/* JSFunction-addSeconds/content/xcp/core/date/addSeconds.js */

// addSeconds.js
Ext.namespace ('xcp.functions');

/*
 * Returns the DateTime produced after adding the number of seconds specified by seconds. 
 *
 * Note: The argument seconds can be a negative number which indicates subtraction.
 * 
 * Example:
 * 		Get the DateTime 22 seconds from now.
 * 
 *		Assume now() returns the DateTime representation of January 31, 2012 12:03:18 AM
 * 
 * 		addSeconds (now(), 22) 
 *		returns the DateTime representation of January 31, 2012 12:03:40 AM
 */
xcp.functions.addSeconds = function (date, seconds) {
	if (!date)
		return '';
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
		date = new Date(date); // In case the variable date is not a Date object
		date.setSeconds(date.getSeconds() + seconds);
		return date;
	} catch (e) {
		xcp.Logger.error('Unable to perform addSeconds function - ' + date);
		return '';
	}
}
/* JSFunction-arrayAverage/content/xcp/core/mathematical/arrayAverage.js */

// arrayAverage.js
Ext.namespace ('xcp.functions');

/*
 * Returns the average of the numbers in the supplied list.
 * 
 * Example:
 * 		arrayAverage ([4, 9, 5, 8, 2])
 * 		returns 5.6
 */
xcp.functions.arrayAverage = function (numAry) {
    //XCPUIC-2077, return 0.0 to the empty array
    if (Ext.isEmpty(numAry))
        return 0.0;

	var count = numAry.length;
	var total = 0.0;
	for (var index = 0; index < count; index ++) {
		total += numAry[index];
	}
	return total / count;
};
/* JSFunction-arrayMax/content/xcp/core/mathematical/arrayMax.js */

// arrayMax.js
Ext.namespace ('xcp.functions');

/*
 * Returns the largest number in the supplied list.
 * 
 * Example:
 * 		arrayMax ([-100, 12, 14, 4, -6, 82]) 
 * 		returns 82
 */
xcp.functions.arrayMax = function (numAry) {
	var count = numAry.length;
	var max = 0;
	if (count > 0)
		max = numAry[0];
	for (var index = 1; index < count; index ++) {
		if (numAry[index] > max) {
			max = numAry[index];
		}
	}
	return max;
}
/* JSFunction-arrayMin/content/xcp/core/mathematical/arrayMin.js */

// arrayMin.js
Ext.namespace ('xcp.functions');

/*
 * Returns the smallest number in the supplied list.
 * 
 * Example:
 * 		arrayMin ([-100, 12, 14, 4, -6, 82]) 
 * 		returns -100
 */
xcp.functions.arrayMin = function (numAry) {
	var count = numAry.length;
	var min = 0;
	if (count > 0)
		min = numAry[0];
	for (var index = 1; index < count; index ++) {
		if (numAry[index] < min) {
			min = numAry[index];
		}
	}
	return min;
}
/* JSFunction-average/content/xcp/core/mathematical/average.js */

// average.js
Ext.namespace ('xcp.functions');

/*
 * Returns the average of the two integers supplied as arguments.
 * 
 * Example:
 * 		average (4, 9)
 * 		returns 6.5
 */
xcp.functions.average = function (num1, num2) {
	var total = 0.0 + num1 + num2;
	return total / 2;
}
/* JSFunction-ceiling/content/xcp/core/mathematical/ceiling.js */

// ceiling.js
Ext.namespace ('xcp.functions');

/*
 * Rounds up the given number to the next integer.
 * 
 * Example:
 * 		ceiling (8.5) 
 * 		returns 9
 */
xcp.functions.ceiling = function (num) {
	return Math.ceil(num);
}
/* JSFunction-contains/content/xcp/core/string/contains.js */

// contains.js
Ext.namespace ('xcp.functions');

/*
 * Returns TRUE if str2 is contained within str1.
 * 
 * Example:
 * 		contains ('The cow jumped over the moon', 'cow') 
 * 		returns TRUE
 */
xcp.functions.contains = function (str1, str2) {
	return str1.indexOf(str2) != -1;
}
/* JSFunction-createDate/content/xcp/core/date/createDate.js */

// createDate.js
Ext.namespace ('xcp.functions');

/*
 * Returns the DateTime representation specified by year, month, day.
 *
 * Note: The time will be set to the current time of the browser session doing the evaluation.
 * The timezone will also be based on the timezone of the browser session doing the evaluation.
 * 
 * Example:
 * 		createDate (2012, 0, 31) 
 *		returns the DateTime representation of January 31, 2012 + current time
 */
xcp.functions.createDate = function (year, month, day) {
	var date = new Date();
	date.setFullYear(year, month, day);
	return date;
}
/* JSFunction-differenceDays/content/xcp/core/date/differenceDays.js */

// differenceDays.js
Ext.namespace ('xcp.functions');

/*
 * Returns as an integer the number of days between date1 and date2.
 * A positive number will be returned if date1 is later than date2, and vice versa.
 *
 * Example:
 * 		differenceDays(createDate(2012,0,31,11,13,45),createDate(2012,1,1,9,28,29))
 *		returns -1
 *
 *		differenceDays(createDate(2012,1,1,9,28,29),createDate(2012,0,31,11,13,45))
 *		returns 1
 *
 *		differenceDays(createDate(2012,0,31,0,00,00),createDate(2012,0,31,23,59,59))
 *		returns 0
 */
xcp.functions.differenceDays = function (date1, date2) {
	if (!date1 || !date2)
		return '';
		
	
	try {
		if (Ext.isString(date1)) {
			date1 = xcp.functions.stringToDate(date1);
		}
		if (Ext.isString(date2)) {
			date2 = xcp.functions.stringToDate(date2);
		}
	
		date1 = new Date(date1); // In case the variable date1 is not a Date object
		date2 = new Date(date2); // In case the variable date2 is not a Date object
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
		var difference = date1.getTime() - date2.getTime();
		return difference / 86400000; // 86400000 miliseconds in a day
	} catch (e) {
		xcp.Logger.error('Unable to perform differenceDays function - ' + date1 + ' - ' + date2);
		return '';
	}
}
/* JSFunction-differenceSeconds/content/xcp/core/date/differenceSeconds.js */

// differenceSeconds.js
Ext.namespace ('xcp.functions');

/*
 * Returns as an integer the number of seconds between date1 and date2.
 * A positive number will be returned if date1 is later than date2, and vice versa.
 *
 * Example:
 * 		differenceSeconds(createDate(2012,0,31,11,13,45),createDate(2012,1,1,9,28,29))
 *		returns -80084
 *
 *		differenceSeconds(createDate(2012,1,1,9,28,29),createDate(2012,0,31,11,13,45))
 *		returns 80084
 *
 *		differenceSeconds(createDate(2012,0,31,0,00,00),createDate(2012,0,31,23,59,59))
 *		returns -86399
 */
xcp.functions.differenceSeconds = function (date1, date2) {
	if (!date1 || !date2)
		return '';
		
	try {
		if (Ext.isString(date1)) {
			date1 = xcp.functions.stringToDate(date1);
		}
		if (Ext.isString(date2)) {
			date2 = xcp.functions.stringToDate(date2);
		}
		date1 = new Date(date1); // In case the variable date1 is not a Date object
		date2 = new Date(date2); // In case the variable date2 is not a Date object
		var difference = date1.getTime() - date2.getTime();
		return difference / 1000; // 1000 miliseconds in a second
	} catch (e) {
		xcp.Logger.error('Unable to perform differenceSeconds function - ' + date1 + ' - ' + date2);
		return '';
	}
}
/* JSFunction-discoveredMetadataLeaf/content/xcp/core/dm/discoveredMetadataLeaf.js */

// discoveredMetadataLeaf.js
Ext.namespace ('xcp.functions');

/*
 * Returns the last level from a hierarchical discovered metadata path.
 *
 * Example:
 *      paths = ['/Europe/France/Paris','/Europe/Italy']
 * 		discoveredMetadataLeaf(paths)
 * 		returns ['Italy','Paris']
 */
xcp.functions.discoveredMetadataLeaf = function (paths) {
    var leafs = new Array() ;

    for (var i = 0, j = 0; i<paths.length; i++) {
        var path = paths[i] ;
        var index = path.lastIndexOf('/') ;
        var leaf ;

        if (index < 0)
            leaf = path ;
        else
            leaf = path.substring(index+1);

        if (leafs.indexOf(leaf) == -1){
            leafs[j] = leaf;
            j++;
        }
    }
    return leafs.sort() ;
} ;


/* JSFunction-discoveredMetadataLevel/content/xcp/core/dm/discoveredMetadataLevel.js */

// discoveredMetadataLevel.js
Ext.namespace ('xcp.functions');

/*
 * Returns the specified level from a hierarchical discovered metadata path, and deletes multiple entries.
 * A optional "default level" can be used to return a default value if the path at the level does not exist.
 * 
 * Examples:
 *      paths = ['/Europe/France','/Europe/Italy']
 * 		discoveredMetadataLevel (paths, 1)
 * 		returns ['France','Italy']
 *
 *      paths = ['/Europe/France','/Europe/France/Paris','/Europe/Italy/Roma']
 * 		discoveredMetadataLevel (paths, 2, 0)
 * 		returns ['Europe','Paris', 'Roma']
 */
xcp.functions.discoveredMetadataLevel = function (paths, level, defaultLevel)
{
    /*
     * function stringByLevels
     * returns the substring of the string "path" at the level specified in the path. If level does not exist,
     * defautLevel parameter is used in replacement. Separator is '/'.
     *
     * Example:
     *     stringByLevels("foo/bar", 1)
     *     returns "bar"
     *
     *     stringByLevels("foo/bar", 2, 0)
     *     return "foo"
     */
    var stringByLevels = function stringByLevel(path, level, defaultLevel)
    {
        var pathResult = null;
        var pathDefaultResult = null;
        var indPrec;
        var indPost = -1;
        var indCurrLvl = -1;


        /* get all substrings of the list for the given levels */
        do
        {
            indCurrLvl++;
            indPrec = indPost + 1 ;
            indPost = path.indexOf('/', indPrec);

            if (indCurrLvl == level){
                if (indPost != -1){
                    pathResult = path.substring(indPrec, indPost);
                }else{//string path finished
                    pathResult = path.substring(indPrec, path.length);
                }
            }else{
                if (indCurrLvl == defaultLevel){ /* store the default result in case the level will not return anything */
                    if (indPost != -1){
                        pathDefaultResult = path.substring(indPrec, indPost);
                    }else{//string path finished
                        pathDefaultResult = path.substring(indPrec, path.length);
                    }
                }
            }
        } while ((indCurrLvl < level) && (indPost != -1));

        if (pathResult == null){
            pathResult = pathDefaultResult;
        }
        return pathResult;
     };
    // end


    var result = new Array() ;

    for (var i = 0, ind = 0; i < paths.length; i++){
        var substring =  stringByLevels(paths[i], level, defaultLevel);
        if ((result.indexOf(substring) == -1) && (substring != null)){
            result[ind] = substring;
            ind++;
        }
    }
    return result.sort();
} ;

/* JSFunction-discoveredMetadataLevels/content/xcp/core/dm/discoveredMetadataLevels.js */

// discoveredMetadataLevels.js
Ext.namespace ('xcp.functions');

/*
 * Returns all specified levels from a hierarchical discovered metadata path, and deletes multiple entries.
 *
 * Example:
 *      paths = ['Europe/France/Paris','Europe/Italy/Roma','Europe/France/Grenoble']
 * 		discoveredMetadataLevels (paths, [0, 2])
 * 		returns ['Europe/Paris','Europe/Roma', 'Europe/Grenoble']
 */
xcp.functions.discoveredMetadataLevels = function (paths, levels)
{
    /*
     * function stringByLevels
     * returns the substring of the string "path" at the levels including in the array "levels", and returns ''
     * otherwise. Separator is '/'.
     * Example:
     *     stringByLevels("it/is/time/to/work", [0,3])
     *     returns "it/to"
     */
    var stringByLevels = function stringByLevel(path, levels)
    {
        var pathResult = "";
        var indPrec;
        var indPost = -1;
        var indCurrLvl = -1;
        var maxLevel = -1;

        /* get max level */
        for (var i = 0; i < levels.length; i++){
            if (levels[i] > maxLevel){
                maxLevel = levels[i];
            }
        }

        /* get all substrings of the list for the given levels */
        do
        {
            indCurrLvl++;
            indPrec = indPost + 1 ;
            indPost = path.indexOf('/', indPrec);

            if (levels.indexOf(indCurrLvl) != -1){
                if (pathResult != ""){
                    //if it's not the first element add a separator before adding the next one.
                    pathResult += '/';
                }
                if (indPost != -1){
                    pathResult += path.substring(indPrec, indPost);
                }else{//string finished
                    pathResult += path.substring(indPrec, path.length);
                }
            }
        } while ((indCurrLvl < maxLevel) && (indPost != -1));

        return pathResult;
    };
    // end


    var result = new Array() ;

    for (var i = 0, ind = 0; i < paths.length; i++){
        var substring =  stringByLevels(paths[i], levels );
        if ((result.indexOf(substring) == -1) && (substring != '')){
            result[ind] = substring;
            ind++;
        }
    }
    return result.sort();
};

/* JSFunction-endsWith/content/xcp/core/string/endsWith.js */

// endsWith.js
Ext.namespace ('xcp.functions');

/*
 * Returns TRUE if str1 ends with str2.
 * 
 * Example:
 * 		endsWith ('The cow jumped over the moon', 'moon') 
 * 		returns TRUE
 */
xcp.functions.endsWith = function (str1, str2) {
	var lastIndex = str1.lastIndexOf(str2);
	var str1Length = str1.length;
	var str2Length = str2.length;
	return lastIndex == (str1Length - str2Length);
}
/* JSFunction-floor/content/xcp/core/mathematical/floor.js */

// floor.js
Ext.namespace ('xcp.functions');

/*
 * Truncates the values after the decimal point
 * 
 * Example:
 * 		floor (3.14159) 
 * 		returns 3
 */
xcp.functions.floor = function (num) {
	return Math.floor(num);
}
/* JSFunction-getDay/content/xcp/core/date/getDay.js */

// getDay.js
Ext.namespace ('xcp.functions');

/*
 * Returns the integer value of the day of the month (1-31) used in date.
 * 
 * Example:
 * 		employee.hire_date = January 30, 2012 8:05:23 AM (or rather the DateTime representation of January 30, 2012)
 * 
 * 		getDay (employee.hire_date)
 *		returns 30
 */
xcp.functions.getDay = function (date) {
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
		return date ? (new Date(date)).getDate() : '';
	} catch (e) {
		xcp.Logger.error('Unable to perform getDay function - ' + date);
		return '';
	}
}
/* JSFunction-getHour/content/xcp/core/date/getHour.js */

// getHour.js
Ext.namespace ('xcp.functions');

/*
 * Returns the integer value of the hour (in 12 hour notation - i.e. 0-11) used in date.
 * 
 * Example:
 * 		employee.hire_date = January 30, 2012 8:05:23 AM (or rather the DateTime representation of January 30, 2012)
 * 
 * 		getHour (employee.hire_date)
 *		returns 8
 */
xcp.functions.getHour = function (date) {
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
		return date ? (new Date(date)).getHours() % 12 : '';
	} catch (e) {
		xcp.Logger.error('Unable to perform getHour function - ' + date);
		return '';
	}

}
/* JSFunction-getMinute/content/xcp/core/date/getMinute.js */

// getMinute.js
Ext.namespace ('xcp.functions');

/*
 * Returns the integer value of the minute (0-59) used in date.
 * 
 * Example:
 * 		employee.hire_date = January 30, 2012 8:05:23 AM (or rather the DateTime representation of January 30, 2012)
 * 
 * 		getMinute (employee.hire_date)
 *		returns 5
 */
xcp.functions.getMinute = function (date) {
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
		return date ? (new Date(date)).getMinutes() : '';
	} catch (e) {
		xcp.Logger.error('Unable to perform getMinute function - ' + date);
		return '';
	}

}
/* JSFunction-getMonth/content/xcp/core/date/getMonth.js */

// getMonth.js
Ext.namespace ('xcp.functions');

/*
 * Returns the integer value of the month (0-11) used in date.
 * 
 * Example:
 * 		employee.hire_date = January 30, 2012 8:05:23 AM (or rather the DateTime representation of January 30, 2012)
 * 
 * 		getMonth (employee.hire_date)
 *		returns 0
 */
xcp.functions.getMonth = function (date) {
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
        //date.getMonth() will return value from 0 - 11
		return date ? (new Date(date)).getMonth() + 1 : '';
	} catch (e) {
		xcp.Logger.error('Unable to perform getMonth function - ' + date);
		return '';
	}

}
/* JSFunction-getValueFromActionFlowInputModel/content/xcp/core/internal/getValueFromActionFlowInputModel.js */

// absFloat.js
Ext.namespace ('xcp.functions.internal');

/*
 * Returns the absolute value of the float supplied as an argument.
 *
 * Example:
 * 		absFloat (-1.36)
 * 		returns 1.36
 */
xcp.functions.internal.getValueFromActionFlowInputModel = function (propId) {
    //Get the caller argument list this would give the evaluation context
	var callerArguments = arguments.callee.caller.arguments;
    var value = "";
    if (callerArguments && callerArguments.length > 0) {

        for (var i = 0; i < callerArguments.length; i++) {
            var val = callerArguments[i];
            if (val !== null && val !== undefined && val instanceof xcp.core.expr.EvaluationContext) {
                var actionFlowExecutionContext = val.getFlowExecutionContext();
                if (actionFlowExecutionContext) {
                    value = actionFlowExecutionContext.getInputPropertyValue(propId);
                }
                return xcp.core.expr.BaseExpression.checkValue(value);
            }
        }
        return value;

    }
};
/* JSFunction-getYear/content/xcp/core/date/getYear.js */

// getYear.js
Ext.namespace ('xcp.functions');

/*
 * Returns the integer value of the year used in date.
 * 
 * Example:
 * 		employee.hire_date = January 30, 2012 8:05:23 AM (or rather the DateTime representation of January 30, 2012)
 * 
 * 		getYear (employee.hire_date)
 *		returns 2012
 */
xcp.functions.getYear = function (date) {
	try {
		if (Ext.isString(date)) {
			date = xcp.functions.stringToDate(date);
		}
		return date ? (new Date(date)).getFullYear() : '';
	} catch (e) {
		xcp.Logger.error('Unable to perform getYear function - ' + date);
		return '';
	}

}
/* JSFunction-htmlEncode/content/xcp/core/string/HTMLEncode.js */

// HTMLEncode.js
Ext.namespace('xcp.functions');

/**
 * Returns the string produced by HTML encoding str.
 * @param str the string to encode
 */
xcp.functions.htmlEncode = function(str) {
    return Ext.htmlEncode(str);
}
/* JSFunction-length/content/xcp/core/string/length.js */

// length.js
Ext.namespace ('xcp.functions');

/*
 * Returns the number of characters that str has as an integer.
 * 
 * Example:
 * 		length ('The cow jumped over the moon')
 * 		returns 28
 */
xcp.functions.length = function (str) {
	return str.length;
}/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.formatter.DateTimeFormatter");

Ext.apply(xcp.Strings.formatter.DateTimeFormatter, {
    invalidValue:                "The given value '{0}' is not a valid datetime"
});
/* xcp_datetime_formatter/content/xcp/formatter/DatetimeFormatter.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
// DatetimeFormatter.js

(function() {
    //RegExp for locale format style
    var LOCALE_FORMAT_REGEXP = "short|medium|long";

    
    
    /**
     * Resolve date format (if locale senstivie format style) otherwise return the specified date format as it is.
     * @param formatConfig
     */
    var getDateFormat = function(formatConfig) {
        var dateFormat = formatConfig.dateFormat;
        if (dateFormat && dateFormat.match(LOCALE_FORMAT_REGEXP)) {
            dateFormat = xcp.Formats.dateFormats[dateFormat];
        }
        return dateFormat;
    };

    /**
     * Resolve time format (if locale senstivie format style) otherwise return the specified time format as it is.
     * @param formatConfig
     */
    var getTimeFormat = function(formatConfig) {
        var timeFormat = formatConfig.timeFormat;
        if (timeFormat && timeFormat.match(LOCALE_FORMAT_REGEXP)) {
            timeFormat = xcp.Formats.timeFormats[timeFormat];
        }
        //XCPUIC-1506: For some special time zone such as UTC/GMT-12:00, the time zone abbreviation got from Java is 'GMT-12:00', 
        //the Format 'T' (TimeZone abbreviation) in the time format need to be changed to 'P' (Difference to Greenwich time (GMT)) to adapt Ext validation.
        if (Ext.isEmpty(xcp.Formats.timezoneAbbreviation)==false && xcp.Formats.timezoneAbbreviation.match(/GMT[\-\+]/i)){
    		if(timeFormat.lastIndexOf('T')== timeFormat.length-1){
    			timeFormat = timeFormat.replace(/[T]/g, "\\G\\M\\TP");  // $NON-NLS-L$ 
    		}
    	}
        return timeFormat;
    };
    /**
     * Resolve date and time format and return as one format, in the combined format,
     * the date and time formats are seperated by single space.
     * @param formatConfig
     */
    var getDateTimeFormat = function(formatConfig) {
        var dateFormat = getDateFormat(formatConfig);
        var timeFormat = getTimeFormat(formatConfig);
        var dateTimeFormat = "";
        if (dateFormat) {
            dateTimeFormat = dateFormat;
            if (timeFormat) {
                //Seperate the date and time format by space.
                dateTimeFormat += " " + timeFormat;
            }
        }
        return dateTimeFormat;
    };
    /*
    Ext.override(Ext.Date,{getTimezone : function(date) {
	    	if (Ext.isEmpty(xcp.Formats.timezoneAbbreviation)==false){
	    		return xcp.Formats.timezoneAbbreviation;
	    	}
	    	this.callOverridden(arguments);
    	}
    });
    */
    Ext.Date.getTimezone = function(date) {
    	if (Ext.isEmpty(xcp.Formats.timezoneAbbreviation)==false){
    		return xcp.Formats.timezoneAbbreviation;
    	}
    	//copy from Ext.Date.getTimezone
    	// the following list shows the differences between date strings from different browsers on a WinXP SP2 machine from an Asian locale:
        //
        // Opera  : "Thu, 25 Oct 2007 22:53:45 GMT+0800" -- shortest (weirdest) date string of the lot
        // Safari : "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)" -- value in parentheses always gives the correct timezone (same as FF)
        // FF     : "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)" -- value in parentheses always gives the correct timezone
        // IE     : "Thu Oct 25 22:54:35 UTC+0800 2007" -- (Asian system setting) look for 3-4 letter timezone abbrev
        // IE     : "Thu Oct 25 17:06:37 PDT 2007" -- (American system setting) look for 3-4 letter timezone abbrev
        //
        // this crazy regex attempts to guess the correct timezone abbreviation despite these differences.
        // step 1: (?:\((.*)\) -- find timezone in parentheses
        // step 2: ([A-Z]{1,4})(?:[\-+][0-9]{4})?(?: -?\d+)?) -- if nothing was found in step 1, find timezone from timezone offset portion of date string
        // step 3: remove all non uppercase characters found in step 1 and 2
    	return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,4})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "");
	}
    /**
    * @class xcp.formatter.DateTimeFormatter
    * @extends xcp.formatter.BaseFormatter
    * Date time formatter.
    * @xtype xcp_datetime_formatter
    */
    Ext.define("xcp.formatter.DateTimeFormatter", {
        extend:"xcp.formatter.BaseFormatter",
        requires: ['Ext.util.Format','Ext.Date'],
        alias: "formatter.xcp_datetime_formatter",
        config : {
            dateFormat:"",
            timeFormat:"",
            dateStyle:""
        },
        /**
         * A Config object used for creating the instance.
         */
        initialConfig : null,

        /**
         * A resolved format.
         */
        resolvedFormat : null,
        /**
         * A resolved date format.
         */
        resolvedDateFormat : null,
        /**
         * A resolved time format.
         */
        resolvedTimeFormat : null,
        
        statics: {
        	// constant for datetime style
        	/**
        	 * the style of datetime
        	 */
            DATE_TIME_STYLE : "datetime",
            
            /**
        	 * the  style of date only
        	 */
            DATE_STYLE : "date",

            /**
             * the style of historical date
             */
            HISTORICAL_DATE_STYLE : "historical_date"
            
        },
        
        /**
         * Constructor.
         * @param initialConfig : Datetime format config object, like
             "format" : {
             "xtype" : "xcp_datetime_formatter",
             "dateFormat" : "long",
             "timeFormat" : "short"
             }
             A dateFormat can have a fixed format or a format pattern key (short, medium, long) for locale sensitive formatting.
             A timeFormat can have a fixed format or a format pattern key (short, medium, long) for locale sensitive formatting.
         */
        constructor: function(initialConfig) {

            this.initialConfig = initialConfig;
            this.resolvedFormat = getDateTimeFormat(initialConfig);
            this.resolvedDateFormat = getDateFormat(initialConfig);
            this.resolvedTimeFormat = getTimeFormat(initialConfig);
        },
        /**
         * Returns the format string of date 
         * @return {String} The format string of date 
         */
        getDateFormatString: function() {
        	return this.resolvedDateFormat;
        },
        /**
         * Returns the format string of time 
         * @return {String} The format string of time 
         */
        getTimeFormatString: function() {
        	return this.resolvedTimeFormat;
        },
        /**
         * Formats a date given the format string.
         * @param {Date} date The date to format
         * @return {String} The formatted date
         */
        formatDate: function(dateValue) {
        	if (Ext.isEmpty(dateValue)){
        		return null;
        	}
        	if (Ext.isString(dateValue)){
        		return dateValue;
        	}
        	return Ext.Date.format(dateValue,this.resolvedDateFormat);
        },
        /**
         * Formats a time given the format string.
         * @param {Date} time The time to format
         * @return {String} The formatted date
         */
        formatTime: function(timeValue) {
        	if (Ext.isEmpty(timeValue)){
        		return null;
        	}
        	if (Ext.isString(timeValue)){
        		return timeValue;
        	}
        	return Ext.Date.format(timeValue,this.resolvedTimeFormat);
        },
        /**
         * Parses the passed string using the specified date format.
         * @param {String} input The raw date string.
         * @return {Date} The parsed Date.
         */
        parse: function(dateTimeString) {
        	if (Ext.isEmpty(dateTimeString)){
        		return null;
        	}
        	return Ext.Date.parse(dateTimeString,this.resolvedFormat);
        },
        /**
          * Returns a formatted value.
          * @param value Input date value/Array of dates, the date value should be as per ISO 8601 standard.
          */

        format : function(value) {
            if (value == undefined)
                return;
            var formattedDate = new Array();
            if(Ext.isArray(value)) {
                for(var i = 0; i < value.length; i++) {
                    formattedDate.push(this.formatValue(value[i]));
                }
            } else {
                formattedDate = this.formatValue(value);
            }
            return formattedDate;
        },

        /**
         * Returns a formatted value.
         * @param value Input date value, the date value should be as per ISO 8601 standard.
         */
        formatValue : function(value) {
        	if (!value) {
        		return value;
        	}
            //Check if value is Date
            var parsedDate = null;
            if (Ext.isDate(value)) {
                parsedDate = value;
            } else {
                //We assume that the input date value is always going to be in ISO 8601 format.
                parsedDate = Ext.Date.parseDate(value, 'c');
            }

            var formatedDate = value;
            if (Ext.isDate(parsedDate)) {
                //Parse the date with given format, otherwise use the locale specific format
                if (Ext.isEmpty(this.initialConfig.dateStyle) || this.initialConfig.dateStyle == xcp.formatter.DateTimeFormatter.DATE_TIME_STYLE){
                    formatedDate = Ext.util.Format.date(parsedDate, this.resolvedFormat);
                }
                else {
                    if (this.initialConfig.dateStyle == xcp.formatter.DateTimeFormatter.HISTORICAL_DATE_STYLE){
                        parsedDate = new Date(parsedDate.getUTCFullYear(), parsedDate.getUTCMonth(), parsedDate.getUTCDate(), parsedDate.getUTCHours(),parsedDate.getUTCMinutes(), parsedDate.getUTCSeconds());
                    }
                    formatedDate = Ext.util.Format.date(parsedDate, this.resolvedDateFormat);
                }
            } else {
                //TODO show error notification
                if (window.console) {
                    window.console.error(Ext.String.format(xcp.Strings.formatter.DateTimeFormatter.invalidValue, value));
                }
            }

            return formatedDate;
        }

    });
})();
// getDayOfWeek-strings.js

Ext.namespace("xcp.Strings.functions.string.lockStatus");

Ext.apply(xcp.Strings.functions.string.lockStatus, {
	lockStatusMessage:  "Locked {0} by {1}"
});
/* JSFunction-lockStatus/content/xcp/core/string/lockStatus.js */

// lockStatus.js
Ext.namespace ('xcp.functions');

/*
 * Returns the generated lock status string produced with input lock date and lock owner for a document.
 */

xcp.functions.lockStatus = function (lockdate, lockowner) {
    var formatter = new xcp.formatter.DateTimeFormatter({ xtype:"xcp_datetime_formatter",
        dateStyle:"datetime",
        dateFormat:"short",
        timeFormat:"short"});
    var date = formatter.format(lockdate);
    return Ext.String.format(xcp.Strings.functions.string.lockStatus.lockStatusMessage, date, lockowner);
}

/* JSFunction-max/content/xcp/core/mathematical/max.js */

// max.js
Ext.namespace ('xcp.functions');

/*
 * Returns the larger of the two integers supplied as arguments.
 * 
 * Example:
 * 		max (4, 8) 
 * 		returns 8
 */
xcp.functions.max = function (int1, int2) {
	return int1 > int2 ? int1 : int2;
}
/* JSFunction-min/content/xcp/core/mathematical/min.js */

// min.js
Ext.namespace ('xcp.functions');

/*
 * Returns the smaller of the two integers supplied as arguments.
 * 
 * Example:
 * 		min (4, 8) 
 * 		returns 4
 */
xcp.functions.min = function (int1, int2) {
	return int1 < int2 ? int1 : int2;
}
/* JSFunction-mod/content/xcp/core/mathematical/mod.js */

// mod.js
Ext.namespace ('xcp.functions');

/*
 * Returns the remainder of the number divided by divisor. 
 * 
 * Example:
 * 		mod (7, 3) 
 * 		returns 1
 */
xcp.functions.mod = function (num, divisor) {
	return num % divisor
}
/* JSFunction-now/content/xcp/core/date/now.js */

// now.js
Ext.namespace ('xcp.functions');

/*
 * Returns the DateTime representation of the current date and current time.
 */
xcp.functions.now = function () {
	return new Date();
}
/* JSFunction-powerFloat/content/xcp/core/mathematical/power.js */

// power.js
Ext.namespace ('xcp.functions');

/*
 * Raises the number to the power of the given parameter
 * 
 * Example:
 * 		power (3, 2) 
 * 		returns 9
 */
xcp.functions.power = function (num, power) {
	return Math.pow(num, power);
}
/* JSFunction-powerInteger/content/xcp/core/mathematical/power.js */

// power.js
Ext.namespace ('xcp.functions');

/*
 * Raises the number to the power of the given parameter
 * 
 * Example:
 * 		power (3, 2) 
 * 		returns 9
 */
xcp.functions.power = function (num, power) {
	return Math.pow(num, power);
}
/* JSFunction-random/content/xcp/core/mathematical/random.js */

// random.js
Ext.namespace ('xcp.functions');

/*
 * Returns the random number between 0 and 1.
 * 
 * Example:
 * 		random () 
 * 		returns 0.314159
 */
xcp.functions.random = function () {
	return Math.random();
}
/* JSFunction-round/content/xcp/core/mathematical/round.js */

// round.js
Ext.namespace ('xcp.functions');

/*
 * Rounds to the nearest number using the precision specified.
 * 
 * Example:
 * 		round (3.14159, 2) 
 * 		returns 3.14
 */
xcp.functions.round = function (num, precision) {
	return parseFloat(new Number(num).toFixed(precision));
}
/* JSFunction-startsWith/content/xcp/core/string/startsWith.js */

// startsWith.js
Ext.namespace ('xcp.functions');

/*
 * Returns TRUE if str1 begins with str2.
 * 
 * Example:
 * 		startsWith ('The cow jumped over the moon', 'The cow') 
 * 		returns TRUE
 */
xcp.functions.startsWith = function (str1, str2) {
	return str1.indexOf(str2) == 0;
}
/* JSFunction-stringToDate/content/xcp/core/date/stringToDate.js */

// stringToDate.js
Ext.namespace ('xcp.functions');

/*
 * Returns the DateTime representation specified by dateValue.
 * If the string is unable to be parsed, the current time will be returned.
 *
 * Note: This function only supports date text in the English locale. (e.g. November would be understood, but novembre would not be.)
 * 
 * Example:
 * 		stringToDate ('Jan 31, 2012') 
 *		returns the DateTime representation of January 31, 2012 12:00:00 AM
 */
xcp.functions.stringToDate = function (dateString) {
    //parsing date string by using extjs first. If it fails, then it goes back to the old logic
	var date = Ext.Date.parse(dateString, 'c');
	if (isNaN(date)) {
	// For Mac/Safari/iPad support.
		dateString = dateString.replace(/\-/g,'\/').replace(/[T|Z]/g,' ').replace(/\.\d\d\d/, '');
		var time = Date.parse(dateString);

		if (isNaN(time)) {
			date = new Date();
		} else {
			date = new Date(time);
		}
	}
	return date;
};
/* JSFunction-substring/content/xcp/core/string/substring.js */

// substring.js
Ext.namespace ('xcp.functions');

/*
 * Returns the string produced by extracting characters from str beginning
 * from the position indicated by start up to and not including position end.
 * The first position is 0, not 1.
 * 
 * Example:
 * 		substring ('Smiles', 1, 5) 
 * 		returns 'mile'
 */
xcp.functions.substring = function (str, start, end) {
	return (!end) ? str.substring(start) : str.substring(start, end);
}
/* JSFunction-toLower/content/xcp/core/string/toLower.js */

// toLower.js
Ext.namespace ('xcp.functions');

/*
 * Returns the string produced by converting all of the characters in str to
 * lowercase.
 * 
 * Example:
 * 		toLower ('I am not YELLING')
 * 		returns 'i am not yelling'
 */
xcp.functions.toLower = function (str) {
	return str.toLocaleLowerCase();
}
/* JSFunction-toUpper/content/xcp/core/string/toUpper.js */

// toUpper.js
Ext.namespace ('xcp.functions');

/*
 * Returns the string produced by converting all of the characters in str to
 * uppercase.
 * 
 * Example:
 * 		toLower ('I am yelling')
 * 		returns 'I AM YELLING'
 */
xcp.functions.toUpper = function (str) {
	return str.toLocaleUpperCase();
}
/* JSFunction-today/content/xcp/core/date/today.js */

// today.js
Ext.namespace ('xcp.functions');

/*
 * Returns the DateTime representation of the current date with the time portion set to midnight (i.e. 00:00:00).
 */
xcp.functions.today = function () {
	var date = new Date();
	return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
}/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// CreateAction-strings.js

Ext.namespace("xcp.Strings.action.form.CreateAction");
Ext.apply(xcp.Strings.action.form.CreateAction, {
    confirmationTitle: "Confirm operation",
    confirmationPromptTemplate: "Are you sure?",
    createSuccessNotificationTemplate:  "Success.",
    createErrorTemplate: "An error occurred while performing the operation."
});
/* create/content/xcp/action/form/CreateAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// CreateAction.js

/**
 * @class xcp.action.form.CreateAction
 * @extends xcp.action.form.DataAction
 * Action implementation for creating resources within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.form.CreateAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.create",

    statics: {
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    var data = Ext.JSON.decode(operation.response.responseText);
                    url = action.redirectUrlModel + "/" + data.id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        }
    },

    config: {
        /**
         * @cfg {String} confirmationPrompt Pattern for string used as confirmation prompt (defaults to
         * Are you sure you want to create an item"?)
         */
        confirmationPrompt: xcp.Strings.action.form.CreateAction.confirmationPromptTemplate,
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false
    },

    /**
     * Handler for the CreateAction
     */
    handler: function(actionArgs, action) {
        var config = this.getConfig();

//        //update action's input model when action is invoked.
//        if (!Ext.isEmpty(actionArgs.selection))
//            this.setInputModel(actionArgs.selection[0]);

        var model = this.getActionModel();

        var handleCreateSuccess = function(record, operation) {
            if (this.showSuccessNotification) {
                xcp.action.form.DataAction.notifyActionSuccess(this.ownerCt || actionArgs.component, xcp.Strings.action.form.CreateAction.createSuccessNotificationTemplate, model);
            }
            xcp.action.form.CreateAction.handleRedirection(this, record, operation);

        };
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    model.save({success: handleCreateSuccess, feedbackContainer: this.ownerCt || actionArgs.component, scope: this, actionConfig: config});
                }
            };

            Ext.Msg.show({
                title:  xcp.Strings.action.form.CreateAction.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.form.CreateAction.confirmationPromptTemplate, model),
                scope: this
            });
        } else {
            model.save({success: handleCreateSuccess, feedbackContainer: this.ownerCt || actionArgs.component, scope: this, actionConfig: config});
        }
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// CreateAction-strings.js

Ext.namespace("xcp.Strings.action.form.CreateFolderAction");
Ext.apply(xcp.Strings.action.form.CreateFolderAction, {
    text: "New Folder",
    tooltip: "Create a new folder",
    confirmationTitle: "Create folder?",
    confirmationPromptTemplate: "Are you sure you want to create this folder?",
    createSuccessNotificationTemplate:  "The folder has been created.",
    createErrorTemplate: "An error occurred while creating this folder. Please try again."
});
/* createfolder/content/xcp/action/form/CreateFolderAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// CreateFolderAction.js

/**
 * @class xcp.action.form.CreateFolderAction
 * @extends xcp.action.form.DataAction
 * Action implementation for creating folder within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.form.CreateFolderAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.createfolder",

    statics: {
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    var data = Ext.JSON.decode(operation.response.responseText);
                    url = action.redirectUrlModel + "/" + data.id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        }
    },

    config: {
        text: xcp.Strings.action.form.CreateFolderAction.text,
        tooltip: xcp.Strings.action.form.CreateFolderAction.tooltip,

        requiredAttributes: ["effectivePermissions"],
        preconditions: {
            targets:{
                validId:    true,
                effectivePermissions: [xcp.Permit.BROWSE]
            }
        },

        /**
         * @cfg {String} confirmationPrompt Pattern for string used as confirmation prompt (defaults to
         * Are you sure you want to create an item"?)
         */
        confirmationPrompt: xcp.Strings.action.form.CreateAction.confirmationPromptTemplate,
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false
    },


   getEnablement:function(actionArgs, action) {
        if (Ext.is.iPad) {
            // No way to select files for import on iPad, so don't even show this action
            return xcp.Enablement.HIDE;
        }

        var target = action.getTargets(actionArgs)[0];
        if (target) {
            var permits = target.get('effectivePermissions');
            if (permits === undefined || permits == "") {
                return xcp.Enablement.ENABLE;
            }
            if (xcp.Permit.hasPermit(permits, xcp.Permit.WRITE)) {
                return xcp.Enablement.ENABLE;
            } else if ((xcp.Permit.hasPermit(permits, xcp.Permit.CHANGE_FOLDER_LINKS)) && (xcp.Permit.hasPermit(permits, xcp.Permit.BROWSE))) {
                return xcp.Enablement.ENABLE;
            } else
                return xcp.Enablement.HIDE;
        }
        return xcp.Enablement.ENABLE;
    },


    /**
     * Handler for the CreateAction
     */
    handler: function(actionArgs, action) {
        var actionConfig = action.getConfig();

        var folderId = actionArgs.selection[0].getId();
        var config = {targetFolderId: folderId};
        Ext.create('xcp_create_folder', config).show();

        // Note that this method will run in the context of the associated component (button, menu, etc.), therefore
        // the "this" refers to the component, not to the action.  Configuration from the action is propogated to the
        // component, but functions are not, thus functions which access instance data won't work.

//        var model = xcp.action.form.DataAction.getModelForComponent(this);
//
//        var handleCreateSuccess = function(record, operation) {
//            if (actionConfig.showSuccessNotification) {
//                xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.form.CreateAction.createSuccessNotificationTemplate);
//            }
//
//            xcp.action.form.CreateAction.handleRedirection(this, record, operation);
//
//        };
//        // Show confirmation if configured
//        if (actionConfig.showConfirmation) {
//            var confirmationCallback = function(btn) {
//                if (btn == "yes") {
//                    model.save({success: handleCreateSuccess, feedbackContainer: actionArgs.component, scope: this});
//                }
//            };
//
//            Ext.Msg.show({
//                title:  xcp.Strings.action.form.CreateAction.confirmationTitle,
//                buttons: Ext.MessageBox.YESNO,
//                fn: confirmationCallback,
//                icon: Ext.MessageBox.WARNING,
//                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.form.CreateAction.confirmationPromptTemplate, model),
//                scope: this
//            });
//        } else {
//            model.save({success: handleCreateSuccess, feedbackContainer: actionArgs.component, scope: this});
//        }
    }
});

/* datasource/content/xcp/action/form/DataSourceAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// DataSourceAction.js

/**
 * @class xcp.action.form.DataSourceAction
 * @extends xcp.action.form.DataAction
 * Action implementation for invoking datasource within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.form.DataSourceAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.datasource",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false,

        /**
         * @cfg {String} action instance Id
         */
        xcpId:null,

        /**
         * Store model name
         */
        actionModel:null,

        /**
         * Auto load data source
         */
        autoLoad:true,

        /**
         * The number of records considered to form a 'page'.
         */
        pageSize:10,

        /**
         * List of invoker events
         */
        invokerEvents:[],

        /**
         * Data source output type, can be either Array or Object
         */
        outputType:"Array"
    },

    DEFAULT_PAGE_SIZE: 10,

    constructor: function(config) {
        this.callParent(arguments);

        this.outputType = config.outputType || "Array";  // $NON-NLS-1$ 

        if (this.outputType == "Object") {
            this.actionModel = Ext.ModelMgr.getModel(config.actionModel);
            if (config.autoLoad) {
                this.on("beforerender", this.handler, this);
            }
        } else {
            var pageSize = config.pageSize ? config.pageSize : this.DEFAULT_PAGE_SIZE;
            //copy proxy from model definition and use it in this store so that the modifications will only
            //apply to the store proxy instead of to the model proxy.
            var proxy = Ext.Object.merge({}, Ext.ModelMgr.getModel(config.actionModel).getProxy());
            proxy.simpleSortMode = true;

            var autoLoad = config.autoLoad || false;
            //if (autoLoad) {
            //    if (this.hasRequiredInputProperties(config)) {
            //        autoLoad = false;
            //        this.on("beforerender", this.handler, this);
            //    }
            //}
            var store = {
                storeId: config.xcpId,
                model: config.actionModel,
                autoLoad: autoLoad,
                pageSize: pageSize,
                proxy: proxy,
                remoteSort:true

            };
            this.store = Ext.data.StoreManager.lookup(store);
        }

    },
    /**
     * @param actionArgs
     * @param action
     */
    hasRequiredInputProperties: function() {
        //TODO: Add isRequired property in generated expr config
        if (this.hasExpressionProps) {
            return true;
        }
        return false;
    },

    /**
     * Handler for the DataSourceAction
     */
    handler: function(actionArgs, action) {

        var me = this;
        var config = this.getConfig();
        var delayedCall = function() {
            xcp.Logger.info("Invoking data source..."+ config.xcpId);
            if (!me.isDisabled() && (me.store || me.actionModel)) {

                if (me.outputType == "Object") {
                    if (me.inputProperties) {
                        me.updateExtraParams(me.actionModel.getProxy(), me.inputProperties);
                    }
                    me.actionModel.load('', {
                            success: function(instance) {
                                xcp.Logger.info("Got response for data source..."+ config.xcpId);
                                me.actionModelInstance=instance;
                                //Fire change event
                                me.fireEvent("change", me);
                            },
                            feedbackContainer: me.ownerCt || actionArgs.component,
                            scope: me,
                            actionConfig: config
                        }
                    );
                } else {
                    //add data into extraParam into the proxy
                    if (me.inputProperties) {
                        me.updateExtraParams(me.store.getProxy(), me.inputProperties);
                    }
                    //XCPUIC-1586, always go back to first page when action is invoked.
                    me.store.currentPage = 1;
                    //reload the data
                    me.store.load({
                        feedbackContainer: me.ownerCt || actionArgs.component,
                        scope: me,
                        actionConfig: config
                    });
                    me.fireEvent("change", me);
                }
            }

        };
        if (config && !Ext.isEmpty(config["invokerEvents"])) {
             xcp.Logger.info("Delaying the data source invocation..."+ config.xcpId);
             xcp.util.PageLayoutUtils.defer(delayedCall);
        } else {
            delayedCall.call(this);
        }
    },
    updateExtraParams: function(proxy, extraParams) {
        if (proxy && Ext.isFunction(proxy.updateExtraParams)) {
            proxy.updateExtraParams(extraParams);
        }
    },

    /**
     * Destroy the data source store.
     */
    destroy: function() {
        this.inputProperties = null;
        if (this.store) {
            Ext.StoreManager.remove(this.store);
        }
        this.actionModel=null;
        this.actionModelInstance=null;

        this.fireEvent("destroy", this);
    },

    /**
     * update the property into the extraParams of story proxy.
     *
     * @param value
     * @param propId
     */
	setInputProperty: function(value, propId) {
		this.callParent(arguments);
		if (this.inputProperties) {
            if (this.outputType == "Object") {
                this.updateExtraParams(this.actionModel.getProxy(), this.inputProperties);
            } else {
			    this.updateExtraParams(this.store.getProxy(), this.inputProperties);
            }
		}
	}
});
// DeleteAction-strings.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */
(function() {
    var nsDefault = Ext.namespace("xcp.Strings.action.form.DeleteAction.default");
    var nsDefaultMultiple = Ext.namespace("xcp.Strings.action.form.DeleteActionMultiple.default");
    var nsRemove = Ext.namespace("xcp.Strings.action.form.DeleteAction.remove");
    var nsDefaultFolder = Ext.namespace("xcp.Strings.action.form.DeleteFolderAction.default");
    var nsDefaultDocument = Ext.namespace("xcp.Strings.action.form.DeleteDocumentAction.default");

    Ext.apply(nsDefault, {
        confirmationTitle: "Delete item?",
        confirmationPromptTemplate: "Are you sure you want to delete this item?",
        deleteSuccessNotificationTemplate:  "The item has been deleted.",
        deleteErrorTemplate: "An error occurred while deleting this item.",
        text: "Delete",
        tooltip: "Delete item",
        progress: "Deleting \"{object_name}\""
    });

    Ext.apply(nsDefaultMultiple, {
        confirmationTitle: "Delete Items?",
        confirmationPromptTemplate: "Deleted items cannot be restored.  Are you sure you want to delete these {Count} items?",
        deleteSuccessNotificationTemplate:  "The items have been deleted.",
        deleteErrorTemplate: "An error occurred while deleting the items. Please try again.",
        text: "Delete",
        tooltip: "Delete item",
        progress: "Deleting \"{object_name}\""
    });

    Ext.apply(nsRemove, {
        confirmationTitle: "Remove Item?",
        confirmationPromptTemplate: "Are you sure you want to remove this item?",
        deleteSuccessNotificationTemplate:  "Item removed.",
        deleteErrorTemplate: "An error occurred while removing this item. Please try again.",
        text: "Remove",
        progress: "Removing item..."
    });

    Ext.apply(nsDefaultFolder, {
        confirmationTitle: "Delete Folder?",
        confirmationPromptTemplate: "Are you sure you want to permanently delete \"{object_name}\" and all of the items it contains? Deleted items cannot be restored.",
        confirmationPromptTemplateAlternate: "Are you sure you want to permanently delete this folder and all of the items it contains? Deleted items cannot be restored.",

        deleteSuccessNotificationTemplate:  "The item has been deleted.",
        deleteErrorTemplate: "An error occurred while deleting this item. Please try again.",
        text: "Delete",
        tooltip: "Delete item",
        progress: "Deleting \"{object_name}\""
    });

    Ext.apply(nsDefaultDocument, {
        confirmationTitle: "Delete Document?",
        confirmationPromptTemplate: "Are you sure you want to permanently delete \"{object_name}\"? A deleted file cannot be restored.",
        confirmationPromptTemplateAlternate: "Are you sure you want to permanently delete this file? A deleted file cannot be restored.",
        deleteSuccessNotificationTemplate:  "The item has been deleted.",
        deleteErrorTemplate: "An error occurred while deleting this item. Please try again.",
        text: "Delete",
        tooltip: "Delete item",
        progress: "Deleting \"{object_name}\""
    });

})();

/* delete/content/xcp/action/form/DeleteAction.js */

// DeleteAction.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * @class xcp.action.form.DeleteAction
 * @extends xcp.action.form.DataAction
 * Action implementation for deleting resources within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
// private trace function
function logIt(s){
    console.debug("DeleteAction: "+s);
}

Ext.define("xcp.action.form.DeleteAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.delete",
    text: xcp.Strings.action.form.DeleteAction["default"].text,
    tooltip: xcp.Strings.action.form.DeleteAction["default"].tooltip,

    requiredAttributes: ["effectivePermissions"],
    config: {
        preconditions: {
            selection: xcp.SelectionType.MULTI,
            targets:{
                validId:    true,
                effectivePermissions: [xcp.Permit.DELETE]
            /* ignore the container permission per XCPUIC-3832 requirement
            },
            container:{
                effectivePermissions: [xcp.Permit.WRITE]
            */
            }
        },


        /**
         * @cfg {String} confirmationPrompt Pattern for string used as confirmation prompt (defaults to
         * Deleted items cannot be restored.  Are you sure you want to delete "{name}"?)
         */
        confirmationPrompt: xcp.Strings.action.form.DeleteAction["default"].confirmationPromptTemplate,
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before deleting the resource (defaults to true)
         */
        showConfirmation: true,

        showSuccessNotification: false
    },

    constructor: function(config) {
        if (config) {
            var nlsKey = config["nlsKey"];
            if (nlsKey) {
                var messageTemplate = xcp.Strings.action.form.DeleteAction[nlsKey];
                if (messageTemplate && messageTemplate.text) {
                    this.text = config.text = messageTemplate.text;
                }
            }
        }
        this.items = [];
        this.initConfig(config);  // merge prototype's .config object
        this.callParent([this.config]);
    },

    getEnablement: function(actionArgs, action) {
         // disable if locked.
        var target = action.getTargets(actionArgs)[0];
        if (target){
            var lockOwner = target.get('r_lock_owner');
            if (lockOwner && lockOwner.length > 0)
                return xcp.Enablement.DISABLE;
        }

        target = actionArgs.getPageModel();
        // if container is folder then get and validate effective permissions on it.
        if(!target){
            if (actionArgs.container && actionArgs.container.model == "xcp_dm_folder"){
                target = actionArgs.container;
            }
        }
        if (target) {
            var permits = target.get('effectivePermissions');
            if (permits === undefined || permits == "") {
                return xcp.Enablement.ENABLE;
            }
            if (xcp.Permit.hasPermit(permits, xcp.Permit.WRITE)) {
                return xcp.Enablement.ENABLE;
            } else if ((xcp.Permit.hasPermit(permits, xcp.Permit.CHANGE_FOLDER_LINKS)) && (xcp.Permit.hasPermit(permits, xcp.Permit.BROWSE))) {
                //User can delete if they have write or change folder links permission
                return xcp.Enablement.ENABLE;
            } else
                return xcp.Enablement.HIDE;

        }
        return xcp.Enablement.ENABLE;
    },

            /**
     * Handler for the DeleteAction
     */
    handler:function(actionArgs, action){
        var config, targets, objectId;
        var targetObjectIsPageObject=false;

        if (Ext.isEmpty(action)) { //delete action invoked from form button
//            //update action's input model when action is invoked.
//            if (!Ext.isEmpty(actionArgs.selection))
//                this.setInputModel(actionArgs.selection[0]);
//
            config = this.getConfig();
            targets = [this.getActionModel()];
            /* Some of the messages in delete document/folder contain the object name. We are going to get the
             * object name from the page model if this action has been invoked from a page that has a delete
              * action. we are making sure the page and the targets have the same object id.*/
            if (actionArgs){
                var pageModel = actionArgs.getPageModel();
                if (pageModel && targets && targets.length==1 && pageModel.getId()===targets[0].getId()){
                    targetObjectIsPageObject=true;
                }
            }

        }
        else {
            config = action.getConfig();
            targets = action.getTargets(actionArgs);
        }

        var messageTemplateKey = "default";
        var nlsKey = config["nlsKey"];
        if (nlsKey) {
            messageTemplateKey=nlsKey;
        }

        // allow the action to select the message template used for feedback and confirmation - choose the correct
        // string based on the selection count
        var messageTemplate = Ext.clone(xcp.Strings.action.form.DeleteAction[messageTemplateKey]);
        var confirmationPromptAlternate;
        if (actionArgs && actionArgs.selection && actionArgs.selection.length > 1)
        {
            Ext.apply(messageTemplate, xcp.Strings.action.form.DeleteActionMultiple[messageTemplateKey] || {});
        }else{
            if (targets && targets.length>0 ){
                objectId = targets[0].getId();
                if (objectId){
                    //delete the object that is presented on current page, the redirectStyle cannot be "current"
                    // and it has to be set to "previous"
                    if (objectId == xcp.navigationManager.currentNavigationContext.objectId &&
                        this.redirectStyle == xcp.action.form.DataAction.REDIRECT_CURRENT) {
                        this.redirectStyle = xcp.action.form.DataAction.REDIRECT_PREVIOUS;
                    }
                    if (objectId.indexOf("0b") === 0){
                        messageTemplate = Ext.clone(xcp.Strings.action.form.DeleteFolderAction[messageTemplateKey]);
                        confirmationPromptAlternate = messageTemplate.confirmationPromptTemplateAlternate;

                    }else if (objectId.indexOf("09") == 0){
                        messageTemplate = Ext.clone(xcp.Strings.action.form.DeleteDocumentAction[messageTemplateKey]);
                        confirmationPromptAlternate = messageTemplate.confirmationPromptTemplateAlternate;
                    }
                }
            }
        }
        // If Carl did not add object_name to result list then we display an alternate prompt. XCPUIC-2936
        if (confirmationPromptAlternate  && !targetObjectIsPageObject && !targets[0].getData().object_name)  {
             this.confirmationPrompt = confirmationPromptAlternate;
        }
        else    {
            this.confirmationPrompt = messageTemplate.confirmationPromptTemplate;
        }
        var msg = xcp.util.Utils.formatTemplateString(messageTemplate.progress, targets[0]);
        if (targetObjectIsPageObject && actionArgs)
            msg = xcp.util.Utils.formatTemplateString(msg, actionArgs.getPageModel());

        var progress = new xcp.ProgressNotifier(this.ownerCt || actionArgs.component,msg);

        var handleDeleteResults = function (record, operation, resultMap) {
            var ids =[];
            var successCount = 0;
            var failureCount = 0;
            for (var id in resultMap) {
                if (resultMap [id] == "success"){  // $NON-NLS-1$ 
                    successCount++;
                    ids.push(id);
                }
                else
                    failureCount++;
            }
            progress.endOperation(config.showSuccessNotification && successCount > 0);

            // todo DLM: 1st target?
            var model=targets[0];

            if (config.showSuccessNotification && successCount > 0) {
                var msg = xcp.util.Utils.formatTemplateString(messageTemplate.deleteSuccessNotificationTemplate, model);
                if (targetObjectIsPageObject)
                    msg = xcp.util.Utils.formatTemplateString(msg, actionArgs.getPageModel());
                progress.showSuccess(msg);

                xcp.event.EventBus.publish(xcp.event.ItemDeleted.NAME, ids);
            }

            /* no need an extra error message display. the feedback manager already handled it.
            if (config.showSuccessNotification && failureCount > 0) {
                xcp.action.form.DataAction.showActionError(this.ownerCt || actionArgs.component, messageTemplate.deleteErrorTemplate, null, model);
            }
             */
            // XCPECM-1096 : Today, Designer is not exposing the redirect 'application'  style when manually configuring a Button bound to the Delete action.
            // consequently any redirect will not work.
            // Instead of introducing the change in Designer at this time we will reset all 'specified' redirect to be 'application'
            // this amounts to a work-around to compensate for Designers current behavior. A true fix requires designer to set this according
            // to Carl's intentions.
            // Specified is not very meaningful on delete anyways since there is no longer an object to be specified -- its been deleted.
            if (this.redirectStyle== xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                this.redirectStyle=xcp.action.form.DataAction.REDIRECT_APPLICATION;
            }

            xcp.action.form.DataAction.handleRedirection(this, record, operation);
        };
        var options = { callback: handleDeleteResults, scope: this};
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    executeModels(targets, options);
                }
            };

            var message = xcp.action.form.DataAction.formatTemplateStringMultiple
                                (this.confirmationPrompt, targets);
            if (targetObjectIsPageObject && actionArgs)
                message = xcp.util.Utils.formatTemplateString(message, actionArgs.getPageModel());

            Ext.Msg.show({
                title:  messageTemplate.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: message,
                scope: this
            });
        } else {
            executeModels(targets, options);
        }

        /**  Execute delete action for array of models
         *   dlm todo: NOTE: Currently we sequentially process multi-select.  We could change this to be
         *   parallel, but there are limits (2-8 connections).  Could do 2-4 item chunks in parallel??  Certainly more complicated than sequential
         * NOTE: callback args:
         *      true -- update completed
         *      false -- update no needed
         *      operation(Object) -- failed operation
         * @param models
         * @param options -- {fields[], callback, scope}
         */
        function executeModels(models, options) {
            var resultMap = {};
            var count = models.length;
            var index = -1;

            function doCallback(record, operation, ret){
                if (!options.callback)
                    return;
                options.callback.call(options.scope || this, record, operation, ret);
            }
            function doSuccess(record, operation){
                var id = operation._objectId;
                xcp.Logger.info("Delete object success: "+ operation.error);
                logIt("delete success: "+ operation.error);  // $NON-NLS-1$ 
                resultMap [id] = "success";  // $NON-NLS-1$ 
                doNext(record, operation);
            }
            function doFail(record, operation){
                var id = operation._objectId;
                xcp.Logger.error("Delete error: "+ operation.error);
                logIt("delete error: "+ operation.error);  // $NON-NLS-1$ 
                resultMap [id] = operation.error;
                doNext(record, operation);
            }
            function doNext(record, operation){
                logIt("doNext(): " + (record || "[starting]"));  // $NON-NLS-L$ 
                index++;
                if (index<count){
                    var model = models[index], config;
                    if(!Ext.isEmpty(action)) {
                        //XCPUIC-2409 - Getting Model from action directly
                       // config = action.getConfig(model);
                       // model = xcp.util.Utils.getAsModel(model, config.actionModel);
                        model = xcp.util.Utils.getAsModel(model, action.actionModel);
                    }
                    if (!model){
                        logIt("can't determine type from model");  // $NON-NLS-1$ 
                        xcp.Logger.error("can't determine type from model");
                    }else
                    {
                        logIt("executing "+ model.getId());  // $NON-NLS-1$ 
                        var msg = xcp.util.Utils.formatTemplateString(messageTemplate.progress, model);
                        if (targetObjectIsPageObject && actionArgs)
                             msg = xcp.util.Utils.formatTemplateString(msg, actionArgs.getPageModel());
                        progress.updateProgress(msg);

                        model.destroy({
                            success: doSuccess,
                            failure: doFail,
                            // don't provide we we can rollup errors
                            feedbackContainer: actionArgs ? actionArgs.component : this.ownerCt,
                            scope: this,
                            _model: model,
                            _index:index,
                            _objectId: model.getId()});
                    }
                }
                if (index==count && options.callback){
                    doCallback(record, operation, resultMap);
                }
            }
            progress.startOperation();
            doNext.call(this);   // start chain of calls
        }
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UpdateAction-strings.js

Ext.namespace("xcp.Strings.action.form.UpdateAction");
Ext.apply(xcp.Strings.action.form.UpdateAction, {
    confirmationTitle: "Update Item?",
    confirmationPromptTemplate: "Are you sure you want to update this item?",
    updateSuccessNotificationTemplate:  "The item has been updated.",
    updateErrorTemplate: "An error occurred while updating this item."
});
/* update/content/xcp/action/form/UpdateAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UpdateAction.js

/**
 * @class xcp.action.form.UpdateAction
 * @extends xcp.action.form.DataAction
 * Action implementation for updating resources within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.form.UpdateAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.update",

    statics: {
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {string} id  instance id
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, id, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (xcp.action.form.DataAction.REDIRECT_SPECIFIED == action.redirectStyle) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    url = action.redirectUrlModel + "/" + id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        }

    },

    config: {
        preconditions: {
            targets:{
                effectivePermissions: [xcp.Permit.WRITE]
            }
        },

        getEnablement:function(actionArgs, action){
            var target = action.getTargets(actionArgs)[0];
            if (target){
                var lockOwner = target.get('r_lock_owner');
                if (lockOwner && (lockOwner !== '') && (xcp.currentUser.currentUser != lockOwner))
                    return xcp.Enablement.HIDE;
            }
            if(xcp.navigationManager.currentNavigationContext.versionRequested == true)
                    return xcp.Enablement.HIDE;
            return xcp.Enablement.ENABLE;
        },

        /**
         * @cfg {String} confirmationPrompt Pattern for string used as confirmation prompt (defaults to
         * Are you sure you want to update an item"?)
         */
        confirmationPrompt: xcp.Strings.action.form.UpdateAction.confirmationPromptTemplate,
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: true
    },

    /**
     * Handler for the UpdateAction
     */
    handler: function(actionArgs, action) {
        var config = this.getConfig();

//        //update action's input model when action is invoked.
//        if (!Ext.isEmpty(actionArgs.selection))
//            this.setInputModel(actionArgs.selection[0]);

        var model = this.getActionModel();

        //to set model instance property "phantom" to be false since this action model is just created
        //and ExtJs expected this value to be false so it can issue a "PUT" action to the server
        model.phantom = false;

        var id = model.getId();

        var handleUpdateSuccess = function(record, operation) {
            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, id);

            if (this.showSuccessNotification) {
                xcp.action.form.DataAction.notifyActionSuccess(this.ownerCt || actionArgs.component, xcp.Strings.action.form.UpdateAction.updateSuccessNotificationTemplate, model);
            }

            xcp.action.form.UpdateAction.handleRedirection(this, id, record, operation);

        };
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    model.save({success: handleUpdateSuccess, feedbackContainer: this.ownerCt || actionArgs.component, scope: this, actionConfig: config});
                }
            };

            Ext.Msg.show({
                title:  xcp.Strings.action.form.UpdateAction.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.form.UpdateAction.confirmationPromptTemplate, model),
                scope: this
            });
        } else {
            model.save({success: handleUpdateSuccess, feedbackContainer: this.ownerCt || actionArgs.component, scope: this, actionConfig: config});
        }
    }

});
/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */

// UpdateParametersAction-strings.js

Ext.namespace("xcp.Strings.action.form.UpdateParametersAction");
Ext.apply(xcp.Strings.action.form.UpdateParametersAction, {
    updateSuccessNotificationTemplate:  "The new values have been applied.",
    updateSuccessNotificationTemplateSingle: "The new value has been applied."
});
/* updateparameters/content/xcp/action/form/UpdateParametersAction.js */

/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */
// UpdateParametersAction.js

/**
 * @class xcp.action.form.UpdateParametersAction
 * @extends xcp.action.Action
 * Action implementation for updating application parameters within an xCP application.  It should be associated with
 * component that is contained within an page (xtype:xcp_page) instance that contains an
 * application parameter container component.
 */
Ext.define("xcp.action.form.UpdateParametersAction", {
    extend: "xcp.action.Action",
    alias: "action.updateparameters",

    /**
     * Handler for the UpdateParametersAction
     */
    handler: function(actionArgs, action) {
        var me = this;
        var page = this.up("xcp_page");
        var params = Ext.ComponentQuery.query("xcp_app_param", page);
        var updatedConfigs = [];
        Ext.Array.each(params, function(value) {
            var config = value.getChangedRecord();
            if (config) {
                updatedConfigs.push(config);
            }
        });

        if (updatedConfigs.length == 0) {
            return;
        }

        var operation = Ext.create('Ext.data.Operation', {
            records: updatedConfigs,
            action: 'create'
        });

        var callback = function(operation) {
            var successMessage;
            if (operation.wasSuccessful()) {
                if (updatedConfigs.length == 1) {
                    successMessage = xcp.Strings.action.form.UpdateParametersAction.updateSuccessNotificationTemplateSingle;
                } else {
                    successMessage = xcp.Strings.action.form.UpdateParametersAction.updateSuccessNotificationTemplate;
                }
                xcp.core.FeedbackManager.showFeedback(me.ownerCt, "", successMessage, "notifications");
                Ext.Array.each(updatedConfigs, function(param) {
                    param.save();
                });
            } else {
                xcp.core.FeedbackManager.showFeedback(me.ownerCt, "", operation.error.statusText, "systemErrors");

                Ext.Array.each(updatedConfigs, function(param) {
                    param.reject(true);
                });
            }
        };

        var proxy = Ext.create('Ext.data.proxy.Rest', {
            model: "xcp.data.model.NamespaceConfigModel",
            url: "application/" + xcp.appContext.namespace + "/parameters",
            writer: Ext.create("Ext.data.writer.Json", {allowSingle: false}),
            appendId: false
        });

        proxy.create(operation, callback, me);
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UpdateAction-strings.js

Ext.namespace("xcp.Strings.action.form.UpdateAction");
Ext.apply(xcp.Strings.action.form.UpdateAction, {
    confirmationTitle: "Update Item?",
    confirmationPromptTemplate: "Are you sure you want to update this item?",
    updateSuccessNotificationTemplate:  "The item has been updated.",
    updateErrorTemplate: "An error occurred while updating this item."
});
/* updatesetting/content/xcp/action/form/UpdateSettingAction.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

// UpdateAction.js

/**
 * @class xcp.action.form.UpdateSettingAction
 * @extends xcp.action.form.UpdateAction
 * Action implementation for updating setting within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.form.UpdateSettingAction", {
    extend: "xcp.action.form.UpdateAction",
    alias: "action.updatesetting",

    /**
     * Handler for the UpdateAction
     */
    handler: function(actionArgs, action) {
        var config = this.getConfig();

        var model = this.getActionModel();

        //to set model instance property "phantom" to be false since this action model is just created
        //and ExtJs expected this value to be false so it can issue a "PUT" action to the server
        model.phantom = false;

        var id = model.getId(),
            role = model.get("role");

        var handleUpdateSuccess = function(record, operation) {
            if (this.showSuccessNotification) {
                xcp.action.form.DataAction.notifyActionSuccess(this.ownerCt || actionArgs.component, xcp.Strings.action.form.UpdateAction.updateSuccessNotificationTemplate, model);
            }

            if (xcp.currentUser) {
                // Update the userContext with the user's role
                xcp.currentUser.currentUserRole = role;
                if (role == "") {
                    xcp.currentUser.currentUserRoleLabel = "";
                } else {
                    var roleStore = Ext.data.StoreManager.lookup("xcp.picklist.RoleStore");
                    if (roleStore) {
                        var roleData = roleStore.getById(role);
                        if (roleData) {
                            xcp.currentUser.currentUserRoleLabel = roleData.get("label");
                        }
                    }
                }
            }
            xcp.core.UserProfile._userProfile.set('role', role);  // $NON-NLS-1$

            xcp.action.form.UpdateAction.handleRedirection(this, id, record, operation);

        };
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    model.save({success: handleUpdateSuccess, feedbackContainer: this.ownerCt || actionArgs.component, scope: this, actionConfig: config});
                }
            };

            Ext.Msg.show({
                title:  xcp.Strings.action.form.UpdateAction.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.form.UpdateAction.confirmationPromptTemplate, model),
                scope: this
            });
        } else {
            model.save({success: handleUpdateSuccess, feedbackContainer: this.ownerCt || actionArgs.component, scope: this, actionConfig: config});
        }
    }

});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// AcquireTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.AcquireTaskDataAction");
Ext.apply(xcp.Strings.action.task.AcquireTaskDataAction, {
    confirmationTitle: "Acquire Task?",
    confirmationPromptTemplate: "Are you sure you want to acquire this task?",
    acquireTaskSuccessNotificationTemplate:  "The task has been acquired.",
    acquireTaskErrorTemplate: "An error occurred while acquiring this task. Please try again.",
    text:"Acquire",
    tooltip:"Acquire"
});
/* xcp_acquire_task/content/xcp/action/task/AcquireTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// AcquireTaskDataAction.js

/**
 * @class xcp.action.form.UpdateAction
 * @extends xcp.action.form.DataAction
 * Action implementation for updating resources within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.task.AcquireTaskDataAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.xcp_acquire_task",

    statics: {
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {string} id  instance id
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, id, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    url = action.redirectUrlModel + "/" + id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        }

    },
    config: {
        requiredAttributes: ["task_state","workqueue_name","task_performer_name"],
        text: xcp.Strings.action.task.AcquireTaskDataAction.text,
        tooltip: xcp.Strings.action.task.AcquireTaskDataAction.tooltip,
        confirmationPrompt: xcp.Strings.action.task.AcquireTaskDataAction.confirmationPromptTemplate,
        showConfirmation: false,
        actionModel:"acquire_task_model",
        showSuccessNotification:true
    },

    constructor: function(config) {
        config = config || {};
        var prototype = this.self.prototype;
        // copy primary attributes from prototype (so handler doesn't have to be in config)
        var prototypeConfig=Ext.copyTo({},prototype.config, ["text", "iconCls", "tooltip", "handler", "actionModel", "showSuccessNotification"]);
        Ext.applyIf(config, prototypeConfig);

        this.callParent([config]);
    },

    /**
     * Handler for the UpdateAction
     */
    handler: function(actionArgs, action) {
        var config;
        // Note that this method will run in the context of the associated component (button, menu, etc.), therefore
        // the "this" refers to the component, not to the action.  Configuration from the action is propogated to the
        // component, but functions are not, thus functions which access instance data won't work.

        if (Ext.isEmpty(action)) { //delete action invoked from form button
//            //update action's input model when action is invoked.
//            if (!Ext.isEmpty(actionArgs.selection))
//                this.setInputModel(actionArgs.selection[0]);
//
            config = this.getConfig();
            targets = [this.getActionModel()];
        }
        else {
            config = action.getConfig();
            targets = action.getTargets(actionArgs);
        }
        var model=xcp.action.form.DataAction.getModelForSelection(targets[0], this.actionModel);

        //to set model instance property "phantom" to be false since this action model is just created
        //and ExtJs expected this value to be false so it can issue a "PUT" action to the server

        model.phantom = false;

        var id = model.getId();

        var handleAcquireSuccess = function(record, operation) {
            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, id);
            if (config.showSuccessNotification) {
                xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.AcquireTaskDataAction.acquireTaskSuccessNotificationTemplate);
            }

            xcp.action.task.AcquireTaskDataAction.handleRedirection(this, id, record, operation);

        };
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    model.save({success: handleAcquireSuccess, feedbackContainer: actionArgs.component, scope: this});
                }
            };

            Ext.Msg.show({
                title:  xcp.Strings.action.form.UpdateAction.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.task.AcquireTaskDataAction.confirmationPromptTemplate, model),
                scope: this
            });
        } else {
            model.save({success: handleAcquireSuccess, feedbackContainer: actionArgs.component, scope: this});
        }
    },
    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;

        if (baseAction.isQueueTask(actionArgs, action)) {
            applicable = baseAction.isQueueTaskActionApplicable(actionArgs, action, true, true,true,false, true,0);
        } else {
            applicable = baseAction.hasTaskState(actionArgs, action,0);
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;
    },
    getInitialEnablement: function() {
        return xcp.Enablement.HIDE;
    }
});


/* xcp_acquire_task/content/xcp/data/model/AcquireTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("acquire_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/acquire"
    },
    "fields" : [
        {
            "name":"id"
        }
    ]
});


/* xcp_action_container/content/xcp/widget/ActionContainer.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * A specialized Ext container component, responsible for holding action instances (data source actions)
 * defined on the page.
 * The action container take care of managing action instance life cycle (create, destroy).
 * @xtype xcp_action_container
 */
Ext.define('xcp.widget.ActionContainer', {
    extend: 'Ext.container.Container',
    alias: 'widget.xcp_action_container',

    statics : {
        findActionInstance: function(sourceComp, actionInstanceId) {
            var evalContext = xcp.core.expr.ExpressionManager.getEvaluationContext(sourceComp, {});
            return evalContext.getAction(actionInstanceId);
        }
    },

    /**
     * Collection of action instances.
     * key : actionInstanceId(xcpId) of action instance.
     * value: action object.
     */

    /**
     * Creates a new action container.
     * @param {Object} (Required) array of action instance configuration objects.
     *
     */
    constructor: function(config) {
        this.actionInstanceMap = new Ext.util.MixedCollection();
        if (config.xcpId) {
            this.xcpId= config.xcpId;
        }
        this.callParent(arguments);
        var actionsConfig = (config && config.actions) || [];
        if (!Ext.isArray(actionsConfig)) {
            actionsConfig = [actionsConfig];
        }
        for (var i=0; i < actionsConfig.length; i++) {
            //Create an action instance
            var actionInst = xcp.core.ActionManager.create(actionsConfig[i]);

            var itemId = (actionsConfig[i].xcpId) || actionsConfig[i].id;
            actionInst.itemId = itemId;
            //Set action container.
            actionInst.ownerCt = this;
            this.actionInstanceMap.add(itemId, actionInst);
        }
    },

    /**
     * Returns the action instance object for given action instance id (xcpId)
     * @param actionInstanceId (String) (Required) xcpId of action instance
     */
    getComponent: function(actionInstanceId) {
        if (this.actionInstanceMap.containsKey(actionInstanceId)) {
            return this.actionInstanceMap.get(actionInstanceId);
        }
        return this.callParent(arguments);
    },
    /**
     * Get all action instances
     */
    getActionInstances: function() {
        return this.actionInstanceMap;
    },
    /**
     * Fire render related events on behalf of action instances
     */
    beforeRender : function() {
        this._fireActionEvent("beforerender");
        return this.callParent(arguments);
    },

    /**
     * Fire render related events on behalf of action instances
     */
    afterRender : function() {
        var ret = this.callParent(arguments);
        this._fireActionEvent("afterrender");
    },

    /**
     * Clean the action instances.
     */
    beforeDestroy : function() {
        var count = this.actionInstanceMap.getCount();
        for (var i=0; i < count; i++) {
            var actionInst = this.actionInstanceMap.getAt(i);
            actionInst.destroy();
        }
        return this.callParent(arguments);
    },
    /**
     * @private
     * @param event
     */
    _fireActionEvent: function(event) {
        var count = this.actionInstanceMap.getCount();
        for (var i=0; i < count; i++) {
            var actionInst = this.actionInstanceMap.getAt(i);
            actionInst.fireEvent(event,actionInst);
        }
    }
});


/* xcp_action_menu/content/xcp/widget/menu/ActionMenu.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.menu.ActionMenu
 * @extend Ext.button.Button
 * @xtype xcp_action_menu
 */
Ext.define("xcp.widget.menu.ActionMenu", {
    extend: "Ext.button.Button",
    alias: "widget.xcp_action_menu",

    constructor: function(config) {
        config = config || {};

        if (!config.menu) {
            this.actionArgs = xcp.core.ActionManager.findActionArgsProvider(this);
            if (!this.actionArgs)
                this.actionArgs = new xcp.core.ActionArgs({component: this, selection:[]});
            var menu = xcp.core.ActionManager.getContextMenu(this.actionArgs, "ActionMenu", {destroyOnHide: false});
            config = Ext.apply(config, {menu: menu});
        }

        this.callParent([config]);
    }
});/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.grid.ResultsListColumn");

Ext.apply(xcp.Strings.widget.grid.ResultsListColumn, {
    trueStr: "true",
    falseStr: "false",
    lockedByAnother : "Locked {0} by {1}",
    lockedByYou: "Locked {0} by you."
});
/* xcp_results_list_column/content/xcp/widget/grid/ResultsListColumn.js */

// ResultsListColumn.js
/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.grid.ResultsListColumn
 * @extends Ext.grid.column.Column
 * Represents a column within a results list
 * @xtype xcp_results_list_column
 */
Ext.define("xcp.widget.grid.ResultsListColumn", {
            extend: "Ext.grid.column.Column",
            alias:  "widget.xcp_results_list_column",
            width: 150,
			xcpSubCmp: true,
            constructor: function(config) {


                config = config || {};

                var expression = config.expression;
                if (expression) {
                    if (!Ext.isArray(expression)) {
                        expression = [expression];
                    }
                    for (var i = 0; i < expression.length; i++) {
                        if (expression[i]["propertyId"] == "dataIndex") {
                            this.dataIndexExpression = expression[i];
                            break;
                        }
                    }
                }
                if (config && config.format) {
                    //Create formatter instance
                    this._formatter = xcp.core.FormatManager.create(config.format);
                }

                if (config && config.repeatingAttributeFormat) {
                    //this._repeatingAttributeFormatter = xcp.core.FormatManager.create(config.repeatingAttributeFormat);
                    this._repeatingAttributeFormatter = Ext.create('formatter.xcp_repeating_attribute_formatter', config.repeatingAttributeFormat);
                }

                this.callParent(arguments);

            },

            renderer : function(value, metaData, record, rowIdx, colIdx, store, view) {
                //renderer scope is resultslist object, so need to get the column object
                var column = view.getHeaderCt().getHeaderAtIndex(colIdx);

                if (column && column.dataIndexExpression) {
                    var page = undefined;
                    if (Ext.isFunction(this.getPage)) {
                        page = this.getPage();
                    }
                    if (!page) {
                        xcp.Logger.debug("Could not find page in page context");
                        page = this.findParentByType("xcp_page");
                    }
                    if (!page) {
                        page = Ext.getCmp("_topPageContainer");
                    }
                    var exprConfig = Ext.apply({}, column.dataIndexExpression);
                    //EvaluationContext would not be able to locate the model object from page
                    //So passing them explicitly.
                    exprConfig.models = {};
                    exprConfig.models[record.modelName] = record;
                    value = xcp.core.expr.ExpressionManager.evaluate(page, exprConfig);
                }

                value = xcp.formatter.Util.formatWidgetValues(column, value,
                            xcp.Strings.widget.grid.ResultsListColumn.trueStr,
                            xcp.Strings.widget.grid.ResultsListColumn.falseStr);

                /* Disable all the cells in the result list if the model is not supported. */
                var id = record.get("id"),
                    modelName = xcp.util.Utils.getModelFromObjectType(record.get("r_object_type"), record.get("id"));
                if (xcp.util.Utils.isSupportedModel(modelName) || xcp.util.Utils.isRelationshipQuery(record) || xcp.util.Utils.isTaskModel(modelName, record))
                    return value;
                else
                    return "<span class='xcp-not-supported'>" + value + "</span>";
            },

            /**
             * Get function from string
             * For example: if the function is defined as:
             * com.myFunction = function(){..}
             * getFunction("com.myFunction") will return the actual function
             * @param str
             */
            getFunction : function(str) {
                var tokens = str ? str.split('.') : [],
                        len = tokens.length,
                        fn = len > 0 ? window[tokens[0]] : false;
                if (fn) {
                    for (var i = 1; i < len; i++) {
                        fn = fn[tokens[i]];
                        if (!fn) {
                            break;
                        }
                    }
                }
                return fn;
            },

            /**
             * Resolves the value to corresponding label if the column is associated with a picklist, returns the value otherwise.
             * @param value value to resolve
             */
            resolvePickListValue: function(value) {
                if (this.valueType && this.valueType.length) {
                    var store = Ext.data.StoreManager.lookup(this.valueType);
                    value = xcp.formatter.Util.resolvePickListLabel(store, value);
                }
                return value;
            },
            /**
             * Apply formatting if configured
             * @param value value to resolve
             */
            formatValue: function(value) {
                if (value !== undefined && value !== null && value !== "") {
                    if (this._formatter) {
                        //Get the applicable css class for the formatted value (e.g. for negative no. there could be a CSS class).
                        value = this._formatter.format(value);
                    }
                    if (this._repeatingAttributeFormatter) {
                        value = this._repeatingAttributeFormatter.format(value);
                    }
                }

                return value;
            }
        });

/* xcp_results_list_page_link_column/content/xcp/widget/grid/ResultsListPageLinkColumn.js */

// ResultsListPageLinkColumn.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.grid.ResultsListDefaultPageLinkColumn
 * @extends xcp.widget.grid.ResultsListColumn
 * Represents a column within a results list where the data is presented as a link to the associated item's default page
 * @xtype xcp_results_list_column
 */
Ext.define("xcp.widget.grid.ResultsListPageLinkColumn", {
    extend: "xcp.widget.grid.ResultsListColumn",
    alias:  "widget.xcp_results_list_page_link_column",

    beforeRender: function() {
        var me = this,
            grid = me.up('xcp_results_list_grid');

        me.callParent();

        if (grid){
            grid.insideDialog = me.up("xcp_wizard") != null;
            grid.appPage = xcp.util.Utils.getNavigationAppPage(this);
        }
    },

    renderer : function(value, metaData, record, rowIdx, colIdx, store, view)
    {
        value = this.callParent(arguments);
        if (this.insideDialog){
            return value;
        }

        var html;
        var id = record.get("id");
        var modelName = this.typeName;

        var pageUrl =  xcp.util.Utils.getDefaultPageFromContextMenu(modelName, record);

        var url;

        if (id && pageUrl && value && value.length > 0)
        {
            // Render the data as a link
            var isVersionRequest = false;

            if(store.proxy.extraParams.type == "versionHistoryQuery")
            {
                modelName = xcp.util.Utils.getModelFromObjectType(record.get("r_object_type"),id);
                pageUrl =  xcp.util.Utils.getDefaultPageFromContextMenu(modelName, record);

                if(record.get("r_version_label")[0] != "CURRENT")
                  isVersionRequest = true;
            } else if (xcp.util.Utils.isTaskModel(modelName, record)) {
                //Set process name as a model name
                modelName = xcp.util.Utils.getProcessName(record);
            }

            url = xcp.util.Utils.buildPageUrl(modelName, id, pageUrl, this.appPage, isVersionRequest);
            html = Ext.String.format('<a href="#{0}" onclick="xcp.navigationManager.navigate(\'{0}\');return false;">{1}</a>',
                    url, value);
            return html;
        }
        else
        {
            return value;
        }
    }
});

/* xcp_folder_list_lock_column/content/xcp/widget/grid/FolderListLockColumn.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function() {
    /**
     * @class xcp.widget.grid.FolderLListLockColumn
     * @extends xcp.widget.grid.ResultsListColumn
     * Represents a column that links to a lock status of a document
     * @xtype xcp_results_list_column
     */
    Ext.define("xcp.widget.grid.FolderLListLockColumn", {
        extend: "xcp.widget.grid.ResultsListColumn",
        alias:  "widget.xcp_folder_list_lock_column",

        renderer : function(value, metaData, record, rowIdx, colIdx, store, view) {
            var html, iconUrl, lockStatus;
            var lockOwner = record.get("r_lock_owner"),
                lockDate = record.get("r_lock_date"),

                format = {
                    xtype: "xcp_datetime_formatter",
                    dateStyle : "datetime",
                    dateFormat: "short",
                    timeFormat : "short"
                },
                datetimeformatter = new xcp.formatter.DateTimeFormatter(format),

                modelName = xcp.util.Utils.getModelFromObjectType(record.get("r_object_type"), record.get("id"));

            if (modelName == "dm_cabinet")
                modelName = "xcp_dm_folder";

            //xcp.currentUser
            if (xcp.currentUser.currentUser == record.get("r_lock_owner")){
                // Render a key image
                iconUrl = "component/xcp-core/icons/key_misc.png";
                lockStatus = Ext.String.format(xcp.Strings.widget.grid.ResultsListColumn.lockedByYou, datetimeformatter.format(lockDate));
                html = "<div data-qtip=\""+ lockStatus +"\"><img data-qtip=\""+ lockStatus + "\" src=\" " + iconUrl + "\" /></div>";  // $NON-NLS-L$ 
                return html;


            } else if ((xcp.currentUser.currentUser != record.get("r_lock_owner")) && (lockOwner !== '')) {
                // Render a lock image
                iconUrl = "component/xcp-core/icons/lock_misc.png";
                lockStatus = Ext.String.format(xcp.Strings.widget.grid.ResultsListColumn.lockedByAnother, datetimeformatter.format(lockDate), lockOwner);
                html = "<div data-qtip=\""+ lockStatus +"\"><img data-qtip=\""+ lockStatus + "\" src=\" " + iconUrl + "\" /></div>";  // $NON-NLS-L$ 
                return html;

            } else {
                return "";
            }
        }
    });
})();

/* xcp_folder_list_page_link_column/content/xcp/widget/grid/FolderListPageLinkColumn.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function()
{

    /**
     * @class xcp.widget.grid.FolderLListPageLinkColumn
     * @extends xcp.widget.grid.ResultsListColumn
     * Represents a column that links to a "view document" or "view file" page depending on type
     * @xtype xcp_results_list_column
     */
    Ext.define("xcp.widget.grid.FolderListPageLinkColumn", {
        extend: "xcp.widget.grid.ResultsListColumn",
        alias:  "widget.xcp_folder_list_page_link_column",

        renderer : function(value, metaData, record, rowIdx, colIdx, store, view)
        {
            value = this.callParent(arguments);

            var html;
            var imgTag = "";
            imgTag = "<img src=\"" + record.get("icon") + "\" border=\"0\" height=\"24\" width=\"24\">";  // $NON-NLS-L$
            if (this.isInsideWizard()){
                return imgTag + value;
            }
            var url, id = record.get("id"),
                    modelName = xcp.util.Utils.getModelFromObjectType(record.get("r_object_type"), record.get("id"));

            var pageUrl =  xcp.util.Utils.getDefaultPageFromContextMenu(modelName, record);

            // XCPECM-1174 Always show the icon but show it disabled
            url = xcp.util.Utils.makePageUrl(modelName, id, pageUrl, this);
            if (url)
            {
                // Render the data as a link
                html = Ext.String.format('<a href="#{0}" onclick="xcp.navigationManager.navigate(\'{0}\');return false;">{1}</a>',
                        url, value);
                value = imgTag + html;
            }
            if (xcp.util.Utils.isSupportedModel(modelName))
                return value;
            // non-supported item are disabled
            return "<span class='xcp-not-supported'>" + value + "</span>";
        }
    });
})();





/* xcp_pagingtoolbar/content/xcp/widget/grid/XCPPagingToolbar.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/*
    @class xcp.widget.grid.XCPPagingToolbar
    * @extends Ext.toolbar.Paging
    Extending Ext.toolbar.Paging to create xcp_pagingtoolbar which works as normal toolbar
    and also handles the services which return "null" total.
    @xtype xcp_pagingtoolbar
 */
Ext.define('xcp.PagingToolbar', {
        extend: 'Ext.toolbar.Paging',
        alias: "widget.xcp_pagingtoolbar",
        displayInfo: false, // turn this off up front for performance.

        // can't override bottom dock bar's top border setting via CSS; do it this way.
        style : {
            "border-top-width": "1px"
        },

    /*
    Overriding private method: Initialize variables to track the total reached so far, total page count reached,
    if actual total is reached (we assume at some point the service will return the actual number instead of "null"
    if total is found.
     TODO: We need to change the logic if the assumption is not correct.
     ****http://cmajira:8080/browse/XCPUIC-246 affects the totals calculated by the xcp_pagingtoolbar.******
     */

     /*
     Create instance variables of the prev, next and displayItem which are used in onLoad()
      */
     onPagingToolbarRender: function(){
        this.prev = this.child('#prev');
        this.next = this.child('#next');
        var displayItem = this.displayItem = this.child('#displayItem');
        if (displayItem) {
            // performance: show/hide of displayItem causes relayout
            displayItem.setVisible = Ext.emptyFn;
            displayItem.show = Ext.emptyFn;
        }
    },

    initComponent: function(){

        this.callParent();
        this.on('render', this.onPagingToolbarRender, this, {single: true});

        if (!this.totalCount){
            this.totalReached = false;
            this.totalCount = 0;
            this.totalPageCount = 1;
            this.currentPage = 0;
        }
    },

    /**
     * Gets the standard paging items in the toolbar
     * Overriding a private method and returning only next and prev elements.
     */
    getPagingItems: function() {
        var me = this;

        return [{
            itemId: 'prev',
            tooltip: me.prevText,
            overflowText: me.prevText,
            iconCls: Ext.baseCSSPrefix + 'tbar-page-prev',
            disabled: true,
            handler: me.movePrevious,
            scope: me
        },
        {
            itemId: 'next',
            tooltip: me.nextText,
            overflowText: me.nextText,
            iconCls: Ext.baseCSSPrefix + 'tbar-page-next',
            disabled: true,
            handler: me.moveNext,
            scope: me
        }];
    },

    /*
    Overriding private method: In case of "null" total "afterPagetext" and "displayMsg" are "this.totalPageCount+" and "this.totalCount+"
    "Go to Last" is disabled for dataset with "null" total.
    In other cases behaves like Ext.toolbar.Paging
     */
    onLoad : function(){
        var me = this,
            pageData,
            currPage,
            pageCount,
            afterText;

        //We want to to render the toolbar in design mode but not do any store loading for it.
        if(!this.store){
            return;
        }

        //this.totalCount is not reliable, change to check the currentPage
        if (this.store.currentPage == 1) {
            this.totalCount = 0;
            this.totalPageCount = 1;
            this.totalReached = false;
            this.updatePageTotals(this.store);
        }

        pageData = me.getPageData();
        currPage = pageData.currentPage;
        pageCount = pageData.pageCount;
        this.prev = this.child('#prev');
        this.next = this.child('#next');
        this.prev.setDisabled(currPage === 1);
        this.next.setDisabled(currPage === pageCount);
        if (me.rendered) {
        	 me.fireEvent('change', me, pageData);
        }
    },
    /*
    Update the Totals
     */
    updatePageTotals: function(store){

        var totalCount = store.getTotalCount();
        this.currentPage = store.currentPage;

        if ((totalCount === "null") && !this.totalReached){ //case: returned data does not have total info
            if (store.data.getCount() < store.pageSize){
                this.totalReached = true;
                this.totalCount = store.data.getCount();
            }
            else{
                if (this.currentPage+1 > this.totalPageCount)
                    this.totalCount = this.totalCount + store.data.getCount();
            }
        }
        else if (Ext.isNumber(totalCount)) { //case: returned data has the total info
            this.totalReached = true;
            this.totalCount = totalCount;
        }
    },
    /*
    Overriding private method: To calculate the pagedata in normal cases and special cases when total from service is "null"
     */
    getPageData : function(){

        var pageCount, store = this.store;
        var totalCount = store.getTotalCount();
        this.currentPage = store.currentPage;

        if (totalCount === "null" && (store.data.getCount() < store.pageSize))
            pageCount = Math.ceil(this.totalCount / store.pageSize);
        else{
            if ((this.totalCount == 0) || (totalCount === "null"))
                pageCount = Math.ceil(this.totalCount / store.pageSize) + 1;
            else
                pageCount = Math.ceil(this.totalCount / store.pageSize);
        }

        return {
            total : this.totalCount,
            currentPage : this.currentPage,
            pageCount: pageCount,
            fromRecord: ((store.currentPage - 1) * store.pageSize) + 1,
            toRecord: Math.min(store.currentPage * store.pageSize, this.totalCount)
        };
    },
   /*
   Overriding the moveNext() method to update the page totals and current page and to update the totalPageCount.
   totalPageCount and variable totalCount and totalReached are important when the total returned by service is "null" to
   keep track of real totals.
    */
    moveNext : function(){

        this.updatePageTotals(this.store);
        if (this.currentPage == this.totalPageCount)
            this.totalPageCount = this.totalPageCount + 1;

        this.callParent();
    }
});
/* xcp_results_list/content/xcp/widget/grid/facets/SelectedFacetModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.widget.grid.facet.SelectedFacetModel", {
    extend: 'Ext.data.Model',
    proxy: {
        type: "memory"
    },
    fields: ["facetId", "facetLabel", "value", "valueLabel", "constraint"]
});/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.grid.facets.SelectedFacets");

Ext.apply(xcp.Strings.widget.grid.facets.SelectedFacets, {
    removeFacetTooltipTemplate: "Remove {0}",
    removeAll: "Remove all"
});
/* xcp_results_list/content/xcp/widget/grid/facets/SelectedFacets.js */

/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

// SelectedFacets.js
/**
 * @class xcp.widget.grid.facets.SelectedFacets
 * @extends Ext.panel.Panel
 * Shows selected facets
 * @xtype xcp_selected_facets
 */
Ext.define("xcp.widget.grid.facets.SelectedFacets", {
    extend: "Ext.panel.Panel",
    alias: "widget.xcp_selected_facets",
    ui: "xcp-selected-facets",
    hidden: true,

    removeIconCls: 'xcp-selected-facet-remove-icon',

    initComponent: function() {
        var me = this;

        me.addEvents(
            /**
             * @event datachanged
             * Fires when the selected facets have changed
             */
            'facetRemoved'
        );

        me.store = Ext.create("Ext.data.Store", {
            model: "xcp.widget.grid.facet.SelectedFacetModel",
            listeners: {
                remove: function(store, record, index, opts) {
                    me.updateDockedItems();
                    me.fireEvent('facetRemoved', record);
                },
                clear: function(store, opts) {
                    me.updateDockedItems();
                    me.fireEvent('facetRemoved', null);
                }
            },
            data: []
        });

        me.dataview = Ext.widget("dataview", {
            store: this.store,
            trackOver: true,
            tpl: this.getTemplate(),
            overItemCls: 'xcp-selected-facet-over',
            itemSelector: 'div.xcp-selected-facet',
            listeners: {
                selectionchange: function(dv, nodes ){
                    me.store.remove(nodes);
                }
            }
        });

        me.removeAll = Ext.widget("tbtext", {
            hidden: true,
            dock: 'bottom',
            xtype: 'tbtext',
            cls: 'xcp-selected-facet-remove-label',
            text: xcp.Strings.widget.grid.facets.SelectedFacets.removeAll,
            listeners: {
                render: function(){
                    this.getEl().addListener('click',
                        me.onRemoveAllFacets,
                        me
                    );
                }
            }
        });

        me.dockedItems = {
            xtype: 'container',
            dock: 'bottom',
            border: false,
            items: [me.removeAll]
        };

        me.items = [me.dataview];

        me.callParent(arguments);
    },

    getTemplate: function() {
        var me = this;
        var template = new Ext.XTemplate(
            '<tpl for=".">',  // $NON-NLS-1$
                '{[this.renderSelectedValues(values)]}',
            '</tpl>',
            {
                renderSelectedValues: function(values) {
                    var facetLabel = Ext.isEmpty(values.valueLabel) ? values.facetLabel : values.valueLabel;
                    var selectedFacet = values.facetLabel + ": " + facetLabel;
                    var qtip = Ext.String.format(xcp.Strings.widget.grid.facets.SelectedFacets.removeFacetTooltipTemplate,
                                                 selectedFacet);

                    var retTpl = [
                        '<div class="xcp-selected-items">',
                            '<div class="xcp-selected-facet" data-qtip="' + Ext.String.htmlEncode(qtip) + '">',  // $NON-NLS-1$
                            '<img alt="" src="' + Ext.BLANK_IMAGE_URL + '" class="' + me.removeIconCls + '" />',  // $NON-NLS-1$
                            '<div class="xcp-selected-facet-value"><span class="xcp-selected-facet-value-label">',
                                Ext.String.htmlEncode(selectedFacet),
                            '</span></div></div>',
                        '</div>'
                    ];

                    return retTpl.join('');
                }
            }
        );

        return template;
    },


    addFacet: function(facet){
        try {
            Ext.suspendLayouts();
             // Add the new facet for display
            var selectedFacet = Ext.create("xcp.widget.grid.facet.SelectedFacetModel", {
                facetId: facet.facetId,
                facetLabel: facet.facetLabel,
                value: facet.value,
                valueLabel: facet.valueLabel,
                constraint: facet.constraint
            });

            this.store.add(selectedFacet);
            this.updateDockedItems();

        } finally {
            Ext.resumeLayouts(true);
        }
    },

    onRemoveAllFacets: function(){
        try {
            Ext.suspendLayouts();

            this.store.removeAll();
            this.updateDockedItems();
        } finally {
            Ext.resumeLayouts(true);
        }
    },

    updateDockedItems: function(){
        // Display the remove all link if more than one facet is selected
        try {
            Ext.suspendLayouts();
            var count = this.store.getCount();
            this.removeAll.setVisible(count > 1);
            this.setVisible(count > 0);
        } finally {
            Ext.resumeLayouts(true);
        }
    }

});


/* xcp_results_list/content/xcp/widget/grid/facets/SimpleFacetModel.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.widget.grid.facets.SimpleFacetModel", {
    extend: 'Ext.data.Model',
    fields: ["id", "count", "constraint"]
});/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.grid.facets.SimpleFacet");

Ext.apply(xcp.Strings.widget.grid.facets.SimpleFacet, {
    showMore : "Show more"
});
/* xcp_results_list/content/xcp/widget/grid/facets/SimpleFacet.js */

/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.widget.grid.facets.SimpleFacet", {
    extend: "Ext.panel.Panel",
    alias: "widget.xcp_facet_simple",
    /*requires: [
        "xcp.facets.FacetManager"
    ],*/
    hidden: true,
    ui: 'xcp-simple-facet',
    collapsible: true,
    titleCollapse: true,
    valueDisplaySize: 7, //default facet value display size
    additionalDisplaySize: 20, //addition facet values to display when click on more

    initComponent: function() {
        var config = this.initialConfig,
            me = this;

        me.addEvents(
                /**
                 * @event facetvalueclicked
                 * Fires when the facet value is selected.
                 */
                 'facetvalueclicked');

        me.currentValueDisplaySize = me.valueDisplaySize;
        if (config.facet) {
            var facet = config.facet;
            var store = Ext.getStore(facet.id),
                filter = !config.showEmptyValueFacets ? Ext.create('Ext.util.Filter', {
                            filterFn: function(item) {
                                return item.get('count') > 0;
                            }
                        }) : [];

            if (!store && facet.modelName) {  //store not found in store manager
                store = new Ext.data.Store({
                    /**
                     * LoadPage when user click showmore
                     * @param page
                     */
                    loadPage: function(page) {
                        var storeScope = this;

                        storeScope.currentPage = page;

                        me.currentValueDisplaySize = storeScope.pageSize + (me.additionalDisplaySize * (storeScope.currentPage - 1));
                        storeScope.read({
                            page: page,
                            start: 0,
                            limit: me.currentValueDisplaySize,
                            addRecords: !storeScope.clearOnPageLoad
                        });
                    },
                    model: facet.modelName,
                    proxy: {
                    //need to create private instance of proxy here instead of shared by the model
                        type: 'pagingmemory',
                        reader: {
                            type: 'json',
                            root: 'values'
                        }
                    },
                    pageSize: me.currentValueDisplaySize,
                    //only show non-empty facet values
                    filters: filter
                });
            }

            this.mon(store, "load", function(records){  // $NON-NLS-1$ 
                    //get the total count of filtered records
                    var count = this.getTotalCount();
                    try {
                        Ext.suspendLayouts();
                        me.setVisible(count > 0);
                        me.showMore.setVisible(this.getCount() < count);
                    } finally {
                        Ext.resumeLayouts(true);
                    }
            }, store);

            me.store = store;
            me.facetId = facet.id;
            //set facet category title
            if (me.label) {
                me.title = me.label;
            } else {
                me.title = xcp.facets.FacetManager.getFacetLabel(me.searchId, me.facetId);
            }
        }

         var tpl = me.getTemplate();

         me.list =  Ext.create('Ext.view.View', {
            store: store,
            tpl: tpl,
            multiSelect: true,
            trackOver: true,
            overItemCls: 'xcp-facet-item-over',
            itemSelector: 'div.xcp-facet-value',

            listeners: {
                itemClick : function(view, record, item, index, e) {
                    me.store.remove(record);
                    me.fireEvent('facetvalueclicked', me, view.selModel, record);
                }
            }
        });

        // performance: combine the timers from the base view implementation.
        Ext.override(me.list, {
            doFirstRefresh: function(store) {
                if (store && !store.loading && this.deferInitialRefresh) {
                    xcp.util.PageLayoutUtils.defer(function () {
                        if (!this.isDestroyed) {
                            this.refresh();
                        }
                    }, this);
                } else {
                    return this.callParent(arguments);
                }
            }
        });

        me.items = me.list;
        me.showMore = Ext.widget('tbtext', {
            dock: 'bottom',
            cls: 'xcp-simple-facet-show-more',
            text: xcp.Strings.widget.grid.facets.SimpleFacet.showMore,
            hidden: true,
            listeners: {
                render: function(){
                    this.mon(this.getEl(), 'click',
                        function(){
                            me.store.nextPage();
                            var parent = me.up();
                            if (parent.maxHeight) {
                                //work around the layout issue where the scroll position moved to the top
                                //after click on show more link
                                parent.setHeight(parent.maxHeight);
                            }
                        }, me
                    );
                }
            }
        });

        me.dockedItems = [me.showMore];

        me.callParent(arguments);
    },

    getTemplate: function() {
        var simpleFacet = this;
        var template = new Ext.XTemplate(
            '<tpl for=".">',
                '{[this.renderFacetValues(values)]}',
            '</tpl>',
            '<div class="x-clear"></div>',
            {
            renderFacetValues: function(values) {
                var valueLabel = xcp.facets.FacetManager.getFacetValueLabel(simpleFacet.searchId, simpleFacet.facetId, values.id);

                //setting dir to ltr will glue the opening and closing brackets with the count inside, otherwise, they could be separated by
                //the rtl label, see XCPUIC-3845
                //if the dir is set to rtl in the parent html tags, the "(#)" will move to the left of the rtl label, which is the right behavior
                var qtip = [valueLabel, "&nbsp;",
                    "<span dir='ltr'>",
                    "(", values.count, ")",
                    "</span>"].join('');

                var retTpl = [
                    '<div class="xcp-facet-item">',
                    '<div class="xcp-facet-value"><span data-qtip="' + Ext.String.htmlEncode(qtip) + '" class="xcp-facet-value-label">',  // $NON-NLS-1$
                    Ext.String.htmlEncode(valueLabel),
                    '</span>&nbsp;<span dir="ltr" class="xcp-facet-value-count">(',
                        values.count,
                    ')</span></div>',
                     '</div>'
                ];

                return retTpl.join('');
            }}
        );

        return template;
    },

    /**
     * Load data into the store
     * @param data
     */
    load: function(data){
        this.store.pageSize = this.currentValueDisplaySize;
        this.store.getProxy().data = data;
        this.store.load({
            page: 0,
            start: 0
        });
    },

    getFacetId: function(){
        return this.facetId;
    }

});
/* xcp_results_list/content/xcp/widget/grid/facets/FacetContainer.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.widget.grid.facets.FacetContainer", {
    extend: "Ext.container.Container",
    alias: "widget.xcp_facet_container",
    /*requires: [
        'Ext.util.MixedCollection',
        'xcp.facets.FacetManager',
        'xcp.widget.grid.facets.SelectedFacets',
        'xcp.widget.grid.facets.SimpleFacetModel'
    ],*/

    border: false,
    autoScroll: true,
    showEmptyValueFacets: false,
    hidden: true,

    minHeight: 360,

    ui: 'xcp-facet-container',

    constructor: function(config) {
        var config = config || {},
            xcpId = config.xcpId,
            facetsConfig = config.facetsConfig,
            facetPanelConfig = [],
            defaultWidth = config.width;

        // Generate xcpId for selected facets using the same index as for the results list
        var selectedFacetsXcpId = "selected_facets" + xcpId.substr(0, "results_list");
        var me = this;

        //boolean to show mask
        this.renderShowFacetsMask = config.renderShowFacetsMask || true;

        //list that contains all the selected facets
        me.selectedFacetsList = Ext.create('Ext.util.MixedCollection');
        //list of facetIds before selectedFacetsList is cleared
        me.clearedFacetIds = [];
        //ui container that display all the selected facets
        me.selectedFacetsWidget = Ext.widget("xcp_selected_facets", {
            listeners : {
                "facetRemoved": {fn: me.onFacetRemoved, scope: me}
            },
            xcpId:selectedFacetsXcpId
        });

        // todo:  Remove this isString fix once builder supports array properties correctly
        if (Ext.isString(facetsConfig)) {
            facetsConfig = facetsConfig.split(",");
        }

        me.facetWidgets = me.createFacetWidgets(config, facetsConfig);

        //facetcontainer contains selectedwidget and facet widgets
        me.items = [this.selectedFacetsWidget].concat(me.facetWidgets);

        me.callParent([config]);
    },

    initComponent: function() {
        this.addEvents(
                /**
                 * @event emptyfacetvalues
                 * Fires when no facet value is loaded.
                 */
                 'emptyfacetvalues');

        this.callParent(arguments);
    },

    /**
     * Create facet widgets based on the facet config
     * @param config the container's initial configuration
     * @param facetsConfig configuration which will be applied to each simple facet widget
     * @return list of created facet widgets
     */
    createFacetWidgets: function(config, facetsConfig){
        var me = this,
            widgetIds = [],
            widgets = [];

        var searchId = me.getSearchId(config);
        var facetLabels = config.facetLabels;

        // Loop and add facet widget for each facet
        Ext.each(facetsConfig, function(facet, index) {
            //save facetId to the list
            widgetIds.push(facet);
            var simpleFacetConfig = {
                showEmptyValueFacets: this.showEmptyValueFacets,
                searchId: searchId,
                facet: { id: facet, modelName: 'xcp.widget.grid.facets.SimpleFacetModel' },
                listeners: {
                    facetvalueclicked: {
                        scope: this,
                        fn: this.onFacetSelected
                    }
                }
            };
            if (facetLabels) {
                Ext.apply(simpleFacetConfig, { label: facetLabels[index] });
            }
            widgets.push( Ext.widget('xcp_facet_simple', simpleFacetConfig));
        }, me);

        me.widgetIds = widgetIds;

        return widgets;
    },

    /**
     * Gets the search id for the associated search
     * @param config
     */
    getSearchId: function(config) {
        if (!this.searchId) {
            var store = Ext.getStore(config.storeId);
            this.searchId = null;
            if (store) {
                var storeProxy = store.getProxy();
                var extraParams = storeProxy.extraParams;
                if (extraParams) {
                    this.searchId = extraParams.type;
                }
            }
        }
        return this.searchId;
    },

    /**
     * Load facet widgets data
     * @param facets - object in the following format:
     *   { id:'facet_author', // the 'facet id'
     *   values:[{id:'marc', count:10, constraint:'marc'}, {id:'ghislain', count:9, constraint:'ghislain'}] },
     */
    loadFacets: function(facets){
        if (!facets) {
            return;
        }

        var ids = this.widgetIds.slice(0);
        var emptyFacetCount = 0;

        this.toggleMask(true);
        Ext.suspendLayouts();
        Ext.each(facets, function(item, index){
            var facetId = item.id;
            var facetPanel = this.query('xcp_facet_simple[facetId=' + facetId + ']')[0];

            if (Ext.isArray(item.values) && item.values.length == 0) {
                emptyFacetCount++;
            }

            if (facetPanel) {
                if (this.selectedFacetsList.containsKey(facetId)) {
                    var facet = this.selectedFacetsList.get(facetId);
                    var valueIndex;
                    var currentValue;
                    // Remove any previously selected values from item.values
                    for (valueIndex = item.values.length - 1; valueIndex >=0; valueIndex--) {
                        currentValue = item.values[valueIndex];
                        if (facet.containsValue(currentValue.id)) {
                            item.values.splice(valueIndex, 1);
                        }
                    }
                }

                //need to call load, in case need to hide or update it
                facetPanel.load(item.values);

                Ext.Array.remove(ids, facetId);
            }

        }, this);

        this.hideFacetWidgetWithEmptyValue(ids);

        if (emptyFacetCount == this.widgetIds.length) {
            //no facets values
            this.fireEvent('emptyfacetvalues', this);
        }

        Ext.resumeLayouts(true);

        this.toggleMask(false);
    },

    /**
     * Hide Facet Widget if it has no facet values
     * @param ids
     */
    hideFacetWidgetWithEmptyValue: function(ids) {
        Ext.each(ids, function(id){
            var facetPanel = this.query('xcp_facet_simple[facetId=' + id + ']')[0];
            if (facetPanel){
                facetPanel.setVisible(false);
            }
        }, this)
    },

    /**
     * Handler when user remove facet
     * @param record
     */
    onFacetRemoved: function(record){
        if (record) {
            this.removeFacetValueFromList(record.data);
        } else {
            this.removeAllFacetValueFromList();
        }
        this.loadResultsList();
    },

    /**
     * handler when user clicks on the facet
     * @param cmp
     * @param dv
     * @param nodes
     */
    onFacetSelected: function(cmp, dv, facet) {
        if (facet) {
            var clickedFacet = facet;
            var facetLabel = xcp.facets.FacetManager.getFacetLabel(this.searchId, cmp.getFacetId());
            var value = clickedFacet.get("id");
            var valueLabel = xcp.facets.FacetManager.getFacetValueLabel(this.searchId, cmp.getFacetId(), value);
            var facetObj = {
                facetId: cmp.getFacetId(),
                facetLabel: facetLabel,
                value: value,
                valueLabel: valueLabel,
                constraint: clickedFacet.get("constraint")
            };

            this.toggleMask(true);

            //add facet to selected list
            this.selectedFacetsWidget.addFacet(facetObj);

            this.addToSelectedFacetsList(facetObj);
            //refresh grid
            this.loadResultsList();
        }
    },

    /**
     * Load resultsList grid
     */
    loadResultsList: function(){
        var me = this;
        var store = Ext.getStore(this.initialConfig.storeId);
        if (store) {
            var params = this.buildExtraParams();
            if (params) {
                store.getProxy().updateExtraParams(params);
            }
            store.currentPage = 1;
            store.load({callback: function(){
                me.toggleMask(false);
            }});
        }
    },

    /**
     * save selected facet to the list
     * @param facet
     */
    addToSelectedFacetsList: function(facet){
        var selected = this.selectedFacetsList.get(facet.facetId);
        if (!selected) {
            this.selectedFacetsList.add(facet.facetId, Ext.create('xcp.widget.grid.facets.Facet', facet));
        } else {
            //same facet id, but different facet value
            selected.addValue(facet.value, {constraint: facet.constraint});
        }
    },

    /**
     * Remove facet from selected list
     * @param facetValue
     */
    removeFacetValueFromList: function(facetValue){
        if (facetValue){
            var selected = this.selectedFacetsList.get(facetValue.facetId);
            if (selected) {
                selected.removeValue(facetValue.value);
                if (selected.getValueCount() == 0){
                    this.clearedFacetIds.push(facetValue.facetId);
                    this.selectedFacetsList.remove(selected);
                }
            }
        }
    },

    removeAllFacetValueFromList: function(){
        var me = this;
        me.selectedFacetsList.eachKey(function(key){
            me.clearedFacetIds.push(key);
        });
        me.selectedFacetsList.clear();
    },

    toggleMask: function(showMask){
        showMask && this.renderShowFacetsMask ? this.getEl().mask() : this.getEl().unmask();
    },

    /**
     * Build extraParams for search query
     */
    buildExtraParams: function(){
        var params = {};
        if (this.clearedFacetIds.length > 0) {
            //assign empty value to param so that the proxy knows how to remove it from the query string
            Ext.each(this.clearedFacetIds, (function(facet){
                params[facet] = '';
            }))
            this.clearedFacetIds = [];
        } else {
            this.selectedFacetsList.each(function(facet){
                params[facet.getFacetId()] = facet.getConstrain();
            })
        }
        return params;
    },

    beforeDestroy: function(){
        this.selectedFacetsList.clear();
        this.callParent();
    }

});


/**
 * Helper class to wrap facets
 */
Ext.define("xcp.widget.grid.facets.Facet", {

    constructor: function(config){
        this._values = Ext.create('Ext.util.MixedCollection');
        this.facetId = config.facetId;
        if (config.value){
            this._values.add(config.value, {value: config.value, constraint: config.constraint});
        }
    },

    containsValue: function(value){
        return this._values.containsKey(value);
    },

    addValue: function(key, value){
        this._values.add(key, value);
    },

    setValue: function(key, value){
        if (this._values.containsKey(key)){
            this._values.add(key, value);
        }
    },

    getValueCount: function() {
        return this._values.getCount();
    },

    getFacetId: function(){
        return this.facetId;
    },

    getConstrain: function(){
        var constraints = [];
        this._values.each(function(v){
            if (v){
                constraints.push(v.constraint)
            }
        })
        return constraints.join("+");
    },

    removeValue: function(valueId){
        if (this.containsValue(valueId)){
            this._values.removeAtKey(valueId);
        }
    },

    resetValues: function(){
        this._values.each(function(v){
            if (v && v.value) {
                this.add(v.value, null);
            }
        },this._values)
    }
});



/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.grid.ResultsList");

Ext.apply(xcp.Strings.widget.grid.ResultsList, {
    loadingText : "Loading...",
    emptyText: "No results found."
});
/* xcp_results_list/content/xcp/widget/grid/ResultsList.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

// ResultsList.js

/**
 * @class xcp.widget.grid.ResultsList
 * @extends Ext.grid.GridPanel
 * A table for displaying data
 * @xtype xcp_results_list
 */
Ext.define("xcp.widget.grid.ResultsList", {
    extend: "Ext.panel.Panel",
    alias: "widget.xcp_results_list",

    defaultFacetPanelWidth: 240,

    constructor: function(c) {
        var config = c || {},
            gridConfig = this.initGridConfig(config),
            facets = config.facets;

        if (facets) {
            config = this.initFacetsConfig(config, gridConfig);
        } else {
            // No facets, just display the grid
            config = {
                items: [
                    gridConfig
                ]
            }
        }

        this.callParent([config]);
    },

    initGridConfig: function(config) {
        var gridConfig = config;
        if (gridConfig.id) {
            this.id = gridConfig.id;
            gridConfig.id += "_grid";
        } else {
            gridConfig.id = this.getId() + "_grid";
        }

        if (gridConfig.title) {
            // Remove title from the grid configuration since we don't want the grid displaying title
            this.title = gridConfig.title;
            delete gridConfig.title;
        }

        // Add listener for grid load event, so that we can update facet widgets
        // Better solution is to use datasourceaction to wire the communication
        if (config.storeId) {
            var store = Ext.data.StoreManager.lookup(config.storeId);
            if (store) {
                store.on("beforeload", this.beforeGridLoad, this);//http://www.sencha.com/forum/showthread.php?135485
                store.on("load", this.onGridLoad, this);
            }
        }

        // Change xtype to point to xcp_results_list_grid now that xcp_results_list is the "container component"
        Ext.apply(gridConfig, {
            xtype:"xcp_results_list_grid",
            flex: 1});

        return gridConfig;
    },

    initComponent: function() {
        var me = this;
        me.callParent(arguments);
        if (me.facetContainer && typeof me.height !== "number") {
            var grid = this.down("xcp_results_list_grid");
            if (grid) {
                // performance: reduce rounds of layout caused by populating or hiding facet container in onGridLoad()
                var store = grid.getStore();
                var reader = store.getProxy().getReader();
                //Workaround for XCPUIC-2786
                //only optimize layout for one store loading
                //It will not optimize the second resultlist if two resultlist use same store.
                //This is because two resultlists share same store will end up two data "read" but only one "load" call
                if (!reader._doneXCPOverride) {
                    reader._doneXCPOverride = true;
                    Ext.override(reader, {
                        read: function() {
                            if (grid.view && grid.view.rendered) {
                                me._suspendedLayoutsOnStoreRead = true;
                                me.suspendLayouts();
                            }
                            return this.callParent(arguments);
                        }
                    });
                    store.on("load", function() {
                        if (me._suspendedLayoutsOnStoreRead) {
                            me._suspendedLayoutsOnStoreRead = false;
                            me.resumeLayouts(true);
                        }
                    }, me);
                }
            }
        }
    },

    beforeGridLoad: function(store, operation) {
        // http://www.sencha.com/forum/showthread.php?135485
        this.gridOperation = operation;
    },

    onGridLoad: function(store, records, successful){
        if (!this.facetContainer || !successful || !this.gridOperation || !this.gridOperation.response) {
            return;
        }
        var responseText = this.gridOperation.response.responseText;
        var data = Ext.JSON.decode(responseText);
        if (data && data.facets) {
            // XCPUIC-1263:  Hide facets panel if upon the initial load of the grid, there are no results
            if (data.total == 0) {
                this.showFacetPanel(false);
            } else {
                this.showFacetPanel(true);
                this.facetContainer.loadFacets(data.facets);
            }
        }
    },

    showFacetPanel: function(visible){
        this.facetContainer.setVisible(visible);
        this.splitter.setVisible(visible);
    },

    setupFacetLabels: function(facetContainerConfig) {
        // Do nothing
    },

    initFacetsConfig: function(config, gridConfig){
        var facetsConfig = config.facets;
        var facetContainerConfig = {
            width: this.defaultFacetPanelWidth,
            storeId: config.storeId,
            xcpId: gridConfig.xcpId,
            facetsConfig: facetsConfig,
             listeners: {
                    emptyfacetvalues: {
                        scope: this,
                        fn: function(){
                            this.showFacetPanel(false);
                        }
                    }
                }
        };
        this.setupFacetLabels(config, facetContainerConfig);
        this.facetContainer = Ext.widget('xcp_facet_container', facetContainerConfig);

        this.splitter = Ext.widget('splitter', {collapseDirection: 'left', hidden: true, width: 5});

        Ext.apply(gridConfig, {border: false});
        this.facetContainer.forStretchMaxOnly = true;
        return {
            layout: {
                type :  'xcp_columnhbox',
                align: 'stretchmax',
                defaultMargins : {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            },
            items:[
                this.facetContainer,
                this.splitter,
                gridConfig
            ]
        };
    },

    /**
     * @override
     *
     */
    add: function() {
        if (!this.items || !this.items.items || !this.items.items.length) {
            return this.callParent(arguments);
        } else {
           var grid = this.query('xcp_results_list_grid')[0];
           if (grid) {
                return grid.add.apply(grid, arguments)
           } else {
               return this.callParent(arguments);
           }
        }
    },

    /**
     * @override
     *
     */
    insert: function() {
        var grid = this.query('xcp_results_list_grid')[0];
        if (grid) {
            return grid.insert.apply(grid, arguments)
        } else {
            return this.callParent(arguments);
        }
    }
});

/**
 * @class xcp.widget.grid.ResultsListGrid
 * @extends Ext.grid.GridPanel
 * A table for displaying data
 * @xtype xcp_results_list_grid
 */
Ext.define("xcp.widget.grid.ResultsListGrid", {
    extend: "Ext.grid.GridPanel",
    alias: "widget.xcp_results_list_grid",

    plugins: "xcp_grid_itemeventplugin",

    statics: {
        COLUMN_WIDTH: 150,
        DEFAULT_PAGE_SIZE: 10,
        LOADING_HEIGHT: 50
    },

    //Commenting the paging scroller as this will be revisited later
    //verticalScrollerType: 'paginggridscroller',
    columnLines: false,
    sortableColumns: true,

    xcpeventconfig : [{
        event : "selectionchange",
        data : function(model, records) {
            return records;
        }
    }],


    // The following (invalidateScrollerOnRefresh) is not listed as a config or property for the grid (only in samples),
    // but seems to be required to get infinite scroll working
     //Commenting following line as this will be revisited later
    //invalidateScrollerOnRefresh: false,

    constructor: function (config) {
        var statics = this.statics();
        var columnDefaults = {
             hideable: false
        };
        config = config || {};
        var pageSize = config.pageSize ? config.pageSize : statics.DEFAULT_PAGE_SIZE;
        config.pageSize = pageSize;
        if (config.columns) {
            var columns;
            if (Ext.isArray(config.columns)) {
                columns = config.columns;
                config.columns = {
                    items: columns,
                    defaults: columnDefaults
                }
            } else {
                columns = config.columns.items;
                config.columns.defaults = columnDefaults;
            }
            this.prepareColumnAutoExpand(config.columns.items, config.columns);
            this.fixDataIndex(columns);
        }

        if (!config.modelName && !config.columns) {
            /*
            Scenario where we donot have config defined we want use memory proxy and not use the store.
            Rightclicking the widget in Builder widget palette is one case we encounter this case.
             */

            var storeConfig = config.store;
            delete config.store;

            storeConfig = Ext.apply({}, storeConfig, {
                type: "store",
                pageSize: pageSize,
                buffered: true
            });

            Ext.apply(storeConfig, {
                model: config.modelName,
                proxy:  {
                    type: "memory",
                    reader: {
                        type: "array"
                    }
                }
            });
            Ext.apply(config, {store: storeConfig});
        }
        else{

            //Define a store if not defined and this will be used in the dockedItems.
            var store = null;
            if (!config.store){

                //check if store with the storeId is present in the store manager, the store would have
                //been created by Data source action.

                if (config.storeId) {
                    store = Ext.data.StoreManager.lookup(config.storeId);
                }

                if (!store) {
                    //copy proxy from model definition and use it in this store so that the modifications will only
                    //apply to the store proxy instead of to the model proxy.
                	var model = Ext.ModelMgr.getModel(config.modelName);
                	if (null != model) {
                		var proxy = Ext.apply({}, model.getProxy());
                	} else {
                		var proxy = new Ext.data.proxy.Proxy({type: 'memory',reader:{type:"json"}});
                	}

                    store = Ext.create('Ext.data.Store', {
                        model: config.modelName,
                        storeId: config.storeId,
                        pageSize: pageSize,
                        autoLoad: true,
                        buffered: true,
                        proxy: proxy
                    });
                }
            }
            else{

                store = config.store;
                     // Create store with modelName and storeId
                 Ext.apply(store, {
                     pageSize: pageSize,
                     model: config.modelName,
                     storeId: config.storeId
                });
            }

             // searches using facets require the client timezone to be passed to the
             // search for use in date facets.
            if (config.facets) {
                var proxy = store.proxy || store.getProxy();
                if (proxy) {
                    if (proxy.updateExtraParams)
                        proxy.updateExtraParams({timezone: xcp.Formats.timezoneId});
                    else if (xcp.Formats)
                        Ext.apply(proxy, {extraParams: {timezone: xcp.Formats.timezoneId}});
                }
             }

            Ext.apply(config, {store: store});
            Ext.applyIf(config, {
                dockedItems: [{
                                xtype: 'xcp_pagingtoolbar',
                                store: store,
                                dock: 'bottom',
                                displayInfo: true
                                }]
                });
        }

        // Apply common configuration items
        var viewConfig = {
            /*
              emptyText doesn't work sporadically (seems like view doesn't always get datachanged event)
             */
            emptyText: xcp.Strings.widget.grid.ResultsList.emptyText
        };

        if (config.loadMask === false) {
            viewConfig.loadMask = false;
        } else {
            if (!Ext.isObject(viewConfig.loadMask)) {
                viewConfig.loadMask = {};
            }
            viewConfig.loadMask.store = config.store;
            viewConfig.loadingText = xcp.Strings.widget.grid.ResultsList.loadingText;
            if (typeof config.loadingHeight === "number") {
                viewConfig.loadingHeight = config.loadingHeight;
            } else if (!config.height) {
                viewConfig.loadingHeight = statics.LOADING_HEIGHT;
            }
        }

        store = config.store;
        Ext.apply(store, {
            listeners: {
                load: {
                    fn: this._onStoreLoad,
                    scope: this
                }
            }
        });
        // dlm: so why not use Ext 'selType' config?
        var selectionModelName = config.selectionModelName;
        if (!selectionModelName) {
            selectionModelName = 'rowmodel';
        }
        if (Ext.is.iPad && selectionModelName == 'rowmodel') {
            selectionModelName = 'xcp_checkboxmenu';
        }

        var selectionModel = config.selectionModel  ? "MULTI" : "SINGLE";
        Ext.applyIf(config, {
            viewConfig: viewConfig,
            columns: [],
            selType: selectionModelName,
            selModel: {mode: selectionModel, ignoreRightMouseSelection:true}
        });

        //add rowbody feature to show the summary if the model contains summary and matchingterms
        if (!Ext.isEmpty(store.model) && Ext.isFunction(store.model['getFields']) && !Ext.isEmpty(Ext.Array.toMap(store.model.getFields(), "name"))
                && Ext.Array.toMap(store.model.getFields(), "name").hasOwnProperty("summary")
                && Ext.Array.toMap(store.model.getFields(), "name").hasOwnProperty("matchingterms")) {

            Ext.applyIf(config, {
                features: [{
                    ftype: 'rowbody',
                    getAdditionalData: this._getAdditionalData
                }],
                //workaround for XCPUIC-2764
                listeners: {
                    itemmouseup: function (view, record, item, index, e, eOpts) {
                        Ext.select('tr', view).removeCls('xcp-summaryrow-selected');
                        var row = Ext.fly(item).next();
                        if (row){
                            row.removeCls('xcp-summaryrow-over');
                            row.addCls('xcp-summaryrow-selected');
                        }
                    },
                    itemmouseenter: function (view, record, item, index, e, eOpts) {
                        var row = Ext.fly(item).next();
                        if (row && !row.hasCls('xcp-summaryrow-selected'))
                            row.addCls('xcp-summaryrow-over');
                    },
                    itemmouseleave: function (view, record, item, index, e, eOpts) {
                        Ext.select('tr', view).removeCls('xcp-summaryrow-over');
                    }
                }
            });
        }

        // extjs 4.1 backward compatible with 4.0
        if (config.selType === "Ext.selection.CheckboxModel") {
            config.selType = "checkboxmodel";
        }

        // temp(?): disable buffering as auto-height is incompatible with buffering; plus we don't have a vertical scrollbar to automate it.
        if (!this.height && !config.height) {
            store.buffered = false;
        }

        this.callParent([config]);
        this.hookColumnAutoExpand();

        //the rest of code is unnecessary since there is a patch for Ext.data.Store.doSort() inside the ExtjsPatch.js. Please
        //reference to XCPUIC-1363.
//        this.on("sortchange", function(container, column, direction) {
//                    this.down('pagingtoolbar').moveFirst();
//                }, this);
    },

    _getAdditionalData: function(data, rowIndex, record, orig) {
        var headerCt = this.view.headerCt,
            colspan = headerCt.getColumnCount();

        var summary = record.get("summary");
        if (Ext.isEmpty(summary)) {
            return {};
        }
        //no need to have this constraints in the runtime
        //summary = Ext.String.ellipsis(summary, 256, true);

        if (!Ext.isEmpty(record.get("matchingterms"))) {
            var matchingterms = Ext.Array.toArray(record.get("matchingterms"));
            //put longer terms in front of array
            matchingterms = matchingterms.sort(function(a, b){return b.length - a.length});
            //escape special characters
            for (var i = 0; i < matchingterms.length; i++) {
                matchingterms[i] = matchingterms[i].replace(/[\^\$\.\*\+\?\=\!\|\\\/\(\)\[\]\{\}]/g, "\\$&");
            }

            /* text matching
            var regExpr = new RegExp(matchingterms.join("|"), "gi");
            summary = summary.replace(regExpr, function(matched) {
                return '<span class="xcp_grid_matchingterms-cls">' + matched + '</span>';
            });
             */

            /* word matching */
            var newTerms;
            for (i = 0; i < matchingterms.length; i++) {
                newTerms = new Array();
                if (!Ext.isEmpty(matchingterms[i])) {
                    //summary texts starts with matching term
                    newTerms.push("^"+matchingterms[i]+"\\W");
                    //summary texts ends with the matching term
                    newTerms.push("\\W"+matchingterms[i]+"$");
                    //matching term in the middle of summary texts
                    newTerms.push("\\W"+matchingterms[i]+"\\W");
                    //summary text is just the matching term
                    newTerms.push("^"+matchingterms[i]+"$");
                }
                //matchingterms = newTerms;
                if (!Ext.isEmpty(newTerms)) {
                    var regExpr = new RegExp(newTerms.join("|"), "gi");
                    summary = summary.replace(regExpr, function(matched) {
                        var htmlString = matched, highlight;
                        for (var k = 0; k < newTerms.length; k++) {
                            if (!Ext.isEmpty(matched.match(new RegExp(newTerms[k], "i")))){
                                switch(k%4) {
                                    case 0:  //summary texts starts with matching term
                                        highlight = newTerms[k].substring(1, newTerms[k].length-2);
                                    break;
                                    case 1:  //summary texts ends with the matching term
                                        highlight = newTerms[k].substring(2, newTerms[k].length-1);
                                    break;
                                    case 2: //matching term in the middle of summary texts
                                        highlight = newTerms[k].substring(2, newTerms[k].length-2);
                                    break;
                                    case 3: //summary text is just the matching term
                                        highlight = newTerms[k].substring(1, newTerms[k].length-1);
                                    break;
                                }

                                htmlString = matched.replace(new RegExp(highlight, "gi"), function(matching){
                                    return ('<span class="xcp_grid_matchingterms-cls">' + matching + '</span>')
                                });
                                break;
                            }
                        }
                        return htmlString;
                    });
                }
            }
            //end of word matching

        }
        return {
            rowBody: summary,
            rowBodyCls: "xcp_grid_rowbody-cls",
            rowBodyColspan: colspan
        };
    },

    _onStoreLoad: function(store, records, successful) {
        if (successful && records.length == 0) {
            // Work around scenario where empty text doesn't always get set due to the view not getting datachanged event
            var view = this.getView();
            if (view.rendered) {
                view.refresh();
            } else {
                // Note:  hasSkippedEmptyText is internal implementation detail of AbstractView and subject to change
                //        If it does, hopefully Sencha manages to fix whatever issue requires this work around
                view.hasSkippedEmptyText = true;
            }
        }
        store.un("load", this._onStoreLoad, this);  // $NON-NLS-1$ 
    },

    /**
     * Save the column width and flex settings before the column instance is created.
     * @param columns
     */
    prepareColumnAutoExpand : function(columns, headerCt) {
        if (columns) {
            var iPad = Ext.is.iPad;
            for (var i = 0, len = columns.length; i < len; i++) {
                var column = columns[i];
                column.xcpInitialWidth = column.width;
                column.xcpInitialFlex = column.flex;
                if (iPad) {
                    // XCPUIC-2429:  Set the width to be the min width so grid width can get set correctly for iPad.  Bug will
                    // remain for other platforms, but since user can manually change width, not as big of a deal and UXD would
                    // prefer to be able to allow the user to manually decrease the size of the column smaller than the initial
                    // width.  The exception for iPad is due to the fact that the user can't change width on iPad so it would be
                    // good to see at least some minimum amount of data

                    // Note that we don't use a global default min width, since columns may need specific width (such as checkbox
                    // column) which we want to maintain.
                    if (column.width) {
                        column.minWidth = column.width;
                    }
                }
            }
        }
        if (headerCt) {
            headerCt.defaultWidth = this.statics().COLUMN_WIDTH;
        }
    },

    /**
     * Hook and prepare column before a column is added.
     * @param columns
     */
    hookColumnAutoExpand : function() {
        var me = this;
        me.setColumnAutoExpand();
        Ext.override(this.headerCt, {
           add : function() {
               var args = Ext.Array.slice(arguments),
                   index = (typeof args[0] == 'number') ? args.shift() : -1,
                   items;
               if (args.length == 1 && Ext.isArray(args[0])) {
                   items = args[0];
               } else {
                   items = args;
               }

               if (Ext.isArray(items)) {
                   items = items.slice();
               } else {
                   items = [items];
               }
               me.prepareColumnAutoExpand(items);
               Ext.suspendLayouts();
               var ret = this.callParent(arguments);
               me.setColumnAutoExpand();
               Ext.resumeLayouts(true);

               return ret;
           }
        });
    },

    /**
     * Set the column to fill the extra width
     * Currently only support setting the last column to auto-expand
     */
    setColumnAutoExpand : function() {
        var headerCt = this.headerCt;
        var columns = headerCt.items.items;
        var iPad = Ext.is.iPad;
        for (var i = 0, len = columns.length; i < len; i++) {
            var column = columns[i];
            var initialWidth = column.xcpInitialWidth;
            var initialFlex = column.xcpInitialWidth;
            if (!initialWidth && !initialFlex) {
                if (i == len - 1) {
                    column.flex = column.initialConfig.flex = 1;
                    column.width = column.initialConfig.width = undefined;
                    column.minWidth = column.initialConfig.minWidth || Ext.grid.plugin.HeaderResizer.prototype.minColWidth;
                } else {
                    column.flex = column.initialConfig.flex = undefined;
                    column.width = column.initialConfig = headerCt.defaultWidth;
                }
            } else if (initialWidth) {
                column.width = column.initialConfig.width = initialWidth;
                column.flex = column.initialConfig.flex = undefined;
            } else {
                column.width = column.initialConfig.width = undefined;
                column.flex = column.initialConfig.flex = initialFlex;
            }

            if (iPad) {
                // XCPUIC-2429:  Set the width to be the min width so grid width can get set correctly for iPad.  Bug will
                // remain for other platforms, but since user can manually change width, not as big of a deal and UXD would
                // prefer to be able to allow the user to manually decrease the size of the column smaller than the initial
                // width.  The exception for iPad is due to the fact that the user can't change width on iPad so it would be
                // good to see at least some minimum amount of data

                // Note that we don't use a global default min width, since columns may need specific width (such as checkbox
                // column) which we want to maintain.
                if (column.width) {
                    column.minWidth = column.width;
                }
            }
        }
    },

    /**
     * Fix data indices on the columns
     * @param columns configuration of columns
     */
    fixDataIndex: function(columns) {
        // Check to see if any of the columns were configured with "r_object_id" and set to "id" since that is
        // what is used by the data services and models
        if (Ext.isArray(columns)) {
            Ext.Array.each(columns, function(column) {
                if (column.dataIndex && column.dataIndex == "r_object_id") {
                    column.dataIndex = "id";
                }
            });
        }
    },
    /**
     * Return the selected row model from the grid
     */
    getModel: function() {
        if (this.getSelectionModel) {
            var model = this.getSelectionModel().getSelection();
            if (Ext.isArray(model) && model.length > 0) {
                return model[0];
            } else if (model) {
                return model;
            }
        }
        return null;
    },
    /**
     * Init component method
     */
    initComponent: function() {
        this.callParent();

        // Set guaranteeRange on the store since the paging scroller code won't get values without it
         //Commenting the following line as this will be revisited later
        //this.store.guaranteeRange(0, 99);

        //if result list has initParams defined, process it. The values of initParams will be put
        //into a name-value pair object and passed to the expression function to evaluate.
        var initParam = this.initialConfig.initParams, expression, param, data = {}, val;
        if (initParam && initParam.extraParams) {
            for (param in initParam.extraParams) {
                expression = Ext.ClassManager.getByAlias(initParam.extraParams[param]);
                if (expression) {
                    val = expression.evaluate();
                    data[param] = val;
                }
            }

            var proxy = this.store.getProxy();

            //update the extraParams of store proxy
            proxy.updateExtraParams(data);
        }

        // performance: combine the timers from the base implementation into one for performances of pages with multiple grids.
        var view = this.getView();
        if (view.deferInitialRefresh) {
            Ext.override(view, {
                doFirstRefresh: function(store) {
                    if (store && !store.loading && this.deferInitialRefresh) {
                        xcp.util.PageLayoutUtils.defer(function () {
                            if (!this.isDestroyed) {
                                this.refresh();
                            }
                        }, this);
                    } else {
                        return this.callParent(arguments);
                    }
                }
            });
        }
    },
    afterRender: function(){
        this.callParent(arguments);
        if (this.allowContextMenu())
            this.on('itemcontextmenu', this.itemContextMenu, this);
    },
    /**
     * Determine if context menu is shown
     * Currently: Don't show in wizards
     */
    allowContextMenu: function(){
        return !this.isInsideWizard();
    },
    /**
     * clean the global cache for the store before the result list being destroyed
     */
    beforeDestroy : function() {
        this.setDisabled(true);

        if (this.initialConfig.storeId) {
            var store = Ext.getStore(this.initialConfig.storeId);
            if (store) {
                store.clearListeners();
                Ext.StoreManager.remove(store);
            } else if (this.store) {
                this.store.clearListeners();
            }
        }
        //this.removeAll() doesn't remove columns
        var cols = this.headerCt.getGridColumns();
        Ext.each(cols, function(col){
            Ext.destroy(col);
        });
        this.callParent(arguments);
    },

    //@Override
    //Scroll bar object is dangling after grid is deleted
    //As a temporary solution, this prevents the null pointer exception
    determineScrollbars: function(){
        if (this.view && this.view.el && this.view.el.dom) {
            return this.callParent();
        }
    },

    /**
     * Get the actionArgs object for this component
     */
    actionArgsProvider: function(){
        var sm = this.view.getSelectionModel();
        var actionArgs=new xcp.core.ActionArgs({
            component:  this.view,
            selection: sm.getSelection(),
            container: null
        });

        // if objectid matches form, provide as container model.
        if (this.getObjectId && this.getObjectId() && actionArgs.getFormModel() && (this.getObjectId()=actionArgs.getFormModel().getId())){
            actionArgs.container = actionArgs.getFormModel();
        }
        return actionArgs;
    },

    itemContextMenu: function( view,  record, item, index, e, eOpts ){
//        if (xcp.isDesignMode())
//            return;
       //XCPECM-825 - Suppressing the Context Menu for Version History Grid.
        if (record.store.proxy.extraParams.type  == "versionHistoryQuery")
            return;

        var target = e.getTarget();
        if(target.nodeName=="A" || e.hasModifier()){         // show browser's menu on link or w/ modifier
            return false;
        }
        e.preventDefault();

        var sm = this.view.getSelectionModel();
        if (!sm.isSelected(record))
            sm.select(record, true, true);

        var actionArgs = this.actionArgsProvider();
        xcp.core.ActionManager.showContextMenu(actionArgs, "ItemContextMenu", null, e);
    }

});

/**
 * Add context menu hover button to checkbox model
 */
Ext.define('xcp.selection.CheckboxModelMenu', {
    extend: 'Ext.selection.CheckboxModel',
    alias: 'selection.xcp_checkboxmenu',

    // override
    getHeaderConfig: function() {
        var cfg = this.callParent(arguments);
        var view = this.view;
        if (!view.isInsideWizard()) {
            // Only add space for trigger if we're NOT in an action flow
            cfg.width = cfg.width+14;
        }
        if (this.mode=='SINGLE'){ // remove checkbox in header if single select
            if (cfg.cls) delete cfg.cls;
            cfg.text='';  // remove nbsp to cause span to be suppressed
        }
        return cfg;
    },
    // override
    renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
        var html=this.callParent(arguments);
        metaData.tdCls = metaData.tdCls+ ' xcp-relative';
        var view = this.view;

        if (!view.isInsideWizard()) {
            return html+'<div class="xcp-actioncol">&#160;</div>';
        } else {
            // Don't show menu trigger if we're in an action flow
            return html;
        }
    },

    // override
    /**
     * Show item context menu (if clicked on menu button)
     * @param view
     * @param record
     * @param item
     * @param index
     * @param e
     */
    onRowMouseDown: function(view, record, item, index, e) {
        if(e.button == 2){
            return;
        }
        if (!this.itemcontextmenu.apply(this, arguments)){
            this.callParent(arguments);
        }
    },
    itemcontextmenu: function(view, record, item, index, e){
        var atrigger = e.getTarget('.xcp-actioncol');
        if (!atrigger){
            return false;
        }
        e.stopEvent();

        var sm = this;
        if (!sm.isSelected(record))
            sm.select(record, true);

        var actionArgs = xcp.core.ActionManager.findActionArgsProvider(view);
        xcp.core.ActionManager.showContextMenu(actionArgs, "ItemContextMenu", atrigger, e);
        return true;
    }

});

/**
 * Watch for item events and refresh store as needed
 */
Ext.define('xcp.event.GridItemEventPlugin', {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.xcp_grid_itemeventplugin",

    init: function(cmp){
        cmp.formInfo = null;
        this.subscriptions = [];
        if(window['OpenAjax']){   // dlm:todo how about xcp.isDesign()???
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ContainerChangedEvent.NAME, this.itemChanged, cmp));
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemUnlockedEvent.NAME, this.containedItemChanged, cmp));
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemLockedEvent.NAME, this.containedItemChanged, cmp));
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemDeleted.NAME, this.containedItemChanged, cmp));
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemModified.NAME, this.containedItemChanged, cmp));
        }
    },
    destroy: function(cmp){
        var subscriptions = this.subscriptions;
        for (var i=0, len=subscriptions.length; i<len; i++){
            xcp.event.EventBus.unsubscribe(subscriptions[i]);
        }
        delete this.subscriptions;
    },

    /**
     *   Refresh if contained item changed
     * @param name
     * @param ids  -- Array of target object IDs or single id
     */
    containedItemChanged: function(name, ids){
        ids = Ext.isArray(ids) ? ids : [ids];
        var store = this.getStore();
        for(var i=0, len=ids.length; i<len; i++){
            var id = ids[i];
            if (store && id && store.getById(id)){
                store.load();
                break;
            }
        }
    },

    /**
     * Refresh if container item or contained item changed.
     * @param name
     * @param ids  -- Array of target object IDs or single id
     */
    itemChanged: function(name, ids){
        var objectId = null;
        if (Ext.isFunction(this.getObjectId)){
            // folderlist has this, resultslist doesn't
            objectId=this.getObjectId();
        }
        ids = Ext.isArray(ids) ? ids : [ids];
        var store = this.getStore();
        for(var i=0, len=ids.length; i<len; i++){
            var id = ids[i];
            if (store && id && (id==objectId || store.getById(id) )){
                store.load();
                break;
            }
        }
    }
});

/* xcp_admin_results_list/content/xcp/admin/RoleUtility.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: balakr2
 * Date: 9/7/11
 * Time: 2:19 PM
 * To change this template use File | Settings | File Templates.
 */
Ext.namespace("xcp.admin.model");

xcp.admin.model.RoleCache = {
    cache : {},
    loadRole : function(recordId,callback) {
        var Role = Ext.ModelManager.getModel('role');  // $NON-NLS-1$ 
        Role.load(recordId,{
            scope:this,
            success:function(record) {
                if(!this.cache[recordId]){
                        this.cache[recordId] = record;
                }
                callback.call(this, record);
            }
        });
    },

    getRole : function(recordId) {
        return this.cache[recordId];
    }
};
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: balakr2
 * Date: 9/20/11
 * Time: 3:47 PM
 * To change this template use File | Settings | File Templates.
 */

Ext.namespace("xcp.Strings.widget.grid.AdminResultsList");

Ext.apply(xcp.Strings.widget.grid.AdminResultsList, {
    addButtonLabel : "Add",
    addButtonTooltip :"Add new members to this application role",
    removeButtonLabel : "Remove",
    removeButtonTooltip :"Remove selected members from this application role"
});

/* xcp_admin_results_list/content/xcp/widget/grid/AdminResultList.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.grid.AdminResultsList
 * @extends xcp.widget.grid.ResultsList
 * A table for displaying admin specific data which is extended from ResultList.
 * @xtype xcp_admin_results_list
 */
Ext.define("xcp.widget.grid.AdminResultsList", {
    extend: "xcp.widget.grid.ResultsListGrid",
    alias: "widget.xcp_admin_results_list",

    constructor:function(config){
        Ext.apply(config,{
            selModel:Ext.create('xcp.admin.selection.CheckboxModel', {mode: 'MULTI'})
        });
        this.callParent(arguments);
    },

    initComponent:function(config) {
        this.callParent();
        this.dockedItems.add(this.createTopToolbar());
    },

    /**
     * Creates the toolbar to be used for adding and removing role members.
     * @private
     * @return {Ext.toolbar.Toolbar}
     */
    createTopToolbar:function() {
        this.toolbar = Ext.widget('xcp_toolbar', {
            dock:'top',
            items:[
                {
                    scope:this,
                    text:xcp.Strings.widget.grid.AdminResultsList.addButtonLabel,
                    iconCls:'xcp-adminAdd',
                    iconAlign: 'left',
                    tooltip:xcp.Strings.widget.grid.AdminResultsList.addButtonTooltip,
                    handler:this.onAddRoleMemberClick
                },
                '-' ,
                {
                    scope:this,
                    text:xcp.Strings.widget.grid.AdminResultsList.removeButtonLabel,
                    itemId:'remove',
                    iconCls:'xcp-adminRemove',
                    iconAlign: 'left',
                    tooltip:xcp.Strings.widget.grid.AdminResultsList.removeButtonTooltip,
                    handler:this.onRemoveMembers
                }
            ]
        });
        return this.toolbar;
    },

    /**
     * Reacts to a rolemember attempting to be added
     * @private
     */
    onAddRoleMemberClick:function() {
        this.win = Ext.create('widget.xcp_memberselectiondialog', {
            listeners:{
                scope:this,
                addmember:this.onAddMembers
            }
        });

        this.win.show();
    },

    /**
     * Reacts to rolemembers being removed
     * @private
     */
    onRemoveMembers:function(){
        var me = this,
                record = null,
                operation,
                proxy,
                callback,
                models = this.getSelectionModel().getSelection(),
                members = [],
                options = {},
                i = 0,
                len = models.length;
        if (len != 0) {
            for (; i < len; i += 1) {
                members.push(this.getNewRoleMember(models[i]));
            }

            Ext.apply(options, {
                records:members,
                action:'destroy',
                success:function() {
                    me.store.load();
                    me.store.sort('name', 'ASC');  // $NON-NLS-1$
                    //always toggle the header checkbox (select all) to unchecked - XCPUIC-3139
                    me.selModel.toggleUiHeader(false);
                },
                feedbackContainer: me //removing failure error should show on main window
            });

            operation = new Ext.create('Ext.data.Operation', options);

            callback = function(operation) {
                if (operation.wasSuccessful()) {
                    Ext.callback(options.success, me, [record, operation]);
                } else {
                    Ext.callback(options.failure, me, [record, operation]);
                }
            };

            proxy = new xcp.data.proxy.AdminProxy({
                model:'xcp.admin.model.RoleMembers',
                reader: Ext.create('Ext.data.reader.Json', {
                }),
                writer: Ext.create("Ext.data.writer.Json", {
                    allowSingle:false
                }),
                url : "application/role/{id}/members",
                appendId: false
            });
            proxy.destroy(operation, callback, me);
        }
    },

    onAddMembers:function(models) {
        var me = this,
                record = null,
                operation,
                proxy,
                callback,

                members = [],
                options = {},
                i = 0,
                len = models.length;
        for (; i < len; i += 1) {
            members.push(this.getNewRoleMember(models[i]));
        }

        Ext.apply(options, {
            records:members,
            action:'create',
            success:function() {
                me.store.load();
                me.store.sort('name','ASC');  // $NON-NLS-1$
                me.win.destroy(); //close dialog is action success
            },
            feedbackContainer: me.win //adding failure error should show on the dialog
        });

        operation = new Ext.create('Ext.data.Operation', options);

        callback = function(operation) {
            if (operation.wasSuccessful()) {
                Ext.callback(options.success, me, [record, operation]);
            } else {
                Ext.callback(options.failure, me, [record, operation]);
            }
        };

        proxy = new xcp.data.proxy.AdminProxy({
            model:'xcp.admin.model.RoleMembers',
            reader: Ext.create('Ext.data.reader.Json', {
            }),
            writer: Ext.create("Ext.data.writer.Json", {
                allowSingle:false
            }),
            url : "application/role/{id}/members",
            appendId: false
        });
        proxy.create(operation, callback, me);
    },

    getNewRoleMember :function(model) {
        var newMember = new xcp.admin.model.RoleMembers();
        newMember.data = Ext.clone(model.data);
        return newMember;
    }

});

Ext.define('xcp.data.proxy.AdminProxy', {
    extend: 'Ext.data.proxy.Rest',
    alias: 'proxy.admin_xcp_rest',

    buildUrl:function(request) {
        var me = this,
                id = this.getSelectedObjectId(),
                url = me.getUrl(request);
        if (id) {
            if (url.indexOf("{id}") > -1) {  // $NON-NLS-1$ 
                url = url.replace("{id}", id);  // $NON-NLS-1$ 
            }
        }
        request.url = url;
        return me.callParent(arguments);
    },

    /**
     *  This function parses the sections of url to identify the object-id and returns.
     *  @private
     *  @return Selected role objectid.
     */
    getSelectedObjectId: function() {
        var navUrl = window.location.hash;
        var sections = navUrl.split('/');
        var objectId = sections[1];
        return objectId;
    }
});


Ext.define('xcp.admin.selection.CheckboxModel', {
    extend: 'Ext.selection.CheckboxModel',
    getHeaderConfig: function() {
        var cfg = this.callParent(arguments);
        cfg.cls = Ext.baseCSSPrefix + 'column-header-admin-checkbox ';
        return cfg;
    },
    removeHeaderSelection:function(){
        var view     = this.views[0],
            headerCt = view.headerCt,
            checkHd  = headerCt.child('gridcolumn[isCheckerHd]');
        if (checkHd) {
            checkHd.el.removeCls(Ext.baseCSSPrefix + 'grid-hd-checker-on');
        }
    }
});


Ext.define('xcp.admin.model.RoleMembers', {
    extend :'Ext.data.Model',
    fields:[
        {
            name:"name",
            type:"string"
        },
        {
            name:"type",
            type:"string"
        },
        {
            name:"email",
            type:"string"
        },
        {
            name:"description",
            type:"string"
        }
    ],
	idProperty:"name"
});

Ext.define("xcp.admin.model.AddRoleMember", {
    extend : "xcp.admin.model.RoleMembers",
    proxy : {
        reader : {
            type : "json"
        },
        writer:{
            type:"json",
            allowSingle:false
        },
        type : "admin_xcp_rest",
        url : "application/role/{id}/members"
    }
});

Ext.define("xcp.admin.model.RoleMember",{
    extend :"xcp.admin.model.RoleMembers",
    proxy : {
        reader : {
            root:'items',
            type : "json"
        },
        writer:{
            type:"json",
            allowSingle:false
        },
        type : "admin_xcp_rest",
        url : "application/role/{id}/members"
    }
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: balakr2
 * Date: 10/3/11
 * Time: 3:09 PM
 * To change this template use File | Settings | File Templates.
 */
Ext.namespace("xcp.Strings.admin.MemberSelectionDialog");

Ext.apply(xcp.Strings.admin.MemberSelectionDialog, {
    addButtonLabel : "Add",
    cancelButtonLabel : "Cancel",
    title:"Add Members to",
    selectedListTitle:"Add to role:"
});
/* xcp_admin_results_list/content/xcp/admin/MemberSelectionDialog.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.admin.MemberSelectionDialog", {
    extend :'Ext.window.Window',
    alias:'widget.xcp_memberselectiondialog',
    mixins: {
        feedbackContainer: 'xcp.util.mixin.FeedbackContainer'
    },
    includeFeedbackTypes: ['systemErrors'],
    plain:true,
    modal: true,

    buttons:['right','left'],
    tooltipText:{
        add: "Add to Selected",
        remove: "Remove from Selected"
    },

    initComponent:function() {
        this.addEvents(
                'addmember'
                );
        Ext.apply(this, {
            title: xcp.Strings.admin.MemberSelectionDialog.title + " " + xcp.admin.model.RoleCache.getRole(this.getSelectedObjectId()).data.name,
            padding:'5,5,10,5',
            border: false,
            height:500,
            width:700,
            items:[{
                //add a container so the system error can be added on top of it
                xtype: 'container',
                items: [{
                    height:420,
                    border:false,
                    layout:{
                        type:'hbox',
                        align:'stretch'
                    },
                    bodyStyle:{
                        background:'white',
                        padding:'10px'
                    },
                    items:[this.createFromField(),this.createButtonBar(),this.createToField()]
                }]
            }]
        });

        this.buttons = this.buildButtons();
        this.callParent(arguments);
    },

    createFromField:function() {
        var me = this;
        fromField = Ext.create('xcp.admin.MemberGridSelectionPanel', {
            multiSelect:true,
            itemId:'AvailableMemberGrid',
            border:true,
            flex:1,
            listeners:{
                itemdblclick: me.onItemDblClick,
                scope:me
            }
        });
        fromField.on('render', fromField.loadAllMembers, fromField, {single: true});
        me.fromField = fromField;
        return me.fromField;
    },

    createToField:function() {
        var me = this;
        me.toField = Ext.create('xcp.admin.MemberItemSelectionPanel', {
            multiSelect:true,
            hideHeaders:true,
            flex:1,
            border:true,
            itemId:'SelectedMemberItem',
            listeners:{
                itemdblclick: me.onItemDblClick,
                scope:me
            }
        });
        me.toField.store.removeAll();
        return me.toField;
    },

    createButtonBar:function() {
        var me = this,
                baseXcpCSSPrefix = 'xcp',
                buttons = [],buttonCtn;
        Ext.Array.forEach(me.buttons, function(name) {
            buttons.push({
                xtype:'button',
                tooltip:me.tooltipText[name],
                handler:me['onButton' + Ext.String.capitalize(name) + 'Click'],
                cls: baseXcpCSSPrefix + '-dualGridSelector-btn',
                iconCls: baseXcpCSSPrefix + '-dualGridSelector-' + name,
                scope:me
            });

            // vertical spacing between the buttons
            buttons.push({
                xtype:'component',
                height:5,
                width:1,
                style:'font-size:0;line-height:0'
            });
        });

        buttonCtn = {
            xtype:'container',
            margins:'0 10',
            layout:{
                type:'vbox',
                pack:'center',
                align:'center'
            },
            items:buttons
        };
        return buttonCtn;
    },

    getSelections:function(list) {
        var store = list.getStore(),
                selections = list.getSelectionModel().getSelection(),
                i = 0,
                len = selections.length;
        return Ext.Array.sort(selections, function(a, b) {
            a = store.indexOf(a);
            b = store.indexOf(b);
            if (a < b) {
                return -1;
            } else if (a > b) {
                return 1;
            }
            return 0;
        });
    },

    onButtonRightClick:function() {
        var me = this, selected = me.getSelections(me.fromField);
		
		// if the field hasn't already been added.
		Ext.Array.forEach(selected, function(item) {
			if (-1 == me.toField.store.find("name",item.get("name"))) {
				me.toField.store.add(item);
			}
		});
		
		me.fromField.getSelectionModel().deselectAll()
		me.toField.store.sort('name', 'ASC');  // $NON-NLS-1$ 
		me.fromField.getSelectionModel().removeHeaderSelection();
        this.updateButtonState();
    },

    onButtonLeftClick:function() {
        var me = this,
                selected = me.getSelections(me.toField);
        me.toField.store.remove(selected);
        this.updateButtonState();
    },

    onItemDblClick:function(view) {
        var me = this;
        if (view.ownerCt.itemId == me.fromField.itemId) {
            me.onButtonRightClick();
        }
        else if (view.ownerCt.itemId == me.toField.itemId) {
            me.onButtonLeftClick();
        }
    },

    updateButtonState:function() {
        var me = this, count = me.toField.store.count(),selected = false;
        if (count > 0) {
            selected = true;
        }
        this.dockedItems.items[1].getComponent('add').setDisabled(!selected);  // $NON-NLS-1$ 
    },

    buildButtons:function() {
        return[
            {
                xtype:'button',
                text:xcp.Strings.admin.MemberSelectionDialog.addButtonLabel,
                itemId:'add',
                scope:this,
                disabled:true,
                handler:this.onAddClick
            },
            {
                xtype:'button',
                text:xcp.Strings.admin.MemberSelectionDialog.cancelButtonLabel,
                scope:this,
                handler:this.destroy
            }
        ];
    },

    onAddClick:function() {
        var models = this.toField.store.data.items;
        if (models) {
            this.fireEvent('addmember', models);
        }
//        this.destroy(); //window should not close here, it should be closed in success handler
    },

    getSelectedObjectId: function() {
        var navUrl = window.location.hash;
        var sections = navUrl.split('/');
        var objectId = sections[1];
        return objectId;
    }
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: balakr2
 * Date: 10/3/11
 * Time: 3:13 PM
 * To change this template use File | Settings | File Templates.
 */
Ext.namespace("xcp.Strings.admin.MemberGridSelectionPanel");

Ext.apply(xcp.Strings.admin.MemberGridSelectionPanel, {
    nameLabel : "Name",
    emailLabel : "Email",
    searchTitle:"Available users, groups, and roles:",
    loadingText : "Loading..."
});
/* xcp_admin_results_list/content/xcp/admin/MemberGridSelectionPanel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define('xcp.admin.MemberGridSelectionPanel', {
    extend:'Ext.grid.Panel',
    alias:'widget.xcp_membergridselectionpanel',
    initComponent:function() {
        var viewConfig = {
            loadingText: xcp.Strings.admin.MemberGridSelectionPanel.loadingText
        };

        Ext.applyIf(this, {
            componentCls:'rolemembergrid',
            viewConfig: viewConfig,
            store:this.buildStore(),
            selModel:Ext.create('xcp.admin.selection.CheckboxModel'),
            dockedItems: [
                {
                    xtype:'toolbar',
                    dock:'top',
                    items:[
                        {
                            xtype:'tbtext',
                            text:xcp.Strings.admin.MemberGridSelectionPanel.searchTitle
                        }
                    ]
                },
                {
                    xtype: 'xcp_pagingtoolbar',
                    store: this.store,
                    dock: 'bottom',
                    displayInfo: true
                }
            ],
            columns:[
                {
                    xtype:'xcp_rolemembericoncolumn',
                    text:xcp.Strings.admin.MemberGridSelectionPanel.nameLabel,
                    dataIndex:'name',
                    menuDisabled:true,
                    draggable:false,
                    flex:1
                },
                {
                    "xtype" : "xcp_results_list_email_link_column",
                    text:xcp.Strings.admin.MemberGridSelectionPanel.emailLabel,
                    dataIndex:'email',
                    menuDisabled:true,
                    draggable:false,
                    width:150
                }
            ]
        });
        this.callParent(arguments);
    },

    buildStore:function() {
        this.store = Ext.create('Ext.data.Store', {
            model:'xcp.admin.model.RoleMembers',
            pageSize:25,
            proxy:{
                type:'admin_xcp_rest',
                url:'application/roles/{id}/membercandidates',
                reader:{
                    type:'json',
                    root:'items'
                }
            }
        })
    },

    loadAllMembers:function() {
        this.store.load();
    }
});

Ext.define('xcp.admin.RoleMemberIconColumn', {
    extend: "Ext.grid.column.Column",
    alias:  "widget.xcp_rolemembericoncolumn",
    constructor:function(config) {
        this.callParent(arguments);
        this.renderer = function(value, metaData, record, rowIdx, colIdx, store, view) {
            var type = record.data.type;
            return  '<span class= xcp-' + type + ' >' + value + '</span>';  // $NON-NLS-L$ 
        }
    }
});




/* xcp_admin_results_list/content/xcp/admin/MemberItemSelectionPanel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define('xcp.admin.MemberItemSelectionPanel', {
    extend:'Ext.grid.Panel',
    alias:'widget.xcp_memberitemselectionpanel',

    initComponent:function() {
        this.store = this.buildStore();
        this.columns = this.buildColumns();
         Ext.apply(this,{
            dockedItems:[this.buildToolBar()]
        });
        this.callParent();
    },

    buildStore:function() {
        var store;
        store = Ext.create('Ext.data.Store', {
            model:'xcp.admin.model.RoleMembers'
        });
        return store;
    },

     buildToolBar:function(){
        this.toolbar = Ext.create('widget.toolbar', {
            items: [{
                xtype:'tbtext',
                text:xcp.Strings.admin.MemberSelectionDialog.selectedListTitle
            }]
        });
        return this.toolbar;
    },

    buildColumns:function() {
        return [
            {
                xtype:'xcp_rolemembericoncolumn',
                text:'Name',
                dataIndex:'name',
                flex:1
            }
        ];
    }
});

/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.form.ApplicationParameter");

Ext.apply(xcp.Strings.widget.form.ApplicationParameter, {
    titleFormatString: "{0} ({1})",
    stringType: "String",
    integerType: "Integer",
    floatType: "Float",
    booleanType: "Boolean",
    dateTimeType: "Date-time",
    userType: "User",
    groupType: "Group",
    folderPathType: "Folder path",
    workQueueType: "Work queue",
    businessCalendar: "Business calendar",
    valueLabel: "Value",
    trueValue: "True",
    falseValue: "False"
});
/* xcp_app_param_container/content/xcp/widget/form/ApplicationParameter.js */

/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.widget.form.ApplicationParameter", {
    extend: "Ext.container.Container",
    alias: "widget.xcp_app_param",

    constructor: function(config) {
        this.appParamChanged = false;
        var record = config.param;
        this.record = record;
        var paramNamespace = record.get("namespace");
        var paramName = record.get("config_name");
        var paramType = record.get("property_datatype")[0];
        var typeStr = this.getTypeString(paramType);
        var paramLabel = xcp.core.ApplicationParameterManager.getAppParameterLabel(paramNamespace, paramName);
        var title = Ext.String.format(xcp.Strings.widget.form.ApplicationParameter.titleFormatString, paramLabel, typeStr);
        var paramValue = record.get("property_value")[0];
        var editorWidgetConfig = this.getWidgetConfig(paramType, paramValue);
        this.paramEditor = Ext.widget(editorWidgetConfig.xtype, editorWidgetConfig);
        this.paramEditor.on("change",
            function(field, newValue, oldValue, eOpts) {
                this.appParamChanged = true;
            },
            this);
        var description = xcp.core.ApplicationParameterManager.getAppParameterDescription(paramNamespace, paramName);

        // Create a column box for the display
        var colBox = Ext.widget("xcp_column_box", {
            title: title,
            collapsible: false,
            collapsed: false,
            collapseFirst: true,
            border: false,
            defaultMargins: "5",
            layout: "xcp_columnbox",
            items: [{
                xtype: "xcp_columnvbox",
                orientation: "Vertical",
                width: "100%",
                overflow_x: "hidden",
                labelWidth: 150,
                labelAlign: "left",
                halign: "left",
                valign: "top",
                defaultMargins: "5",
                items: [
                    // Description
                    {
                        xtype:  "xcp_rich_text",
                        html: description
                    },
                    // Editor
                    this.paramEditor
                ]
            }]
        });

        Ext.apply(config, {items: [colBox]});

        this.callParent([config]);
    },

    getTypeString: function(paramType) {
        switch (paramType) {
            case "int":
                return xcp.Strings.widget.form.ApplicationParameter.integerType;
            case "string":
                return xcp.Strings.widget.form.ApplicationParameter.stringType;
            case "float":
                return xcp.Strings.widget.form.ApplicationParameter.floatType;
            case "boolean":
                return xcp.Strings.widget.form.ApplicationParameter.booleanType;
            case "Datetime":
                return xcp.Strings.widget.form.ApplicationParameter.dateTimeType;
            case "dm_user":
                return xcp.Strings.widget.form.ApplicationParameter.userType;
            case "dm_group":
                return xcp.Strings.widget.form.ApplicationParameter.groupType;
            case "dm_folder":
                return xcp.Strings.widget.form.ApplicationParameter.folderPathType;
            case "dmc_workqueue":
                return xcp.Strings.widget.form.ApplicationParameter.workQueueType;
            case "dmc_calendar":
                return xcp.Strings.widget.form.ApplicationParameter.businessCalendar;
        }
    },

    getWidgetConfig: function(paramType, paramValue) {
        var config;
        switch (paramType) {
            case "int":
                config = {
                    xtype: "xcp_number_input",
                    allowDecimals : false,
                    hideTrigger : true,
                    keyNavEnabled : false,
                    mouseWheelEnabled : false,
                    autoStripChars : true,
                    hstretch : true
                };
                break;
            case "string":
                config = {
                    xtype: "xcp_text_input"
                };
                break;
            case "float":
                config = {
                    xtype: "xcp_number_input",
                    allowDecimals : true,
                    hideTrigger : true,
                    keyNavEnabled : false,
                    mouseWheelEnabled : false,
                    autoStripChars : true,
                    hstretch : true
                };
                break;
            case "boolean":
                config =  {
                    xtype: "xcp_dropdown_list",
                    store: Ext.create('Ext.data.Store', {
                        fields: [{name: "value", type: "string"}, {name:"label", type: "string"}],
                        data: [
                            {"value": "true", "label": xcp.Strings.widget.form.ApplicationParameter.trueValue},
                            {"value": "false", "label": xcp.Strings.widget.form.ApplicationParameter.falseValue}
                        ]
                    }),
                    valueField: "value",
                    displayField: "label",
                    fieldWidth: 300
                };
                break;
            case "Datetime":
                config = {
                    xtype: "xcp_date_time_input",
                    format: {
                        xtype: "xcp_datetime_formatter",
                        dateFormat: "short",
                        timeFormat: "short",
                        dateStyle: "datetime"
                    },
                    fieldWidth: 300
                };
                break;
            case "dm_user":
                config = {
                    xtype: "xcp_text_input"
                };
                break;
            case "dm_group":
                config = {
                    xtype: "xcp_text_input"
                };
                break;
            case "dm_folder":
                config = {
                    xtype: "xcp_text_input"
                };
                break;
            case "dmc_workqueue":
                config = {
                    xtype: "xcp_text_input"
                };
                break;
            case "dmc_calendar":
                config = {
                    xtype: "xcp_text_input"
                };
                break;
        }
        // Apply the things that are common to all of the configurations
        Ext.apply(config, {
            fieldLabel: xcp.Strings.widget.form.ApplicationParameter.valueLabel,
            value: paramValue
        });
        return config;
    },

    getChangedRecord: function() {
        if (this.appParamChanged) {
            var enteredValue = this.paramEditor.getValue();
            this.record.set("property_value", [enteredValue.toString()]);
            return this.record;
        }
        return null;
    }
});
/* xcp_app_param_container/content/xcp/widget/form/ApplicationParameterContainer.js */

/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.widget.form.ApplicationParameterContainer", {
    extend: "Ext.container.Container",
    alias: "widget.xcp_app_param_container",
    requires: ["xcp.core.ApplicationParameterManager"],

    constructor: function(config) {
        config = config || {};
        var paramStore = xcp.core.ApplicationParameterManager.getParameters();
        // Loop through parameters and add an application parameter UI instance for each
        var paramCount = paramStore.getCount();
        var index = 0;
        var params = [];
        for (index = 0; index < paramCount; index++) {
            var record = paramStore.getAt(index);
            var appParam = Ext.widget("xcp_app_param", {param: record});
            params.push(appParam);
        }
        Ext.apply(config, {items: params});
        this.callParent([config]);
    }
});/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// AssignTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.AssignTaskDataAction");
Ext.apply(xcp.Strings.action.task.AssignTaskDataAction, {
    confirmationTitle: "Assign Task?",
    confirmationPromptTemplate: "Are you sure you want to assign this task?",
    updateSuccessNotificationTemplate:  "The task has been assigned.",
    updateErrorTemplate: "An error occurred while assigning this task. Please try again."
});
/* xcp_assign_task/content/xcp/action/task/AssignTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// AssignTaskDataAction.js

/**
 * @class xcp.ation.task.AssignTaskDataAction
 * @extends xcp.action.task.BaseTaskDataAction
 * Action implementation for assign task action.
 */
Ext.define("xcp.action.task.AssignTaskDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_assign_task",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false
    },

    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if (baseAction.isQueueTask(actionArgs, action)) {
            var queueName = baseAction.getTaskAttribute(actionArgs,action,"queue_name");
            var performer = baseAction.getTaskAttribute(actionArgs,action,"performer");
            applicable = performer === queueName && baseAction.isQueueTaskActionApplicable(actionArgs,action,true,true,false, false,false);
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;
    },

    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.AssignTaskDataAction";
    }
});

/* xcp_assign_task/content/xcp/data/model/AssignTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp_da_def_assign_currenttask",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/assign"
    },
    "fields" : [
        {
            "name" : "id",
            "type" : "string"
        },
        {
            "name" : "userName",
            "type" : "string"
        }
    ]
});


/* xcp_attachment/content/xcp/data/proxy/AttachmentProxy.js */

/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

// This is the proxy for accessing folder contents via the application content services

Ext.define("xcp.data.proxy.AttachmentProxy",
{
    extend: "Ext.data.proxy.Rest",
    alias: "proxy.xcp_rest_attachment",

    constructor: function(config) {
        this.callParent(arguments);
        this.attachmentIds = new Array();
    },

    // override the method used by the store to build the URL that invokes the
    // RESTful service.
    getUrl: function(request) {
        var ids = this.attachmentIds, url = this.url;
        url += "/";

        for (var i = 0; i < ids.length; i++) {
            url += ids[i];
            if (i + 1 !== ids.length)
                url += ',';
        }
        return url;
    }
});


/* xcp_attachment/content/xcp/data/model/AttachmentModel.js */

/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

/**
 * The static model used by the child grid of Attachment widget.
 * Should not be used by other widgets.
 **/
Ext.define("xcp.data.model.AttachmentModel", {
    extend: 'xcp.data.Model',
    "proxy" : {
        "type" : "xcp_rest_attachment",
        "url" : "application/content/attachments",
        "reader" : {
            type: "xcpjson",
            root: "items"
        }
    },
    fields: [
        {name: 'id', type: "string"},
        {name: 'object_name', type: "string"},
        {name: 'r_object_type', type: "string"},
        {name: 'r_lock_owner', type : "string"},
        {name: 'a_content_type', type: "string"},
        {name: 'icon', type : "string"},
        {name: 'effectivePermissions', type : "auto"}
    ]
});

Ext.define("xcp.data.model.AttachmentFlowInputModel", {
    extend: 'xcp.data.Model',
    fields: [
        {name: 'folderRoot', type: "string"}
    ]
});
/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.selector.Attachment");

Ext.apply(xcp.Strings.widget.selector.Attachment, {
	add : "Add",
	remove : "Remove"
});
/* xcp_attachment/content/xcp/widget/selector/Attachment.js */

/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */
(function () {
    var nlsCls = xcp.Strings.widget.selector.Attachment;
    var NAME_PROP = "object_name";
    var gridAlias = "xcp_results_list_grid";

    Ext.define("xcp.widget.selector.Attachment", {
        extend:'Ext.form.FieldContainer',
        mixins:{
            observable:'Ext.util.Observable',
            field:'Ext.form.field.Field',
            xcpFixedFieldWidthModelMixin:'xcp.util.mixin.FixedFieldWidthModelMixin'
        },
        alias:'widget.xcp_attachment',
        xcpeventconfig:[
            {
                event:"change",
                data:function (field, newValue, oldValue, options) {
                    return newValue;
                }
            },
            {
                event:"select",
                data : function(model, record) {
                    return record;
                }
            }
        ],

        constructor:function (config) {
            config = config || {};
            config.height = config.height || 200;
            config.width = config.width || 300;
            var navMgr = xcp.navigationManager;
            var pageSize = navMgr ? 10 : 5;

            var modelName = navMgr ? "xcp.data.model.AttachmentModel" : "xcp.data.Model";
            // add in the child grid and copy some of the config to the child grid
            config.items = {
                xtype:"xcp_attachment_grid",

                pageSize: pageSize,
                modelName:modelName,
                height: config.height,
                width: config.width,
                columns:[
                    {
                        "xtype":"xcp_folder_list_page_link_column",
                        "dataIndex":NAME_PROP
                    }
                ],
                objectType:config.objectType,
                actionFlowId:config.actionFlowId,
                isID: config.isID
            };
            this.mixins.observable.constructor.call(this, config);
            this.mixins.xcpFixedFieldWidthModelMixin.constructor.call(this, "width");
            this.callParent([config]);
        },

        initComponent:function () {
            this.callParent();
            var grid = this.down(gridAlias);
            if (grid) {
                grid.on("select", function (sm, rec) {
                    this.fireEvent('select', this, rec);
                }, this);
            }
            this.initField();
        },

        getValue:function () {
            var store = this.getStore();
            if (store)
                return store.proxy.attachmentIds;
        },

        setValue:function (value) {
            var me = this;
            var oldValue = me.getValue();
            var store = me.getStore();
            if (store && value) {
                //XCPECM-986 Dont load with an empty array
                if(Ext.isArray(value) && value.length == 0)
                    return;
                store.proxy.attachmentIds = value;
                store.load();
                me.fireEvent('change', me, value, oldValue);
            }
        },

        getStore:function () {
            return this.down(gridAlias).store;
        },

        //Gets called through expr setter
        setFolderRoot: function(root){
            if (!!root) {
                xcp.Logger.debug('Attachment: setFolderRoot as ' + root);
                this.down('xcp_attachment_grid').folderRoot = root;
            }
        },

        getSelectionModel: function(){
            return this.down(gridAlias).selModel;
        },

        /**
         * Returns the {@link Ext.form.field.Field#name name} attribute of the field. This is used as the parameter name
         * when including the field value in a {@link Ext.form.Basic#submit form submit()}.
         * @return {String} name The field {@link Ext.form.field.Field#name name}
         */
        getName: function() {
            var name = this.name;
            if (Ext.isEmpty(name)) {
                name = this.getInputId();
                if (Ext.isEmpty(name)) {
                    name = this.id + "-inputEl";
                }
            }
            return name;
        }
    });

    Ext.define("xcp.widget.selector.AttachmentGrid", {
        extend:'xcp.widget.grid.ResultsList',
        alias:'widget.xcp_attachment_grid',

        /*
         * Override the grids default constructor to handle column renderer, and plugins.
         */
        constructor:function (config) {
            config.hideHeaders = true;
            config.tbar = this.getToolBar();
            this.subscriptions = new Array();

            this.isID = config.isID;

            var model = Ext.ModelMgr.getModel(config.modelName);
            if (model)
                var proxy = Ext.apply({}, model.getProxy());

            config.store = Ext.create('Ext.data.Store', {
                model:config.modelName,
                pageSize:config.pageSize,
                proxy:proxy
            });

            Ext.apply(config,{selectionModel:true});

            this.callParent(arguments);
        },

        clearSubscriptions:function () {
            var subscriptions = this.subscriptions;
            if (!subscriptions) return;
            for (var i = 0, len = subscriptions.length; i < len; i++) {
                xcp.event.EventBus.unsubscribe(subscriptions[i]);
            }
        },

        // Invoked when an attachment is selected from selector
        onSelectionDone:function (name, objId) {
            if (objId) {
                var store = this.down(gridAlias).store;
                var idsArray = store.proxy.attachmentIds;
                if(Ext.isArray(objId)){
                    Ext.Array.insert(idsArray, idsArray.length-1, objId);
                    store.proxy.attachmentIds = Ext.Array.unique(idsArray);
                }
                else
                    Ext.Array.include(idsArray, objId);
                store.load();
                this.clearSubscriptions();
                this.ownerCt.fireEvent('change', this.ownerCt);
            }
        },

        /*
         * The function to call when the user clicks the add button. It adds a new
         * record to the store and updates the grid.
         */
        onAddClicked:function () {
            var handle = xcp.event.EventBus.subscribe(xcp.event.SelectorEvent.NAME, this.onSelectionDone, this);
            this.subscriptions.push(handle);

            var actionDef = {};
            Ext.apply(actionDef, xcp.core.ActionManager.getUserActionDefConfig(this.initialConfig.items[0].objectType, this.initialConfig.items[0].actionFlowId));
            var wizardConfig = {
                title: nlsCls.add,
                height: 570,
                width: 700};
            Ext.apply(actionDef, wizardConfig);
            Ext.apply(actionDef, {});

            if(!this.folderRoot){
                this.launchAttachmentWizard(actionDef, '');
                return;
            }

            if (this.isID)
                this.getFolderPathFromID(this.folderRoot, actionDef);
            else
                this.launchAttachmentWizard(actionDef, this.folderRoot);
        },

        // Launches the attachment wizard by setting the input model
        launchAttachmentWizard: function (actionDef, path) {
            var copyOfActionDef = xcp.util.Utils.deepCopy(actionDef);
            copyOfActionDef["inputModel"] = Ext.ModelManager.create({"folderRoot":path}, "xcp.data.model.AttachmentFlowInputModel");
            var wizard = Ext.create("widget.xcp_wizard", copyOfActionDef);
            wizard.show();
        },

        // Resolves path from Id and launches attachment wizard
        getFolderPathFromID: function(objectId, actionDef){

            if (!objectId) {
                xcp.Logger.debug("no object id in getFolderPathFromID");
                return;
            }

            Ext.Ajax.request({
                    url: "application/folderpath/".concat(objectId),
                    scope: this,
                    disableCaching: false,
                    success: function (response, options) {
                        this.launchAttachmentWizard(actionDef, Ext.decode(response.responseText));
                    }
                }
            );
        },

        /*
         * Function to invoke when the delete button is clicked. Deletes the previously
         * selected row
         */
        onDeleteClicked:function () {
            var grid = this.down(gridAlias),
                store = grid.store,
                selRows = grid.selModel.selected.items;

            if (selRows && selRows.length>0 && Ext.isArray(selRows)) {
                Ext.Array.each(selRows, function(row) {
                    Ext.Array.remove(store.proxy.attachmentIds, row.data.id);
                });

                store.remove(grid.selModel.getSelection());
                grid.selModel.select(0);
                this.ownerCt.fireEvent('change', this.ownerCt);
            }
        },

        /*
         * Returns the toolbar config
         */
        getToolBar:function () {
  		return [{
			xtype: 'xcp_toolbar',
			dock: 'top',
			border: 0,
			items: [{
                    xtype:'button',
                    text:nlsCls.add,
                    scope:this,
                    cls:'x-btn-text-icon',
                    iconCls:'multivalue-add-icon',
                    handler:this.onAddClicked
                },
                {
                    xtype:'button',
                    text:nlsCls.remove,
                    scope:this,
                    cls:'x-btn-text-icon',
                    iconCls:'multivalue-remove-icon',
                    handler:this.onDeleteClicked
                }]
          }]
        }
    });

})();
/* xcp_base_action_flow_launcher/content/xcp/action/BaseActionflowLauncher.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.task.BaseTaskActionflowLauncher
 * @extend xcp.action.Action
 * Base Task Actionflow Launcher handler.
 * This is a common xcp task action flow launcher implementation used to launch all task action flows.
 * Actionflows are by default launched in wizard.
 */
Ext.define("xcp.action.BaseActionflowLauncher", {
    extend: "xcp.action.form.DataAction",
    alias: "action.xcp_action_flow_launcher",
    config : {
      actionflowId: "",
      modal : true,
      refreshParent: true,
      wizardConfig:{},
      showConfirmation:false
    },
    statics: {
        handleRedirection: function(config, id) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (config.redirectStyle == xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                var url = config.redirectUrl;
                if (config.redirectUrlModel != '') {
                    //instance page
                    //var data = Ext.JSON.decode(operation.response.responseText);
                    url = config.redirectUrlModel + "/" + id + "/" + config.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            }
        },
        applyFallbackConfigToActionFlowInst:function(actionFlowInstance, fallbackConfig) {
            if (actionFlowInstance && fallbackConfig) {
                var actionFlowConfig = actionFlowInstance.flowDef;
                var fallbackActionConfig = fallbackConfig['action'];
                if (fallbackActionConfig && actionFlowConfig) {
                    var fallbackDataAction=fallbackActionConfig['actionType'];
                    if (fallbackDataAction) {
                        var dataServiceActions = actionFlowConfig[xcp.core.actionflow.FlowEngine.FLOW_DATA_ACTION_SECTION_NAME];
                        if (dataServiceActions && dataServiceActions.length > 0) {
                            //Take the first data service action and apply the enablement from it
                            for (var index=0; index < dataServiceActions.length; index++) {
                                var dataAction = dataServiceActions[index];
                                var actionType = dataAction.actionType;
                                if (fallbackDataAction == actionType) {
                                    for (var prop in fallbackActionConfig) {
                                        dataAction[prop] = fallbackActionConfig[prop];
                                    }
                                }
                            }
                        }
                    }

                }

            }
        }

    },

    constructor: function(config) {
        this.applyPreConditionSetting(config);
        this.callParent(arguments);
    },
    applyPreConditionSetting: function(config) {
        var typeName = config["objectType"];
        var actionFlowId = config["actionFlowId"];
        var actionFlowType = config["actionFlowType"];
        var fallbackToDataAction = config["fallbackToDataAction"] || false;
        var fallbackConfig = config["fallbackConfig"];
        if (!(actionFlowId || actionFlowType) && !typeName) {
            xcp.Logger.debug("Could not apply enablement as action flow Id/action type or object type is not known");
            return;
        }
        var actionFlowDef = this.getActionFlowDef(typeName,  actionFlowId, actionFlowType);
        var actionClass = null;
        var actionType = null;
        if (actionFlowDef) {
            var actionFlowConfig = actionFlowDef.flowDef;
            var dataServiceActions = actionFlowConfig[xcp.core.actionflow.FlowEngine.FLOW_DATA_ACTION_SECTION_NAME];
            if (dataServiceActions && dataServiceActions.length > 0) {
                //Take the first data service action and apply the enablement from it
                var dataAction = dataServiceActions[0];
                actionType = dataAction.actionType;
            }

        } else if (fallbackToDataAction && fallbackConfig && fallbackConfig.action) {
            actionType = fallbackConfig.action["actionType"];
        } else {
            xcp.Logger.debug("Could not find action flow definition for id :" + actionFlowId + " under type : "+ typeName);
            this.getEnablement = function (actionArgs, action) {
                return xcp.Enablement.HIDE;
            };
        }

        if (actionType) {
            actionClass = Ext.ClassManager.getByAlias("action." + actionType);
            if (actionClass) {
                if (Ext.isFunction(actionClass.prototype.getEnablement)) {
                    //Refer to the getEnablement method from wrapped action
                    this.getEnablement = actionClass.prototype.getEnablement;
                    var actionConfig = actionClass.prototype.config;
                    if (actionConfig) {
                        var preconditions = actionConfig.preconditions;
                        if (preconditions) {
                            config['preconditions'] = preconditions;
                        }
                    }
                    if (actionClass.prototype.requiredAttributes) {
                        this['requiredAttributes'] = actionClass.prototype.requiredAttributes;
                    }
                }
            } else {
                xcp.Logger.debug("Could not find action type for action type : "+ actionType);
            }
            if (Ext.isFunction(actionClass.prototype.getInitialEnablement)) {
                //Refer to the getEnablement method from wrapped action
                this.getInitialEnablement = actionClass.prototype.getInitialEnablement;
            }

        } else {
            xcp.Logger.debug("Could not find action type");
        }

    },
    getActionFlowDef: function(typeName, actionFlowId, actionType) {
        var actionFlowDef = null;
        if (typeName) {
            if (!actionFlowId || actionFlowId.length == 0) {
                 if (actionType && actionType.length  != 0) {
                    //Lets get the action flow id
                    actionFlowDef = xcp.core.ActionManager.getUserActionDefConfigFromActionType(typeName, actionType);
                 }
            } else {
                actionFlowDef = xcp.core.ActionManager.getUserActionDefConfig(typeName,  actionFlowId);
            }
        }
        return actionFlowDef;
    },
    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        if (!actionArgs || !actionArgs.isActionArgs)
            actionArgs = xcp.core.ActionManager.getActionArgs(this);
        //Check if action launched from button configured on application page
        if (!actionArgs) {
            actionArgs = {};
            if (!actionArgs.component) {
                actionArgs.component = Ext.isEmpty(action) ? this.ownerCt : action.ownerCt;
            }
        }
        var actionInstanceConfig;
        var targets=null;
        if (Ext.isEmpty(action)) {
            action = this;
            targets = [action.getActionModel()];
        } else {
            targets = action.getTargets(actionArgs);
        }

        var inputModel = targets && targets.length>0 ? targets[0] : {};

        actionInstanceConfig=action.getConfig();

        var cmp=actionArgs.component;
        var typeName = actionInstanceConfig["objectType"];
        if (!typeName) {
            typeName = cmp.typeName || cmp.ownerCt.typeName;
        }
        var actionFlowId = actionInstanceConfig.actionFlowId;
        var actionFlowType =  actionInstanceConfig.actionFlowType;
        var fallBackToDataAction = actionInstanceConfig.fallbackToDataAction || false;

        var actionFlowDef = action.getActionFlowDef(typeName,  actionFlowId, actionFlowType);
        if (actionFlowDef) {
            var actionFlowPostProcessingConfig = {
                defaultConfirmationPrompt : actionInstanceConfig.defaultConfirmationPrompt,
                showConfirmation : actionInstanceConfig.showConfirmation,
                redirectStyle : actionInstanceConfig.redirectStyle,
                showSuccessNotification : actionInstanceConfig.showSuccessNotification,
                redirectUrl: actionInstanceConfig.redirectUrl
            };

            var actionFlowInstance = xcp.util.Utils.deepCopy(actionFlowDef);

            Ext.apply(actionFlowInstance,actionInstanceConfig.wizardConfig);
            actionFlowInstance["postExecutionConfig"] = actionFlowPostProcessingConfig;

            //Apply fallback config attributes to the action flow data action
            if (fallBackToDataAction) {
                var fallbackConfig = actionInstanceConfig.fallbackConfig;
                if (fallbackConfig) {
                    xcp.action.BaseActionflowLauncher.applyFallbackConfigToActionFlowInst(actionFlowInstance, fallbackConfig);
                }
            }
            actionFlowInstance["inputModel"]=inputModel;
            var wizard = Ext.create("widget.xcp_wizard", actionFlowInstance);
            wizard.show();

        } else if (fallBackToDataAction){
            var fallbackConfig = actionInstanceConfig.fallbackConfig;
            if (fallbackConfig) {
                var actionInstance = xcp.core.ActionManager.getActionInst(fallbackConfig);
                actionInstance.actionArgs = actionArgs;
                actionInstance.inputProperties = inputModel.data || {};
                actionInstance.handler(actionInstance, null);
            }
        } else {
            throw Error("Could not find action flow definition for id :" + actionFlowId + " under type : "+ typeName);
        }
    }

});

/* xcp_baseuser_action/content/xcp/action/BaseUserAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.BaseUserAction
 * @extend xcp.action.Action
 * Base user defined action handler.
 * This is a common xcp action handler implementation used to launch all action flows. Actionflows are by default
 * launched in wizard.
 */
Ext.define("xcp.action.BaseUserAction", {
    extend: "xcp.action.Action",
    alias: "action.baseuseraction",
    config : {
        actionId: "",
        modal : true,
        refreshParent: true,
        wizardConfig:{},
        preconditions: {
            targets:{
                effectivePermissions: [xcp.Permit.RELATE]
            }
        }
    },
    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        if (!actionArgs || !actionArgs.isActionArgs)
            actionArgs = xcp.core.ActionManager.getActionArgs(this);
        var actionInstanceConfig=action.getConfig();
        var cmp=actionArgs.component;
        var typeName;

        if (actionInstanceConfig && actionInstanceConfig.action)
            typeName=actionInstanceConfig.action.objectType;

        if (!typeName){
            typeName = cmp.typeName || cmp.ownerCt.typeName;
        }

        var actionDef = {};
        Ext.apply(actionDef, xcp.core.ActionManager.getUserActionDefConfig(typeName,  actionInstanceConfig.actionId));
        Ext.apply(actionDef,actionInstanceConfig.wizardConfig);
        actionDef.inputModel=actionArgs.selection[0];
        var wizard = Ext.create("widget.xcp_wizard", actionDef);
        wizard.show();
    }
});

/* xcp_breadcrumb/content/xcp/widget/breadcrumb/Breadcrumb.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.breadcrumb.Breadcrumb
 * @extends Ext.container.Container
 * Its a bread crumb container which helps in displaying data very specific to admin role member page requirement.
 * Its not very generic and if future if we need to make it generic we may need to extend this.
 * @xtype xcp_breadcrumb
 */
Ext.define("xcp.widget.breadcrumb.Breadcrumb",  {
    extend: 'Ext.container.Container',
    alias: 'widget.xcp_breadcrumb',
    layout: {
            type:"hbox",
            padding:"10",
            align:"left"
    },
    //
    initComponent : function() {
        var id = xcp.navigationManager.currentNavigationContext.objectId;
        var label = this.text;
        var pageUrl = this.xcp_nav_url;
        var link = Ext.String.format('<a href="#" onclick="xcp.navigationManager.navigate(\'{0}\');return false;">{1}</a>',
                pageUrl, label);
        this.items = [
            {
                xtype:"component",
                html:link
            },
            {
                xtype:"component",
                html:"&nbsp;&gt;&nbsp;"
            },
            {
                xtype:"component",
                html:this.sub_text + ":&nbsp;"
            },
            {
                id: id,
                xtype:"component"
            }
        ];

        xcp.admin.model.RoleCache.loadRole(id, function(record) {
            Ext.getCmp(id).update("<b>" + record.data.name + "</b>");
        });
        this.callParent(arguments);
    }
});


/* xcp_button/content/xcp/widget/button/Button.js */

// Button.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.button.Button
 * @extends Ext.button.Button
 * Allows users to initiate an action such as submitting a form or starting a search.
 * @xtype xcp_button
 */
Ext.define("xcp.widget.button.Button", {
    extend: "Ext.button.Button",
    alias: "widget.xcp_button",
    mixins:{
        actionLinker:'xcp.action.ActionLinker'
    },
    constructor: function(config) {
        var realConfig = {};
        if (config) {
            if (config.action) {
                // Use the action as basis for button config if available.  In regular ExtJS, we'd just
                // create the button with the action in the button constructor, but we can't do that
                // in the JSON syntax so we use the action configuration to store the action initially
//                realConfig = xcp.core.ActionManager.create(config.action);
                realConfig = xcp.core.ActionManager.getAction(config);
            }
            Ext.apply(realConfig, config);
            if (realConfig.initialConfig) {
                // If the realConfig has an initialConfig (i.e., is an action), the default constructor will
                // use the initialConfig value.  We need to reapply any button specific config to it as well
                Ext.apply(realConfig.initialConfig, config);
            }
        }else{
            realConfig=config;
        }
        xcp.widget.button.Button.superclass.constructor.apply(this, [realConfig]);
        this.mixins.actionLinker.initMixin.call(this, config);
    }

    /**
     * @cfg {Ext.Action} action action instance to associate with the button.  The action's configuration will be
     * the button's configuration.
     */
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.action.CancelEdit");
Ext.apply(xcp.Strings.action.CancelEdit, {
    text: "Cancel Editing",
    tooltip: "Cancel Editing"
});


/* xcp_canceledit/content/xcp/action/CancelEdit.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.CancelEdit
 * @extend xcp.action.Action
 *
 * Implementation of Cancel Edit document page action.
 */
Ext.define("xcp.action.CancelEdit", {
    extend: "xcp.action.Action",
    alias: "action.xcp_canceledit",
    config : {
        text: xcp.Strings.action.CancelEdit.text,
        tooltip: xcp.Strings.action.CancelEdit.tooltip,
        page : "",
        hidden: true,

       // requiredAttributes: ["effectivePermissions","r_lock_owner"],
        preconditions: {
            targets:{
                effectivePermissions: [xcp.Permit.WRITE]
            }
        }
    },
    getEnablement:function(actionArgs, action){
        var target = action.getTargets(actionArgs)[0];
        if (target){
            var lockOwner = target.get('r_lock_owner');
            if (lockOwner !== '')
                return xcp.Enablement.ENABLE;
        }
        return xcp.Enablement.HIDE;
    },
    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var targets = action.getTargets(actionArgs);
        var target = action.getTargets(actionArgs)[0];

        if (target) {
            var typeName = actionArgs.getTypeName(target);
            var id = target.getId();
            Ext.Ajax.request(
            {
                method: 'POST', url: Ext.String.format('application/{0}/{1}/unlock', typeName, id),
                scope: this,

                success: function(response, options)
                {
                    //Application Level event fired (handler will update the lock status on page)
                    if (xcp.event && xcp.event.EventBus) {
                        xcp.event.EventBus.publish(xcp.event.ItemUnlockedEvent.ITEM_UNLOCKED_EVENT, id);
                }

                },
                failure: function(response, options)
                {
                    Ext.MessageBox.alert('Server Error', response.responseText);
                }
            });

        } else {
                //We always are going to have typeName and id, otherwise something is wrong and we will throw an error.
                console.error("Error unlocking the editing document.");
            }
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// ChangeWorkQueueDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.ChangeWorkQueueDataAction");
Ext.apply(xcp.Strings.action.task.ChangeWorkQueueDataAction, {
    confirmationTitle: "Change work queue?",
    confirmationPromptTemplate: "Are you sure you want to change work queue?",
    updateSuccessNotificationTemplate:  "The work queue has been changed.",
    updateErrorTemplate: "An error occurred while changing work queue. Please try again."
});
/* xcp_changeworkqueue/content/xcp/action/task/ChangeWorkQueueDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// ChangeWorkQueueDataAction.js

/**
 * @class xcp.action.task.ChangeWorkQueueDataAction
 * @extends xcp.action.task.BaseTaskDataAction
 * Action implementation for change work queue action.
 */
Ext.define("xcp.action.task.ChangeWorkQueueDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_changeworkqueue",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false
    },

    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if (baseAction.isQueueTask(actionArgs, action)) {
            var queueName = baseAction.getTaskAttribute(actionArgs,action,"queue_name");
            var performer = baseAction.getTaskAttribute(actionArgs,action,"performer");
            var state = baseAction.getTaskAttribute(actionArgs,action,"state");
            applicable = performer === queueName &&
                         state != 2 &&
                         baseAction.isQueueTaskActionApplicable(actionArgs,action,true,false,false,false,false);
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;

    },

    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.ChangeWorkQueueDataAction";
    }
});

/* xcp_changeworkqueue/content/xcp/data/model/ChangeWorkQueueTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp_da_def_changeworkqueue",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/changeworkqueue"
    },
    "fields" : [
        {
            "name" : "id",
            "type" : "string"
        },
        {
            "name" : "queueName",
            "type" : "string"
        }
    ]
});


/* xcp_checkbox/content/xcp/widget/form/Checkbox.js */

//Checkbox.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */


/**
 * @class xcp.widget.form.Checkbox
 * @extends Ext.form.Checkbox
 * Checkbox widget capable of allowing boolean user input
 * @xtype xcp_checkbox
 */
Ext.define("xcp.widget.form.Checkbox", {
    extend: 'Ext.form.Checkbox',
    alias: 'widget.xcp_checkbox',
    constructor: function(config) {
        xcp.widget.form.Form.encodeFieldLabel(config);
        this.callParent(arguments);
    },
    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {
            return newValue;
        }
    }]
});

/* xcp_column_box/content/xcp/widget/layout/ColumnBox.js */

// ColumnBox.js

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

(function() {
    var _columnBoxXtype = "xcp_column_box";
    var _columnHBoxXtype = "xcp_columnhbox";
    var _columnVBoxXtype = "xcp_columnvbox";

    // xtypes of child components whose width will be stretched in a vbox when it is not specified explicitly via xcp component definition.
    // auto-width widgets won't have a width set in extjs 4, so there is no need to stretch the <div> components of auto width.
    var _stretchWidthXTypes = ["textfield", "xcp_rich_text", "xcp_value_display", "xcp_checkbox"];

    /**
     * As items in hbox are packaged, nested columnbox needs to be auto in width, and some of the columnbox feature needs to be disabled.
     * @param layout the container layout.
     */
    function checkInCompactHbox(layout) {
        var ct = layout.owner;
        if (typeof ct.initialConfig.width !== "number") {
            var parentCt = ct.ownerCt;
            if (parentCt && parentCt._inCompactHbox) {
                ct._inCompactHbox = true; // mess with component's autoWidth can upset overflow handling.
                delete ct.flex;
            }
        }
        var inCompactHbox = ct._inCompactHbox;
        var items = ct.items.items;
        for (var i = 0, len = items.length; i < len; i++) {
            var child = items[i];
            if (typeof child.initialConfig.width !== "number") {
                if (child.isXType(_columnHBoxXtype) || (inCompactHbox && (child.isXType(_columnBoxXtype) || child.isXType(_columnVBoxXtype)))) {
                    child._inCompactHbox = true;
                    if (inCompactHbox) {
                        delete child.flex;
                    }
                }
            }
        }
    }

    /**
     * Sets the addtional margins between components.
     * @param layout the container layout.
     */
    function setMargins(layout) {
        var ct = layout.owner;
        var margins = ct.defaultMargins;
        if (Ext.isString(margins)) {
            layout.defaultMargins = Ext.util.Format.parseBox(margins);
        } else if (margins && Ext.isObject(margins)) {
            layout.defaultMargins = margins;
        }
    }

    /**
     * The layout manager for a column of horizontal flowing contents.
     */
    Ext.define("xcp.widget.layout.ColumnHBoxLayout",  {
        extend : "Ext.layout.container.HBox",
        alias: "layout.xcp_columnhbox",
        type:  "xcp_columnhbox",

        /**
         * @override
         */
        beginLayout: function (ownerContext) {
            checkInCompactHbox(this);
            setMargins(this);

            // the base class can handle horizontal alignment.
            // use align might cause compatibility issues, e.g, Ext Designer sets layout parameters as the container properties.
            var ct = this.owner;
            var halign = ct.halign || ct.align;
            if (halign === "left" || halign === "start") {
                this.pack = "start";
            } else if (halign === "middle" || halign === "center") {
                this.pack = "center";
            } else if (halign === "right" || halign === "end") {
                this.pack = "end";
            }

            // the base class can't handle bottom alignment. setting to "middle" will make the innerCt stretch.
            var valign = ct.valign;
            if (valign) {
                if (valign !== "top" && valign !== "start") {
                    this.align = "middle";
                }  else {
                    this.align = "top";
                }
            }

            return this.callParent(arguments);
        },

        /**
         * Adds bottom alignment feature.
         * Support Facet container which is constrained by the grid height.
         * @override
         */
        calculatePerpendicular: function(ownerContext, names, plan) {
            var childItems = ownerContext.childItems,
                childItemsLength = childItems.length,
                childContext,
                heightName = names.height,
                i, target,
                hasForStretchMaxOnly = false;

            for (i = 0; i < childItemsLength; i++) {
                if (childItems[i].target.forStretchMaxOnly) {
                    hasForStretchMaxOnly = true;
                    break;
                }
            }
            if (hasForStretchMaxOnly) {
                var stretchHeight = 0;
                for (i = 0; i < childItemsLength; i++) {
                    childContext = childItems[i];
                    target = childContext.target;
                    if (!target.forStretchMaxOnly && !target.isXType("splitter")) {
                        stretchHeight = childContext.props[heightName] || childContext.getProp(heightName);
                        break;
                    }
                }
                if (stretchHeight) {
                    for (i = 0; i < childItemsLength; i++) {
                        childContext = childItems[i];
                        target = childContext.target;
                        if (target.forStretchMaxOnly) {
                            var height = childContext.props[heightName];
                            if (height && height > stretchHeight && height > target.minHeight) {
                                childContext.setProp(heightName, stretchHeight);
                            }
                        }
                    }
                }
            }

            var ret = this.callParent(arguments);

            if (this.owner.valign !== "bottom" && this.owner.valign != "end") {
                return ret;
            }

            var padding = this.padding,
                topName = names.top,
                topPositionName = names.y;

            var targetSize = plan.targetSize;
            var top = padding[topName];
            var availHeight = targetSize[heightName] - top - padding[names.bottom];
            if (isNaN(availHeight)) {
                return ret;
            }

            if (plan.scrollParallel && plan.tooNarrow) {
                availHeight -= Ext.getScrollbarSize().height;
            }

            for (i = 0; i < childItemsLength; i++) {
                childContext = childItems[i];
                var childMargins = childContext.marginInfo || childContext.getMarginInfo();
                var childTop = top + childMargins[topName];
                childTop =  availHeight - childContext.props[heightName] -  childMargins.top;
                if (childContext[topPositionName] != childTop) {
                    childContext.setProp(topPositionName, childTop);
                }
            }

            return ret;
        }
    });

    // cache for performance.
    var _splitterWidth = 0;

    /**
     * The columnbox layout: A ColumnHBoxLayout with splitter support and with auto/percentage width support.
     */
    Ext.define("xcp.widget.layout.ColumnBoxLayout", {
        extend : "Ext.layout.container.HBox",
        alias : "layout.xcp_columnbox",
        type: "xcp_columnbox",
        initialFlexSet : false,  // this can be set by the builder to reset the flex.
        align : "stretchmax",

        /**
         * Configure the items before rendering any.
         */
        _configureItems : function() {
            checkInCompactHbox(this);
            if (!this.owner._inCompactHbox) {
                this.addResizeSupport();
                if (!this.initialFlexSet) {
                    this.setInitialFlex();
                }
            }
        },

        /**
         * @override
         */
        renderItems : function() {
            this._configureItems();
            return this.callParent(arguments);
        },

        /**
         * Configure the width policy after the flex has been calculated.         *
         * @override
         */
        getItemSizePolicy: function (item) {
            if (!this.initialFlexSet) {
                this._configureItems();
            }
            return this.callParent(arguments);
        },

        /**
         * Sets the initial flex based on UI specifications.
         */
        setInitialFlex : function() {
            var visibleItems = this.getLayoutItems();
            var percentWidthComponents = [], autoWidthComponents = [];
            var totalFlex = 0, totalPercent = 0, totalFixedWidth = 0;
            for (var i = 0, len = visibleItems.length; i < len; i++) {
                var child = visibleItems[i];
                if (child.hidden !== true) {
                    if (child.flex) {
                        totalFlex += child.flex;
                    } else if (typeof child.width === "number") {
                        totalFixedWidth += child.width;
                    } else if (child.isXType("splitter")) {
                        if (!_splitterWidth) {
                            _splitterWidth = child.getWidth();   // cache for performance.
                        }
                        totalFixedWidth += _splitterWidth;
                    } else {
                        var iniWidth = child.initialConfig.width;
                        if (typeof iniWidth === "string") {
                            var pc = parseFloat(iniWidth.replace('%', ''));
                            totalPercent += pc;
                            percentWidthComponents.push({
                                component: child,
                                percent: pc
                            });
                            if (child.width === iniWidth) {
                                delete child.width;
                            }
                        } else {
                            autoWidthComponents.push(child);
                        }
                    }
                }
            }

            if (percentWidthComponents.length > 0) {
                // UXD: percent width is against the total container width;
                // EXT JS: flex is relative against flexible width after the fixed width has been taken away;
                var adjustment = 1;
                if (totalFixedWidth > 0) {
                    // performance: avoid doing a DOM read.
                    var size = this.getTarget().getViewSize();
                    adjustment = size.width > totalFixedWidth ? size.width / (size.width - totalFixedWidth) : 1;
                }
                for (i=0; i<percentWidthComponents.length; i++) {
                    var pwc = percentWidthComponents[i];
                    var flex = pwc.percent  * adjustment;
                    pwc.component.flex = flex > 0 ? flex : 1;
                    totalFlex += flex;
                }

                if (totalFlex > 100) {
                    // scale the flex to 100.
                    // ignore scaling if the total percentage does not add up to 100% when there is no auto, which will be good ratio by the "flex"
                    // while allows giving dynamically added component a big enough flex.
                    var scale = (totalFlex/100);
                    for (i=0; i<percentWidthComponents.length; i++) {
                        child = percentWidthComponents[i];
                        if (child.hidden !== true && child.flex) {
                            child.flex /= scale;
                        }
                    }
                    totalFlex = 100;
                }
            }
            if (autoWidthComponents.length > 0) {
                var flexPerAuto = (100 - totalFlex) / autoWidthComponents.length;
                if (flexPerAuto < 1) {
                    flexPerAuto = 1;
                }
                for (i=0; i<autoWidthComponents.length; i++) {
                    autoWidthComponents[i].flex = flexPerAuto;
                }
            }
            this.initialFlexSet = true;
        },

        /**
         * Adds splitters even for dynamically added/showing components.
         */
        addResizeSupport : function() {
            var splitters = [];
            var container = this.owner;
            var items = container.items.items;
            var prevComponent = null;
            for (var i = 0, len = items.length; i < len; ++i) {
                var item = items[i];
                if (item.isXType("splitter") || typeof(item.initialConfig.width) === "number") {
                    prevComponent = null;
                } else if (!item.hidden) {
                    var isFlexWidth = typeof(item.initialConfig.width) !== "number";
                    if (prevComponent && !item.isXType("splitter") && isFlexWidth) {
                        splitters.push({
                            left : prevComponent,
                            right : item
                        });
                    }
                    if (item.split === true && isFlexWidth) {
                        prevComponent = item;
                    } else {
                        prevComponent = null;
                    }
                }
            }

            // called with the scope of the component to be destroyed.
            function removeSplitter() {
                var sb = this._splitter;
                if (sb) {
                    delete this._splitter;
                    sb.destroy();
                }
            }

            for (i = 0, len = splitters.length; i < len; ++i) {
                var sb = splitters[i];
                var sbobj = container.insert(container.items.indexOf(sb.right), {
                    _left: sb.left,
                    _right: sb.right,
                    xtype : "splitter",
                    collapseDirection: "right", // this get around extjs splitter class hard-code "hbox" as the layout type.
                    listeners : {
                        beforedestroy : function() {
                            delete this._left;
                            delete this._right;
                        }
                    }
                });
                sb.left._splitter = sbobj;
                sb.left.on("destroy", removeSplitter);
                sb.right._splitter = sbobj;
                sb.right.on("destroy", removeSplitter);
            }
        }
    });

    /**
     * Layout manager for a column of vertically flowing content.
     */
    Ext.define("xcp.widget.layout.ColumnVBoxLayout",  {
        extend : "Ext.layout.container.VBox",
        type: "xcp_columnvbox",
        alias: "layout.xcp_columnvbox",
		padding: '0 4 0 0',

        /**
         * Patch ExtJs Labelable.nowWrap to make form fields wrap correctly on the first layout.
         * It works fine after the first layout is done.
         * See EXTJSIV-6678: http://www.sencha.com/forum/showthread.php?227044-Layout-of-VBox-does-not-take-text-wrapping-into-account-on-first-layout&highlight=text+wrap
         * Still having the same issue with extjs 4.1.2 sept nightl;y build.
         * @param ownerContext
         */
        patchNoWrap : function(ownerContext) {
            var childItems = this.owner.items.items;
            for (var i = 0, childItemsLength = childItems.length; i < childItemsLength; i++) {
                var target = childItems[i];
                if (target.isXType("field") && this.shouldStretchChildWidth(target)) {
                    // we need to set this flag to false to make form fields wrap correctly on the first layout.
                    target._iniNoWrap = target.noWrap;
                    target._wasHidden = target.hidden;
                    target.noWrap = false;
                }
            }
        },

        /**
         * Restore ExtJs Labelable.nowWrap after the first layout.
         * @param ownerContext
         */
        restoreNoWrap : function(ownerContext) {
            var childItems = this.owner.items.items;
            for (var i = 0, childItemsLength = childItems.length; i < childItemsLength; i++) {
                var target = childItems[i];
                if (!target.hidden && !target._wasHidden && target.isXType("field") && this.shouldStretchChildWidth(target)) {
                    // restore to its initial value for performance.
                    // noWrap == "false" will cause delay of box measurement.
                    target.noWrap = target._iniNoWrap;
                    target._wasHidden = false;
                }
            }
        },

        /**
         * @override
         */
        beginLayout: function (ownerContext) {
            checkInCompactHbox(this);
            setMargins(this);

            var ret = this.callParent(arguments);
            var ct = this.owner;

            // - Choose the best alignment for runtime. However a layout failure can happen (XCPUIC-3938) if the aligned is switched so
            //   we use all the children including invisible ones to determine the alignment.
            // - For design mode, we disable this optimization to allow dynamically mixing non-stretchable (buttons) and stretchable into a single column.

            // set the align to "stretch" if all the child components are to be stretched.
            var childItems = ct.items.items;
            var hasNaturalWidth = !xcp.core.NavigationManager;
            if (!hasNaturalWidth) {
                for (var i = 0, childItemsLength = childItems.length; i < childItemsLength; i++) {
                    var target = childItems[i];
                    if (!this.shouldStretchChildWidth(target)) {
                        hasNaturalWidth = true;
                        break;
                    }
                }

                this._beginLayoutCallCount = this._beginLayoutCallCount || 0;
                if (this._beginLayoutCallCount == 0) {
                    this.patchNoWrap(ownerContext);
                    this._beginLayoutCallCount++;
                } else {
                    this.restoreNoWrap(ownerContext);
                    this._beginLayoutCallCount++;
                }
            }
            if (!hasNaturalWidth) {
                this.align = "stretch";
            } else {
                // the base class can handle "left" and "center".
                // use align might cause compatibility issues, e.g, Ext Designer sets layout parameters as the container properties.
                var halign = ct.halign || ct.align;
                if (halign === "middle" || halign === "center") {
                    this.align = "center";
                } else {
                    this.align = "left";
                }
            }

            var valign = ct.valign;
            if (valign === "middle" || valign === "center") {
                this.pack = "center";
            } else if (valign == "bottom" || valign == "end") {
                this.pack = "end";
            }

            return ret;
        },

        /**
         * Configure the width policy based on individual widgets.
         * The base class can only stretch either all or none of the children.
         *
         * @override
         */
        getItemSizePolicy: function (item) {
            if (item.isComponent && (this.align === "stretch" || this.shouldStretchChildWidth(item))) {
                return this.sizePolicy.stretch;
            } else {
                return this.callParent(arguments);
            }
        },

        /**
         * Force the base class to get the innerCt size correct
         * @override
         */
        publishInnerCtSize: function(ownerContext, reservedSpace) {
            var align = ownerContext.boxOptions.align;
            var plan = ownerContext.state.boxPlan;
            var targetSize = plan.targetSize;

            // for estimating of size defined or not; no need to be accurate
            var innerCtStretchWidth = targetSize.width;
            var innerCtHeight = (ownerContext.parallelSizeModel.shrinkWrap || (plan.tooNarrow && plan.scrollParallel)
                    ? ownerContext.state.contentWidth : targetSize["height"]);

            var ret;
            if (!this.done || isNaN(innerCtStretchWidth + innerCtHeight) || align.stretch || align.center || this.owner._inCompactHbox) {
                ret = this.callParent(arguments);
            } else {
                var owner = this.owner;
                var overflowX = owner["overflow_x"] || owner["overflow-x"] || owner["overflowX"] || "hidden";
                if (overflowX !== "hidden" && !isNaN(plan.maxSize) && plan.targetSize[this.getNames().height] < plan.maxSize) {
                    ret = this.callParent(arguments);
                } else {
                    // ask the parent method to do a stretch so we don't need to copy the logic.
                    var stretch = align.stretch;
                    align.stretch = true;
                    try {
                        ret = this.callParent(arguments);
                    } finally {
                        align.stretch = stretch;
                    }
                }
            }

            return ret;
        },

        /**
         * Patch extjs to prevent layout failures due to dead locks.
         * Setting height can't be done for an auto-size component unless its width is known, but vbox tries to calculate the height first.
         */
        calculate: function(ownerContext) {
            var state = ownerContext.state;
            var perpendicularDone = state.perpendicularDone;

            this.callParent(arguments);

            // Get height if width is known now in case that extjs thinks that there is no progress (Context.progressCount <= 0 will quit layout)
            // Layout failures happen in a complex page after parent hboxes have called calculateStretchMax().
            if (!perpendicularDone && state.perpendicularDone && !state.parallelDone) {
                this.callParent(arguments);
            }
        },

        /**
         * Stretching a child widget if it is required.
         * Adds right-alignment support.
         * @override
         */
        calculatePerpendicular: function(ownerContext, names, plan) {
            var heightName = names.height,
                setHeightName = 'set' + names.heightCap,  // $NON-NLS-1$ 
                padding = this.padding,
                topName = names.top,
                topPositionName = names.y;

            var targetSize = plan.targetSize;
            var top = padding[topName];
            var availHeight = targetSize[heightName] - top - padding[names.bottom];
            if (isNaN(availHeight)) {
                return this.callParent(arguments);
            }

            if (plan.scrollParallel && plan.tooNarrow) {
                availHeight -= Ext.getScrollbarSize().height;
            }

            var owner = this.owner;
            var childItems = ownerContext.childItems;
            var i, childContext, childMargins;
            var childItemsLength = childItems.length;
            if (this.align !== "stretch") {
                for (i = 0; i < childItemsLength; i++) {
                    childContext = childItems[i];
                    var target = childContext.target;
                    if (target.isComponent && this.shouldStretchChildWidth(target)) {
                        childMargins = childContext.marginInfo || childContext.getMarginInfo();
                        var height = availHeight - childMargins[heightName];
                        if (childContext[heightName]  != height) {
                            childContext[setHeightName](height);
                        }
                    }
                }
            }

            var ret = this.callParent(arguments);

            if (owner.halign === "right" || owner.align === "right") {
                for (i = 0; i < childItemsLength; i++) {
                    childContext = childItems[i];
                    childMargins = childContext.marginInfo || childContext.getMarginInfo();
                    var childTop = top + childMargins[topName];
                    childTop =  availHeight - childContext.props[heightName] -  childMargins[heightName];
                    if (childContext[topPositionName] != childTop) {
                        childContext.setProp(topPositionName, childTop);
                    }
                }
            }

            return ret;
        },

        /**
         * defaults to false for compatibility with extjs vbox
         */
        shouldStretchChildWidth : function (child) {
            if (typeof child.width === "number") {  // can't stretch as it won't pass extjs's ContextItem.checkAuthority
                return false;
            }

            var hstretch = child.hstretch;
            if (child._inCompactHbox || this.owner._inCompactHbox) {
                return false;
            } else if (hstretch === true) {
                return true;
            } else if (hstretch === false) {
                return false;
            } else if (typeof child.initialConfig.width !== "number") {
                if (child.isXType("container")) {
                    return true;
                }
                for (var i=0, len = _stretchWidthXTypes.length; i<len; i++) {
                    if (child.isXType(_stretchWidthXTypes[i])) {
                        return true;
                    }
                }
            }

            return false;
        }
    });
})();

(function() {
    function fixWidthConfig(config) {
        if (config) {
            var items = config.items;
            if (items) {
                for (var i = 0, len = items.length; i < len; i++) {
                    var item = items[i];
                    var width = item.width;
                    if (typeof width === "string" && width.indexOf("%") < 0 && width.length != 0) {
                        item.width = parseInt(width, 10);
                    }
                }
             }
        }
    }

    var defaultLabelConfigs = [
        "labelAlign", "labelWidth", "labelCls", "labelSeparator", "labelStyle", "hideEmptyLabel"
    ];

    /**
     * Applies the container setting on labels to the default of the child widgets.
     * @param config The container config.
     */
    function fixLabelConfig(config) {
        var defaults = config.defaults;
        if (!defaults) {
            defaults = config.defaults = {};
        }
        for (var i=0; i<defaultLabelConfigs.length; i++) {
            var name = defaultLabelConfigs[i];

            // applying "undefined" value can cause form fields and labels to have "undefined" string in the generated HTML styles.
            if (typeof defaults[name] === "undefined" && typeof config[name] !== "undefined") {
                defaults[name] = config[name];
            }
        }
    }

    var minHeight = 20, minWidth = 20;

    var defaultMargins = {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
    };

    Ext.define("xcp.widget.layout.ColumnHBox",  {
        extend : "Ext.container.Container",
        alias: "widget.xcp_columnhbox",
        layout : "xcp_columnhbox",
        defaultMargins: defaultMargins,
        minHeight: minHeight,
        minWidth: minWidth,

        constructor : function(config) {
            if (config && config.overflow_x) {
                config.overflowX = config.overflow_x;
            }
            fixWidthConfig(config);
            fixLabelConfig(config);
            this.callParent(arguments);
        },

        initComponent: function() {
            this.callParent(arguments);
            if (Ext.is.iPad) {
                this.on("afterlayout", this.adjustLayoutTarget, this);
            }
        },

        adjustLayoutTarget: function() {
            // XCPUIC-2622 - During layout, the targetCt can get out of line on the iPad (not sure why), workaround
            // is to make sure that targetCt gets positioned correctly
            var layout = this.getLayout();
            var innerCt = layout.getElementTarget();
            var targetCt = layout.getRenderTarget();
            var innerX = innerCt.getX();
            var targetX = targetCt.getX();
            if (innerX != targetX) {
                targetCt.setX(innerX);
            }
        },

        // tracking down inserting, adding and creating a component
        onBeforeAdd : function(child) {
            fixWidthConfig({items: [child]});
            return this.callParent(arguments);
        }
    });

    Ext.define("xcp.widget.layout.ColumnVBox", {
        extend : "Ext.container.Container",
        alias: "widget.xcp_columnvbox",
        layout : "xcp_columnvbox",
        defaultMargins: defaultMargins,
        minHeight: minHeight,
        minWidth: minWidth,

        constructor : function(config) {
            if (config && config.overflow_x) {
                config.overflowX = config.overflow_x;
            }
            fixWidthConfig(config);
            fixLabelConfig(config);
            this.callParent(arguments);
        },

        initComponent: function() {
            this.callParent(arguments);
            if (Ext.is.iPad) {
                this.on("afterlayout", this.adjustLayoutTarget, this);
            }
        },

        adjustLayoutTarget: function() {
            // XCPUIC-2622 - During layout, the targetCt can get out of line on the iPad (not sure why), workaround
            // is to make sure that targetCt gets positioned correctly
            var layout = this.getLayout();
            var innerCt = layout.getElementTarget();
            var targetCt = layout.getRenderTarget();
            var innerX = innerCt.getX();
            var targetX = targetCt.getX();
            if (innerX != targetX) {
                targetCt.setX(innerX);
            }
        },

        // tracking down inserting, adding and creating a component
        onBeforeAdd : function(child) {
            fixWidthConfig({items: [child]});
            return this.callParent(arguments);
        }
    });

    Ext.define("xcp.widget.layout.ColumnBox", {
        extend : "Ext.panel.Panel",
        alias: "widget.xcp_column_box",
        layout : "xcp_columnbox",
        minHeight: minHeight,
        minWidth: minWidth,
        ui: 'xcp-column-box-ui',

        /**
         * ExtJS 4 bug: the sum of widget heights in a vbox would count the body size even after a panel is collapsed.
         */
        animCollapse : false,

        /**
         * Flag marking the column box as a form region. Default is false.
         */
            
        constructor : function(config) {
            if (config && !config.title) {
                config.collapsible = false;
            }
            fixWidthConfig(config);

            this.callParent(arguments);
        },

        // tracking down inserting, adding and creating a component
        onBeforeAdd : function(child) {
            fixWidthConfig({items: [child]});
            if (child.isXType("xcp_columnhbox") || child.isXType("xcp_columnvbox")) {
                if (typeof child.width === "string" && child.width.indexOf("%") >= 0) {
                    // Remove the mess caused by width in percentage.
                    // we use initialConfig for flex calculation.
                    delete child.width;
                }
            }
            return this.callParent(arguments);
        }
    });
})();
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.report.Reports");
Ext.apply(xcp.Strings.widget.report.Reports, {
    componentId:                "ID",
	columnsFieldLabel:		    "Columns",
	titleGeneralSectionLabel:	"General",
	titleBasicSectionLabel:	    "Basic",
    titleFieldValue:	        "Title",
    generalDataSectionLabel:    "Data",
    rangesLabel:                "Ranges",
    defaultDisplayLabel: "Default Display",
    displayLabel: "Display",
    reportTyprField:	        "Report Type",
    timeGranularityField:	     "Time Granularity",
    titleInfoSectionLabel:	     "Info",
    titleRulesSectionLabel:	     "Display Rules",
    titleStyleSectionLabel:	     "Style",
    btnEditCrystalReportLabel:	     "Edit in Crystal Reports",
    btnFinishEditCrystalReportLabel:	     "Edit in Crystal Reports",
    msgReportBeingEdited:	     "This report is beign edited",
    msgLoadingReport:             "Loading Report .....",
    msgLastEdited:                "Last saved on ",
    msgErrorLoadingCrystalReport:   "Error loading crystal report RPT file",
    msgUnkownReportType:    "Unkown report type or report type is empty",
    btnSyncCrystalReportLabel:"Sync Crystal Report with Data Source",
    msgErrorUpdatingCrystalReport:   "Error updating crystal report RPT file",
    msgErrorCrystalReportOpenByOtherProcess:  "Cannot update the Crystal Report because it is being used by another process." ,

    chartTypeColumn:"Column",
    chartTypeLine:"Line",
    chartTypePie:"Pie",

    xAxisLabel: "Categories",
    yAxisLabel:"Values",
    prefix:"",

    sampleDataC1 : "A",
    sampleDataC2 : "B",
    sampleDataC3 : "C",
    sampleDataC4 : "D",
    sampleDataC5 : "E",
    sampleDataC6 : "F",
    sampleDataC7 : "G",


    dataC11 : 45,
    dataC21 : 125,
    dataC31 : 50,
    dataC41 : 25,
    dataC51 : 45,
    dataC61 : 90,
    dataC71 : 150,


    dataC12 : 20,
    dataC22 : 15,
    dataC32 : 20,
    dataC42 : 40,
    dataC52 : 35,
    dataC62 : 70,
    dataC72 : 20,


    dataC13 : 70,
    dataC23 : 40,
    dataC33 : 25,
    dataC43 : 10,
    dataC53 : 70,
    dataC63 : 150,
    dataC73 : 10,


    dataC14 : 90,
    dataC24 : 25,
    dataC34 : 40,
    dataC44 : 30,
    dataC54 : 7,
    dataC64 : 2,
    dataC74 : 65,


    dataC15 : 15,
    dataC25 : 10,
    dataC35 : 100,
    dataC45 : 40,
    dataC55 : 75,
    dataC65 : 95,
    dataC75 : 25,


    dataC16 : 110,
    dataC26 : 80,
    dataC36 : 20,
    dataC46 : 35,
    dataC56 : 90,
    dataC66 : 45,
    dataC76 : 70,

    dataC17 : 110,
    dataC27 : 80,
    dataC37 : 20,
    dataC47 : 35,
    dataC57 : 90,
    dataC67 : 45,
    dataC77 : 70,

    dataC18 : 110,
    dataC28 : 80,
    dataC38 : 2,
    dataC48 : 35,
    dataC58 : 90,
    dataC68 : 45,
    dataC78 : 70,


    dataC19 : 110,
    dataC29 : 80,
    dataC39 : 20,
    dataC49 : 35,
    dataC59 : 90,
    dataC69 : 45,
    dataC79 : 70,

    dataC110 : 110,
    dataC210 : 80,
    dataC310 : 20,
    dataC410 : 35,
    dataC510 : 60,
    dataC610 : 45,
    dataC710 : 70,

    dataSectionLabel: "Data",

    createNewOrUsePageTitle: "Data Service and Instance Creation",
    createNewOrUseInstructionText: "A Chart must be connected to an instance of a data service.",
    createNewOrUseRadioHeader: "Create:",
    createNewOrUseRadio1Label: "Data service and instance",
    createNewOrUseRadio1Instructions: "Add a new data service.  An instance of the data service will also be created and connected to the chart.",
    createNewOrUseRadio2Label: "Instance of an existing data service",
    createNewOrUseRadio2Instructions: "Select an existing data service.  A new instance of the data service will be created and connected to the chart.",

    chooseTypePageTitle: "Data Service Creation",
    chooseTypeInstructionText: "Create a data service that returns:",

    selectDSPageTitle: "Create an Instance of an Existing Data Service",
    selectDSInstructionText: "Select a data service:",
    selectDSTitleLabel: "Data service label",

    typeListLabel: "Data service:",

    chooseColumnPageTitleScreen3a: "Specify column chart categories (X Axis)",
    chooseColumnPageTitleScreen3b: "Specify column chart values (Y Axis)",
    
    chooseColumnPageTitleScreen4: "Define values and categories (X and Y axes)",
    chooseColumnPageTitleScreen5: "Create user inputs for the query",
    chooseColumnPageTitle: "Specify columns for Crystal Reports",
    showAllAvailableFields:"Show all available",
    availableColumnsLabel:"Available:",
    includedColumnsLabel:"Included:",
    primaryTypeLabel: "{0} ({1})",

    categoriesXaxis:"Categories (X Axis)",
    valuesYaxis:"Values (Y Axis)",
    
    dataSourceName:"Data Source",
    axis_Label: "Axis Label",
    yAxis_Label:"Y Axis Label",
    xAxis_Label:"X Axis Label",
    xAxisType:"X Axis Type",

    xAxisFields: "X Axis Fields",
    yAxisFields: "Y Axis Fields",

    displayTitle: "Display",
    fieldTitle: "Field",
    typeTitle: "Type",
    chartWidgetTitle: "Chart widget title",
    crystalWidgetTitle: "Crystal Reports widget title",
    chartHasNoData: "No data to display",
    chartNoDataLabel: "No data",

    slaLines: "Lines",

    ranges: "Ranges",
    layoutSectionLabel: "Layout",
    sizeGroupLabel: "Size"

});
/* xcp_column_line_chart/content/xcp/widget/report/ColumnChartComponent.js */

var columnChartComponentColors=new Array();

Ext.define("xcp.widget.report.ColumnChartComponent",
    {
        extend: "Ext.Panel",
        alias: 'widget.xcp_column_line_chart',
        layout: 'fit',

        /**
         * Returns the field value from the Selected Row Data associated with the given component
         * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
         * @param compId  {String} (Required) The component id
         * @param fieldId  {String} (Required)
         */
        statics : {

            getValueFromRowSelection: function(context, compId, fieldId) {

                var comp = context.getComponent(compId);
                var value = "";
                if (!comp) {
                    xcp.Logger.warn("Could not find the component : " + compId);
                } else {

                    value = comp.getSelectedRowData()[fieldId] ;
                    return xcp.core.expr.BaseExpression.checkValue(value);
                }
            }
        },

        // IWC The object which stores the selected row data from the chart.
        selectedRowData:{},

        // IWC: Publish the series "itemmouseup" as "seriesselected" event.
        xcpeventconfig : [{
            event : "seriesselected"
        }],

        // IWC: Returns the selected row data
        getSelectedRowData:function(){
               return this.selectedRowData;
        },
        constructor: function (config) {
            var me = this;
            config = config || {};
            if(!config.xAxisSelectedFields) {
                config.xAxisSelectedFields = ['X'];
            }

            if(!config.yAxisSelectedFields) {
                config.yAxisSelectedFields = ['Y'];
            }
            if(!config.yAxisSelectedFieldsNames) {
                config.yAxisSelectedFieldsNames = ['Y'];
            }
            if(!config.xAxisSelectedFieldsNames) {
                config.xAxisSelectedFieldsNames = ['X'];
            }
            if(!config.yAxisSelectedTypes) {
                config.yAxisSelectedTypes = ['column'];
            }
            if(!config.yAxisSelectedLabels) {
                config.yAxisSelectedLabels =  ['Y'];
            }



            me.chartLegend ={
                position:'bottom',
                boxStrokeWidth:0,
                padding: 5,
                itemSpacing: 10,
                labelFont: '10px Helvetica, Arial, Sans-serif',
                fill: '#707070'
            };
            me.showInLegend = true;
            Ext.useShims = true;
            me.config = config;
            me.chartStore = null;
            me.maximum=0;
            me.setMaximum = false;
            me.rotationDegrees = 0;
            me.xFields = config.xAxisSelectedFields;
            me.yFields = config.yAxisSelectedFields;
            me.yAxisSelectedLabels = config.yAxisSelectedFieldsNames;

            me.xFieldsNames = config.xAxisSelectedFieldsNames;
            me.yFieldsNames = config.yAxisSelectedFieldsNames;
            me.yAxisSelectedTypes = config.yAxisSelectedTypes;

            me.runtimeEmptyChartData = null;


            this.runtime = Ext.isDefined(xcp.navigationManager);
            me.chartReportUtil = new xcp.widget.report.ChartReportUtil();
            if (this.runtime)
            {
                me.chartStore = me.chartReportUtil.getRunTimeStore(config);
                me.chartStore.on( 'load', function( store, records, options ) {
                    if( !(store.data.length>0)){
                        me.runtimeEmptyChartData = [[xcp.Strings.widget.report.Reports.chartNoDataLabel,0]];

                        var newStore = me.chartReportUtil.createEmptyStore(config.modelName, me.runtimeEmptyChartData, me.xFields, me.yFields, 0);

                        me.items.items[0].store = newStore;

                    }else{
                        me.runtimeEmptyChartData = null;
                        me.setMaximumMinimum(config, me.chartStore);
                        // Need to set remoteSort = false as chart will be using data action framework and in
                        //DataSourceAction.js remoteSort is set to true. Since we are doing sorting on the client we need to
                        // set it to false.
                        store.remoteSort = false;
                        // Removed the sorters config in the store and instead added sort fields here as there were issues
                        // while using sorters with RealtimeQuery.
                        if(config.sortingFieldName && config.sortingOrder)
                            store.sort(config.sortingFieldName,config.sortingOrder);

                        me.items.items[0].store = store;
                    }
                    me.items.items[0].redraw();
                });
                me.rotationDegrees = 315;
            }
            else
            {
                me.chartStore = me.chartReportUtil.getDesignTimeStore(config);
                me.setMaximum = true;
                me.rotationDegrees = 0;

                // Refer to bug BAM-4712, the problem happens only at design time
                xcp.widget.report.ChartReportUtil.ENCODER.addCharEntities();

            }

            this.getSeriesColors(config);


            Ext.apply(this,Ext.apply(this.initialConfig, config), {
                title: config.title,
                cls: 'xcp-chart-outer-panel',
                padding: 3,
                items:[this.getMultipleSeriesChart(config)]
            });

            xcp.widget.report.ColumnChartComponent.superclass.constructor.call(this, config);


        },
        initComponent: function()
        {
            var me = this;
            xcp.widget.report.ColumnChartComponent.superclass.initComponent.call(this);
            me.addEvents(
                /**
                 * @event seriesselected
                 * Fires when user clicks on any of the series on the chart.
                 */
                'seriesselected'
            );
        },

        redrawChart:function(config){
            var me = this;
            me.chartStore = me.chartReportUtil.getDesignTimeStore(config);
            this.getSeriesColors(config);

            me.removeAll(true);
            me.addClass('xcp-chart-outer-panel');
            me.add(this.getMultipleSeriesChart(config));

            this.setMaximumMinimum(config, me.chartStore);
            this.reloadDataStore(config);
        },

        regenerateChart:function(config){
            var me = this;
            me.removeAll(true);
            me.addClass('xcp-chart-outer-panel');
            me.chartStore = me.chartReportUtil.getDesignTimeStore(config);
            me.getSeriesColors(config);
            me.add(this.getMultipleSeriesChart(config));
        },

        getMultipleSeriesChart : function(config)  {
            var me = this;
            me.addBodyCls('xcp-column-chart-panel-body');
            me.yFields = config.yAxisSelectedFields;
            var thisLegend = true;

            if(config.legendDisplay == "true") {
                me.showInLegend = true;
            }  else {
                  me.showInLegend = false;
            }

            var series = this.getMultipleSeries(config);

            var minimum = me.yFields? me.chartStore.min(me.yFields[0]):0;
            if (!minimum || minimum >= 0 ) minimum  = 0;

            var columnOpacity = 1.0;

            var chart = new Ext.chart.Chart({

                animate: true,
                layout:'fit',
                anchor:'100%',
                legend: me.chartLegend,
                height:275,
                theme: 'XCPColumnChartTheme:gradients',
                store: me.chartStore,
                axes: [{
                    type: 'Numeric',
                    position: 'left',
                    majorTickSteps:5,
                    minorTickSteps:0,
                    grid: {
                        fill: '#FFFFFF',
                        stroke: '#CCCCCC',
                        'stroke-width': 0.25
                    },
                    fields: me.yFields,
                    label: {
                         renderer: function(label){
                             if(!me.runtime) {
                                 return Ext.util.Format.number(label,'0');
                             }
                             var srtValue = me.chartReportUtil.formatValue(me.config, me.yFields[0], label);

//                             return srtValue.replace('<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)</\1>','');
                             return srtValue;
                         }
                    },
                    title: config.yAxisLabel
                }, {
                    type: 'Category',
                    position: 'bottom',
                    fields:me.xFields? [me.xFields[0]]:[],
                    title: config.xAxisLabel,
                    label: {
                        renderer:function(label){
                            if(label == undefined) return xcp.Strings.widget.report.Reports.chartNoDataLabel;
                            var newValue = null;
                            if(!me.runtime) {
                                newValue = me.getActualValue(me.xFields[0], label);
                            } else {
                                newValue = me.chartReportUtil.formatValue(me.config,me.xFields? me.xFields[0]:[], me.getActualValue(me.xFields? me.xFields[0]:[], label));
                            }
                            if(newValue.length > 10)
                               newValue = newValue.substr(0,10);
                            return newValue;
                        }
                    }
                }],
                series:series

            });
            if(me.setMaximum)
                chart.axes.get(0).maximum = this.getNormalMaximum(config, me.chartStore);

            return chart;
        },
        getMultipleSeries:function(config){
            var me = this;
            var series = [];
            var singleSeries;
            var columnsFields=[], columnFieldsLabels=[];
            var xField = config.xAxisSelectedFields?config.xAxisSelectedFields[0]:[];
            var allFields = config.yAxisSelectedFields;
            var lineSeries = [];
            //var dotSeries = []
            var lineCount=0;
            var allFieldsLabels = config.yAxisSelectedLabels;
            var allFieldsTypes = config.yAxisSelectedTypes;

            var slaFields = [];
            var slaLabels = config.slaAllLabels;
            var slaColors = config.slaAllColors || [];

            for(var i = 0; i < slaColors.length; i++){
                var yFieldForSla = (slaLabels[i] && slaLabels[i] != "")? slaLabels[i]: "sla"+(i+1);
                slaFields.push(this.getSlaField(xField,"sla_"+(i+1),yFieldForSla,slaColors[i]));
            }



            var lineFill =(config.lineFill=== "false" ? false : true);
            var lineSmooth = (config.lineSmooth=== "false" ? false : true);
            var dotType = config.dotTypeList;

            var lineFillSelected = config.lineFillSelected;
            var lineSmoothSelected = config.lineSmoothSelected;
            var lineDotTypeSelected = config.lineDotTypeSelected;

            var seriesCounter = 0;
            if(allFieldsTypes)
            {
                for (var i = 0; i < allFieldsTypes.length; i++) {
                    if (allFieldsTypes[i] == 'column') {
                        seriesCounter++;
                    }
                }

                for(var i=0;i<allFields.length;i++){
                    var type = allFieldsTypes[i];


                    if(type=='column') {
                        columnsFields.push(allFields[i]);
                        columnFieldsLabels.push(allFieldsLabels[i]);
                    } else
                    if(type=='line') {
                                lineFill = lineFillSelected[lineCount] == "true" ? true : false;
                                lineSmooth =  lineSmoothSelected[lineCount] == "true" ? true : false;
                                dotType =  lineDotTypeSelected[lineCount];
                        lineSeries.push(this.getLineField(xField, allFields[i], allFieldsLabels[i],lineFill, lineSmooth,dotType, seriesCounter++));
                                lineCount++;
                    }

                }
            }


            if(columnsFields.length>0){
                series.push(this.getColumnField(xField,columnsFields, columnFieldsLabels));
            }
            var slaPlusLines = lineSeries.concat(slaFields);
            return series.concat(slaPlusLines);
        },
        getColumnField:function(xField, yFields, yFieldLabels){
            var me = this;
            return {
                type: 'column',
                showInLegend:me.showInLegend,
                axis: 'left',
                groupGutter:2,
                xField: xField,
                yField:yFields,
                title: yFieldLabels,
                tips: {
                    trackMouse: true,
                    maxWidth: 1000,
                    renderer: function(storeItem, item) {
                        var title = null;
                        if(!me.runtime){
                            title = me.getActualValue(xField, item.value[0]) + ': ' + item.value[1] + ' ';
                        } else {
                            if(me.runtimeEmptyChartData != null) {
                                title = xcp.Strings.widget.report.Reports.chartHasNoData ;
                            }
                            else {
                                title = me.chartReportUtil.formatValue(me.config, xField, me.getActualValue(xField, item.value[0])) + ': ' + me.chartReportUtil.formatValue(me.config, item.yField, item.value[1]) + ' ';
                            }
                        }
                        this.update(title);
                    }
                },
                label: {
                    display: 'insideEnd',
                        'text-anchor': 'middle',
                        field: yFields,
                        renderer: function(field, value) {
                            if(!me.runtime) {
                               return Ext.util.Format.number(value, '0');
                            } else {
                                if(me.runtimeEmptyChartData != null) {
                                    return '';
                                } else {
                                    return me.chartReportUtil.formatValue(me.config, field, value);
                                }
                            }

                        },
                        orientation: 'vertical',
                        font:'11px Helvetica, Arial, Sans-serif',
                        contrast:true
                },
                onPlaceLabel: function(label, storeItem, item, i, display, animate, j, index) {
                    var chartReportUtil = new xcp.widget.report.ChartReportUtil();
                    chartReportUtil.onPlaceLabelForColumnChart(this,label, storeItem, item, i, display, animate, j, index);
                },
                listeners: {
                itemmouseup: function(item){
                    // There is no itemclick event for series so using itemmouseup
                    if (!me.runtime) return;
                    xcp.widget.report.ChartReportUtil.populateSelectedRowData(item,  me);
                }
                }
            }
        },
        getLineField:function(xField, yField, yFieldLabel, lineFill, lineSmooth, dotType, placeInFieldsArray){
            var me = this;
            return{
                type: 'line',
                showInLegend:me.showInLegend,
                axis: 'left',
                id:yField,
                smooth:lineSmooth,
                fill:lineFill,
                style: {
                   'stroke-width':2,
                    stroke:columnChartComponentColors[placeInFieldsArray],
                    fill: columnChartComponentColors[placeInFieldsArray]
                },
                fillOpacity: 0.2,
                xField: xField,
                yField: yField,
                title: yFieldLabel,
                tips: {
                    trackMouse: true,
                    maxWidth: 1000,
                    renderer: function(storeItem, item) {
                        var title = null;
                        if(!me.runtime){
                         title = me.getActualValue(xField, storeItem.data[xField]) + ': ' + storeItem.data[yField] + ' ';
                        } else {
                            title = me.chartReportUtil.formatValue(me.config, xField, me.getActualValue(xField, storeItem.data[xField])) + ': ' + me.chartReportUtil.formatValue(me.config, yField, storeItem.data[yField]) + ' ';
                        }
                       this.update(title);
                    }
                },
                markerConfig: {
                    type: dotType,
                    size: 4,
                    radius: 4,
                    'stroke-width': 0,
                    fill: columnChartComponentColors[placeInFieldsArray]
                },
                selectionTolerance: 10,
                listeners: {
                    itemmouseup: function(item){
                        if (!me.runtime) return;
                        xcp.widget.report.ChartReportUtil.populateSelectedRowData(item, me);
                    }
                }
            }
        },
        getSlaField:function(xField, yField, yFieldLabel,slaColor){
            var me = this;
            return{
                type: 'line',
                showInLegend:me.showInLegend,
                axis: 'left',
                id:yField,
                smooth:false,
                fill:false,
                style: {
                    stroke:slaColor,
                    'stroke-width':2
                },
                xField: xField,
                yField: yField,
                title: yFieldLabel,
                markerConfig: {
                    type:'cross',
                    size: 0,
                    radius: 0,
                    'stroke-width': 0
                }

            }
        },
        getScatterField:function(xField, yField, yFieldLabel){
            var me = this;
            return{
                type: 'scatter',
                showInLegend:me.showInLegend,
                axis: 'left',
                id:yField,
                smooth: false,
                fill: false,
                fillOpacity: 0.3,
                xField: xField,
                yField: yField,
                title: yFieldLabel,
                tips: {
                    trackMouse: true,
                    width: 140,
                    height: 28,
                    renderer: function(storeItem, item) {
                        //var title = storeItem.raw[0] + ': ' + item.value[1] + ' ';this.setTitle(title);this.setWidth((title.length * 10));
                        var title = storeItem.data[xField] + ': ' + storeItem.data[yField] + ' '; this.setTitle(title); this.setWidth((title.length * 10));
                    }
                },
                markerConfig: {
                    type: 'circle',
                    size: 4
                }
            }
        },
        getNormalMaximum:function(config, store){
        var me = this;
        me.yFields = config.yAxisSelectedFields;
        var maximum = 1;
        var maxField = 1;
        if(me.yFields){
            for(var i=0;i<me.yFields.length; i++){
                maxField =  store.max(me.yFields[i])
                if( maxField> maximum)
                    maximum = maxField;
            }
        }
        var slaAllValues =config.slaAllValues;
        if(slaAllValues)
            for(var j=0;j<slaAllValues.length;j++)
                if(parseInt(slaAllValues[j]) > parseInt(maximum))
                    maximum =  slaAllValues[j];

         maximum = parseInt(maximum);
        var maximumLength = maximum.toString().length;
            maximum = (maximum - (maximum % (Math.pow(10,maximumLength-1)))) + (Math.pow(10,maximumLength-1));
        return maximum;
    },
        getNormalMinimum:function(config, store){
            var me = this;
            me.yFields = config.yAxisSelectedFields;
            var minimum = 999999999999999;
            var minField = 1;
            if(me.yFields){
                for(var i=0;i<me.yFields.length; i++){
                    minField =  store.min(me.yFields[i])
                    if( minField< minimum)
                        minimum = minField;
                }
            }
            var slaAllValues = config.slaAllValues;
            if(slaAllValues)
                for(var j=0;j<slaAllValues.length;j++)
                    if(parseInt(slaAllValues[j]) < parseInt(minimum))
                        minimum =  slaAllValues[j];

            if(minimum > 0 ) return 0;

            minimum = parseInt(minimum * -1);
            var minimumLength = minimum.toString().length;
            minimum = (minimum - (minimum % (Math.pow(10,minimumLength-1)))) + (Math.pow(10,minimumLength-1));
            return (minimum * -1);
        },


        getChart : function(config, chartStore)  {

            var me = this;
            var showLegend = false;
            if(config.legendDisplay == "true")
                showLegend = true;

            var maximum = chartStore.max(this.yFields[0]);
            if (!maximum) maximum  = 1;

            minimum = chartStore.min(this.yFields[0]);
            if (!minimum || minimum >= 0 ) minimum  = 0;

            var columnOpacity = 1.0;

            var chart = new Ext.chart.Chart({

                animate: false,
                layout:'fit',
                width:329,
                legend:showLegend,
                height:250,
                store: chartStore,
                axes: [{
                    type: 'Numeric',
                    position: 'left',
                    fields: [this.yFields[0]],
                    label: {
                        renderer: Ext.util.Format.numberRenderer('0')
                    },
                    title: config.yAxisLabel,
                    minimum: minimum

                }, {
                    type: 'Category',
                    position: 'bottom',
                    fields: [this.xFields[0]],
                    title: config.xAxisLabel,
                    grid: true,
                    label: {
                        rotate: {
                            degrees: this.rotationDegrees
                        }
                    }
                }],
                series: [{
                    type: this.xAxisSelectedTypes[0],
                    axis: 'left',
                    highlight: false,
                    tips: {
                        trackMouse: true,
                        width: 140,
                        height: 28,
                        renderer: function(storeItem, item) {
                            var title = storeItem.get(me.xFields[0]) + ': ' + storeItem.get(me.yFields[0]) + ' ';
                            this.setTitle(title);
                            this.setWidth((title.length * 10));
                        }
                    },
                    label: {

                        display: 'rotate',
                        'text-anchor': 'middle',
                        field: this.yFields[0],
                        renderer: Ext.util.Format.numberRenderer('0'),
                        orientation: 'vertical',
                        color: '#333'
                    },
                    xField: this.xFields[0],
                    yField: [this.yFields[0]],
                    title: [this.yFieldsNames[0]],
                    renderer: function(sprite, record, attr, index,store) {
                        var color = ['rgb(102,204,102)'];
                        return Ext.apply(attr, {
                            fill: color,
                            stroke:color,
                            opacity:columnOpacity
                        });
                    }
                }]

            });
            return chart;
        },
        reloadDataStore:function(config){
            var me = this;
            var chart = me.items.getAt(0);
            chart.store = me.chartReportUtil.getDesignTimeStore(config);
            chart.redraw();
        },
        reloadDataAxisChange:function(config){
            var me = this;
            var chart = me.items.getAt(0);
            chart.store = me.chartReportUtil.getDesignTimeStore(config);
            var xFields =config.xAxisSelectedFields?config.xAxisSelectedFields:[];
            me.xFields = xFields;
            chart.series.getAt(0).xField = xFields;
            chart.axes.get(1).fields = xFields;
            chart.redraw();
        },
        getGroupFields:function(config){
            var yFields = config.yAxisSelectedFields;
            var yFieldsNames =config.yAxisSelectedFieldsNames;
            var yFieldsTypes = config.yAxisSelectedTypes;

            var allFields = [];
            for(i=0;i<yFieldsTypes.length;i++)
            {
                allFields.push({name:yFields[i],fieldLabel:yFieldsNames[i], fieldType:yFieldsTypes[i]})
            }


        },

        getSeriesColors:function(config) {
            var chartColorsLocal = new xcp.widget.report.ChartColorUtil().getChartColors();
            var yFields = config.yAxisSelectedFields;
            var yFieldsAmount = yFields?yFields.length:10;

            var colorIndex = 0;
            for (var i = 0; i < yFieldsAmount; i++) {
                if (colorIndex > 9) {
                    colorIndex = 0;
                }
                columnChartComponentColors[i] = chartColorsLocal[colorIndex];
                colorIndex++;
            }

        } ,

        setMaximumMinimum:function(config, store){
            var me = this;
            me.maximum = me.getNormalMaximum(config, store);
            me.minimum = me.getNormalMinimum(config, store);
            if((me.items.getAt(0).axes.get(0).maximum != me.maximum) ||
                (me.items.getAt(0).axes.get(0).minimum != me.minimum))
            {
                me.items.getAt(0).axes.get(0).maximum = me.maximum;
                me.items.getAt(0).axes.get(0).minimum = me.minimum;
            }
        },
        setChartMaximumValue:function(config, store){
            var me = this;
            me.maximum = me.getNormalMaximum(config, store);
            if((me.items.getAt(0).axes.get(0).maximum != me.maximum))
                me.items.getAt(0).axes.get(0).maximum = me.maximum;
        },
    getActualValue: function(field, value) {
        var me = this;
        if (!me.runtime) return value;
        var newValue = me.chartReportUtil.resolvePickListValue(field, value, me.config);
        return newValue;
    }
 });



/* xcp_column_line_chart/content/xcp/widget/report/ChartColorUtil.js */

/**
 * Created by IntelliJ IDEA.
 * User: shawb2
 * Date: 8/17/12
 * Time: 5:37 PM
 * To change this template use File | Settings | File Templates.
 */
 Ext.define("xcp.widget.report.ChartColorUtil",{
     getChartColors:function() {
         var chartColors = [ '#8CA608',
                     '#3399CC',
                     '#D2A01A',
                     '#B64A14',
                     '#8C314F',
                     '#587306',
                     '#356993',
                     '#CC7014',
                     '#F2CE18',
                     '#A60001'
                     ];

         return   chartColors;
     },

     getEmptyChartColor:function() {
         var emplyColor = '#EEEEEE';

         return emplyColor;
     },

     getGradient:function(baseColor, index) {
         var midColor = Ext.draw.Color.fromString(baseColor);
         var color = this.getDarkerColor(midColor);
         var key = this.getColorKey(baseColor, index)
         var gradient = {
                        id: key,
                        angle: 45,
                        stops: {
                            0: {
                                color: midColor.toString()
                            },
                            100: {
                                color: color.toString()
                            }
                        }
                    };
         return gradient;
     },

     getColorKey:function(baseColor, index) {
         var midColor = Ext.draw.Color.fromString(baseColor);
         var color = this.getDarkerColor(midColor);
         var key = 'theme-' + midColor.toString().substr(1) + '-' + color.substr(1) + '-' + index;

         return key;
     },

     getDarkerColor:function(midColor) {
       return midColor.getDarker(0.1).toString();
     }
 });


/* xcp_column_line_chart/content/xcp/widget/report/XCPColumnChartTheme.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: docadmin
 * Date: 1/8/12
 * Time: 2:50 PM
 * To change this template use File | Settings | File Templates.
 */

    //move to compo

//end move
var widjetLabelText='11px Helvetica, Arial, Sans-serif';
var widjetValueText='10px Helvetica, Arial, Sans-serif';

Ext.define('Ext.chart.theme.XCPColumnChartTheme', {
    extend: 'Ext.chart.theme.Base',

    constructor: function(config) {
        this.callParent([Ext.apply(
            {
                background:false,
                colors:  new xcp.widget.report.ChartColorUtil().getChartColors(),
                padding:50,
                axis: {
                    stroke: '#707070',
                    'stroke-width': 1
                },
                axisLabelTop: {
                    fill: '#707070',
                    font: widjetValueText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisLabelRight: {
                    fill: '#707070',
                    font: widjetValueText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisLabelBottom: {
                    fill: '#707070',
                    font:widjetValueText,
                    padding: 8,
                    rotate: {
                        degrees: 315
                    },
                    renderer: function(v) { return v; }
                },
                axisLabelLeft: {
                    fill: '#707070',
                    font: widjetValueText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisTitleTop: {
                    font: widjetLabelText,
                    fill: '#707070'
                },
                axisTitleRight: {
                    font: widjetLabelText,
                    fill: '#707070',
                    rotate: {
                        x:0, y:0,
                        degrees: 270
                    }
                },
                axisTitleBottom: {
                    font: widjetLabelText,
                    fill: '#707070'
                },
                axisTitleLeft: {
                    font: widjetLabelText,
                    fill: '#707070',
                    rotate: {
                        x:0, y:0,
                        degrees: 270
                    }
                }
            }
            , config)]);
    }
});/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.comments.Comments");

Ext.apply(xcp.Strings.widget.comments.Comments, {
    commentsTitleSingular: "Comment",
    commentsTitlePlural: "Comments",
    commentText_n: "{0} Comment",
    commentsText_n: "{0} Comments",
    loadingMsg: "Loading comments ...",
    errorLoadingCommentsMsg: "Error loading comments",
    noCommentsMsg: "There are no comments for this item",
    creationDateFormat: "M j Y, g:i a",
    commentHeaderFormat: "{0} on {1}",
    addCommentLabel: "Add a comment",
    refreshCommentLabel: "Refresh comments",
    addCommentFormLabel: "New comment",
    postBtnLabel: "Post",
    cancelBtnLabel: "Cancel",
    saveBtnLabel: "Save",
    ReplyText_Noun: "Reply",
    ReplyText_Verb: "Reply",
    repliesText: "Replies",
    replyText_n: "{0} Reply",
    repliesText_n: "{0} Replies",
    editText: "Edit",
    deleteText: "Delete",
    replyLabelFormat: "Reply to {0}",
    deleteCommentConfirmationTitle: "Delete Comment?",
    deleteCommentConfirmationPrompt1: "Deleting this comment will also delete its replies.  Are you sure you want to do this?",
    deleteCommentConfirmationPrompt2: "Deleting this comment will also delete its replies and the comment marker.  Are you sure you want to do this?",
    deleteCommentSuccessNotificationTemplate:  "The comment has been deleted",
    deleteCommentErrorTemplate: "An error occurred while deleting this comment. Please try again.",
    deleteCommentText: "Delete"
});


/* xcp_comments/content/xcp/widget/comments/Comments.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.comments.Comments
 * @extends Ext.tree.Panel
 * Tree panel based widget for displaying comments
 * @xtype xcp_comments
 */
(function() {
    function defer(func, millis, thisWidgetScope) {
        var args = Ext.Array.slice(arguments, 0);
        args[0] = function() {
            // Check whether the comment widget has already been destroyed before dispatching the delayed call.
            // this can happen in unit tests where the widget was destroyed before it is been fully laid out.
            // or when a user quickly switched to another page.
            if (!thisWidgetScope.destroying && !thisWidgetScope.isDestroyed) {
                func.apply(thisWidgetScope, arguments);
            }
        };
        Ext.defer.apply(this, args);
    }

//  Test whether CKEDITOR is defined at global scope
    function hasCK() {
        return typeof(CKEDITOR) != 'undefined';
    }

    Ext.require([
        'Ext.tree.*',
        'Ext.data.*',
        'Ext.window.MessageBox'
    ]);

    NodeMouseoverPlugin =
        Ext.extend(Object, {
            init: function(tree) {
                if (tree.designMode)
                    return;
                if (!tree.rendered) {
                    tree.on('render', function() {
                        this.init(tree)
                    }, this);
                    return;
                }
                this.tree = tree;
                tree.body.on('mouseover', this.onTreeMouseover, this, {delegate: 'div.x-grid-cell-inner'});
                tree.body.on('mouseout', this.onTreeMouseout, this, {delegate: 'div.x-grid-cell-inner'});
            },

            onTreeMouseover: function(e, t) {
                //var nodeEl = Ext.fly(t).up('div.x-tree-node-el');
                var nodeEl = Ext.get(t);
                this.tree.fireEvent('mouseover', nodeEl, e);
            },

            onTreeMouseout: function(e, t) {
                //var nodeEl = Ext.fly(t).up('div.x-tree-node-el');
                var nodeEl = Ext.get(t);
                this.tree.fireEvent('mouseout', nodeEl, e);
            }
        });

//  Localized strings referenced in this file
    var widgetStrings = xcp.Strings.widget.comments.Comments;

//  Remember whether comments widget on a visited page was expanded or not
    var wasExpanded = {};

///////////////////////////////////////////////////////////////////////////////////////////
//   Comments panel
///////////////////////////////////////////////////////////////////////////////////////////

    var commentModel = 'xcp.data.Comment';

    Ext.define('xcp.widget.comments.Comments',
        {
            extend: 'Ext.tree.Panel',
            plugins: new NodeMouseoverPlugin(),
            alias: 'widget.xcp_comments',

            /**
             * @cfg {String} Repository object id of object with comments.  If undefined and running
             * in xCP runtime, defaults to xcp.navigationManager.currentNavigationContext.objectId.
             */
            commentsParentId: undefined,

            /**
             * @cfg {Array} An array of comment items.  If undefined and running in xCP runtime, a
             * service call will be made to obtain comments on object associated with current page.
             */
            data:
            {   total: 2,
                items: [1,2]
            },

            constructor: function(config) {
                function hasExpression() {
                    if (config.plugins) {
                        for (var i = 0; i < config.plugins.length; i++) {
                            if (config.plugins[i].expression) {
                                if (config.plugins[i].expression[0].events) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                }

                var me = this;
                config = config || {};
                me.runtime = Ext.isDefined(xcp.navigationManager);

                if (me.runtime) {
                    // if the widget has an expression then we can not make a reliable guess for the commentsParentId.
                    // Carl can add a comment widget to Task pages, results pages etc.. and the heuristic of getting ID from anything
                    // other than the expression can throw an error, or erroneously show comments for a container object (such as folder) instead of the
                    // the selected row as specified by Carl.
                    if (!hasExpression()) {
                        if (config.pageContextID)
                            var pageContext = xcp.core.PageContextManager.get(config.pageContextID);
                        if (pageContext)
                            config.commentsParentId = pageContext.getObjectId();
                        else
                            config.commentsParentId = xcp.navigationManager.currentNavigationContext.objectId;
                    }
                }

                this.setConfig(config);
                this.callParent(arguments);

                this.initTreeActionListeners();
            },

            initComponent: function() {
                this.callParent(arguments);

                //Load comments,stats
                //also upates comment widget title with parent object Name.
                this.loadCommentsAndStats(false);
            },

            setObjectId : function(value) {
                if (value && value.length != 0) {
                    if (this.commentsParentId != value) {
                        this.commentsParentId = value;
                        this.loadCommentsAndStats(true); //force load comments.
                    }
                }
            },

            formLoaded: function(model, form) {
                //there are 2 entries that could enter this method, see form.js
                //but once this callback is invoked, we are pretty much sure that form is loaded to use.
                //however, we need to obtain the model again, because another entry doesn't set the model for us
                var model = this.up('xcp_form').getModel("");
                if (model) {
                    var objectId = model.get("id");
                    if (objectId == this.commentsParentId) {
                        this.objName = model.get("object_name");
                        if (this.objName)
                        //here, we will use the cached counts variable to save one network trip to get the comment count
                            this.updateTitle(this.counts);
                    }
                }
            },

            fetchObjectName: function() {
                // get the primary model; calls your provided callback
                var formModel = xcp.widget.form.Form.getFormModel2(this, this.formLoaded, this);
                return formModel ? true : false;
            },

            loadCommentsAndStats : function(force) {
                if (force)
                    unmaskBody.call(this);

                var root = this.store.getRootNode();
                if (force || (!root && !this.collapsed)) {
                    defer(this.loadComments, 1, this);
                }

                //Get comments stats asyncronously.
                if (this.commentsParentId) {
                    this.getCommentsStats(); //Gets the comments read and unread count.
                    //we only use the count number obtained from getCommentStats and update title when the widget is in collapsed state.
                    //if the widget is expanded, we will manually count the unread number because it's more accurate
//                    if(this.collapsed) {
//                        this.updateTitle(this.counts);
//                    }
                }
                else {
                    if (this.runtime)
                        return;
                    var total = (this.data) ? this.data.items.length : 2;
                    //  Simulate asynchronous service call here
                    defer(this.updateTitle, 300, this, [
                        {total: total, unread: 0}
                    ]);
                }
                if (this.runtime)
                    this.subscribeToExternalEvents();
            },

            //  Load comments from server and initialize tree store with results.
            // Also shows a loading mask while waiting for response from server.
            loadComments: function() {
                var proxyConfig = {reader: {type: 'json', root: 'items'}};
                if (this.commentsParentId) {
                    proxyConfig.type = 'rest';  // $NON-NLS-1$
                    proxyConfig.url = /* GET */ Ext.String.format('application/comments/{0}', this.commentsParentId); // $NON-NLS-1$
                }
                else if (!this.runtime && this.data) {
                    proxyConfig.type = 'memory'; // $NON-NLS-1$
                    proxyConfig.data = this.data;
                }
                else
                    return;

                var serviceDataStore = new Ext.data.Store(
                    {
                        model: commentModel,
                        proxy: proxyConfig
                    });

                var mask = new Ext.LoadMask(this, {msg: widgetStrings.loadingMsg});

                function onServiceDataStoreLoaded(records, successful, operation, options) {
                    if (mask.rendered) {
                        mask.hide();
                    }
                    mask.destroy();
                    mask = undefined;
                    if (successful) {
                        var data = serviceDataStore.proxy.reader.rawData;
                        if (data && data.items)
                            this.store.setRootNode(data);
                        if (!data || !data.items || data.items.length == 0)
                            maskBody.call(this, widgetStrings.noCommentsMsg, 'xcp-mask-info');  //  Hides spinning icon and changes bgcolor
                        //this.registerNavigationComplete();
                        //we don't need to markread explicitly now because we do that on the server side when we retrieve comment thread.
                        //also, there is problem to send markread ajax request during page navigation.

                        //here, as soon as we got the comment data, we count and update the count title
                        this.counts = this.countComments();
                        this.updateTitle(this.counts);
                    }
                    else
                        maskBody.call(this, widgetStrings.errorLoadingCommentsMsg, 'xcp-mask-error');  //  Hides spinning icon and changes bgcolor
                }

                serviceDataStore.on('load', onServiceDataStoreLoaded, this);
                if (this.rendered) {
                    mask.show();
                }

                var proxyType = serviceDataStore.getProxy().type;
                if (proxyType == 'rest')  // $NON-NLS-1$
                    serviceDataStore.load();
                else if (proxyType == 'memory') { // $NON-NLS-1$
                    if (!this.runtime)
                        serviceDataStore.load();
                    else
                        Ext.Function.defer(serviceDataStore.load, 1000, serviceDataStore);  //  Simulate asynchronous service call here
                }
            },

            //Updates the comments widget title with comments parent object name.
            updateTitle: function(counts) {

                var title = counts.total + '&nbsp;';
                var commentsTitleFormat = counts.total != 1 ? widgetStrings.commentsText_n :
                    widgetStrings.commentText_n;
                if (!counts.unread || counts.unread == 0) {
                    title = Ext.String.format(commentsTitleFormat, title);
                }
                else {
                    title += '(' + counts.unread + ')';
                    title = Ext.String.format(commentsTitleFormat, title);
                }

                // XCPECM-407 design mode should include the filename
                if (this.designMode && this.showItemNameInTitle) {
                    title += '&nbsp;-&nbsp;' + "filename.doc";
                    this.setTitle(title);
                }
                else {
                    if(!this.showItemNameInTitle)
                        this.setTitle(title);
                    else {
                        if (!this.objName) {
                            if (!this.fetchObjectName()) {
                                //formModel not found
                                this.setTitle(title);
                            }
                        } else {
                            title += '&nbsp;-&nbsp;' + this.objName;
                            this.setTitle(title);
                        }
                    }
                }
            },


            getCommentsStats : function() {
                Ext.Ajax.request(
                    {
                        method: 'GET', url: Ext.String.format('application/comments/{0}/stat', this.commentsParentId),
                        scope: this,

                        success: function(response, options) {
                            //  {isEnabled: true, annotationCount: 18, commentWidgetUnreadCount: 2, commentWidgetCount: 2}
                            var result = Ext.JSON.decode(response.responseText);

                            this.addCommentBtn.setDisabled(!result.canComment || this.designMode);
                            if (!result.canComment) {
                                var viewEl = this.getView().getEl();
                                if (viewEl)
                                    viewEl.addCls("xcp-comment-tree-hide-btn");
                                else {
                                    this.getView().on("afterrender", function(view) {
                                        view.getEl().addCls("xcp-comment-tree-hide-btn");
                                    }, this, {single: true});
                                }
                            }

                            this.counts =
                            {
                                total: result.annotationCount + result.commentWidgetCount,
                                unread: result.commentWidgetUnreadCount + result.annotationUnreadCount
                            };
 
                            if(this.collapsed) {
                                this.updateTitle(this.counts);
                                }
                        },

                        failure: function(response, options) {
                            Ext.MessageBox.alert('Server Error', response.responseText);
                        }
                    });
            },

            setConfig : function(config) {
                var store = config.store;
                if (!store) {
                    store = Ext.create('Ext.data.TreeStore',
                        {
                            model: commentModel,
                            proxy: {type: 'memory', reader: {type: 'json'}},
                            setRootNode: storeSetRootNode
                        });
                }

                //Make sure  NodeMouseoverPlugin get added to plug-ins list.
                if (config.plugins) {
                    if (Ext.isArray(config.plugins))
                        config.plugins.push(new NodeMouseoverPlugin())
                    else
                    if (Ext.isObject(config.plugins))
                        config.plugins = [config.plugins, new NodeMouseoverPlugin()]
                }

                this.addCommentBtn = new Ext.button.Button({
                    //cls: 'toolbar-btn',
                    height:26,
                    iconCls: 'xcp-comment-tree-add-comment',
                    disabled: true,
                    text: widgetStrings.addCommentLabel,
                    handler: Ext.bind(this.onAddComment, this)
                });

                Ext.applyIf(config,
                    {
                        title: widgetStrings.commentsTitlePlural,
                        designMode: false,
                        store: store,
                        rootVisible: false,
                        collapsed: false,
                        resizable: true,
                        resizeHandles: 'se',
                        collapsible: true,
                        useArrows: true,
                        folderSort: false,
                        frame: false,
                        frameHeader: false,
                        cls: 'xcp-comment-tree',
                        height: 250,
                        hideHeaders: true,
                        columns: [
                            {
                                dataIndex: 'commentId',
                                scope: config.scope,
                                flex: 1,
                                sortable: false,
                                xtype: 'xcp_commentcolumn'
                            }
                        ],
                        dockedItems: [
                            {
                                xtype: 'toolbar',
                                items: [this.addCommentBtn]
                            }
                        ],
                        overCls: 'xcp-comment-tree-over-grid-row',
                        viewConfig:
                        {
                            trackOver: true,
                            overItemCls: 'xcp-comment-tree-over-item'
                        }
                    });

                //  Override config.collapsed if we have already visited this page in the current browser session
                var expanded = getWasExpanded();
                if (typeof(expanded) == 'boolean')
                    config.collapsed = !expanded;

                if (config.collapsed)
                    this.collapsed = true;
                else
                    this.collapsed = false;
            },

            initTreeActionListeners : function() {
                this.registeredNavigationComplete = false;
                this.commentActionsEnabled = true;

                if (this.collapsed) {
                    function beforeexpand(p, animate, eOpts) {
                        this.loadComments(this);
                        this.doLayout();
                        this.un('beforeexpand', beforeexpand, this);
                    }

                    this.on('beforeexpand', beforeexpand, this);
                }

                this.on('collapse', this.onCollapse, this);
                this.on('expand', this.onExpand, this);
                this.on('beforeexpand', this.onBeforeExpand, this);
                this.on('beforeitemdblclick', this.onBeforeItemDblClick, this);
                this.on('beforeitemcollapse', this.onBeforeItemCollapse, this);
                this.on('mouseover', this.onMouseOverCommentCell, this);
                this.on('mouseout', this.onMouseOutCommentCell, this);

                var view = this.getView();
                view.on('itemadd', this.onTreeItemAdd, this);
                view.on('itemclick', this.onTreeItemClick, this);
            },

            registerNavigationComplete: function() {
                if (Ext.isDefined(xcp.navigationManager) && !this.registeredNavigationComplete) {
                    this.registeredNavigationComplete = true;
                    var scope = {commentsParentId: this.commentsParentId};
                    xcp.navigationManager.on('navigationcomplete', onNavigationComplete, scope);
                }
            },

            onBeforeExpand: function(panel, animate, options) {

            },

            onCollapse: function(panel, options) {
                setWasExpanded(false);
            },

            onExpand: function(panel, options) {
                setWasExpanded(true);
            },

            onBeforeItemExpand: function(node, options) {
                //  Prevent user from expanding nodes if they are in the midst of editing or creating a new comment
                return this.commentActionsEnabled;
            },

            onBeforeItemCollapse: function(node, options) {
                //  Prevent user from collapsing nodes if they are in the midst of editing or creating a new comment
                return this.commentActionsEnabled;
            },

            onBeforeItemDblClick: function(view, record, item, index, event, options) {
                //  Prevent user from expanding or collapsing nodes via doubleclick if they are in the midst of editing or creating a new comment
                return this.commentActionsEnabled;
            },

            onMouseOverCommentCell: function(node, e) {
                //we don't allow showing action link when we are in editing mode
                /*if( !this.commentActionsEnabled)
                 return;*/
                var actionBar = node.down("div.comment-footer-action");
                if (actionBar) {
                    actionBar.setStyle("display", "block");
                    if (!this.commentActionsEnabled)
                        actionBar.addCls("disable-comment-actions");
                }
            },

            onMouseOutCommentCell: function(node, e) {
                //var actionBar = node.down("div.comment-footer");
                var actionBar = node.down("div.comment-footer-action");
                if (actionBar)
                    actionBar.setStyle("display", "none");
            },

            enableCommentActions: function(status) {
                //  Update state of tree that indicates whether comment actions are enabled.
                //  This state is used by the above event handlers to prevent undesirable
                //  behavior while composing, editing, or deleting a comment.
                this.commentActionsEnabled = status;

                //  Add or remove css class to tree in order to control rendering of various elements.
                //  Currently, these elements include the comment-action-img and comment-action-text spans
                //  and the tree node expander img tags.  Adding the class causes the span elements to
                //  be re-rendered in a lightened state to indicate a disablement of the associated actions.
                //  Adding the class to the node exander img tags suppresses the default hover behavior.
                var cls = 'disable-comment-actions';
                if (status)
                    this.removeCls(cls);
                else
                    this.addCls(cls);
            },

            countComments: function() {
                var total = 0;
                var unread = 0;
                var root = this.getStore().getRootNode();

                function accumulateCounts(node) {
                    var commentId = node.get('commentId');
                    if (!Ext.isEmpty(commentId) && commentId != 'new' && commentId != 'dummy')  // $NON-NLS-1$  $NON-NLS-2$
                    {
                        total += 1;
                        if (node.get('unread'))
                            unread += 1;
                    }

                    if (node.childNodes && node.childNodes.length > 0) {
                        for (var i = 0; i < node.childNodes.length; i++)
                            accumulateCounts(node.childNodes[i]);
                    }
                }

                accumulateCounts(root);
                return {total: total, unread: unread};
            },

            onTreeItemClick : function(view, record, el, index, evt, eOpts) {
                var target = evt.getTarget();
                var targetEl = Ext.get(target);
                var commentBtn = targetEl.findParent('.comment-action', 5, true);
                if (!commentBtn) {
                    var annotationEle = targetEl.findParent('.comment-marker', 5, true); //what's the right depth
                    if (!annotationEle)
                        return true;

                    var topContainer = Ext.getCmp("_topPageContainer");
                    if (topContainer.down("xcp_viewer")) {
                        var commentId = record.get('commentId');
                        var documentId = this.commentsParentId;

                        if (xcp.event && xcp.event.EventBus) {
                            var commentViewedEvent = new RM.event.CommentViewedEvent;
                            commentViewedEvent.commentId = commentId;
                            commentViewedEvent.documentId = documentId;
                            xcp.event.EventBus.publish(RM.event.CommentViewedEvent.COMMENT_VIEWED_EVENT, commentViewedEvent);
                        }
                    }
                    return true;
                }

                //  Suppress default event handling while composing, editing, or deleting a comment
                if (!this.commentActionsEnabled)
                    return false;

                this.enableCommentActions(false);

                var commentId = record.get('commentId');
                var commentNumber = record.get('commentNumber');
                var documentId = this.commentsParentId;

                if (commentBtn.hasCls('comment-reply'))
                    this.onReplyComment(documentId, commentId, commentNumber);
                else if (commentBtn.hasCls('comment-edit'))
                    this.onEditComment(documentId, commentId, commentNumber);
                else if (commentBtn.hasCls('comment-delete'))
                    this.onDeleteComment(documentId, commentId, commentNumber);

                return false;
            },
            hideToolbarButtons : function() {
                this.getDockedItems('toolbar')[0].items.items[0].hide();
            },
            showToolbarButtons : function() {
                this.getDockedItems('toolbar')[0].items.items[0].show();
            },
            removeCKEditor : function() {
                if (this.ckeditor) {
                    this.ckeditor.destroy();
                }

                this.showToolbarButtons();
            },
            onAddComment: function() {
                if (hasCK()) {
                    this.hideToolbarButtons();
                }
                unmaskBody.call(this);

                //dealing with empty tree problem as in the delete case
                if (this.getStore().getRootNode().childNodes.length == 0) {
                    var data = {"total":0, "items":[]};
                    this.store.setRootNode(data);
                }

                var rootNode = this.getStore().getRootNode();
                rootNode.appendChild({
                    commentId: 'new',
                    leaf: true,
                    expandable: false
                });
            },

            onRefreshComment: function() {
                /*if(hasCK()) {
                 this.hideToolbarButtons();
                 }*/

                var annotationChangedEvent = new xcp.widget.comments.event.AnnotationChangedEvent;
                annotationChangedEvent.annotationId = 0;
                annotationChangedEvent.documentId = 0;
                xcp.event.EventBus.publish(xcp.widget.comments.event.AnnotationChangedEvent.ANNOTATION_CHANGE_EVENT, annotationChangedEvent);

                //this.refreshComments();
                //unmaskBody.call(this);
            },

            refreshComments: function() {
                defer(this.loadComments, 1, this);
            },

            onReplyComment: function(documentId, replyToCommentId, commentNumber) {
                if (hasCK()) {
                    this.hideToolbarButtons();
                }

                var parentNode = this.getStore().getNodeById(replyToCommentId);
                var annotationReply = this.isAnnotation(replyToCommentId) ? 1 : 0;
                parentNode.appendChild(
                    {
                        commentId: 'new',
                        leaf: true,
                        expandable: false,
                        documentId: documentId,
                        annotationReply: annotationReply,
                        replyTo: replyToCommentId
                    });
            },

            onEditComment: function(documentId, commentId, commentNumber) {
                if (hasCK()) {
                    this.hideToolbarButtons();
                }
                var node = this.getStore().getNodeById(commentId);
                var commentRowEl = this.getView().getNode(node);

                // Replace the read only comment view with the editor
                var commentBodyEl = Ext.get(commentRowEl).down('.comment-body');
                commentBodyEl.remove();
                var commentFooterEl = Ext.get(commentRowEl).down('.comment-footer');
                commentFooterEl.remove();
                var commenthr = Ext.get(commentRowEl).down('.comment-hr');
                var commentForm = this.addCommentForm(node, commentRowEl);
                if (commenthr)
                    commenthr.insertAfter(commentForm.getEl());
            },

            removeComment : function(commentId) {
                var node = this.getStore().getNodeById(commentId);
                node.remove();
            },

            onDeleteComment: function(documentId, commentId, commentNumber) {
                var node = this.getStore().getNodeById(commentId);

                function confirmationCallback(reply) {
                    if (reply == 'yes') {
                        // For testing the UI without the service support
                        if (!this.commentsParentId) {
                            this.removeComment(commentId);
                            this.updateTitle(this.countComments());
                            this.enableCommentActions(true);
                            return;
                        }

                        Ext.Ajax.request({
                            method: 'DELETE', url: Ext.String.format('application/comments/{0}/{1}/{2}', this.commentsParentId, commentId, commentNumber),
                            scope: this,

                            success: function(response, options) {
                                var annotation = this.isAnnotation(commentId);
                                this.removeComment(commentId);
                                this.updateTitle(this.countComments());
                                this.enableCommentActions(true);

                                var topContainer = Ext.getCmp("_topPageContainer");
                                if (topContainer.down("xcp_viewer")) {
                                    if (annotation && xcp.event && xcp.event.EventBus) {
                                        var commentDeletedEvent = new RM.event.CommentDeletedEvent();
                                        commentDeletedEvent.commentId = commentId;
                                        commentDeletedEvent.documentId = documentId;
                                        xcp.event.EventBus.publish(RM.event.CommentDeletedEvent.COMMENT_DELETE_EVENT, commentDeletedEvent);
                                    }
                                }
                            },

                            failure: function(response, options) {
                                Ext.MessageBox.alert('Server Error', response.responseText);
                                this.enableCommentActions(true);
                            }
                        });
                    }
                    else {
                        this.enableCommentActions(true);
                    }
                    // XCPECM-901 Make sure we have the correct comment count
                    //there is case the dummy node is gone mysterious after remove treenode,
                    //in that case tree itemadd event won't fire. This is to reconstruct the tree
                    //also we don't want to refetch everything and reload, too costly.
                    var root = this.store.getRootNode();
                    if (root.childNodes.length == 0) {
                        var data = {"total":0, "items":[]};
                        this.store.setRootNode(data);
                    }
                }

                var prompt = widgetStrings.deleteCommentConfirmationPrompt1;
                var parentCommentId = node.get('replyTo');
                if (parentCommentId && parentCommentId.length == 0)
                    parentCommentId = null;
                var commentNumber = node.get('commentNumber');
                if (!commentNumber || commentNumber.length == 0)
                    commentNumber = 0;

                if (!parentCommentId && commentNumber > 0)
                    prompt = widgetStrings.deleteCommentConfirmationPrompt2;

                Ext.Msg.show(
                    {
                        title:  widgetStrings.deleteCommentConfirmationTitle,
                        buttons: Ext.MessageBox.YESNO,
                        fn: confirmationCallback,
                        icon: Ext.MessageBox.WARNING,
                        msg: prompt,
                        scope: this
                    });
            },

            onTreeItemAdd: function(records, index, nodes, eOpts) {
                var record = records[0];
                var commentId = record.get('commentId');
                if (commentId === 'new') {  // $NON-NLS-1$
                    var commentRowEl = nodes[0];
                    this.addCommentForm(record, commentRowEl);
                }
            },

            addCommentForm : function(record, commentRowEl) {

                this.enableCommentActions(false);

                var commentCellEl = commentRowEl.firstChild;
                Ext.get(commentCellEl).addCls('xcp-comment-form-ct');

                // The comment form will be rendered to the cell inner div element
                var renderToNode = commentCellEl.firstChild;

                var depth = record.getDepth();
                var marginLeft = depth * 16;

                var self = this;

                var commentForm = new xcp.widget.comments.CommentForm({
                    owner : self,
                    renderTo: renderToNode,
                    commentsParentId: this.commentsParentId,
                    record: record,
                    style: {marginLeft: marginLeft + "px"}
                });

                commentForm.on('postcommentsuccess', this.onPostCommentSuccess, this);
                commentForm.on('cancelcomment', this.onCancelComment, this);
                commentForm.on('editorResize', this.onEditorResize, this);
                commentForm.on('contentChanged', this.onContentChanged, this);

                // Set the view's width to eliminate the horizontal scroll bar
//        var viewEl = this.getView().getEl();
//        viewEl.setWidth (this.getWidth () + 20);

                // Fix the scrollbar position and set focus
                // ScrollIntoView doesn't work properly without
                // a delay.
//        defer(function() {
                var viewEl = this.getView().getEl();
                commentForm.getEl().scrollIntoView(viewEl);
                commentForm.commentEditor.focus();
//        }, 250, this);

                return commentForm;
            },

            onPostCommentSuccess : function(comment, editMode) {
                if (hasCK()) {
                    this.removeCKEditor();
                }
                var store = this.getStore();
                var node;
                if (editMode)
                    node = store.getNodeById(comment.commentId);
                else {
                    node = store.getNodeById('new');  // $NON-NLS-1$
                    store.tree.unregisterNode(node);
                }
                node.beginEdit();
                node.set('commentContent', comment.commentContent);
                if (!editMode) {
                    node.set('leaf', false);  // $NON-NLS-1$
                    node.set('creationDate', comment.creationDate);
                    node.set('creatorName', comment.creatorName);
                    node.set('commentId', comment.commentId);
                    node.set('canDelete', comment.canDelete);
                    node.set('canEdit', comment.canEdit);
                    node.expand();
                    store.tree.registerNode(node);
                }
                node.endEdit();

                this.getDockedItems('toolbar')[0].show();
                this.updateTitle(this.countComments());
                this.enableCommentActions(true);

                //should we differenciate reply and edit cases here?
                //annotation
                //if(comment.commentNumber > 0 && xcp.event && xcp.event.EventBus) {
                var topContainer = Ext.getCmp("_topPageContainer");
                if (topContainer.down("xcp_viewer")) {
                    if (this.isAnnotation(comment.commentId) && xcp.event && xcp.event.EventBus) {
                        if (editMode) {
                            var commentUpdatedEvent = new RM.event.CommentUpdatedEvent();
                            commentUpdatedEvent.commentId = comment.commentId;
                            commentUpdatedEvent.documentId = this.commentsParentId;
                            xcp.event.EventBus.publish(RM.event.CommentUpdatedEvent.COMMENT_UPDATE_EVENT, commentUpdatedEvent);
                        }
                        else {
                            var commentCreatedEvent = new RM.event.CommentCreatedEvent();
                            commentCreatedEvent.commentId = comment.commentId;
                            commentCreatedEvent.documentId = this.commentsParentId;
                            xcp.event.EventBus.publish(RM.event.CommentCreatedEvent.COMMENT_ADD_EVENT, commentCreatedEvent);
                        }
                    }
                }

            },

            onCancelComment: function(commentNode) {
                if (hasCK()) {
                    this.removeCKEditor();
                }
                var store = this.getStore();
                var view = this.getView();
                if (commentNode.get("commentId") == "new")  // $NON-NLS-2$
                    commentNode.remove();
                else
                    view.onUpdate(store, commentNode);
                this.getDockedItems('toolbar')[0].show();
                // XCPECM-901 Make sure we have the correct comment count
                //this.loadCommentsAndStats(true);
                this.enableCommentActions(true);
            },

            onEditorResize: function(commentForm) {
                var viewEl = this.getView().getEl();
                commentForm.submitBtn.getEl().scrollIntoView(viewEl);
            },

            onContentChanged: function(commentForm) {
                if (commentForm.owner.ckeditor.checkDirty())
                    commentForm.submitBtn.setDisabled(false);
                else
                    commentForm.submitBtn.setDisabled(true);
            },

            isAnnotation: function(commentId) {
                var parentNode = this.getStore().getNodeById(commentId);

                while (parentNode && parentNode.getDepth() > 0) {
                    if (parentNode.get("commentNumber") > 0)
                        return true;
                    parentNode = parentNode.parentNode;
                }
                return false;
            },

            onAnnotationUpdated: function(eventName, eventData) {
                if (
                    eventData.documentId != this.commentsParentId) {
                    return;
                }
                this.refreshComments();
                unmaskBody.call(this);
            },

            onAnnotationCreated: function(eventName, eventData) {
                if (
                    eventData.documentId != this.commentsParentId) {
                    return;
                }

                var count = this.countComments();
                count.total = count.total + 1;
                count.unread = count.unread + 1;
                this.updateTitle(count);
                this.refreshComments();
                unmaskBody.call(this);
            },

            onAnnotationDeleted: function(eventName, eventData) {
                if (
                    eventData.documentId != this.commentsParentId) {
                    return;
                }
                var count = this.countComments();
                count.total = count.total - 1;
                this.updateTitle(count);
                this.refreshComments();
                unmaskBody.call(this);
            },

            //new version of object created
            onPageModified: function(eventName, eventData) {
                this.commentsParentId = eventData;
                this.refreshComments();
                unmaskBody.call(this);
            },

            onObjectDeleted: function(eventName, eventData) {
                if (this.commentsParentId == eventData) {
                    //we need to do something here, either we navigate to a new page, or to the parent page
                }
            },

            subscribeToExternalEvents: function() {
                if (xcp && xcp.event) {
                    var eventBus = xcp.event.EventBus;
                    if (eventBus) {
                        eventBus.subscribe(xcp.widget.comments.event.AnnotationCreatedEvent.ANNOTATION_CREATE_EVENT, this.onAnnotationCreated, this, null);
                        eventBus.subscribe(xcp.widget.comments.event.AnnotationDeletedEvent.ANNOTATION_DELETE_EVENT, this.onAnnotationDeleted, this, null);
                        eventBus.subscribe(xcp.widget.comments.event.AnnotationUpdatedEvent.ANNOTATION_UPDATE_EVENT, this.onAnnotationUpdated, this, null);
                        //we don't care the following two events for c18
                        //eventBus.subscribe(xcp.event.PageModEvent.NAME,  this.onPageModified, this, null);
                        //eventBus.subscribe(xcp.event.ItemDeleted.NAME,  this.onObjectDeleted, this, null);
                    }
                }
            }
        });

///////////////////////////////////////////////////////////////////////////////////////////
//   Comment model
///////////////////////////////////////////////////////////////////////////////////////////

    Ext.define(commentModel,
        {
            extend: 'Ext.data.Model',
            idProperty: 'commentId',
            fields:
                [
                    {name: 'commentNumber', type: 'int'},
                    {name: 'commentColor', type: 'string'},
                    {name: 'commentTitle', type: 'string'},
                    {name: 'replyTo', type: 'string'},
                    {name: 'commentContent', type: 'string'},
                    {name: 'commentId', type: 'string'},
                    {name: 'creatorLoginName', type: 'string'},
                    {name: 'creatorName', type: 'string'},
                    {name: 'creationDate', type: 'string'},
                    {name: 'unread', type: 'boolean'},
                    {name: 'canDelete', type: 'boolean'},
                    {name: 'canEdit', type: 'boolean'}
                ]
        });

///////////////////////////////////////////////////////////////////////////////////////////
//   Comment form (Comment editor container)
///////////////////////////////////////////////////////////////////////////////////////////

    var timer;

    Ext.define('xcp.widget.comments.CommentForm',
        {
            extend: 'Ext.form.Panel',
            cls: 'xcp-comment-form',
            border: false,
            //bodyPadding: 7
            buttonAlign: 'left',
            initComponent:function() {
                var me = this;

                this.editMode = false;
                this.replyMode = false;
                var labelText = '';
                var submitBtnLabel;
                var commentId = this.record.get("commentId");
                if (commentId != 'new') {  // $NON-NLS-1$
                    this.editMode = true;
                    submitBtnLabel = widgetStrings.saveBtnLabel;
                }
                else {
                    submitBtnLabel = widgetStrings.postBtnLabel;
                    if (Ext.isEmpty(this.record.get("replyTo")))
                        labelText = widgetStrings.addCommentFormLabel;
                    else {
                        this.replyMode = true;

                        var parentNode = this.record.parentNode;
                        var creatorName = parentNode.get('creatorName');
                        var creationDateStr = parentNode.get('creationDate');
                        var creationDate = new Date(Ext.Date.parse(creationDateStr, 'c'));
                        var formattedCreationDate = Ext.Date.format(creationDate, widgetStrings.creationDateFormat);
                        var commentHeaderText = Ext.String.format(widgetStrings.commentHeaderFormat, creatorName, formattedCreationDate);

                        labelText = Ext.String.format(widgetStrings.replyLabelFormat, commentHeaderText);
                    }
                }

                this.commentEditor = new Ext.form.field.TextArea({
                    fieldLabel: labelText,
                    name: 'commentContent',
                    labelAlign: 'top',
                    labelClsExtra: 'xcp-comment-tree-editor-label',
                    allowBlank: false,
                    enableKeyEvents: true,
                    grow: true,
                    fieldStyle: {
                        overflow: 'hidden'
                    }
                });

                me.items = [this.commentEditor];

                this.submitBtn = new Ext.button.Button({
                    text: submitBtnLabel,
                    formBind: true,
                    handler: Ext.bind(this.onPostComment, this)
                });

                this.submitBtn.setDisabled(true);

                var cancelBtn = new Ext.button.Button({
                    text: widgetStrings.cancelBtnLabel,
                    handler: Ext.bind(this.onCancel, this)
                });

                me.buttons = [this.submitBtn, cancelBtn];

                me.callParent(arguments);

                me.on('afterrender', function() {
                    // Stop bubbling the comment form events, so the tree selection model event handlers won't be
                    // invoked when interact with the comment form.
                    var commentFormDom = this.getEl().dom;
                    if (commentFormDom.addEventListener) {
                        commentFormDom.addEventListener('keydown', this.stopBubblingCommentFormEvent, false);
                        commentFormDom.addEventListener('keypress', this.stopBubblingCommentFormEvent, false);
                        commentFormDom.addEventListener('keyup', this.stopBubblingCommentFormEvent, false);
                        commentFormDom.addEventListener('mousedown', this.stopBubblingCommentFormEvent, false);
                    }
                    else {
                        // IE prior to IE9
                        commentFormDom.attachEvent('onkeydown', this.stopBubblingCommentFormEvent);
                        commentFormDom.attachEvent('onkeypress', this.stopBubblingCommentFormEvent);
                        commentFormDom.attachEvent('onkeyup', this.stopBubblingCommentFormEvent);
                        commentFormDom.attachEvent('onmousedown', this.stopBubblingCommentFormEvent);
                    }

                    this.commentEditor.on("autosize", function() {
                        this.fireEvent('editorResize', this);
                    }, this);

                    var cellInnerWidth = this.renderTo.clientWidth;
                    var indentWidth = this.record.getDepth() * 16/*image width*/ + 5 /* header margin*/;
                    var editorBorder = 2;
                    /* from textarea.x-form-field border: 1px style*/
                    var fudgeFactor = 18;
                    this.commentEditor.setWidth(cellInnerWidth - indentWidth - editorBorder - fudgeFactor);

                    this.commentEditor.setValue(this.record.get("commentContent"));

                    if (this.replyMode) {
                        var parentNode = this.record.parentNode;
                        var replyingToContent = parentNode.get("commentContent");
                        var labelEl = this.getEl().down('.xcp-comment-tree-editor-label');
                        var tip = Ext.create('Ext.tip.ToolTip', {
                            target: labelEl,
                            html: replyingToContent
                        });
                    }

                    if (hasCK()) {
                        this.getCKEditor = function() {
                            return this.owner.ckeditor;
                        }

                        var toolbarId = this.owner.getDockedItems('toolbar')[0].id;

                        var ckconfig =
                        {
                            height: this.commentEditor.getHeight(),
                            contentsCss: 'component/xcp-core/ckeditor/lib/ckeditor/skins/xcp/formats.css',
                            extraPlugins: 'autogrow',
                            removePlugins: 'maximize,resize,elementspath,menubutton,scayt',
                            skin: 'xcp',
                            toolbarCanCollapse: false,
                            startupFocus: true,
                            toolbar: [
                                ['Bold','Italic','Underline','Strike', 'BGColor'],
                                ['Cut','Copy','Paste','-','Undo','Redo','-'],
                                ['BulletedList','NumberedList','-','Outdent','Indent'],
                                ['Table', 'Link', 'HorizontalRule','SpecialChar']
                            ],
                            autoGrow_maxHeight: 0,
                            autoGrow_minHeight: this.commentEditor.getHeight(),
                            sharedSpaces:
                            {
                                top: toolbarId
                            }
                        };

                        // Avoid firing the event too often
                        function ckEditorContentChanged() {
                            if (timer)
                                return;

                            timer = setTimeout(function() {
                                timer = 0;
                                self.fireEvent('contentChanged', self);
                            }, 100);
                        }

                        //To fix XCPUIC-1054, XCPECM-220
                        if (xcp && xcp.ckeditorlanguage)
                            ckconfig.language = xcp.ckeditorlanguage;

                        var textareaId = this.commentEditor.inputEl.id;
                        var ckeditor = this.owner.ckeditor = CKEDITOR.replace(textareaId, ckconfig);

                        var self = this
                        ckeditor.on('instanceReady', function() {
                            //REDRAW CONTAINER
                            self.doLayout();
                            self.fireEvent('editorResize', self);
                        });

                        ckeditor.on('resize', function() {
                            //REDRAW
                            self.doLayout();
                            self.fireEvent('editorResize', self);
                        });

                        ckeditor.on('blur', function() {
                            var iframe = document.getElementById('cke_contents_' + self.commentEditor.inputEl.id);
                            if(iframe) {
                                if(iframe.classList)
                                    iframe.classList.remove("xcp_comment_editor_bkg_color");
                            }
                        });

                        ckeditor.on('focus', function() {
                            var iframe = document.getElementById('cke_contents_' + self.commentEditor.inputEl.id);
                            //it looks like IE doesn't work with classList, in that case, we will not render bk color
                           //bkcolor in IE doen't work well with table border color anyway
                           if(iframe) {
                                if(iframe.classList)
                                    iframe.classList.add("xcp_comment_editor_bkg_color");
                            }
                        });

                        ckeditor.on('saveSnapshot', function(e) {
                            ckEditorContentChanged();
                        });
                        //ckeditor.getCommand('Undo').on( 'afterUndo', function(e) { ckEditorContentChanged(); });
                        //ckeditor.getCommand('Redo').on( 'afterRedo', function(e) { ckEditorContentChanged(); });

                        ckeditor.on('afterCommandExec', function(event) {
                            if (event.data.command.canUndo !== false)
                                ckEditorContentChanged();
                        });

                        ckeditor.on('contentDom', function() {
                            ckeditor.document.on('keydown', function(event) {
                                if (!event.data.$.ctrlKey && !event.data.$.metaKey)
                                    ckEditorContentChanged();
                            });

                            // Firefox OK
                            ckeditor.document.on('drop', function() {
                                ckEditorContentChanged();
                            });
                            // IE OK
                            ckeditor.document.getBody().on('drop', function() {
                                ckEditorContentChanged();
                            });
                        });
                    }
                }, this, {single: true});
            },

            stopBubblingCommentFormEvent: function(event) {
                event = event.browserEvent || event;
                if (event.stopPropagation) {
                    event.stopPropagation();
                }
                else {
                    event.cancelBubble = true;
                }
                return true;
            },

            onPostComment: function() {
                var commentContent;

                if (hasCK()) {
                    commentContent = this.getCKEditor().getData();
                }
                else {
                    commentContent = this.commentEditor.getValue();
                }

                if (commentContent.length == 0)
                    return;

                // Remove this once RTE is hooked up
                //commentContent = Ext.String.htmlEncode(commentContent);

                // For testing the UI without the service support
                if (!this.commentsParentId) {
                    var comment = Ext.clone(this.record.data);
                    comment.commentContent = commentContent;
                    if (!this.editMode) {
                        var now = new Date();
                        comment.creationDate = Ext.Date.format(now, 'Y-m-d\\TH:i:s');
                        comment.creatorName = '';
                        comment.commentId = now.getTime();
                        comment.canEdit = true;
                        comment.canDelete = true;
                    }
                    this.fireEvent('postcommentsuccess', comment, this.editMode);
                    return;
                }

                var replyToCommentId = this.record.get("replyTo");
                var data = {commentContent:commentContent, replyTo:replyToCommentId };
                data.commentNumber = this.record.get("annotationReply");
                //the real value of commentNumber is not important, it only tell service code whether this is viewer topic or not

                if (this.editMode)
                    data.commentId = this.record.get("commentId");

                Ext.Ajax.request({
                    method: this.editMode ? 'PUT' : 'POST', url: Ext.String.format('application/comments/{0}', this.commentsParentId),
                    scope: this,

                    jsonData: data,
                    success: function(response) {
                        var responseText = response.responseText;
                        var comment = Ext.JSON.decode(responseText);
                        this.fireEvent('postcommentsuccess', comment, this.editMode)
                    },
                    feedbackContainer: this
                });
            },

            onCancel: function() {
                this.fireEvent('cancelcomment', this.record);
            }
        });

///////////////////////////////////////////////////////////////////////////////////////////
//   Comment column
///////////////////////////////////////////////////////////////////////////////////////////

    Ext.define('xcp.grid.column.CommentColumn',
        {
            extend: 'Ext.grid.column.Column',
            alias: 'widget.xcp_commentcolumn',

            initComponent: function() {
                this.renderer = function(value, metaData, record, rowIdx, colIdx, store, view) {
                    var commentId = record.get('commentId');

                    if (commentId == 'new' || commentId == 'dummy' || Ext.isEmpty(commentId))   // $NON-NLS-L$
                        return '';

                    var depth = record.getDepth();
                    var treePrefix = Ext.baseCSSPrefix + 'tree-';
                    var elbowPrefix = treePrefix + 'elbow-';
                    var expanderCls = treePrefix + 'expander';  // $NON-NLS-1$
                    var imgText = '<img src="{1}" class="{0}" />';
                    //for annotation number rendering
                    var commentNumber = record.get('commentNumber');
                    var commentColor = record.get('commentColor');
                    var headerSpans = [];

                    //headerSpans.push('<span>');
                    if (commentNumber != null && commentNumber > 0) {
                        var tpl = '<div class="comment-marker" style="background-color:{0}">' +
                            '<span class="comment-marker-icon"></span>' +
                            '<span class="comment-marker-num">{1}</span>' +
                            '</div>';

                        commentNumberSpan = Ext.String.format(tpl, commentColor, commentNumber);
                        headerSpans.push(commentNumberSpan);
                    }

                    var creatorName = record.get('creatorName');
                    var creationDateStr = record.get('creationDate');
                    var creationDate = new Date(Ext.Date.parse(creationDateStr, 'c'));
                    var formattedCreationDate = Ext.Date.format(creationDate, widgetStrings.creationDateFormat);
                    var commentHeaderText = Ext.String.format(widgetStrings.commentHeaderFormat, creatorName, formattedCreationDate);
                    var commentHeaderSpan = Ext.String.format('<span class="comment-header">{0}</span>', commentHeaderText);
                    headerSpans.push(commentHeaderSpan);
                    //headerSpans.push('</span>');
                    var commentHeader = headerSpans.join('');

                    var href = record.get('href');
                    var target = record.get('hrefTarget');
                    var unread = record.get('unread');
                    var cls = (unread) ? 'comment-unread' : undefined;

                    function formatComment(header, content, footer) {
                        var lpad = depth * 16 + 5;  // pixels;
                        var header_span_attributes = 'style="margin-left: 5px"';
                        var content_div_attributes = 'class="comment-body" style="margin-left: ' + lpad + 'px"';    // $NON-NLS-1$

                        if (!(content || footer)) {
                            //  Render just the header for collapsed nodes
                            return Ext.String.format('<span {0}>{1}</span>', header_span_attributes, header);
                        }

                        var renderDivider = false;
                        var recordExpanded = record.isExpanded();

                        //  Render divider unless this node is the last node to be rendered
                        //  The last node rendered will either be the last top level child node
                        //  or one of its descendants.
                        renderDivider = true;
                        if (!record.nextSibling && !record.firstChild) {
                            var parentNode = record.parentNode;
                            while (parentNode && parentNode.getDepth() > 1)
                                parentNode = parentNode.parentNode;
                            renderDivider = (parentNode && parentNode.nextSibling != null);
                        }

                        var footer_div_attributes = 'class="comment-footer" style="margin-left: ' + lpad + 'px"'; // $NON-NLS-L$
                        if (!renderDivider) {
                            //  Don't render the divider if this node it the last to be rendered and is expanded
                            if (content) {
                                return Ext.String.format('<span {0}>{1}</span><div {2} >{3}</div><div {4}>{5}</div>',
                                    header_span_attributes, header, content_div_attributes, content, footer_div_attributes, footer);
                            }
                            else
                                return Ext.String.format('<span {0}>{1}</span></div><div {2}>{3}</div>',
                                    header_span_attributes, header, footer_div_attributes, footer);
                        }

                        var hr_attributes = 'class="comment-hr" style="margin-left: ' + lpad + 'px; margin-right: 4px"';

                        if (content) {
                            return Ext.String.format('<span {0}>{1}</span><div {2} >{3}</div><div {4}>{5}</div><hr {6}/>',
                                header_span_attributes, header, content_div_attributes, content, footer_div_attributes, footer, hr_attributes);
                        }
                        else
                            return Ext.String.format('<span {0}>{1}</span><div {2}>{3}</div><hr {4}/>',
                                header_span_attributes, header, footer_div_attributes, footer, hr_attributes);
                    }

                    var buf = [];
                    var formattedComment = '';
                    var btnFormat = '<span class="comment-action comment-{0}"><span class="comment-action-img {0}"></span><span class="comment-action-text">{1}</span></span>';

                    while (record) {
                        if (!record.isRoot() || (record.isRoot() && view.rootVisible)) {
                            var imgcls = elbowPrefix;
                            if (record.getDepth() === depth) {
                                var content, footer = '';
                                var footerReplyCount;
                                var numReplies = 0;
                                var numUnread = 0;
                                if (record.firstChild) {
                                    var result = countReplies(record);
                                    numReplies = result.numReplies;
                                    numUnread = result.numUnread;
                                    var replyText = (numReplies == 1) ? widgetStrings.replyText_n : widgetStrings.repliesText_n;

                                    if (numUnread == 0) {
                                        if (numReplies != 0) {
                                            var footerReplyFormat = '<span class="comment-footer-reply">{0}</span>';
                                            var formatedReplyCount = Ext.String.format(footerReplyFormat, numReplies);
                                            footerReplyCount = Ext.String.format(replyText, formatedReplyCount);
                                        }
                                    }
                                    else {
                                        if (numReplies != 0) {
                                            var footerReplyFormat = '<span class="comment-footer-reply">{0} (<span class="comment-unread-count">{1}</span>)</span>';
                                            var formatedReplyCount = Ext.String.format(footerReplyFormat, numReplies, numUnread);
                                            footerReplyCount = Ext.String.format(replyText, formatedReplyCount);
                                        }
                                    }
                                }
                                var footerButtons = '';
                                if (record.isExpanded()) {
                                    content = record.get('commentContent');
                                    footerButtons = '';
                                    var sb = [];
                                    sb.push('<div class="comment-footer-action" style="display:none;float:right">');
                                    sb.push(Ext.String.format(btnFormat, 'reply', widgetStrings.ReplyText_Verb));    // $NON-NLS-1$
                                    if (record.get('canEdit'))
                                        sb.push(Ext.String.format(btnFormat, 'edit', widgetStrings.editText));     // $NON-NLS-1$
                                    if (record.get('canDelete'))
                                        sb.push(Ext.String.format(btnFormat, 'delete', widgetStrings.deleteText));  // $NON-NLS-1$
                                    sb.push('</div>');
                                    footerButtons = sb.join('');
                                }

                                if (footerReplyCount)
                                    footer += footerReplyCount;
                                else
                                    footer += '<span> </span>';
                                footer += footerButtons;

                                formattedComment = formatComment(commentHeader, content, footer);
                                imgcls += (record.isLast() ? 'end-plus ' : 'plus ') + expanderCls;   // $NON-NLS-2$
                            }
                            else {
                                imgcls += ((record.isLast() || record.getDepth() == 0) ? 'empty' : 'line');
                            }
                            buf.unshift(Ext.String.format(imgText, imgcls, Ext.BLANK_IMAGE_URL));
                        }
                        record = record.parentNode;
                    }

                    if (href)
                        formattedComment = Ext.String.format('<a href="{0}" target="{1}">{2}</a>', href, target, formattedComment);

                    if (cls)
                        metaData.tdCls += ' ' + cls;

                    return buf.join('') + formattedComment;
                };

                this.callParent(arguments);
            },

            defaultRenderer: function(value) {
                return value;
            }
        });

//events for widget communication
    Ext.define('xcp.widget.comments.event.AnnotationChangedEvent', {
        extend: 'xcp.event.ApplicationEvent',
        applicationEventType: 'xcpApp.annotation.changed',
        annotationId: '',
        documentId: '',
        statics:{
            ANNOTATION_CHANGE_EVENT: 'xcpApp.annotation.changed'
        }
    });


    Ext.define('xcp.widget.comments.event.AnnotationCreatedEvent', {
        extend: 'xcp.event.ApplicationEvent',
        applicationEventType: 'xcpApp.annotation.created',
        annotationId: '',
        documentId: '',
        statics:{
            ANNOTATION_CREATE_EVENT: 'xcpApp.annotation.created'
        }
    });

    Ext.define('xcp.widget.comments.event.AnnotationUpdatedEvent', {
        extend: 'xcp.event.ApplicationEvent',
        applicationEventType: 'xcpApp.annotation.updated',
        annotationId: '',
        documentId: '',
        statics:{
            ANNOTATION_UPDATE_EVENT: 'xcpApp.annotation.updated'
        }
    });

    Ext.define('xcp.widget.comments.event.AnnotationDeletedEvent', {
        extend: 'xcp.event.ApplicationEvent',
        applicationEventType: 'xcpApp.annotation.deleted',
        annotationId: '',
        documentId: '',
        statics:{
            ANNOTATION_DELETE_EVENT: 'xcpApp.annotation.deleted'
        }
    });


///////////////////////////////////////////////////////////////////////////////////////////
//   Private methods and utilities
///////////////////////////////////////////////////////////////////////////////////////////

//  Mask tree panel body
    function maskBody(msg, cls) {
        var el = this.getEl();
        if (el.dom) {
            el.down('.x-panel-body').mask(msg, cls);
        }
    }

//  Unmask tree panel body
    function unmaskBody(msg, cls) {
        var el = this.getEl();
        if (el.dom) {
            el.down('.x-panel-body').unmask();
        }
    }

    function getPageURL() {
        return ((Ext.isDefined(xcp.navigationManager)) ? xcp.navigationManager.getPageURL() : window.location.href);
    }

    function getWasExpanded() {
        return wasExpanded[getPageURL()];
    }

    function setWasExpanded(state) {
        wasExpanded[getPageURL()] = state;
    }

//  Generic function for building tree store data from an array of nodes.
//  A node's parent is specified by its parentIdKey field (e.g. 'replyTo')
//  A node's id is specified by its idKey field (e.g. 'commentId')
//  This function returns an object with a 'children' field holding an array of top-level child nodes.
//  A top-level child node has no parentIdKey field.
    function buildTreeStoreDataUtil(nodes, idKey, parentIdKey) {
        if (nodes && nodes.length == 0)
            return {expanded: true, children: []};

        //  Build map of nodes keyed by idKey field
        var node;
        var nodeMap = {};
        for (var i = 0; i < nodes.length; i++) {
            node = nodes[i];
            node.expandable = true;
            node.expanded = true;
            nodeMap[node[idKey]] = node;
        }

        //  Add children nodes to parent nodes (i.e. nodes having the parentIdKey property)
        var parentId, parent;
        var topLevelChildren = [];
        for (i = 0; i < nodes.length; i++) {
            node = nodes[i];
            parentId = node[parentIdKey];
            parent = nodeMap[parentId];
            if (!parent) {
                topLevelChildren.push(node);
                continue;
            }

            if (!parent.children)
                parent.children = [];

            parent.children.push(node);
        }

        return {expanded: true, children: topLevelChildren};
    }

    function storeSetRootNode(root) {
        if (!root)
            return;

        var items = (root.items) ? root.items : (Ext.isArray(root) ? root : undefined);
        if (!items)
            return;

        var treeStoreData = buildTreeStoreDataUtil(items, 'commentId', 'replyTo');
        if (treeStoreData.children.length == 0) {
            //  Add dummy node to treeStoreData to work around apparent Ext problem with
            //  adding a node to a tree store that has a root node with no children.
            treeStoreData.children = [
                {commentContent: '', commentId: 'dummy'}
            ];
        }
        Ext.data.TreeStore.prototype.setRootNode.call(this, treeStoreData);
    }

//  Recursively count replies and unread replies on a node.
//  If result is not present, it is initialized as {numReplies: 0, numUnread: 0}.
//  Returns a result object with these fields.
    function countReplies(record, result) {
        if (!result)
            result = {numReplies: 0, numUnread: 0};

        if (!record.childNodes)
            return result;

        var numReplies = record.childNodes.length;

        for (var i = 0; i < numReplies; i++) {
            //don't count the "new" node
            if (record.childNodes[i].get('commentId') != "new")
                result.numReplies += 1;
        }

        for (var i = 0; i < numReplies; i++) {
            if (record.childNodes[i].get('unread'))
                result.numUnread += 1;
        }

        for (i = 0; i < numReplies; i++)
            countReplies(record.childNodes[i], result);

        return result;
    }

// Register a 'navigationcomplete' handler on xcp.navigationManager that makes a
// service call to mark all comments as read when the user navigates away from a
// page with comments.
    function onNavigationComplete(xcpNavigationManager) {
        if (Ext.isDefined(xcp.navigationManager)) {
            //  Remove listener since it must only be called once
            xcp.navigationManager.un('navigationcomplete', onNavigationComplete, this);
            this.registeredNavigationComplete = false;
            //  Mark all comments as read
            Ext.Ajax.request(
                {
                    method: 'PUT', url: Ext.String.format('application/comments/{0}/markRead', this.commentsParentId),
                    scope: {}
                });
        }
    }

})();
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// CompleteTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.CompleteTaskDataAction");
Ext.apply(xcp.Strings.action.task.CompleteTaskDataAction, {
    confirmationTitle: "Complete Task?",
    confirmationPromptTemplate: "Are you sure you want to complete this task?",
    updateSuccessNotificationTemplate:  "The task has been completed.",
    updateErrorTemplate: "An error occurred while completing this task. Please try again."
});
/* xcp_complete_task/content/xcp/action/task/CompleteTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// CompleteTaskDataAction.js

/**
 * @class xcp.action.task.CompleteTaskDataAction
 * @extends xcp.action.form.DataAction
 * Action implementation for completing a task.
 */
Ext.define("xcp.action.task.CompleteTaskDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_complete_task",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         * @cfg {Boolean} nextTaskEnabled True to enable auto next task on this action. Context Menu will set this to false to disable
         */
        nextTaskEnabled: true,
        showConfirmation: false,
        objectTypePropName: "activity_system_name"
    },

    /**
     * Returns true if the action is applicable otherwise false
     * @param actionArgs
     * @param action
     */
    getEnablement:function(actionArgs, action){
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if(baseAction.isContextMenuAction(action) && baseAction.isTaskViewPageExist(actionArgs, action)) {
            return xcp.Enablement.HIDE;
        }
        return baseAction.isTaskActionApplicable(actionArgs, action, true, true, true, true, 1) ?
            xcp.Enablement.ENABLE :
            xcp.Enablement.HIDE;
    },

    /**
     * Get the localization object path for the action.
     */
    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.CompleteTaskDataAction";
    },

    /**
    * Return if get next task should be triggered from this action.
    */
    isGetNextTaskAction: function() {
        return this.config.nextTaskEnabled;
    }
});

/* xcp_complete_task/content/xcp/data/model/CompleteTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("complete_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/complete"
    },
    "fields" : [
        {
            "name":"id"
        },{
        "name" : "path",
        "type" : "array"
        },{
        "name" : "signOffPassword",
        "type" : "string"
        }
    ]
});
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.tree.ContentTree");

Ext.apply(xcp.Strings.widget.tree.ContentTree, {
    a_folder : "A folder",
    an_open_folder: "An open folder",
    folder_in_folder: "A folder in a folder",
    myfiledotdoc: "My file.doc",
    treetop: "Tree top",
    moreItems: "more items"
});
/* xcp_content_tree/content/xcp/widget/tree/ContentTree.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// This widget implements a folder tree having its root at a configurable
// point in the folder hierarchy, or at the repository root. Clicking on a
// node causes navigation to the view page of the specified object.

(function() {
    var NAME_PROP = "object_name";
    var MORE_ITEMS_NODE = "more_items";
    // Delays needed to resize autoheight trees after expand/collapse of a node
    var browserExpansionNodeDelay = 150;
    var ieBrowserExpansionNodeDelay = 1000;

    Ext.define("xcp.widget.ContentTree",
            {
                extend: "Ext.tree.Panel",
                alias: "widget.xcp_content_tree",

                plugins: "xcp_tree_itemeventplugin",

                xcpeventconfig : [{
                    event : "itemclick",
                    targetEvent : "change"
                }],

                statics : {
                    getSelectedNodeId : function(context, compId) {
                        var comp = context.getComponent(compId);
                        var selectedNodeId = "";
                        if (!comp) {
                            xcp.Logger.warn("Could not find the component with id : " + compId);
                        } else {
                            selectedNodeId =  comp.getSelectedNodeId();
                        }
                        return xcp.core.expr.BaseExpression.checkValue(selectedNodeId);
                    }
                },

                constructor: function(config) {
                    this.rootSet = false;
                    this.processConfig(config);
                    if (!isDesignMode() && !config.height) {
                        config.manageHeight = false;
                        config.layout = "auto";
                    }

                    this.callParent(arguments);
                    if (!isDesignMode())
                        this.store.proxy.useContents(true);
                    if(this.showOnlyFolders) {
                        this.store.proxy.showOnlyFolders(this.showOnlyFolders);
                    }
                    this.selectedNodeId = null;
                },

                initComponent: function() {
                    this.callParent(arguments);

                    // render event required to set up tooltip and events
                    this.on("render", onRender, this, {single: true});

                    // beforeappend event required for node initialization
                    this.store.on("beforeappend", onBeforeAppendNode, this);

                    // Append event listener will be used to add a pseudo node if parent node has more than 100 child items.
                    this.store.on("append", onAppendNode, this);

                    // add a CSS class to the root to hide the icon and expander
                    this.view.getRowClass = function(record, idx, rowParams, store) {
                        if (record.data.root) {
                            /* XCPECM-1118 root node should have the same style like runtime.*/
                            /*if (isDesignMode())
                                return "xcp-content-tree-root";
                            else*/
                                return "xcp-content-runtime-tree-root";
                        }
                        else if(!isDesignMode() && !xcp.util.Utils.isSupportedModel(record.model)){
                            if(record && record.data && record.data["id"] == MORE_ITEMS_NODE)
                                return "xcp-more-items-node";
                            else
                                return "xcp-not-supported";

                        }
                        else
                            return "";
                    };

                    // prevent root collapse
                    this.view.collapse = function(node) {
                        if (!node.get("root")) {
                            Ext.tree.View.prototype.collapse.apply(this, arguments);
                        }
                    };

                    this.hasHeader = !!this.initialConfig.title;
                    this.previousId = "";
                    if (!isDesignMode()) {
                        this.mon(xcp.navigationManager, "navigationcomplete", onNavigation, this);
                    }

                    // Workaround for Extjs 4.0.0 issue --
                    // TODO check to see if this is fixed in later release
                    // TODO NFF I tried this and can be removed
                    var upIndxs = this.view.updateIndexes;
                    this.view.updateIndexes = function() {
                        try {
                            upIndxs.apply(this, arguments);
                        }
                        catch (e) {
                            xcp.Logger.debug("swallowing exception from tree.view.updateIndexes");
                        }
                    };

                    this.on('itemcontextmenu', this.itemContextMenu, this);
                },

                // Initialize the configuration with default values. This is overridden
                // by the design time class.
                processConfig: function(config) {
                    if (config.title && (typeof config.title == "string")) {
                        config.title = Ext.String.htmlEncode(config.title);
                    }

                    // Root is Folder ID or Path, currently only Folder view uses it
                    var isId;
                    if(config.isID)
                        isId = config.isID;

                    Ext.applyIf(config, {
                                "displayField": NAME_PROP,
                                "useArrows" : "true",
                                "store" : {
                                    "model": "xcp_folderlist_0",
                                    "root": {
                                        "id": "root",
                                        "path" : config.root,
                                        "expanded": true,
                                        "children": [],
                                        "object_name": this.getRootName(config, isId),
                                        "r_object_type" : "dm_folder",
                                        "contentTree": this
                                    },
                                    "proxy": {
                                        "type": "xcp_rest_folder",
                                        "url": "application/dm_folders",
                                        "reader": {
                                            "type": "json",
                                            "root": "items"
                                        }
                                    },
                                    "setRootNode" : storeSetRootNode
                                }
                            });

                    // autoHeight is true unless the config specifies a non-zero numeric
                    // value for the height
                    this.autoHeight = true;
                    if (config.height) {
                        var ch = parseInt(config.height);
                        if ((typeof ch == "number") && (ch > 0)) {
                            this.autoHeight = false;
                        }
                    }
                    this.navigateOnItemClick = true;
                    if(typeof config.navigateOnItemClick !== undefined) {
                        this.navigateOnItemClick = config.navigateOnItemClick;
                    }

                    this.showContextMenu = true;
                    if(typeof config.showContextMenu !== undefined) {
                        this.showContextMenu = config.showContextMenu;
                    }

                    this.showOnlyFolders = false;
                    if(typeof config.showOnlyFolders !== undefined) {
                        this.showOnlyFolders = config.showOnlyFolders;
                    }

                    this.treeChildMax = 100;//Default show only 100 child items in a tree parent node.
                    if(typeof config.depth !== undefined) {
                        this.treeChildMax = config.depth;
                    }
                },

                // Handler invoked when a node of the tree is clicked. Causes navigation.
                // This is overridden in the design mode class.
                onItemClick: function (tree, item, elem, index, evt, opts) {

                    var url, model = item.model || "xcp_folderlist_0";

                    var targetId = item.get("id");
                    if (!targetId)
                        return;

                    item.expand();

                    if (targetId == "root"){
                        //url = xcp.util.Utils.makePageUrl(model, null, null, this);
                        /* for now clicking on the root will not navigate to a page.*/
                        return;
                    }
                    else {
                        if (!xcp.util.Utils.isSupportedModel(model))
                            return;
                        var pageUrl =  xcp.util.Utils.getDefaultPageFromContextMenu(model);

                        url = xcp.util.Utils.makePageUrl(model, targetId, pageUrl, this);
                        this.previousId = targetId;
                        this.selectedNodeId = targetId;
                    }
                    if(this.navigateOnItemClick)
                        xcp.navigationManager.navigate(url);
                },

                setToolTip: function(tt) {
                    if (this._tt) {
                        this._tt.destroy();
                        delete this._tt;
                    }
                    this._tt = Ext.create("Ext.tip.ToolTip", {
                                target: this.header.el,
                                html: tt
                            });
                },

                // XCPECM-1210 Make sure the tree adjusts the height or scroll bar for the new elements
                // TODO According to Sencha we should no longer need to call doLayout but we must have some
                // constraint issue in the parents of the control
                onRefresh: function() {
                    if (!isDesignMode()) {
                        var delay = 1;
                        Ext.Function.defer(this.ownerCt.doLayout,delay, this.ownerCt);
                    }
                },

                doComponentLayout: function() {
                    this.callParent(arguments);
                    if (this.autoHeight && !isDesignMode())
                        adjustHeader.call(this);
                },

                itemContextMenu: function( view,  record, item, index, e, eOpts ){
                    if (isDesignMode())
                        return;
                    if(this.showContextMenu === false)
                        return;
                    if (record.getId()=="root")
                        return;
                    var parentModel = null;
                    if (record.parentNode){
                        parentModel = record.parentNode;
                    }
                    var actionArgs= new xcp.core.ActionArgs({
                        component:  this.view,
                        selection: [record],
                        container: parentModel
                    });
                    xcp.core.ActionManager.showContextMenu(actionArgs, "ItemContextMenu", null, e);
                },

                // in ext4 doc, but method is missing :(
                getNodePath:function(node, attr, sep) {
                    sep = sep || "/";
                    var path = [];
                    while(node){
                        path.unshift(node.data[attr]);
                        node = node.parentNode;
                    }
                    return "/"+path.join(sep);
                },

                refreshChildren: function(node){
                    var expanded = node.isExpanded();
                    if(!expanded){
                        node.collapse();
                        node.removeAll(false);
                        Ext.apply(node.data, {expanded:false, loaded:false});
                    }
                    else
                    {
                        node.removeAll(false);
                        Ext.apply(node.data, {expanded:false, loaded:false});
                        node.expand();
                    }
//issue-node shows as expanded w/ no items                    this.selectPath(this.getNodePath(node, "id"), "id", "/", onPathExpanded, this);
                },

                // Get the text for the root node from the config object.
                getRootName:function (config, isId) {
                    // this has to be re-written when we switch over to Global Location Parameters
                    // instead of path string
                    var rootName = "";
                    if (config.root) {
                        var elems = config.root.split("/");
                        rootName = elems[elems.length - 1];
                    }
                    return rootName;
                },

                getSelectedNodeId : function() {
                    return this.selectedNodeId;
                },

                /* Setter fn for the hidden folderRoot property in content tree
                 */
                setFolderRoot: function(root){
                    //If root is blank we need to set repo root in storeSetRootNode
                    if(root == '' && !this.rootSet)
                    {
                        var root = {
                            isBlank:true,
                            expanded:true,
                            contentTree:this
                        };
                        this.setRootNode(root);
                    }
                    else if(!!root && !this.rootSet){
                        xcp.Logger.debug('Content Tree: setFolderRoot as ' + root);
                        var root = {
                            path:root,
                            contentTree:this,
                            expanded:true
                        };
                        var node ={};
                        node.root = root.path;
                        root[NAME_PROP] = this.getRootName(node,false);
                        this.setRootNode(root);
                    }
                    this.rootSet = true;
                },

                /* Checks whether expr has been configured for root/folderRoot properties
                * This is required to delay the setting of empty root on content tree, so that it can pick the root
                * from the expr setter fn
                * */
                isRootExprSet:function () {
                    if (!this.plugins)
                        return false;
                    else {
                        for (var j = 0; j < this.plugins.length; j++) {
                            var exprConfigs = this.plugins[j].config.expression;
                            if (exprConfigs) {
                                if (!Ext.isArray(exprConfigs)) {
                                    exprConfigs = [exprConfigs];
                                }
                                for (var i = 0; i < exprConfigs.length; i++) {
                                    var exprConfig = exprConfigs[i];
                                    if (exprConfig["propertyId"] == "root" || exprConfig["propertyId"] == "folderRoot") {
                                        xcp.Logger.debug("Tree has a root configured");
                                        return true;
                                    }
                                }
                            }
                        }
                        return false;
                    }
                }
            });


    // Given a folder path string, find the corresponding object in the repository.
    // Asynchronous.
    //
    //   folderPath        string specifying the folder by its path e.g. "/foo/bar/baz"
    //   cb                callback function to invoke with result
    //   failFn            called if request fails
    //   scope             scope used to invoke the callback function
    function resolveRootPath(folderPath, cb, failFn, scope) {

        function success(response, options) {
            var folder = Ext.decode(Ext.String.format("new Object({0})", response.responseText));  // $NON-NLS-1$
            cb.call(scope, folder.id);
        }

        function failed(response) {
            this._rootFail = true;
            var result = Ext.decode(Ext.String.format("new Object({0})", response.responseText));  // $NON-NLS-1$
            xcp.Logger.debug("Content Tree failed to resolve folderPath: " + folderPath);
            if (failFn) {
                failFn.call(scope, result);
            }
        }

        Ext.Ajax.request({
                    url: "application/breadcrumbs/resolve?" + Ext.Object.toQueryString({path: folderPath}),
                    scope: this,
                    disableCaching: Ext.isIE8,         //XCPECM-1068 IE8 has over zealous cache issues. making allowing subsequent user of same window sessions to use cache of previous user.
                    success: success,
                    failure: failed
                });
    }


    function getBreadcrumbsForObject(objectId, callback, scope) {

        function success(response, options) {
            var crumbs = Ext.decode(Ext.String.format("new Object({0})", response.responseText));  // $NON-NLS-1$
            callback.call(this, crumbs);
        }

        if (!objectId) {
            xcp.Logger.debug("no object id in getBreadcrumbsForObject");
            return;
        }

        Ext.Ajax.request({
                    url: "application/breadcrumbs/".concat(objectId),
                    scope: scope,
                    disableCaching: false,
                    success: success
                }
        );
    }

    // Get the name of the repository for this session. Asynchronous.
    //
    //   cb                callback function to invoke with result
    //   scope             scope used to invoke the callback function
    // TODO Consolidate repository information into global context for current user.
    function getRepositoryName(cb, scope) {

        function success(response, options) {
            var repoName = Ext.decode(response.responseText);
            cb.call(scope, repoName);
        }

        Ext.Ajax.request({
                    url: "application/currentUser/repository",
                    scope: this,
                    disableCaching: true,
                    success: success
                });
    }

    // Override for the store's setRootNode method. We have to override this
    // because we need to either (a) get the name of the repository, or (b)
    // resolve the root folder path to an object id, both of which require a
    // service call. The base class method is invoked after the service call
    // returns.
    function storeSetRootNode(root) {

        function idCallback(resolvedId) {

            if (resolvedId == null) {
                this.on("beforeload", function() {
                    return false;
                });

                root.contentTree.hide();
            }
            if(resolvedId && root.contentTree.hidden) {
                xcp.Logger.debug('Toggling content tree visibility to true since Folder Id was resolved');
                root.contentTree.show();
               }
            root.id = resolvedId;

            var r = Ext.data.TreeStore.prototype.setRootNode.call(this, root);
            r.set('leaf', false);  // $NON-NLS-1$
        }

        function repoCallback(repoName) {
            root[NAME_PROP] = repoName;

            var r = Ext.data.TreeStore.prototype.setRootNode.call(this, root);
            r.set('leaf', false);  // $NON-NLS-1$
        }

        //TODO Refactor FolderView code out by moving storeSetRootNode to a class
        var tree = root.contentTree;
        var node ={};
        node.root = root.path;

        // Root of folderviewcontenttree is passed as folder ID
        if (root.path && tree instanceof xcp.widget.tree.FolderViewContentTree && tree.isID){

            this.proxy.useContents(true);
            root.id = root.path;
            var me = this;
            var callback = function(record) {
                var rootName = record.data[NAME_PROP];
                xcp.Logger.debug('FolderViewContentTree: Update root in callback as - ' + rootName);
                root[NAME_PROP] = rootName;
                var r = Ext.data.TreeStore.prototype.setRootNode.call(me, root);
                r.set('leaf', false);  // $NON-NLS-1$
            }
            root[NAME_PROP] = tree.getRootName(node, tree.isID, callback);
        }

        else if(root.path){
            resolveRootPath(root.path, idCallback, null, this);

            // Root of folderviewcontenttree is passed as folder Path
            if(tree && tree instanceof xcp.widget.tree.FolderViewContentTree)
                root[NAME_PROP] = tree.getRootName(node, tree.isID);
        }
        else {
            // Root will be set via expr setter "setFolderRoot", hence return
            //In case of attachment widget, root is expr enabled in the wizard step page,
            // but can be left blank while configuring attachment widget. Hence need to set repo root
            if(Ext.isFunction(tree.isRootExprSet) && tree.isRootExprSet() && root.isBlank != true)
                return;

            root.id = "root";
            getRepositoryName(repoCallback, this)
        }
    }

    // After the panel has rendered, set up the the tooltip on the panel's header.
    // This requires setting a render event hook on the header itself.
    function onRender() {
        if (this.header && this.initialConfig.tooltip) {
            this.header.on("render", function() {
                this.setToolTip(this.initialConfig.tooltip);

            }, this, {single: true});
        }

        // XCPECM-1210 Make sure the tree adjusts the height or scroll bar for the new elements
        // TODO According to Sencha we should no longer need to call doLayout but we must have some
        // constraint issue in the parents of the control
        this.view.on("refresh", this.onRefresh, this);
        if (!isDesignMode() && this.autoHeight) {
            // XCPECM-1210 Make sure the tree adjusts the height or scroll bar for the new elements
            // For autoheight trees we need to call layout after the expansion or collapse to get the height
            // to change
            this.on("itemexpand", onExpandCollapseNode, this, [true]);
            this.on("itemcollapse", onExpandCollapseNode, this, [true]);
        }

        // itemclick event required for navigation logic
        this.on("itemclick", this.onItemClick, this);
    }

    // Initialize the tree node before it is appended to the tree.
    //
    //     parentNode       node to which new node is to be appended
    //     newNode          node being appended
    //
    function onBeforeAppendNode(parent, newNode) {

        if (isDesignMode())
            return true;

        var nid = newNode.get("id");
        if(nid == MORE_ITEMS_NODE) //Has more items node do not need any model or any extra styles.
           return true;

        newNode.model = xcp.util.Utils.getModelFromObjectType(newNode.get("r_object_type"), nid);

        if (newNode.model == "dm_cabinet")
            newNode.model = "xcp_folderlist_0";

        //Make sure show only childrens nodes as per spec limit.
        if (parent && parent.childNodes && parent.childNodes.length > this.treeChildMax)
            return false;

        var isLeaf = ((nid.indexOf("0b") != 0) && (nid.indexOf("0c") != 0));
        newNode.set('leaf', isLeaf);  // $NON-NLS-1$

        // XCPECM-572 set the node icon for leaf nodes but not the folder nodes.  If the folder node is set
        // then the extjs will not handle the open/close of the folder icon.  If we want custom icons then
        // we need to handle the expand/collapse events
        var nodeName = newNode.data[NAME_PROP];
        if (nodeName && !newNode.data._xcp_name_encoded) {

            if (isLeaf) {
                var iconURL = newNode.data["icon"];
                if (iconURL != ""){
                   newNode.set('icon', iconURL);  // $NON-NLS-1$
                }
            }
            else
                newNode.set('icon', "");  // $NON-NLS-1$

            newNode.data[NAME_PROP] = Ext.String.htmlEncode(nodeName);
            newNode.data._xcp_name_encoded = true;
        }
        if (!xcp.util.Utils.isSupportedModel(newNode.model)){
            newNode.data[NAME_PROP]="<span class='xcp-not-supported'>"+newNode.data[NAME_PROP]+"</span>"
        }

        // Return false if not showing files in the root. This prevents the node from being attached.
        return !!((this.showRootFiles !== false) || !newNode.data.leaf || !parent || parent.parentNode);
    }


    // Each folder item model instance will be automatically
    // decorated with methods/properties of Ext.data.NodeInterface
    // (i.e., a "node"). Whenever a item node is appended
    // to the tree, this TreeStore will fire an "append" event.
    function onAppendNode( parent, newChildNode, index, eOpts ) {
        if( !newChildNode.isRoot() ) {
            //If node childs count 100 then add 'zzz more items' pseudo node. 'zzz' is no of remaining nodes to show.
            //TO-D0 Currently real-time service is returning only 100 childrens maximum.
            //This code need to be revisit if the real-time service returns more than 100.
            if (parent && parent.data && newChildNode && (index==this.treeChildMax-1) && parent.childNodes.length ==this.treeChildMax &&
                (parent.data["r_link_cnt"] > this.treeChildMax) && newChildNode["id"] != MORE_ITEMS_NODE) {
                parent.appendChild(
                {
                    id : MORE_ITEMS_NODE,
                    object_name: Ext.String.format("{0} {1}", (parent.data["r_link_cnt"]-this.treeChildMax) ,xcp.Strings.widget.tree.ContentTree.moreItems),
                    leaf: true,
                    icon: ""
                    //iconCls: "xcp-more-items-node"
                });
            }
        }
    }

    // event handler for node collapse or expand
    // XCPECM-1210 Make sure the tree adjusts the height or scroll bar for the new elements
    // For autoheight trees we need to call layout after the expansion or collapse to get the height
    // to change.  The delay may need to be tweaked
    function onExpandCollapseNode(node, options) {
        var delay = this.view.expandDuration + browserExpansionNodeDelay ;
        // Making the delay universal to address XCPECM-1419
        delay = delay + ieBrowserExpansionNodeDelay;
        // IE9 needs a little more delay
        if(Ext.isIE9)
            delay += 200;
        Ext.Function.defer(this.ownerCt.doLayout,delay, this.ownerCt);
    }

    // Handler for navigation event. Get the breadcrumbs for the object to which we navigated,
    // and expand tree nodes as necessary.
    function onNavigation() {
        var targetId = this.getPageObjectId();
        if (targetId == this.previousId)
            return;
        this.previousId = targetId;

        // Completion callback for breadcrumb request.
        function processBreadcrumbs(bc) {
            if (!this.getRootNode()) // initial rendering race condition
                return;

            var rootOfThisTree = this.getRootNode().get("id"),
                path = "";

            // The bc path returned from the service starts at the repository root. If the
            // root of this content tree is not the bc path, then we ignore this navigation.
            var onPath;
            if (rootOfThisTree == "root") {
                onPath = true;
                path = "/root";  // $NON-NLS-1$
            }
            else
                onPath = false;

            for (var i=0; i < bc.total; ++i) {
                var crumbId = bc.items[i].id;

                if ((crumbId == rootOfThisTree))
                    onPath = true;

                if (onPath)
                    path = path.concat("/", crumbId);
            }

            // the bc path does not include the target of the navigation, so add it
            // before calling selectPath
            path = path.concat("/", targetId);

            if (onPath) {
                // Use the selectPath method of the Tree to expand to the target node.
                this.selectPath(path, "id", "/", onPathExpanded, this);
            }
        }

        if (targetId && (targetId.indexOf("08") != 0)) // ignore business objects navigations
            getBreadcrumbsForObject(targetId, processBreadcrumbs, this);
    }


    function onPathExpanded(isSuccess, node) {
        if (node && !node.get('leaf')) {
            node.expand();
        }
    }

    function isDesignMode() {
        return !xcp.navigationManager;
    }
})();


/**
 * Watch for item events and refresh store as needed
 */
Ext.define('xcp.event.TreeEventPlugin', {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.xcp_tree_itemeventplugin",

    init: function(cmp){
        cmp.formInfo = null;
        this.subscriptions = [];
        if(window['OpenAjax']){   // dlm:todo how about xcp.isDesign()???
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemDeleted.NAME, this.itemDeleted, cmp));
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ContainerChangedEvent.NAME, this.itemChanged, cmp));
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemUnlockedEvent.NAME, this.containedItemChanged, cmp));
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemLockedEvent.NAME, this.containedItemChanged, cmp));
            this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemModified.NAME, this.containedItemChanged, cmp));
        }
    },
    destroy: function(cmp){
        var subscriptions = this.subscriptions;
        for (var i=0, len=subscriptions.length; i<len; i++){
            xcp.event.EventBus.unsubscribe(subscriptions[i]);
        }
        delete this.subscriptions;
    },

    /**
     *   Refresh if contained item changed
     * @param name
     * @param ids  -- Array of target object IDs or single id
     */
    containedItemChanged: function(name, ids){
        var node;
        ids = Ext.isArray(ids) ? ids : [ids];
        var store = this.view.getTreeStore();
        for(var i=0, len=ids.length; i<len; i++){
            var id = ids[i];
            if (id && (node=store.getNodeById(id))){
                if (node.parentNode){
                    this.refreshChildren(node.parentNode);
                }
            }
        }
    },

    /**
     * Refresh if container item or contained item changed.
     * @param name
     * @param ids  -- Array of target object IDs or single id
     */
    itemChanged: function(name, ids){
        var node;
        ids = Ext.isArray(ids) ? ids : [ids];
        var store = this.view.getTreeStore();
        for(var i=0, len=ids.length; i<len; i++){
            var id = ids[i];
            if (id && (node=store.getNodeById(id))){
                this.refreshChildren(node);
            }
        }
    },

    itemDeleted: function(name, ids){
        var node;
        ids = Ext.isArray(ids) ? ids : [ids];
        var store = this.view.getTreeStore();
        for(var i=0, len=ids.length; i<len; i++){
            var id = ids[i];
            if (id && (node=store.getNodeById(id))){
                node.remove(false);
            }
        }
    }

});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// Cut-strings.js

Ext.namespace("xcp.Strings.action.Copy");
Ext.apply(xcp.Strings.action.Copy, {
    text: "Copy",
    tooltip: "Copy items to the clipboard",
    notification: "{object_name} copied",
	notification_multi: "{_count} items copied",
    progress: "Copying \"{object_name}\""
});
/* xcp_copy/content/xcp/action/Copy.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.Copy
 * @extend xcp.action.Action
 *
 */
Ext.define("xcp.action.Copy", {
    extend: "xcp.action.Action",
    alias: "action.xcp_copy",
    config: {
        text: xcp.Strings.action.Copy.text,
        tooltip: xcp.Strings.action.Copy.tooltip,
        showSuccessNotification:true,

        requiredAttributes: ["effectivePermissions"],
        preconditions: {
            selection: xcp.SelectionType.SINGLE,   // xcp.SelectionType.MULTI,
            targets:{
                validId:    true,
                effectivePermissions: [xcp.Permit.READ]
            }
        }
    },
    statics:{
        /**
         * Copy implementation
         * @param sources
         * @param targets
         * @param sourceLocationId -- not used (for cut only)
         * @param config -- action's config object
         */
        copy: function(actionArgs, sources, targets, sourceLocationId, config){
            config = config || {};
            var target = targets[0];
            if (!target)
                return;
            var targetId = target.getId();

            var source = sources[0];
            var sourceId = source.getId();
            var progress = new xcp.ProgressNotifier(actionArgs.component, xcp.util.Utils.formatTemplateString(xcp.Strings.action.Copy.progress, source));
            progress.startOperation();
            Ext.Ajax.request(
            {
                feedbackContainer: actionArgs.component,
                method: 'POST', url: Ext.String.format('application/folders/{0}?sourceObjectId={1}', targetId, sourceId),
                scope: this,
                success: function(response, options)
                {
                    progress.endOperation(config.showSuccessNotification);
                    if (config.showSuccessNotification) {
                        progress.showSuccess(xcp.util.Utils.formatTemplateString(xcp.Strings.action.Copy.notification, source));
                    }
                    xcp.event.EventBus.publish(xcp.event.ContainerChangedEvent.NAME, targetId);
                    xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, targetId);
                },
                failure: function(response, options)
                {
                    progress.endOperation();
//                    xcp.action.form.DataAction.showActionError(actionArgs.component, "error copying {0}", response, source);
                }
            });
        }

    },
    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var targets = action.getTargets(actionArgs);

        xcp.Clipboard.setData(targets, null, actionArgs.getPageModel(), "copy", xcp.action.Copy.copy, action.getConfig());  // $NON-NLS-1$ 
    }


});


/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.report.Reports");
Ext.apply(xcp.Strings.widget.report.Reports, {
    componentId:                "ID",
	columnsFieldLabel:		    "Columns",
	titleGeneralSectionLabel:	"General",
	titleBasicSectionLabel:	    "Basic",
    titleFieldValue:	        "Title",
    generalDataSectionLabel:    "Data",
    rangesLabel:                "Ranges",
    defaultDisplayLabel: "Default Display",
    displayLabel: "Display",
    reportTyprField:	        "Report Type",
    timeGranularityField:	     "Time Granularity",
    titleInfoSectionLabel:	     "Info",
    titleRulesSectionLabel:	     "Display Rules",
    titleStyleSectionLabel:	     "Style",
    btnEditCrystalReportLabel:	     "Edit in Crystal Reports",
    btnFinishEditCrystalReportLabel:	     "Edit in Crystal Reports",
    msgReportBeingEdited:	     "This report is beign edited",
    msgLoadingReport:             "Loading Report .....",
    msgLastEdited:                "Last saved on ",
    msgErrorLoadingCrystalReport:   "Error loading crystal report RPT file",
    msgUnkownReportType:    "Unkown report type or report type is empty",
    btnSyncCrystalReportLabel:"Sync Crystal Report with Data Source",
    msgErrorUpdatingCrystalReport:   "Error updating crystal report RPT file",
    msgErrorCrystalReportOpenByOtherProcess:  "Cannot update the Crystal Report because it is being used by another process." ,

    chartTypeColumn:"Column",
    chartTypeLine:"Line",
    chartTypePie:"Pie",

    xAxisLabel: "Categories",
    yAxisLabel:"Values",
    prefix:"",

    sampleDataC1 : "A",
    sampleDataC2 : "B",
    sampleDataC3 : "C",
    sampleDataC4 : "D",
    sampleDataC5 : "E",
    sampleDataC6 : "F",
    sampleDataC7 : "G",


    dataC11 : 45,
    dataC21 : 125,
    dataC31 : 50,
    dataC41 : 25,
    dataC51 : 45,
    dataC61 : 90,
    dataC71 : 150,


    dataC12 : 20,
    dataC22 : 15,
    dataC32 : 20,
    dataC42 : 40,
    dataC52 : 35,
    dataC62 : 70,
    dataC72 : 20,


    dataC13 : 70,
    dataC23 : 40,
    dataC33 : 25,
    dataC43 : 10,
    dataC53 : 70,
    dataC63 : 150,
    dataC73 : 10,


    dataC14 : 90,
    dataC24 : 25,
    dataC34 : 40,
    dataC44 : 30,
    dataC54 : 7,
    dataC64 : 2,
    dataC74 : 65,


    dataC15 : 15,
    dataC25 : 10,
    dataC35 : 100,
    dataC45 : 40,
    dataC55 : 75,
    dataC65 : 95,
    dataC75 : 25,


    dataC16 : 110,
    dataC26 : 80,
    dataC36 : 20,
    dataC46 : 35,
    dataC56 : 90,
    dataC66 : 45,
    dataC76 : 70,

    dataC17 : 110,
    dataC27 : 80,
    dataC37 : 20,
    dataC47 : 35,
    dataC57 : 90,
    dataC67 : 45,
    dataC77 : 70,

    dataC18 : 110,
    dataC28 : 80,
    dataC38 : 2,
    dataC48 : 35,
    dataC58 : 90,
    dataC68 : 45,
    dataC78 : 70,


    dataC19 : 110,
    dataC29 : 80,
    dataC39 : 20,
    dataC49 : 35,
    dataC59 : 90,
    dataC69 : 45,
    dataC79 : 70,

    dataC110 : 110,
    dataC210 : 80,
    dataC310 : 20,
    dataC410 : 35,
    dataC510 : 60,
    dataC610 : 45,
    dataC710 : 70,

    dataSectionLabel: "Data",

    createNewOrUsePageTitle: "Data Service and Instance Creation",
    createNewOrUseInstructionText: "A Chart must be connected to an instance of a data service.",
    createNewOrUseRadioHeader: "Create:",
    createNewOrUseRadio1Label: "Data service and instance",
    createNewOrUseRadio1Instructions: "Add a new data service.  An instance of the data service will also be created and connected to the chart.",
    createNewOrUseRadio2Label: "Instance of an existing data service",
    createNewOrUseRadio2Instructions: "Select an existing data service.  A new instance of the data service will be created and connected to the chart.",

    chooseTypePageTitle: "Data Service Creation",
    chooseTypeInstructionText: "Create a data service that returns:",

    selectDSPageTitle: "Create an Instance of an Existing Data Service",
    selectDSInstructionText: "Select a data service:",
    selectDSTitleLabel: "Data service label",

    typeListLabel: "Data service:",

    chooseColumnPageTitleScreen3a: "Specify column chart categories (X Axis)",
    chooseColumnPageTitleScreen3b: "Specify column chart values (Y Axis)",
    
    chooseColumnPageTitleScreen4: "Define values and categories (X and Y axes)",
    chooseColumnPageTitleScreen5: "Create user inputs for the query",
    chooseColumnPageTitle: "Specify columns for Crystal Reports",
    showAllAvailableFields:"Show all available",
    availableColumnsLabel:"Available:",
    includedColumnsLabel:"Included:",
    primaryTypeLabel: "{0} ({1})",

    categoriesXaxis:"Categories (X Axis)",
    valuesYaxis:"Values (Y Axis)",
    
    dataSourceName:"Data Source",
    axis_Label: "Axis Label",
    yAxis_Label:"Y Axis Label",
    xAxis_Label:"X Axis Label",
    xAxisType:"X Axis Type",

    xAxisFields: "X Axis Fields",
    yAxisFields: "Y Axis Fields",

    displayTitle: "Display",
    fieldTitle: "Field",
    typeTitle: "Type",
    chartWidgetTitle: "Chart widget title",
    crystalWidgetTitle: "Crystal Reports widget title",
    chartHasNoData: "No data to display",
    chartNoDataLabel: "No data",

    slaLines: "Lines",

    ranges: "Ranges",
    layoutSectionLabel: "Layout",
    sizeGroupLabel: "Size"

});
/* xcp_crystal_report/content/xcp/widget/report/CrystalReportComponent.js */

// BarChartComponent.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.report.CrystalReportComponent
 * @extends Ext.Panel
 * CrystalReport component
 * @constructor
 * Creates a new runtime
 * @param {Object} config Configuration options.
 * @xtype xcp_crystal_report 
 */
Ext.define("xcp.widget.report.CrystalReportComponent", {
    extend: 'Ext.Panel',
    alias: 'widget.xcp_crystal_report',
    layout: 'fit',
    cls: 'xcp-chart-outer-panel',
    constructor: function(config)
    {
        Ext.useShims = true;
        this.config = config;

        this.runtime = Ext.isDefined(xcp.navigationManager);
        if (this.runtime)
        {
            this.runTimeWidget(config);
        }
        else
        {
            this.designTimeWidget(config);
        }

        xcp.widget.report.CrystalReportComponent.superclass.constructor.call(this, config);

    },
    initComponent: function()
    {
        xcp.widget.report.CrystalReportComponent.superclass.initComponent.call(this);
    },

    runTimeWidget:function(config)
    {
        this.widgetId = this.getId();
        var me = this;
        var reportType = config.reportType;
        var crystalReportManager = new xcp.widget.report.CrystalReportManagerRunTime();
        var currentReport = crystalReportManager.getReportObject(config);

        var currentCrStore = Ext.data.StoreManager.lookup(config.storeId);
        if (currentCrStore)  {
                currentCrStore.buffered = false;
                currentCrStore.on('load', function( store, records, options ) {
                    currentReport = crystalReportManager.getNewReportObject(config, store);
                    me.removeAll(true);
                    me.add(currentReport);
            });
        }

         Ext.apply(this,Ext.apply(this.initialConfig, config), {
			items:[currentReport]
         });
        


    },


    
    designTimeWidget:function(config)
    {
        this.widgetId = this.getId();
        var reportType = config.reportType;
        var crystalReportManager = new xcp.widget.report.CrystalReportManagerDesignTime();
        var currentReport = crystalReportManager.getReportObject(config);

         Ext.apply(this,Ext.apply(this.initialConfig, config), {
			items:[currentReport],
			listeners: {
				mouseover: {
					element: 'el', //bind to the underlying el property on the panel
					fn: function(e, el)
						{
							//if(!e.within(currentReport, true))
								//showHideStatusBar(currentReport.items.get(1),'show');

						}
				},
				mouseout: {
					element: 'body', //bind to the underlying body property on the panel
					fn: function(e, el)
						{

						//if(!e.within(currentReport, true))
							//showHideStatusBar(currentReport.items.get(1),'hide');
						}
				}
			}             

         });



		Ext.each(currentReport.items.items, function(item) {
			item.enableBubble('mouseover');
			item.enableBubble('mouseout');
		}, this);

        
    }



});

/* xcp_crystal_report/content/xcp/widget/report/CrystalReportManagerDesignTime.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("xcp.widget.report.CrystalReportManagerDesignTime",
{
    name  : null,


    getReportObject : function(config)  {

        var buttonCfg = {
            xtype:'button',
            cls:'x-btn-icon',
            iconAlign:'top'
        };


		var clickCounter=0;
		var crystalEditBtn = new Ext.Button(Ext.apply(buttonCfg, {
            text     : xcp.Strings.widget.report.Reports.btnEditCrystalReportLabel,

			 handler : function() {
				clickCounter++;
                var result;
                  // open Crystal Editor
                 bottomStatusbar.items.get(0).setText(xcp.Strings.widget.report.Reports.msgLoadingReport);
                 result = fireJavaEvent("20011", config.rtpfilename, 'dataSourcesType');
                    if(result!='false'){
                           bottomStatusbar.items.get(0).setText(xcp.Strings.widget.report.Reports.msgLastEdited + result);
                       } else{
                         alert(xcp.Strings.widget.report.Reports.msgErrorLoadingCrystalReport);
                    }
			 }
		 }));

        var crystalUpdateBtn = new Ext.Button(Ext.apply(buttonCfg, {
            text     : xcp.Strings.widget.report.Reports.btnSyncCrystalReportLabel,

			 handler : function() {

                var result;
                result = fireJavaEvent("20014", config.rtpfilename, config.dataServiceName, config.xcpId);

                 if(result.indexOf("100") > -1){
                     alert(xcp.Strings.widget.report.Reports.msgErrorUpdatingCrystalReport);

                 }else if (result.indexOf("101") > -1){
                     alert(xcp.Strings.widget.report.Reports.msgErrorCrystalReportOpenByOtherProcess );
                 }
			 }
		 }));

        crystalEditBtn.setDisabled(true);
        crystalUpdateBtn.setDisabled(true);
        if (config.dataServiceName && config.dataServiceName.trim().length >0){
            crystalEditBtn.setDisabled(false);
            crystalUpdateBtn.setDisabled(false);
        }

        var bottomStatusbar = new Ext.toolbar.Toolbar( {
			items: [
                crystalEditBtn,
                crystalUpdateBtn,
                {
                    xtype: 'tbtext',
                    text: '',
                    highlight:false,
                    display:false,
                    align:'right'
                },
                '->'
                //crystalEditBtn
            ]
        });

        var tempImage = Ext.create('Ext.Img', {
            src: xcp.designer.iconsDir + '/crystal_chart_placeholder-small.png'
        });

        var  crHeight =   300;
        if (config.height && config.height >0) {
              crHeight =  config.height;
        }

        var reportContainer = new Ext.panel.Panel({
            width:329,
            height:crHeight,
            cls: 'xcp-chart-panel-body',
            items:[tempImage, bottomStatusbar]
        });

  return reportContainer;        
  }


});






/* xcp_crystal_report/content/xcp/widget/report/CrystalReportManagerRunTime.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.widget.report.CrystalReportManagerRunTime",
{
    getReportObject : function(config)  {
        var tempImage = Ext.create('Ext.Img', {
            src: this.geIconPath() + '/crystal_chart_placeholder-small.png'
        });
        var cTimezone = xcp.Formats.timezoneId;
        var crUrl = 'crystalreport?dsName='+config.modelName+'&dsType='+config.categoryID+'&rptName='+config.rtpfilename+'&timeGranularity='+config.timeGranularity+'&appNamespace='+config.appNamespace+'&pageName='+config.pageName
            +'&clientTimeZone='+encodeURIComponent(cTimezone) ;

        var  crHeight =   300;
        if (config.height && config.height >0) {
              crHeight =  config.height;
        }
        var reportContainer = new Ext.panel.Panel({
            width:329,
            height:crHeight,
            html: '<iframe class="xcp-chart-subcmp"  width="100%" height="100%" src="'+crUrl+'"> </iframe>'
        });

  return reportContainer;
  },
    getNewReportObject:function(config, store){
       me = this;

        var cTimezone = xcp.Formats.timezoneId;
        var crUrl = 'crystalreport?dsName='+config.modelName+'&dsType='+config.categoryID+'&rptName='+config.rtpfilename+'&timeGranularity='+config.timeGranularity+'&appNamespace='+config.appNamespace+'&pageName='+config.pageName
            +'&clientTimeZone='+encodeURIComponent(cTimezone) ;

        var widgetInputs = Ext.decode(config.userInputsNames);
        if(widgetInputs)
        for(var i=0;i<widgetInputs.length;i++){
            try{
                if(store.proxy.extraParams[widgetInputs[i]])
                    crUrl = crUrl + '&' +widgetInputs[i]+'='+store.proxy.extraParams[widgetInputs[i]];
            }
            catch(e) {
            }

        }
        var currentReport = me.getReportObject(config);
        currentReport.html = '<iframe class="xcp-chart-subcmp"  width="100%" height="100%" src="'+crUrl+'"> </iframe>';
        return currentReport;
    }
    ,
    geIconPath : function()
    {
    var appPath = document.location.pathname;
    if (appPath.charAt(appPath.length - 1) == '/') {
     appPath = appPath.substr(0, appPath.length - 1);
    }
    return appPath + "/component/xcp-report-widgets/icons";
    }
  
});



/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// Cut-strings.js

Ext.namespace("xcp.Strings.action.Cut");
Ext.apply(xcp.Strings.action.Cut, {
    text: "Cut",
    tooltip: "Cut items to the clipboard",
    notification: "{object_name} moved",
	notification_multi: "{_count} items moved",
    progress: "Moving \"{object_name}\"" ,
    lockedByAnother : "It is locked by {1}",
    lockedByYou: "It is locked by you."
});
/* xcp_cut/content/xcp/action/Cut.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.Cut
 * @extend xcp.action.Action
 *
 */
Ext.define("xcp.action.Cut", {
    extend: "xcp.action.Action",
    alias: "action.xcp_cut",
    config: {
        text: xcp.Strings.action.Cut.text,
        tooltip: xcp.Strings.action.Cut.tooltip,

        showSuccessNotification:true,

        requiredAttributes: ["effectivePermissions"],
        preconditions: {
            selection: xcp.SelectionType.SINGLE,   // xcp.SelectionType.MULTI,
            targets:{
                validId:    true,
                effectivePermissions: [xcp.Permit.WRITE]
            }
        }
    },


    getEnablement:function(actionArgs, action) {

         // disable if locked.
        var target = action.getTargets(actionArgs)[0];
        if (target){
            var lockOwner = target.get('r_lock_owner');
            if (lockOwner && lockOwner.length > 0)
                return xcp.Enablement.DISABLE;
        }
        // XCPECM-421 User can cut if they have write or change folder links permission
        target = actionArgs.getPageModel();
        // if container is folder then get and validate effective permissions on it.
        if(!target){
            if (actionArgs.container && actionArgs.container.model == "xcp_dm_folder"){
                target = actionArgs.container;
            }
        }
        if (target) {
            var permits = target.get('effectivePermissions');
            if (permits === undefined || permits == "") {
                return xcp.Enablement.ENABLE;
            }
            if (xcp.Permit.hasPermit(permits, xcp.Permit.WRITE)) {
                return xcp.Enablement.ENABLE;
            } else if ((xcp.Permit.hasPermit(permits, xcp.Permit.CHANGE_FOLDER_LINKS)) && (xcp.Permit.hasPermit(permits, xcp.Permit.BROWSE))) {
                return xcp.Enablement.ENABLE;
            } else
                return xcp.Enablement.HIDE;

        }
        return xcp.Enablement.ENABLE;
    },
    statics:{
        /**
         * Move action impl.
         * @param actionArgs
         * @param sources
         * @param targets
         * @param sourceLocationId
         * @param config -- action's config object
         */
        move: function(actionArgs, sources, targets, sourceLocationId, config){
            var target=targets[0];

            var typeName = actionArgs.getTypeName(target);
            var source = sources[0];
            var sourceId = source.getId();
            var targetId = targets[0].getId();

            var progress = new xcp.ProgressNotifier(actionArgs.component, xcp.util.Utils.formatTemplateString(xcp.Strings.action.Cut.progress, source));
            progress.startOperation();
            sourceLocationId = sourceLocationId || "";
            Ext.Ajax.request(
            {
                feedbackContainer: actionArgs.component,
                method: 'PUT', url: Ext.String.format('application/{0}/{1}?targetId={2}&sourceFolderId={3}&moveAllVersions=true', typeName, sourceId, targetId, sourceLocationId),
                scope: this,
                success: function(response, options)
                {
                    progress.endOperation(config.showSuccessNotification);
                    if (config.showSuccessNotification) {
                        progress.showSuccess(xcp.util.Utils.formatTemplateString(xcp.Strings.action.Cut.notification, source))
                    }
                    xcp.event.EventBus.publish(xcp.event.ContainerChangedEvent.NAME, [targetId, sourceLocationId]);
                    xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, targetId);
                },
                failure: function(response, options)
                {
                    progress.endOperation();
  //                    xcp.action.form.DataAction.showActionError(actionArgs.component, "error moving", null, source);
                }
            });

        }
    },
    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var targets = action.getTargets(actionArgs);
        function targetOverlap(targets, oid){
            var bOver = false;
            for(var i=0, len=targets.length; i<len; i++){
                if (targets[i].getId()==oid){
                    return true
                }
            }
            return false;
        }
        var container = actionArgs.container;
        if (actionArgs.getPageModel() && !container && !targetOverlap(targets, actionArgs.getPageModel().getId())){
            container=actionArgs.getPageModel();
        }
        xcp.Clipboard.setData(targets, container, actionArgs.getPageModel(), "cut", xcp.action.Cut.move, action.getConfig());  // $NON-NLS-1$ 
        if (actionArgs.component) {
            new xcp.action.CutMarker(actionArgs.component, action.getTargets(actionArgs));
        }
    }
});

/**
 * Object to mark/unmark cut rows (in tree/grid)
 */
Ext.define("xcp.action.CutMarker", {
    constructor: function(component, models){
        if (component.cutMarker){
            component.cutMarker.clear(component);
        }
        this.component = component;
        component.cutMarker = this;
        xcp.Clipboard.on("clear", this.clear, this);
        xcp.Clipboard.on("change", this.clear, this);
        this.markModels(component, models);
    },
    markModels: function(component, models){
        var view = component;
        var ids=this.ids = [];
        if (!view.getNode) return;
        for(var i=0, len=models.length; i<len; i++){
            var node = view.getNode(models[i]);
            var el = Ext.get(node);
            if (el){
                this.addMark(el);
            }
        }
    },
    clear:function(component /*optional*/){
        component = component || this.component;
        if (!component)
            return;
        delete component.cutMarker;
        var ids = this.ids;
        for (var i=0, len=ids.length; i<len; i++){
            var el = Ext.get(ids[i]);
            if (el){
                this.removeMark(el);
            }
        }
    },
    addMark: function(el){
        this.ids.push(el.id);
        el.addCls("xcp-cut");
    },
    removeMark: function(el){
        el.removeCls("xcp-cut");
    }

});


/* xcp_date_time_input/content/xcp/widget/form/DateTimeField.js */

/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.form.DateTimeField
 * @extends Ext.form.FieldContainer DateTimeField widget capable of allowing
 *          user input or select the date and time
 * @xtype xcp_date_time_input
 */
Ext.picker.Date.override({
    onRender : function(container, position){
 
        var me = this;
        this.callOverridden(arguments);
        me.monthBtn.setTooltip("");
        me.todayBtn.setTooltip("");
    }
});

//The workaround for XCPUIC-2768
//it will be deleted if extjs bug (Sencha Support: Ticket #8572) is fixed.
Ext.form.field.Time.override({
    isFirstRefresh: true,
    onListRefresh: function() {
        this.alignPicker();
        if (!this.isFirstRefresh) {
            this.syncSelection();
        }
        this.isFirstRefresh = false;
    }
});

Ext.define('xcp.widget.form.DateTimeField', {
    extend:'Ext.form.FieldContainer',
    mixins: {
        field: 'Ext.form.field.Field',
        xcpFixedFieldWidthModelMixin : 'xcp.util.mixin.FixedFieldWidthModelMixin'
    },
    statics: {
    	// constant for datetime style
    	/**
    	 * the default style of datetime
    	 */
        DATE_TIME_STYLE : "datetime",

    	/**
    	 * the style of date
    	 */
        DATE_STYLE : "date",

    	/**
    	 * the style of historical date
    	 */
        HISTORICAL_DATE_STYLE : "historical_date",

        /**
         * the width of date field in date time field.
         */
        DEFAULT_DATE_FIELD_WIDTH_PERCENT : 55,
        /**
         * the width of time field in date time field.
         */
        DEFAULT_TIME_FIELD_WIDTH_PERCENT : 45,
        /**
         * the date value format is used to communicate with server.
         */
        BACKEND_DATE_VALUE_FORMAT : 'Y-m-d\\T',
        /**
         * the time value format is used to communicate with server.
         */
        BACKEND_TIME_VALUE_FORMAT : 'H:i:s.uO'
        
	},
    alias: 'widget.xcp_date_time_input',
  
    /**
     * @cfg {Boolean} combineErrors
     * If set to true, the field container will automatically combine and display the validation errors from
     * all the fields it contains as a single error on the container, according to the configured
     * {@link #msgTarget}. Defaults to false.
     */
    combineErrors: true,
    /**
     * @cfg {String} msgTarget <p>The location where the error message text should display.
     * Must be one of the following values:</p>
     * <div class="mdetail-params"><ul>
     * <li><code>qtip</code> Display a quick tip containing the message when the user hovers over the field. This is the default.
     * <div class="subdesc"><b>{@link Ext.tip.QuickTipManager#init Ext.tip.QuickTipManager.init} must have been called for this setting to work.</b></div></li>
     * <li><code>title</code> Display the message in a default browser title attribute popup.</li>
     * <li><code>under</code> Add a block div beneath the field containing the error message.</li>
     * <li><code>side</code> Add an error icon to the right of the field, displaying the message in a popup on hover.</li>
     * <li><code>none</code> Don't display any error message. This might be useful if you are implementing custom error display.</li>
     * <li><code>[element id]</code> Add the error message directly to the innerHTML of the specified element.</li>
     * </ul></div>
     */
    msgTarget :'qtip',
    /**
     * @cfg {String} layout
     * The layout of datetime field container
     */
    layout: {
        type: 'hbox',
        align: 'middle'
    },
    /**
     * the date time value format is used to communicate with server.
     */
    valueFormatStr : null,
    /**
     * @cfg {Object} value
     * A value to initialize this field with.
     */
    value:null,
    /**
     * the configuration of datefield
     */
    dateCfg:{},
    /**
     * the configuration of timefield
     */
    timeCfg:{},
    /**
     * the configuration of datetime style 
     */
    dateStyle:null,
    /**
     * @cfg {Integer} fieldWidth
     * The width of datetime field (not include label)
     */
    fieldWidth: null,

    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {
            return newValue;
        }
    }],

    /**
     * @cfg {Boolean} autoFitErrors
     * Whether to adjust the component's body area to make room for 'side' or 'under'
     * {@link #msgTarget error messages}.
     */
    autoFitErrors: false,
    /**
     * Creates new form.
     * @param {Object} init configuration
     */
    constructor: function(config) {
    	var me = this;

        this.dateStyle = xcp.widget.form.DateTimeField.DATE_TIME_STYLE;

        // Check if formatting is configured
        if (config && config.format) {
            // Create formatter instance
            this._formatter = xcp.core.FormatManager.create(config.format);
            if (!Ext.isEmpty(config.format.dateStyle))
                this.dateStyle = config.format.dateStyle;
        }
        this.valueFormatStr = xcp.widget.form.DateTimeField.BACKEND_DATE_VALUE_FORMAT+xcp.widget.form.DateTimeField.BACKEND_TIME_VALUE_FORMAT;
        xcp.widget.form.Form.encodeFieldLabel(config);
        me.callParent(arguments);
        this.mixins.xcpFixedFieldWidthModelMixin.constructor.call(this, "fieldWidth");
    },
    //@protected
    initComponent: function() {
        var me = this;
        me.buildField();
        me.callParent();
        this.dateField = this.down('datefield');
        this.dateField.on('change',this.onDateTimeFieldChange,this);
        if(this.dateStyle == xcp.widget.form.DateTimeField.DATE_TIME_STYLE){
        	this.timeField = this.down('timefield');
        	this.spacer = this.down('tbspacer');
        	this.timeField.on('change',this.onDateTimeFieldChange,this);
        }
        
        me.addEvents(
                /**
                 * @event focus
                 * Fires when this field receives input focus.
                 * @param {xcp.widget.form.DateTimeField} this
                 */
                'focus',  // $NON-NLS-1$ 
                /**
                 * @event blur
                 * Fires when this field loses input focus.
                 * @param {xcp.widget.form.DateTimeField} this
                 */
                'blur'
        );
    },
    
    onDateTimeFieldChange: function( field, newValue, oldValue, eOpts){    	      
    	if(this.dateStyle == xcp.widget.form.DateTimeField.DATE_TIME_STYLE){
            //both of day and time are not empty
    		if (!Ext.isEmpty(this.dateField.getValue()) && !Ext.isEmpty(this.timeField.getValue())){
    			var date = this.dateField.getValue(); 
    			var time = this.timeField.getValue();
                this.value = this.getDateValue(date,time);
                this.fireEvent('change',this,this.getValue());
    		}
            //neither of day nor time has value
            else if (Ext.isEmpty(this.dateField.getValue()) && Ext.isEmpty(this.timeField.getValue())){
    			this.value = null;
    			this.fireEvent('change',this,this.getValue());
    		}
            //time is empty but not day and change comes from time widget (XCPUIC-1056)
            else if (!Ext.isEmpty(this.dateField.getValue()) 
                    && Ext.isEmpty(this.timeField.getValue())
                    && field === this.timeField) {
                this.value = this.dateField.getValue();
                this.fireEvent('change',this,this.getValue());
            }
            // time is empty and change comes from date field
            else {
                this.fireEvent('change',this,this.getValue());
            }
    	}else{
    		this.value = this.dateField.getValue(); 
    		this.fireEvent('change',this,this.getValue(),oldValue);
    	}
    },
    handleFocusChange : function() {
        var hasFocusEvent = this.hasFocusEvent;
        delete this.hasFocusEvent;
		if (!this.isDestroyed) {
			if (hasFocusEvent) {
				this.fireEvent("focus", this, "");
			} else {
				this.fireEvent("blur",  this, "");
			}
	    }
    },

    onFocus : function () {
        this.hasFocusEvent = true;
        if (!this.delayedFocusChangeTask) {
            this.delayedFocusChangeTask = new Ext.util.DelayedTask(this.handleFocusChange, this);
        }
        this.delayedFocusChangeTask.delay(100);
    },

    onBlur : function () {
        if (!this.delayedFocusChangeTask) {
            this.delayedFocusChangeTask = new Ext.util.DelayedTask(this.handleFocusChange, this);
        }
        this.delayedFocusChangeTask.delay(100);
    },
    
    
    /**
     * Sets the read-only state of this field.
     * @param {Boolean} readOnly True to prevent the user changing the field and click the trigger.
     */
    setReadOnly: function(readOnly) {
        if (readOnly) {
            if (this.dateField) {
                this.dateField.bodyEl.mask();
            }
            if (this.timeField) {
                this.timeField.bodyEl.mask();
            }
        } else {
            if (this.dateField) {
                this.dateField.bodyEl.unmask();
            }
            if (this.timeField) {
                this.timeField.bodyEl.unmask();
            }
        }
        this.doComponentLayout();
    },

    /**
     * XCPUIC-1367, Override setDisabled function to enable or disable the component.
     * Turn the config option "maskOnDisable" to true dose not help.
     * @param {Boolean} disabled True to disable.
     */
    setDisabled : function(disabled) {
        return this.setReadOnly(disabled);
    },

    // @private
    buildField: function(){
        var me = this;
        if (!Ext.isEmpty(this.value) && Ext.isString(this.value)){
        	var dt = new Date();
        	dt = Ext.Date.parse(this.value, 'c');
        	this.value = dt;
        }
        if (!Ext.isEmpty(this._formatter)){
        	this.dateCfg ={format:this._formatter.getDateFormatString(),emptyText:this.emptyText};
        	this.timeCfg ={format:this._formatter.getTimeFormatString()};
        }
        if(this.dateStyle == xcp.widget.form.DateTimeField.DATE_TIME_STYLE){
        	this.items = [
        	              Ext.apply({
        	                  xtype: 'datefield',
        	                  flex : xcp.widget.form.DateTimeField.DEFAULT_DATE_FIELD_WIDTH_PERCENT,
        	                  value: this.value,
        	                  validateOnChange: false,
                             clearInvalid: function(){
                                 return me.clearInvalid();
                             }
        	              },this.dateCfg),
        	              { xtype: 'tbspacer', width: 5 },
        	              Ext.apply({
        	                  xtype: 'timefield',
        	                  flex : xcp.widget.form.DateTimeField.DEFAULT_TIME_FIELD_WIDTH_PERCENT,
        	                  value: this.value,
        	                  validateOnChange: false,
                             clearInvalid: function(){
                                 return me.clearInvalid();
                             }
        	              },this.timeCfg)
        	          ]
        }else{
        	this.items = [
        	              Ext.apply({
        	                  xtype: 'datefield',
        	                  flex : 1,
        	                  validateOnChange: false,
        	                  value: this.value
        	              },this.dateCfg)
        	          ]
        }
    },
    onRender: function() {
    	var me = this;
    	me.callParent(arguments);
        var timeField  = me.timeField;
        if (timeField) {
            timeField.on("focus", this.onFocus, me);
            timeField.on("blur", this.onBlur, me);
			timeField.on("render", function() {var me = this;this.timeField.triggerEl.on("mousedown",this.onFocus, me);}, me);
        }
        var dateField  = me.dateField;
        if (dateField) {
            dateField.on("focus", this.onFocus, me);
            dateField.on("blur", this.onBlur, me);            
			dateField.on("render", function() {var me = this;this.dateField.triggerEl.on("mousedown",this.onFocus, me);}, me);
        }
    },

    // @private
    getDateValue: function(date,time){
    	if (Ext.isEmpty(date)||Ext.isEmpty(time) || !this._formatter){
    		return null;
    	}
    	return this._formatter.parse(this._formatter.formatDate(date)+" "+this._formatter.formatTime(time));
    },
    /**
     * Returns the current datatime value as a string. The invalid value will also be return if the fields are invalid.
     */
    getValue: function() {
        var date = this.dateField.getValue();
        var value = date, time;

        if(this.dateStyle == xcp.widget.form.DateTimeField.DATE_TIME_STYLE){
            time = this.timeField.getValue();
            if (!Ext.isEmpty(time) && !Ext.isEmpty(date)) {
                value = this.getDateValue(date,time);
            }
        }
        else if(!Ext.isEmpty(date) && this.dateStyle == xcp.widget.form.DateTimeField.HISTORICAL_DATE_STYLE){
            try {
                //To historical date widget only, convert the local date time (mid-night of the day)
                // into the UTC mid-night of same date
                value = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
            } catch (error) {
                //catch the parsing error if it exists, no need to do anything here. the invalid value will be handled in later statements
            }
        }

        if (!Ext.isEmpty(value)){
        	value = Ext.Date.format(value, this.valueFormatStr);
        }

        //value is still empty return the original value which will not accepted by the service.
        //The invalid value will be shown in the service error messages.
        if (Ext.isEmpty(value)){
            value = !Ext.isEmpty(date) ? date.toString() : "";
            value = !Ext.isEmpty(time) ? (value + " " +time.toLocaleTimeString()) : value;
        }

        return value;
    },
    /**
     * Returns the raw String value of the field, without performing any normalization, conversion, or validation. Gets
     * the current value of the input element if the field has been rendered, ignoring the value if it is the
     * {@link #emptyText}. To get a normalized and converted value see {@link #getValue}.
     * @return {String} The raw String value of the field
     */
    getRawValue:function(){
    	return this.value;
    },
    /**
     * Sets a data value into the field and runs the change detection and validation. To set the value directly
     * without these inspections see {@link #setRawValue}.
     * @param {Object} value The value to set
     * @return {Ext.form.field.Field} this
     */
    setValue: function(value){
    	if (!Ext.isEmpty(value) && Ext.isString(value)){
        	var dt = new Date();
            //parse the date time string into a local date object
        	dt = Ext.Date.parse(value, 'c');
            //eliminate the time zone offset (min) to the local date if the datetime widget is a date widget only
            if (this.dateStyle == xcp.widget.form.DateTimeField.HISTORICAL_DATE_STYLE) {
				dt = new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate(), dt.getUTCHours(),dt.getUTCMinutes(), dt.getUTCSeconds());
			}
			this.value = dt;
        }else{
        	this.value = value;
        }
        this.dateField.setValue(this.value);
        if(this.dateStyle == xcp.widget.form.DateTimeField.DATE_TIME_STYLE){
        	this.timeField.setValue(this.value)
        }
    },
    /**
     * Returns the value that would be included in a standard form submit for this field. This will be combined with the
     * field's name to form a name=value pair in the {@link #getSubmitData submitted parameters}. If an empty string is
     * returned then just the name= will be submitted; if null is returned then nothing will be submitted.
     *
     * Note that the value returned will have been {@link #processRawValue processed} but may or may not have been
     * successfully {@link #validate validated}.
     *
     * @return {String} The value to be submitted, or null.
     */
    getSubmitValue: function(){
        var value = this.getValue();
        return Ext.isDate(value) ? Ext.Date.format(value, this.valueFormatStr) : value;
    },
    // private override to use getSubmitValue() as a convenience
    getSubmitData: function(){
    	var me = this,
        data = null;
	    if (!me.disabled && me.submitValue && !me.isFileUpload()) {
	        data = {};
	        data[me.getName()] = me.getSubmitValue();
	    }
	    return data;
    },
    beforeDestroy : function() {
        
        this.dateField.un('change',this.onDateTimeFieldChange);  // $NON-NLS-1$ 
        if(this.dateStyle == xcp.widget.form.DateTimeField.DATE_TIME_STYLE){
        	this.timeField.un('change',this.onDateTimeFieldChange);  // $NON-NLS-1$ 
        }
        var me = this;
        me.callParent();
    },

    /**
     * Mark date and time both fields invalid.
     *
     * @param errors
     */
    markInvalid:function(errors){
        this.dateField.markInvalid(errors);
        if(this.dateStyle == xcp.widget.form.DateTimeField.DATE_TIME_STYLE) {
            this.timeField.markInvalid(errors);
        }
    },

     clearInvalid: function(){
         Ext.form.field.Date.prototype.clearInvalid.apply(this.dateField, arguments);
         if(this.dateStyle == xcp.widget.form.DateTimeField.DATE_TIME_STYLE) {
            Ext.form.field.Time.prototype.clearInvalid.apply(this.timeField, arguments);
         }
     },

    /**
     * Override Ext.form.FieldContainer getCombinedErrors function to avoid duplicated error messages.
     *
     * @param {Ext.form.field.Field[]} invalidFields An Array of the sub-fields which are currently invalid.
     * @return {String[]} The combined list of error messages
     */
    getCombinedErrors: function(invalidFields) {
        var forEach = Ext.Array.forEach,
            errors = [];
        forEach(invalidFields, function(field) {
            forEach(field.getActiveErrors(), function(error) {
                var label = field.getFieldLabel();
                if (!label){
                    for(var i = 0; i < errors.length; i++){
                        if(errors[i] == error){
                            return;
                        }
                    }
                    errors.push(error);
                }
                else
                    errors.push(label + ': ' + error);
            });
        });
        return errors;
    },

    /**
     * Returns the {@link Ext.form.field.Field#name name} attribute of the field. This is used as the parameter name
     * when including the field value in a {@link Ext.form.Basic#submit form submit()}.
     * @return {String} name The field {@link Ext.form.field.Field#name name}
     */
	getName: function() {
		var name = this.name;
		if (Ext.isEmpty(name)) {
			name = this.getInputId();
			if (Ext.isEmpty(name)) {
				name = this.id + "-inputEl";
			}
		}
		return name;
	}
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// DelegateTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.DelegateTaskDataAction");
Ext.apply(xcp.Strings.action.task.DelegateTaskDataAction, {
    confirmationTitle: "Delegate Task?",
    confirmationPromptTemplate: "Are you sure you want to delegate this task?",
    updateSuccessNotificationTemplate:  "The task has been delegated.",
    updateErrorTemplate: "An error occurred while delegating this task. Please try again."
});
/* xcp_delegate_task/content/xcp/action/task/DelegateTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// DelegateTaskDataAction.js

/**
 * @class xcp.action.task.DelegateTaskDataAction
 * @extends xcp.action.task.BaseTaskDataAction
 * Action implementation for delegating a task.
 */
Ext.define("xcp.action.task.DelegateTaskDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_delegate_task",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        objectTypePropName: "activity_system_name",
        showConfirmation: false
    },

    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if(baseAction.isContextMenuAction(action) && baseAction.isTaskViewPageExist(actionArgs, action)) {
            return xcp.Enablement.HIDE;
        }

        if (!baseAction.isQueueTask(actionArgs, action)) {
            //Superuser, sysadmin, supervisor
            applicable = baseAction.isTaskActionApplicable(actionArgs,action,true,true,true,false,1);
            if (!applicable) {
                //Check if task is marked as delgatable by task performer
                var isdelegable = baseAction.getTaskAttribute(actionArgs, action,"isdelegable");
                if (isdelegable) {
                    //Is Task performer
                    applicable = baseAction.isTaskActionApplicable(actionArgs,action,false,false,false,true,1);
                }
            }
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;

    },

    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.DelegateTaskDataAction";
    }
});

/* xcp_delegate_task/content/xcp/data/model/DelegateTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("delegate_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/delegate"
    },
    "fields" : [
        {
            "name" : "id",
            "type" : "string"
        },
        {
            "name" : "userName",
            "type" : "string"
        }
    ]
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// Paste-strings.js

Ext.namespace("xcp.Strings.action.DownloadFileAction");
Ext.apply(xcp.Strings.action.DownloadFileAction, {
    text: "Download",
    tooltip: "Download the file"
});


/* xcp_downloadfile/content/xcp/action/DownloadFileAction.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.DownloadFileAction
 * @extend xcp.action.Action
 *
 * Implementation of download-file action.
 */
Ext.define("xcp.action.DownloadFileAction", {
    extend: "xcp.action.Action",
    alias: "action.xcp_downloadfile",

    config: {
        text: xcp.Strings.action.DownloadFileAction.text,
        tooltip: xcp.Strings.action.DownloadFileAction.tooltip,

        requiredAttributes: ["effectivePermissions"],
        preconditions: {
            targets:{
                effectivePermissions: [xcp.Permit.READ]
            }
        }
    },
    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var target = action.getTargets(actionArgs)[0];
        if (target) {
            var url = "application/document/" + target.getId();
            if (Ext.is.iPad) {
                window.open(url, "_blank");
            } else {
                var downloadIFrame = xcp.action.DownloadFileActionUtil.getDownloadIFrame();
                downloadIFrame.src = url;
            }
        }
    }
});

xcp.action.DownloadFileActionUtil = {
    getDownloadIFrame: function()
    {
        var iframeContainerID = 'xcp_thinclient_download_iframe_container';
        var iframeContainer = document.getElementById(iframeContainerID);
        if (iframeContainer == null)
        {
            iframeContainer = document.createElement('DIV');
            iframeContainer.id = iframeContainerID;
            document.body.appendChild(iframeContainer);

            //	Create new iframes and attach them to our container
            var iframe = document.createElement('IFRAME');
            iframe.width = 0+'px';
            iframe.height = 0+'px';
            iframe.style.display = 'none';
            iframeContainer.appendChild(iframe);
            return iframe
        } else
            return iframeContainer.firstChild;
    }
};

/* xcp_dropdown_list/content/xcp/widget/form/DropdownList.js */

/**
 * @class xcp.widget.form.DropdownList
 * @extends Ext.form.field.Combobox
 * @xtype xcp_dropdown_list
 */
Ext.define("xcp.widget.form.DropdownList", {
    extend: "Ext.form.field.ComboBox",
    alias: "widget.xcp_dropdown_list",
    mixins : {
        xcpFixedFieldWidthModelMixin : 'xcp.util.mixin.FixedFieldWidthModelMixin',
        xcpDropDownMixin : 'xcp.util.mixin.DropdownMixin'
    },
    constructor: function(config) {
        this.mixins.xcpDropDownMixin.constructor.call(this, config);
        this.callOverridden(arguments);
        this.mixins.xcpFixedFieldWidthModelMixin.constructor.call(this, "fieldWidth");  // $NON-NLS-1$
    },
    assertValue: function() {
        // Need to override assertValue to allow for clearing of values, simply having the same
        // method in the mixin doesn't allow for overriding the base class method, so using the mixin code as
        // library code so it can be shared between single and multi value dropdown implementations
        this.mixins.xcpDropDownMixin.assertValue.call(this);
    },
    setValue: function(value, doSelect) {
        if (!this.dataSourceStoreLoaded) {
            // XCPUIC-3422:  If the data store isn't loaded yet, the call to the parent version of setValue will do a
            // comparison against an empty store.  Since we have the forceSelection flag set, this will cause
            // the value to be thrown out as it doesn't match any existing value.  We save the value, so that we can
            // initialize the widget after the data source values are retrieved and we have valid values for
            // comparison.
            this.initialXcpValue = value;
        }
        this.callParent(arguments);
    }
});

/* xcp_dropdown_list_multi/content/xcp/widget/form/DropdownListMulti.js */

/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.form.DropdownList
 * @extends Ext.form.field.Combobox
 * @xtype xcp_dropdown_list
 */
Ext.define("xcp.widget.form.DropdownListMulti", {
    alias: "widget.xcp_dropdown_list_multi",
    extend: "Ext.ux.form.field.BoxSelect",
    growMax: 60,
	// height = growMax + borders, margins, padding, etc.
	height: 62,
  	mixins : {
        xcpFixedFieldWidthModelMixin : 'xcp.util.mixin.FixedFieldWidthModelMixin',
        xcpDropDownMixin : 'xcp.util.mixin.DropdownMixin'
    },
    constructor: function(config) {
		this.mixins.xcpDropDownMixin.constructor.call(this, config);
        this.callOverridden(arguments);
        this.mixins.xcpFixedFieldWidthModelMixin.constructor.call(this, "fieldWidth");  // $NON-NLS-1$
    },
    assertValue: function() {
        // Need to override assertValue to allow for clearing of values, simply having the same
        // method in the mixin doesn't allow for overriding the base class method, so using the mixin code as
        // library code so it can be shared between single and multi value dropdown implementations
        this.mixins.xcpDropDownMixin.assertValue.call(this);
    },
    setValue: function(value, doSelect) {
        if (!this.dataSourceStoreLoaded) {
            // XCPUIC-3422:  If the data store isn't loaded yet, the call to the parent version of setValue will do a
            // comparison against an empty store.  Since we have the forceSelection flag set, this will cause
            // the value to be thrown out as it doesn't match any existing value.  We save the value, so that we can
            // initialize the widget after the data source values are retrieved and we have valid values for
            // comparison.
            this.initialXcpValue = value;
        }
        this.callParent(arguments);
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// EditFile-strings.js

Ext.namespace("xcp.Strings.action.EditFile");
Ext.apply(xcp.Strings.action.EditFile, {
    text: "Edit Document",
    tooltip: "Edit Document",
    attributeEditWarning: "This item is currently locked by <{0}> and cannot be modified. Please try again later.",
    noPermitWarning: "You do not have the required permission to modify this item (WRITE permission is required)."
});


/* xcp_editfile/content/xcp/action/EditFile.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.EditFile
 * @extend xcp.action.Action
 *
 * Implementation of Edit document action.
 */
Ext.define("xcp.action.EditFile", {
    extend: "xcp.action.Action",
    alias: "action.xcp_editfile",
    config : {
        text: xcp.Strings.action.EditFile.text,
        tooltip: xcp.Strings.action.EditFile.tooltip,
        page : "",
        requiredAttributes: ["effectivePermissions","r_lock_owner"],
        preconditions: {
            targets:{
                effectivePermissions: [xcp.Permit.WRITE]
            }
        }
    },

    getEnablement:function(actionArgs, action){
        var target = action.getTargets(actionArgs)[0];
        if (target){
            var lockOwner = target.get('r_lock_owner');
            if (lockOwner !== '')
                return xcp.Enablement.HIDE;
        }
        if (Ext.is.iPad) {
            // No way to select files for import on iPad, so don't even show this action
            return xcp.Enablement.HIDE;
        } else {
            return xcp.Enablement.ENABLE;
        }
    },

    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var targets = action.getTargets(actionArgs);
        var target = action.getTargets(actionArgs)[0];

//        if (!target) {
//            /* Case to handle when actionArgs.selection is undefined, we get id from xcp.navigationManager */
//            console.debug("actionArgs.selection is undefined");
//            if (Ext.isDefined(xcp.navigationManager))
//                id = xcp.navigationManager.currentNavigationContext.objectId;
//        }

        if (target) {
            var typeName = actionArgs.getTypeName(target);
            var id = target.getId();
            Ext.Ajax.request(
            {
                method: 'POST', url: Ext.String.format('application/{0}/{1}/lock', typeName, id),
                scope: this,

                success: function(response, options)
                {
                    var downloadIFrame = xcp.action.DownloadFileActionUtil.getDownloadIFrame();
                    downloadIFrame.src = "application/document/" + id;

                    //Application Level event fired (handler will update the lock status on page)
                    if (xcp.event && xcp.event.EventBus) {
                        xcp.event.EventBus.publish(xcp.event.ItemLockedEvent.ITEM_LOCKED_EVENT, id);
                }

                },
                failure: function(response, options)
                {
                    Ext.MessageBox.alert('Server Error', response.responseText);
                }
            });

        } else {
                //We always are going to have typeName and id, otherwise something is wrong and we will throw an error.
                console.error("Error locking the document.");
            }
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// CreateAction-strings.js

Ext.namespace("xcp.Strings.action.report.ExportToExcel");
Ext.apply(xcp.Strings.action.report.ExportToExcel, {
    confirmationTitle: "Create item?",
    confirmationPromptTemplate: "Are you sure you want to download report data in Excel fomat?",
    createSuccessNotificationTemplate:  "The report has been downloaded.",
    createErrorTemplate: "An error occurred while creating this item. Please try again."
});
/* xcp_export_to_excel/content/xcp/action/report/ExportToExcel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */


// ExportToExcel.js

/**
 * @class xcp.action.report.ExportToExcel
 * @extends xcp.action.form.DataAction
 * Action implementation for creating resources within an xCP application.
 */
Ext.define("xcp.action.report.ExportToExcel", {
    extend: "xcp.action.form.DataAction",
    alias: "action.xcp_export_to_excel",

    statics: {
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    var data = Ext.JSON.decode(operation.response.responseText);
                    url = action.redirectUrlModel + "/" + data.id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        }
    },

    config: {
        /**
         * @cfg {String} confirmationPrompt Pattern for string used as confirmation prompt (defaults to
         * Are you sure you want to create an item"?)
         */
        confirmationPrompt: xcp.Strings.action.form.CreateAction.confirmationPromptTemplate,
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false
    },

    /**
     * Handler for the CreateAction
     */
    handler: function(actionArgs, action) {
        var config = this.getConfig();

//        //update action's input model when action is invoked.
//        if (!Ext.isEmpty(actionArgs.selection))
//            this.setInputModel(actionArgs.selection[0]);

        var model = this.getActionModel();

        var handleCreateSuccess = function(record, operation) {
            if (this.showSuccessNotification) {
                xcp.action.form.DataAction.notifyActionSuccess(this.ownerCt || actionArgs.component, xcp.Strings.action.form.CreateAction.createSuccessNotificationTemplate, model);
            }
            xcp.action.form.CreateAction.handleRedirection(this, record, operation);

        };
        var handleGetNextTaskFailure = function(record, operation) {


        };
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    var modelClass = model.modelName
                    var urlToLoad = Ext.ClassManager.get(modelClass).getProxy().url;
                    urlToLoad = urlToLoad + "?type="+model.modelName+"&action=export";
                    id = 'dm_exort_to_excel';
					frame = document.createElement('iframe');
					frame.id = id;
					frame.name = id;
					frame.className = 'x-hidden';
					frame.src = urlToLoad;
					document.body.appendChild(frame);
                }
            };

            Ext.Msg.show({
                title:  xcp.Strings.action.form.CreateAction.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.form.CreateAction.confirmationPromptTemplate, model),
                scope: this
            });
        } else {
            var modelClass = model.modelName
            var urlToLoad = Ext.ClassManager.get(modelClass).getProxy().url;
            urlToLoad = urlToLoad + "?type="+model.modelName+"&action=export";
            id = 'dm_exort_to_excel';
            frame = document.createElement('iframe');
            frame.id = id;
            frame.name = id;
            frame.className = 'x-hidden';
            frame.src = urlToLoad;
            document.body.appendChild(frame);
        }
    }
});

/* xcp_folder_view/content/xcp/widget/folder/FolderView.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.widget.folder.FolderView", {
            extend:'Ext.panel.Panel',
            alias:"widget.xcp_folder_view",

            constructor:function (config) {
                var me = this;
                config = config || {};
                me.runtime = Ext.isDefined(xcp.navigationManager);
                (me.runtime) ? me.runTimeWidget(config) : me.designTimeWidget(config);
                me.config = config;
                xcp.widget.folder.FolderView.superclass.constructor.apply(this, [config]);
            },

            initComponent:function () {
                var me = this;
                var toolTip = me.tooltip;
                // render event required to set up tooltip
                if (toolTip) {
                    me.on("render", function () {
                        me.setToolTip(toolTip);
                    }, me);
                }
                if (me.runtime) {
                    if (xcp.event)
                        xcp.event.EventBus.subscribe(this.id + "_nav_url", this.setPage, this, null);
                    me.on("beforedestroy", me.cleanUp, me);
                }
                xcp.widget.folder.FolderView.superclass.initComponent.call(me);
            },

            cleanUp:function () {
                xcp.event.EventBus.unsubscribe(this.id + "_nav_url");
                xcp.core.PageContextManager.remove(this.down('xcp_page').getPageContextID());
            },

            runTimeWidget:function (config) {
                if (!config.height)
                    config.height = 440;
                var titleHt = (config.title) ? 40 : 15;
                var treeCfg = {"isID":config.isID,
                    "height":config.height - titleHt,
                    "showRootFiles":config.showRootFiles,
                    "navigateOnItemClick":false,
                    "showOnlyFolders": false,
                    "showContextMenu":true
                };

                config.cls ? Ext.apply(treeCfg, {"cls":config.cls}) : Ext.apply(treeCfg, {"cls": 'xcp_content_tree-cls'});
                config.plugins ? Ext.apply(treeCfg, {"plugins":config.plugins}) : Ext.apply(treeCfg, {"root":""});

                treeCfg = Ext.apply(treeCfg, {
                    plugins : (config["plugins"] || []).concat(["xcp_tree_itemeventplugin"])
                });

                var folderContentTree = new xcp.widget.tree.FolderViewContentTree(treeCfg);
                var folderContentArea = new xcp.widget.Page({insideFolderView:true, autoScroll:true, height:config.height - titleHt});
                var itemsCfg = [
                    {
                        "xtype":"xcp_column_box",
                        defaults:{
                            "xtype":"xcp_columnvbox"
                        },
                        "items":[
                            {"width":"20%", "items":[folderContentTree], "defaultMargins" : '5 0 5 5'},
                            {"xtype":'splitter', "orientation":'vertical', collapseDirection: 'right'},
                            {"items":[folderContentArea], "defaultMargins":'5 5 5 0'}
                        ]
                    }
                ];
                Ext.apply(config, {items:itemsCfg});
            },

            setToolTip: function(tt) {
                if (this._tt) {
                    this._tt.destroy();
                    delete this._tt;
                }
                this._tt = Ext.create("Ext.tip.ToolTip", {
                            target: this.el,
                            html: tt
                        });
            },

            // Sets the default view page for the item selected in Folder View Content Tree
            setPage:function (eventName, item) {
                var page = this.down("xcp_page");
                if (page.getPageContextID())
                    xcp.core.PageContextManager.remove(page.getPageContextID());

                var pageUrl, model = item.model || "xcp_folderlist_0";
                var targetId = item.get("id");

                if (targetId == "root")
                    model = "xcp_dm_folder";

                var id = (targetId == "root") ? null : targetId;
                pageUrl = xcp.util.Utils.frameUrl(model, id, null, xcp.core.UserProfile.getRole());

                Ext.Ajax.request({
                            url:pageUrl,
                            scope:this,
                            disableCaching:false,
                            success:function (response) {
                                var responseText = response.responseText;
                                var pageConfig = Ext.JSON.decode(responseText);

                                page.setPageContext(pageConfig, targetId);
                                if (pageConfig && page)
                                    page.replaceChild(pageConfig);

                            },
                            failure:function (response, options) {
                                var message = Ext.String.format(xcp.Strings.core.NavigationManager.pageFetchError, pageUrl);
                                xcp.core.FeedbackManager.showFeedback(null, "", message, "systemErrors", false);
                            }
                        });
            },

            // Expression setter fn called if folder Root has an expression mapping
            setFolderRoot:function (rootValue) {
                if (!!rootValue) {
                    xcp.Logger.debug('FolderView: setFolderRoot as ' + rootValue);
                    var tree = this.down("xcp_folderview_content_tree");
                    var root = {
                        path:rootValue,
                        contentTree:tree,
                        expanded:true
                    };
                    tree.setRootNode(root);

                    var page = this.down("xcp_page");
                    var owner = page.ownerCt;
                    var ht = page.height;
                    owner.remove(page);
                    owner.insert(0, {xtype:"xcp_page",
                                insideFolderView:true,
                                autoScroll:true,
                                height: ht
                            });
                }
            },

            designTimeWidget:function (config) {

                function renderName(val) {
                    return '<a href>' + val + '</a>';
                }

                Ext.define('dummyModel', {
                            extend: 'Ext.data.Model',
                            fields: [ 'name' ]
                        });
                var folderStore = Ext.create('Ext.data.Store', {
                            pageSize:10,
                            model: 'dummyModel',
                            data: [
                                { name: xcp.Strings.widget.folder.designer.FolderView.a_folder},
                                { name: xcp.Strings.widget.folder.designer.FolderView.an_open_folder},
                                { name: xcp.Strings.widget.folder.designer.FolderView.myfiledotdoc}
                            ]
                        });

                Ext.applyIf(config, {
                            "items" :{
                                "xtype" : "xcp_column_box",
                                "items" : [
                                    {
                                        "xtype" : "xcp_column_box",
                                        "orientation" : "Vertical",
                                        "width" : "30%",
                                        "items" : [
                                            {
                                                "xtype":"xcp_content_tree",
                                                "showRootFiles":true,
                                                "rootLabel": xcp.Strings.widget.folder.designer.FolderView.rootFolder
                                            }
                                        ]
                                    },
                                    {
                                        "xtype" : "xcp_columnvbox",
                                        "items" : [
                                            {
                                                "xtype" : "xcp_column_box",
                                                "items" : [
                                                    {

                                                        "xtype" : "xcp_column_box",
                                                        "width":"60%",
                                                        "defaultMargins" : "0",
                                                        "items" : [
                                                            {
                                                                 xtype:'label',
                                                                text: xcp.Strings.widget.folder.designer.FolderView.rootFolder,
                                                                style: 'font-weight:bold;color:grey;'
                                                            }
                                                        ]
                                                    },
                                                    {
                                                        "xtype" : "xcp_column_box",
                                                        "halign":'right',
                                                        "width":"40%",
                                                        "defaultMargins" : "0",
                                                        "items" : [
                                                            {
                                                                xtype:'button',
                                                                text: xcp.Strings.widget.folder.designer.FolderView.createFolder
                                                            },
                                                            {
                                                                xtype:'button',
                                                                text: xcp.Strings.widget.folder.designer.FolderView.deletebutton
                                                            }
                                                        ]
                                                    }
                                                ]
                                            },
                                            {
                                                "xtype" : "xcp_column_box",
                                                "defaultMargins" : "0",
                                                "items" : [
                                                    {
                                                        xtype:'grid',
                                                        store:folderStore,
                                                        columns:[
                                                            {
                                                                dataIndex: 'name',
                                                                text: xcp.Strings.widget.folder.designer.FolderView.name,
                                                                flex:1,
                                                                sortable:false,
                                                                renderer: renderName
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        });
            }
        });
/* xcp_folder_view/content/xcp/widget/tree/FolderViewContentTree.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// This widget implements a content tree that will be wrapped by the folderview widget having its root at a configurable
// point in the folder hierarchy, or at the repository root. Clicking on a
// node causes navigation within the content area of folderview to the view page of the specified object.

(function () {

    Ext.define("xcp.widget.tree.FolderViewContentTree",
        {
            extend:"xcp.widget.ContentTree",
            alias:"widget.xcp_folderview_content_tree",

            // Handler invoked when a node of the tree is clicked. Causes navigation inside folderview.
            onItemClick:function (tree, item, elem, index, evt, opts) {
                var targetId = item.get("id");
                if (!targetId || !xcp.util.Utils.isSupportedModel(item.model))
                    return;

                item.expand();

                /* for now clicking on the root will not navigate to a page.*/
                if (targetId == "root")
                    return;

                if (!item.parentNode && this.root_model)
                    item.model = this.root_model;
                if (xcp.event)
                    xcp.event.EventBus.publish(this.up('xcp_folder_view').id + '_nav_url', item);
            },

            // If folderPath is passed, update the rootname as the last node
            // If folder ID is passed, async load the model and get name
            getRootName:function (config, isId, callback) {

                var rootName = "", modelName;
                if (config.root) {
                    var elems = config.root.split("/");
                    rootName = elems[elems.length - 1];
                }

                if (rootName.length > 0 && isId) {
                    var model = Ext.ModelManager.getModel("xcp_folderlist_0");
                    if (!model) return;
                    xcp.Logger.debug('FolderViewContentTree: Load model for objectID: '+rootName);
                    model.load(rootName, { scope:this,
                        failure:function (record, operation) {
                             xcp.Logger.debug('FolderViewContentTree: Model load failed for id; '+rootName);
                        },
                        success:function (record, operation) {
                            modelName = record.get("r_object_type");
                            if (modelName == "dm_cabinet")
                                modelName = "xcp_dm_folder";

                            this.root_model = modelName;
                            if (callback && Ext.isFunction(callback)) {
                                callback.call(this, record);
                            }
                        }
                    });
                }
                if (isId)
                    return "";
                else if (modelName = config.modelName) {
                    if (modelName == "dm_cabinet")
                        modelName = "xcp_dm_folder";
                    this.root_model = modelName;
                }

                return rootName;
            },

            //do nothing, folderview will set the root
            setFolderRoot: function(root){
                return true;
            }

        });

})();/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.form.Form");

Ext.apply(xcp.Strings.widget.form.Form, {
    loadInstanceFailed: "Failed to load the instance '{0}'",
    objectIdMissing: "Object id is missing.",
    modelNotDefined: "Model '{0}' is not defined."
});
/* xcp_form/content/xcp/widget/form/Form.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// Form.js

/**
 * @class xcp.widget.form.Form
 * @extends Ext.form.FormPanel
 * FormPanel provides the extra features that include data loading, field calculation and
 * model validation, ect.
 * @param {Object} config Configuration options.
 * @xtype xcp_form
 */
Ext.define('xcp.widget.form.Form', {
    extend: 'Ext.form.FormPanel',
    alias: 'widget.xcp_form',
    mixins: {
        feedbackContainer: "xcp.util.mixin.FeedbackContainer"
    },
    "includeFeedbackTypes":["validationErrors"],

// dlm: this didn't work
//    xcpeventsub:[
//        {channel:xcp.event.ItemLockedEvent.NAME, handler: this.onItemModified},
//        {channel:xcp.event.ItemUnlockedEvent.NAME, handler: this.onItemModified},
//        {channel:xcp.event.ItemModified.NAME, handler: this.onItemModified}
//    ],
    statics:{
        getForm: function(component){
            if (!component) return null;
            var form=null;
            if (component.getXType().indexOf("xcp_form")!=-1)
                form = component;
            else{
                form = component.up("xcp_form");
            }
            return form;
        },
        /**
         *  Get the form model instance from component (if not form, finds form)
         * @param component
         */
        getFormModel: function(component){
            var form = this.getForm(component);
            if (form && Ext.isFunction(form.getModel))
                return form.getModel();
            xcp.Logger.error("can't getFormModel!");
            return null;
        },
        /**
         *  Get the form model instance from component (if not form, finds form)
         * @param component
         * @param callback  -- optional; if specified, model is returned when available.
         * @param scope  -- optional; scope for callback
         */
        getFormModel2: function(component, callback /*optional*/, scope /*optional*/){
            var model = null;
            var form = this.getForm(component);
            if (form && Ext.isFunction(form.getModel)){
                model=form.getModel();
                if (model && callback){
                    callback.call(scope || window, model, form)
                } else if(!model && callback){
                    form.on("load", callback, scope || window, {single:true});
                }
                else{
                    xcp.Logger.error("can't getFormModel!");
                }
            }
            return model;
        },

        encodeFieldLabel: function(fieldConfig) {
            if (!xcp.navigationManager)
                return; // ignore in design mode
            if (fieldConfig && fieldConfig.fieldLabel) {     // XCPECM-170
                fieldConfig.fieldLabel = Ext.htmlEncode(fieldConfig.fieldLabel);
            }
        }
    },
    constructor: function(config) {

        //Add event to event pub configuration
        var xcpeventpub=config.xcpeventpub;
        var xcpeventconfig = [];
        this.layoutSuspended=false;
        var modelName = null;
        if (!xcpeventpub) {
            xcpeventpub = [];
            if (Ext.isEmpty(config.models))
                config.models = [];
            for (var i = 0; i < config.models.length; i++) {

                modelName = config.models[i];
                var channelName = modelName + ".";
                var changeEvent = channelName + "change";  // $NON-NLS-1$ 
                var loadEvent = channelName + "load";  // $NON-NLS-1$ 
                //workaround to fire event on behalf of model.
                this.addEvents(
                    /**
                     * Fires when model loads or changes
                     */
                        changeEvent,
                        loadEvent);
                var changeEventPubConfig = {
                    event:changeEvent,
                    channel:changeEvent
                };
                var loadEventPubConfig = {
                    event:loadEvent,
                    channel:loadEvent
                };
                xcpeventpub.push(changeEventPubConfig);
                xcpeventpub.push(loadEventPubConfig);

                xcpeventconfig.push(changeEventPubConfig);
                xcpeventconfig.push(loadEventPubConfig);
            }
        }
        //add it to config and this object so that Publisher mixin can use it.
        config.xcpeventpub = xcpeventpub;
        config.xcpeventconfig = xcpeventconfig;
        this.xcpeventconfig=xcpeventconfig;
        this.xcpeventpub = xcpeventpub;

        this.loadModel = true;
        if (config.loadModel !== undefined && config.loadModel !== null) {
            this.loadModel=config.loadModel;            
        }
        this.addEvents("load");   // dlm temp need this for now at least! $NON-NLS-1$

        this.callParent(arguments);
    },
    destroy: function(){
        this.callParent(arguments);
        for (var i=0; i<this.subscriptions.length; i++) {
            xcp.event.EventBus.unsubscribe(this.subscriptions[i]);
        }
    },

    /**
     * Performs the following tasks 1)add model reference to the form,
     * 2)load the model instances and add a reference to the instances in this form.
     */
    initComponent: function() {
        var me = this, objectId, modelName, model, data;

        me.callParent(arguments);

        me.instances = {};
        me.modelNames = {};

        if (!me.objectId) {
            // TODO this is not initialized if the form is inside of a page
            if(Ext.isDefined(xcp.navigationManager))
                me.objectId = me.getPageObjectId();
        }

        objectId = (me.objectId) ? me.objectId : '';

        var basicForm = me.getForm();
        //Flag to keep track of registered model change events

        me.registeredModelChangeEvents={};

        basicForm.on("loadRecord", me.handleLoadRecord, me);
        basicForm.on("failedLoadRecord", me.handleFailedLoadRecord, me);
        for (var i = 0; i < me.models.length; i++) {

            modelName = me.models[i];
            model = Ext.ModelManager.getModel(modelName);

            if (model) {
                if (me.loadModel && model.getProxy() instanceof Ext.data.proxy.Server
                    && !(model.getProxy() instanceof xcp.proxy.FolderProxy && objectId=="")) {  // yuck: special case! avoid no id; returns all cabinets

                    // the action flow model can contan an api.read call in order to get the template url.
                    // in that case we don;t want that url to be appended with objectid so this
                    //  loadId will store objectId and loadId will be empty if api.read is a template url.
                    // all other cases will pass in the value of objectId to model.load().
                    var loadId = objectId;
                    if (model.getProxy().api.read && model.getProxy().api.read.indexOf("/template") > 0) {  // $NON-NLS-1$ 
                        loadId = "";
                    }

                    if( xcp.navigationManager.currentNavigationContext.versionRequested != null)
                        model.getProxy().extraParams.version = xcp.navigationManager.currentNavigationContext.versionRequested;
                    else
                    {
                        model.getProxy().setExtraParam('version',false);
                    }
                    xcp.Logger.info("Loading Model ..."+ model.prototype.modelName);
                    model.load(loadId, {
                        support404Redirect: "" != loadId, //don't do 404 redirect for template service
                        failure: function(instance, op){
                            me.fireEvent("load", me, instance);   // always fire event (need to know failure too)
                        },
                        success : function(instance) {
                            xcp.Logger.info("Loaded Model ..."+ model.prototype.modelName);
                            var currentObjectId = me.getPageObjectId();
                            var newObjId =   instance.data.id;          //might return a new object id if there is newer version

                            me.instances[instance.modelName] = instance;
                            me.pageModel = instance.modelName;
                            if (instance.modelName == "xcp.data.model.UserPreferences") {
                                xcp.UserPreferences = instance;
                            }
                            try {
                                me.suspendLayouts();
                                xcp.Logger.info("Loading the form data");
                                basicForm.loadRecord(instance);

                                if(currentObjectId && !Ext.isEmpty(currentObjectId) && !Ext.isEmpty(newObjId) && currentObjectId != newObjId) //
                                {
                                    var url = xcp.util.Utils.makePageUrl(instance.modelName,newObjId , null);
                                    window.location.hash =  url;
                                }

                                // put this inside the layout loop, otherwise there can be multiple rounds of layouts due to
                                // xcp.action.Enablement.displayReadOnlyPage() which will call setReadOnly of a form field etc.
                                 //me.fireEvent("load", me, instance);   // always fire event (need to know failure too)
                            } finally {
/*
                                Call the ResumeLayouts after complete form data including nested model is loaded
                                Ext.resumeLayouts(true);
*/
                            }
                        },
                        feedbackContainer: me
                    });
                } else {
                    data = model.getProxy().data;
                    me.instances[modelName] = Ext.ModelManager.create(data ? data : {}, modelName);
                    try {
                        me.suspendLayouts();
                        basicForm.loadRecord(me.instances[modelName]);
                    } finally {
/*
                                Call the ResumeLayouts after complete  for data is loaded
                                Ext.resumeLayouts(true);
*/
                    }
                }
                me.modelNames[modelName] = modelName;

            } else {
                var error = Ext.String.format(xcp.Strings.widget.form.Form.modelNotDefined, modelName);
                xcp.core.FeedbackManager.showFeedback(me, "", error, "systemErrors", false);
            }
        }

        //always set the first model to be primary model if no model being instantiated by load api
        if (!me.pageModel && me.models.length >0 ) {
            me.pageModel = me.models[0];
        }

        if (!this.subscriptions) this.subscriptions=[];
        this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemLockedEvent.NAME,  me.onItemModified, me, null));
        this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemUnlockedEvent.NAME,  me.onItemModified, me, null));
        this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.ItemModified.NAME,  me.onItemModified, me, null));
        this.subscriptions.push(xcp.event.EventBus.subscribe(xcp.event.PageModEvent.NAME,  me.onNewVersionCreated, me, null));

        if (model && !objectId && model.getProxy() instanceof xcp.proxy.FolderProxy){
            me.on("afterrender", function(){
                this.fireEvent("load", this, null)
            }, me, {single: true});
        }

    },

    createForm: function() {
        return Ext.create('xcp.widget.form.Basic', this, Ext.applyIf({listeners: {}}, this.initialConfig));
    },

    onItemModified: function(eventName, eventData){
        var modelName, model, i;
        var me  = this;
        if (this.isDestroyed) return;
        for (i = 0; i < this.models.length; i++) {
            modelName = this.models[i];
            model = Ext.ModelManager.getModel(modelName);

            if (this.objectId == eventData) {
            model.load(eventData, {
                        success : function(instance) {
                            this.instances[instance.modelName] = instance;
                            this.pageModel = instance.modelName;
                            try {
                                me.suspendLayouts();

                                if (!this.isDestroyed) {
					                this.getForm().loadRecord(instance);
				                }
                                if (!this.isDestroyed) {
					                this.fireEvent("load", this, instance);
				                }
                            } finally {
                                me.resumeLayouts();
                            }
                        },
                        feedbackContainer: this,
                        scope: this
                    });
            }
        }
    },

    onNewVersionCreated: function(eventName, eventData){
        var modelName, model, i;

        for (i = 0; i < this.models.length; i++) {
            modelName = this.models[i];
            model = Ext.ModelManager.getModel(modelName);

            //we got a new object id, it could be the new version of the object, we will navigate to the new obejct
            model.load(eventData, {
                        success : function(instance) {
                            this.instances[instance.modelName] = instance;
                            this.pageModel = instance.modelName;
                            //this.getForm().loadRecord(instance);
                        },
                        feedbackContainer: this,
                        scope: this
                    });
            //we got a new object id, it could be the new version of the object, we will navigate to the new obejct
            var url = xcp.util.Utils.makePageUrl(modelName, eventData, null, this);
            var newLocation = xcp.navigationManager.adjustLocation(url);
            //can we prevent reloading here?
            window.location.href =  newLocation;
        }
    },
    suspendLayouts: function() {
        xcp.Logger.info("Suspending page layouting");
        this.layoutSuspended=true;
        Ext.suspendLayouts();
        xcp.Logger.info("Suspended page layouting");
    },

    resumeLayouts: function() {
        if (this.layoutSuspended) {
            this.layoutSuspended=false;
            xcp.Logger.info("Resuming page layouting");
            Ext.resumeLayouts(true);
            xcp.Logger.info("Resumed page layouting");
        } else {
            xcp.Logger.info("Ignoring Resume page layouting");
        }

    },

    handleLoadRecord: function(record) {
        xcp.Logger.info("Completed loading the form data");
        this.publishModelLoadEvent(record);
    },
    publishModelLoadEvent: function(record) {
        var me = this;
        var modelName = record ? record.modelName : undefined;
        if (modelName) {
            me.publishXcpEvent(modelName+".load", record, true);
            if (!me.registeredModelChangeEvents[modelName]) {} {
                me._registerToFieldChangeEvent(modelName);
                me.registeredModelChangeEvents[modelName] = true;
            }
        }
        me.fireEvent("load", me, record);   // always fire event (need to know failure too)
        me.resumeLayouts();
    },
    handleFailedLoadRecord: function(record) {
        xcp.Logger.info("Failed loading some of the nested models");
        if (!record || !record.modelName) {
            //Use page model
            record = this.pageModel;
        }
        this.publishModelLoadEvent(record);
    },
    _registerToFieldChangeEvent : function(modelName) {
        var me = this;
        var fireChangeEvent  = function(field, newValue, oldValue, options) {
            if (field.isDirty() && !this.modelImmutable) {
                xcp.Logger.debug("Firing model change event for model : "+modelName);
                me.fireEvent(modelName + '.change', field, newValue, oldValue, options);
            }
        };

        this.getForm().getFields().each(function(f) {

              if (f.isFormField)
              {
                 if (f.name) {
                    //Check if the field have the model name in it
                    var name = f.name;
                    var tokens = name.split("@");
                    var fieldModelName = modelName;
                    if (tokens.length > 1) {
                        fieldModelName = tokens.shift();
                    }
                     name = tokens.join("@");
                     if (fieldModelName == modelName) {
                         var instance = this.instances[modelName];
                         if (instance && Ext.isFunction(instance.isValidField) && instance.isValidField(name)) {
                             f.on("change", fireChangeEvent, this);
                         }
                     }
                 }
              }
          },this);
    },

    formEventHandler: function(name, pubData, subData) {
        if (pubData) {
            this.getForm().loadRecord(pubData);
        }
    },
     /**
     * Find the form model associated in the current component.
     * @param modelName model name
     * @returns form model
     */
     getModel : function(modelName) {
         var model = null, name, list;
         if (this.instances) {
             if (Ext.isEmpty(modelName) || Ext.isEmpty(this.instances[modelName])) {
                 modelName = this.pageModel;
             }
             model = this.instances[modelName];

             if (model && !this.modelImmutable ) {
                 this.getForm().updateRecord(model);
                 this.getForm().getFields().each(function(f) {
                     //TODO to check isDirty(), EXTJS is broken with checkbox isDirty
                     // Update(dirty state is not set) does not happen on checkbox from checked to unchecked state
                     if (f.isFormField && f.isCheckbox) {
                         //handle special format for widget name <model name>@<model field name>
                         name = f.name;
                         if (name.indexOf("@") != -1) {
                             list = name.split('@');
                             if (modelName == list[0]) {//to check if widget binds to current model
                                 name = list[0];
                             }
                             else
                                 return; //don't set value into current model
                         }
                         model.set(name, f.checked);
                     }
                 }, this);
             }
         }
         return model;
     },

    /**
     * Get the actionArgs object for this component
     */
    actionArgsProvider: function(){
        return  new xcp.core.ActionArgs({
            component:  this,
            selection: [this.getModel()]
        });
    }
});


/* xcp_form/content/xcp/widget/form/Basic.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define('xcp.widget.form.Basic', {
    extend: 'Ext.form.Basic',

    /**
     * Constructor
     * @param config
     */
    constructor: function(config) {
        //Add this event to notify form panel, so that it can fire the model load event.
        // Also start listening for field change events to fire the model change.
        this.addEvents("loadRecord", "failedLoadRecord");
        this.callParent(arguments);
    },

    /**
     * Get the fields that are required for loading all the required models
     * This method gets the form fields and adds dummy form fields to load child models
     * used by expressions
     * @param record
     * @param exprModels
     */
    getAllFields: function(record, exprModels) {
        var fields = this.getFields();
        if(!Ext.isEmpty(exprModels)) {
            for(var i = 0; i < exprModels.length; i++) {
                var exprModel = exprModels[i];
                var dummyFieldName = this.getDummyFieldName(record, exprModel, fields.items);
                if(dummyFieldName) {
                    //add the dummy form field
                    xcp.Logger.info("Dummy Field \"" + dummyFieldName + "\" inserted to load child model "+ exprModel);
                    var zlass = Ext.ClassManager.getByAlias("widget.xcp_value_display");
                    if(zlass) {
                        var config = {'name': dummyFieldName, 'hidden' : true};
                        var dummyField = new zlass(config);
                        fields.items.push(dummyField);
                    }
                }
            }
        }
        return fields;
    },

    /**
     * Get dummy form field name
     * Used to add the dummy form field to load child models used by expressions
     * @param record
     * @param exprModel
     * @param formFields
     */
    getDummyFieldName : function(record, exprModel, formFields) {
        var dummyFieldName = undefined;
        var isDummyFieldRequired = true;
        var props = exprModel.split(".");
        var exprRootModelName = props[0];
        props = Ext.Array.remove(props, exprRootModelName);
        var exprModelFieldName = props.join(".");
        if(exprRootModelName === record.modelName) {
            var exprModelField = record.getField(exprModelFieldName, true);
            var exprModelIdField = undefined;
            if(record.isNestedModelField(exprModelField)) {
                var exprChildModel = record.getNestedModelInstance(exprModelFieldName);
                exprModelIdField = exprModelFieldName + "." + exprChildModel.idProperty;
            }
            for(var i = 0; i < formFields.length; i++) {
                var field = formFields[i];
                var formFieldName = this.getFieldName(field);
                if(formFieldName.indexOf(exprModelFieldName) !== -1 && formFieldName !== exprModelIdField) {
                    isDummyFieldRequired = false;
                    break;
                }
            }
            if(isDummyFieldRequired && record.isNestedModelField(exprModelField)) {
                var exprChildModel = record.getNestedModelInstance(exprModelFieldName);
                var childExprField = this.getNonIdField(record, exprChildModel, exprChildModel.idProperty);
                dummyFieldName =  exprRootModelName + '@' + exprModelFieldName;
                if(childExprField) {
                    dummyFieldName = dummyFieldName + "." + childExprField.name;
                }
            }
        }
        return dummyFieldName;
    },

    /**
     * Return a model field that is not an id and not a nested field
     * @param childModel
     * @param idProperty
     */
    getNonIdField: function(rootModel, childModel, idProperty) {
        var fields = childModel.fields.items;
        for(var i = 0; i < fields.length; i++) {
            var field = fields[i];
            if(field.name !== idProperty && !rootModel.isNestedModelField(field)) {
                return field;
            }
        }
        return undefined;
    },

    /**
     * Load Record and fire the loadRecord event.
     * @param record
     */
    loadRecord: function(record) {
        this._record = record;
        if (record && record.modelName) {
            if (! this._records)
                this._records = {};
            this._records[record.modelName] = record;
        }
        this._record.modelsToLoad = {};
        this.setValuesOnFormFields(record, this.getAllFields(record, this.childModelsToLoad).items);
        if(xcp.util.Utils.isEmptyObject(this._record.modelsToLoad)) {
            this.fireEvent("loadRecord", this._record);
        }
        return this;
    },

    /**
     * Sets values on to the form fields. Iterates the formfields, finds the binding,
     * retrieves data from the record and sets on to the field
     * Called recursively to dynamically load child models, in case if the child models are not preloaded.
     * @param record
     * @param formFields
     */
    setValuesOnFormFields : function(record, formFields) {
        var modelsToLoad = {};
        for(var i = 0; i < formFields.length; i++) {
            var field = formFields[i];
            var formFieldName = this.getFieldName(field);
            var value = record.get(formFieldName);
            var modelField = record.getField(formFieldName, true);
            if(modelField) {
                if(Ext.isEmpty(value) && !this.isModelLoaded(record, field)) {
                    this.constructModelsToLoad(record, field, modelsToLoad);
                } else {
                    field.setValue(value);
                    if (this.trackResetOnLoad) {
                        field.resetOriginalValue();
                    }
                }
            }
        }
        xcp.util.Utils.merge(this._record.modelsToLoad, modelsToLoad);
        for(var fieldName in modelsToLoad) {
            this.loadChildModel(fieldName, modelsToLoad[fieldName]);
        }
    },

    /**
     * Checks if the child model is loaded already
     * @param rootModelInstance
     * @param formField
     */
    isModelLoaded : function(rootModelInstance, formField) {
        var formFieldName = this.getFieldName(formField);
        var props = formFieldName.split(".");
        var fieldName = props[0];
        for(var i = 1; i < props.length; i++) {
            var childFieldName = props[i];
            var parentFieldName = fieldName;
            fieldName = fieldName + "." + childFieldName;
            var parentField = rootModelInstance.getField(parentFieldName, true);
            if (parentField && rootModelInstance.isNestedModelField(parentField)) {
                var instance = rootModelInstance.getNestedModelInstance(parentFieldName);
                if (instance) {
                    if (!instance.isDataLoaded()) {
                        return false;
                    }
                } else {
                    return false;
                }
            }
        }
        return true;
    },

    /**
     * Keeps track of child models to load during second pass
     * @param rootModelInstance
     * @param formField
     * @param modelsToLoad
     */
    constructModelsToLoad : function (rootModelInstance, formField, modelsToLoad) {
        var formFieldName = this.getFieldName(formField);
        var props = formFieldName.split(".");
        var fieldName = props[0];
        var parentModelInstance = rootModelInstance;
        for(var i = 1; i < props.length; i++) {
            var childFieldName = props[i];
            var parentFieldName = fieldName;
            fieldName = fieldName + "." + childFieldName;
            var parentField = rootModelInstance.getField(parentFieldName, true);
            var instance = rootModelInstance.getNestedModelInstance(parentFieldName);
            if (instance && instance.isDataLoaded() === false) {
                //check if the id property available for child model
                var id = null;
                //get id from child model instance
                if (rootModelInstance.get(parentFieldName) &&
                    rootModelInstance.get(parentFieldName)[instance.idProperty]) {
                    id = rootModelInstance.get(parentFieldName)[instance.idProperty];
                }
                //get id from attribute of parent model instance
                else if (rootModelInstance.get(parentFieldName)&&
                    Ext.isString(rootModelInstance.get(parentFieldName))) {
                    id = rootModelInstance.get(parentFieldName);
                }
                //get id from parent object id, the relationship is a typical case
                if (!id && instance.useParentId()) {
                    id = parentModelInstance.get(parentModelInstance.idProperty);
                }
                if (id) {
                    if (!modelsToLoad[parentFieldName]) {
                        var modelToLoad = {};
                        modelToLoad.modelName = parentField.modelName;
                        modelToLoad.id = id;
                        modelToLoad.fields = new Array();
                        modelsToLoad[parentFieldName] = modelToLoad;
                    }
                    modelsToLoad[parentFieldName].fields.push(formField);
                }
                break;
            }
            parentModelInstance = instance;
        }
    },

    /**
     * Asynchronously loads the child model
     * @param fieldName
     * @param modelData
     */
    loadChildModel : function(fieldName, modelData) {
        var model = Ext.ModelManager.getModel(modelData.modelName);
        var me = this;
        if(model && model.getProxy() instanceof Ext.data.proxy.Server && model.getProxy().url) {
            xcp.Logger.info("Loading model data for "+ modelData.modelName);
            var isRelationModel = xcp.util.Utils.isSubTypeOf(model, xcp.data.BaseRelationModel);
            var feedbackContainer = isRelationModel ? undefined : me.owner;
            var options = {
                scope: this,
                success : function(instance) {
                    xcp.Logger.info("Got data for "+instance.modelName);
                    this.updateFieldWithModelInstance(fieldName, modelData, instance);
                },
                failure: function(response, operation)  {
                    if (xcp.util.Utils.isSubTypeOf(model, xcp.data.BaseRelationModel)) {
                        if (operation.error.status == 404) {
                            //Ignore the error
                            var instance = Ext.ModelManager.create({}, modelData.modelName);
                            this.updateFieldWithModelInstance(fieldName, modelData, instance);
                            return;
                        }
                        //Log Error
                        if (operation.error && operation.error.detailedMessage)  {
                            var errorJson = Ext.JSON.decode(operation.error.detailedMessage);
                            xcp.core.FeedbackManager.showFeedback(me.owner, "", null, "systemErrors", xcp.core.FeedbackManager.formatServiceErrorFeedback(errorJson));
                        }
                        xcp.Logger.error("Error in retrieving child model "+ model.prototype.modelName);
                    }
                    this.fireEvent("failedLoadRecord", me._record);
                },
                feedbackContainer: feedbackContainer

            };
            model.load(modelData.id, options);
        } else {
            var data = model.getProxy().data;
            var instance = Ext.ModelManager.create(data ? data : {}, modelData.modelName);
            this.updateFieldWithModelInstance(fieldName, modelData, instance);
        }
    },


    /**
     * Update the field with the child model instance that is loaded.
     * @param instance
     */
    updateFieldWithModelInstance : function (fieldName, modelData, instance) {
        this._record.set(fieldName, instance.data);
        this.setValuesOnFormFields(this._record, modelData.fields);
        delete this._record.modelsToLoad[fieldName];
        if (xcp.util.Utils.isEmptyObject(this._record.modelsToLoad)) {
            this.fireEvent("loadRecord", this._record);
        }
    },


    /**
     * Get the model field name from the form field name
     * @param field
     */
    getFieldName : function(field) {
        var formFieldName = field.getName();
        var tokens = formFieldName.split("@");
        formFieldName = tokens[0];
        if(tokens.length > 1) {
            formFieldName = tokens[1];
        }
        return formFieldName;
    },

    /**
     * Find the field associated with model.
     * @param id
     */
    findField: function(id) {
        var modelName = (this.getRecord() && this.getRecord().modelName) ? this.getRecord().modelName : null;
        var field = this.getFields().findBy(function(f) {
            return f.id === id || f.getName() === id;
        });

        //if field cannot be found, try <model name>@<field id> pattern
        if (!field && modelName) {
            field = this.getFields().findBy(function(f) {
            return f.id === modelName +"@" + id || f.getName() === modelName +"@" + id;
        });
        }

        return field;
    },

    /**
     * Update the model instance. This method take care of updating the nested model fields.
     * @param record : Model Instance
     * @param fieldQualifier : The model name of the top most model
     * @param recordPath: Nested field path
     */
    updateRecord: function(record, fieldQualifier, recordPath) {
        var me = this,
            fields = record.fields,
            values = this.getFieldValues(),
            name, newName,
            obj = {};

        fieldQualifier = fieldQualifier || record.modelName;
        var found=false;
        fields.each(function(f) {
            var recordFieldPath = recordPath || '';
            var instance = null;
            if (record && Ext.isFunction(record.getNestedModelInstance)) {
                instance = record.getNestedModelInstance(f.name, false);
            }
            if (instance && f.type == Ext.data.Types.AUTO) {
                recordFieldPath  += f.name + '.';
                me.updateRecord(instance, fieldQualifier, recordFieldPath);
                if (instance.dirty) {
                    obj[f.name] = instance.data;
                }
            } else {
                name = recordFieldPath  + f.name;
                if (name in values) {
                    obj[f.name] = values[name];
                    found = true;
                }
                else if (fieldQualifier) {
                    //if field cannot be found, try <model name>@<field id> pattern
                    newName = fieldQualifier + "@" + name;
                    if (newName in values) {
                        obj[f.name] = values[newName];
                        found=true;
                    }
                }
            }
        });

        if (found) {
            record.beginEdit();
            record.set(obj);
            record.endEdit();
        }

        return this;
    },
    /**
     * Sets the form field values from the model. This method take care of setting value from the nested
     * model fields.
     * @param values
     */
    setValues: function(values) {
        var me = this;
        /**
         * Note: The method is not safe against the recursive references of the object. So object with recursive
         * references should not be passed in the
         * @param orgObj
         */
        var flatten = function (orgObj){
            var flatObj = {},
                walk = function(obj, baseName){
                    var prop;
                    for(var propName in obj){
                        prop = obj[propName];
                        var flatName = baseName + propName;
                        if(Ext.isObject(prop)){
                            walk(prop, flatName + ".");
                        }
                        else {
                            flatObj[flatName] = prop;
                        }
                    }
                };
            var tempObj = Ext.apply({}, orgObj);
            walk(tempObj, "");
            return flatObj;
        };
        function setVal(fieldId, val) {
            var field = me.findField(fieldId);
            if (field) {
                field.setValue(val);
                if (me.trackResetOnLoad) {
                    field.resetOriginalValue();
                }
            }
        }

        if (Ext.isArray(values)) {
            Ext.each(values, function(val) {
                setVal(val.id, val.value);
            });
        } else {
            var flatObj = flatten(values);
            Ext.iterate(flatObj, setVal);
        }
        return this;
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.report.Reports");
Ext.apply(xcp.Strings.widget.report.Reports, {
    componentId:                "ID",
	columnsFieldLabel:		    "Columns",
	titleGeneralSectionLabel:	"General",
	titleBasicSectionLabel:	    "Basic",
    titleFieldValue:	        "Title",
    generalDataSectionLabel:    "Data",
    rangesLabel:                "Ranges",
    defaultDisplayLabel: "Default Display",
    displayLabel: "Display",
    reportTyprField:	        "Report Type",
    timeGranularityField:	     "Time Granularity",
    titleInfoSectionLabel:	     "Info",
    titleRulesSectionLabel:	     "Display Rules",
    titleStyleSectionLabel:	     "Style",
    btnEditCrystalReportLabel:	     "Edit in Crystal Reports",
    btnFinishEditCrystalReportLabel:	     "Edit in Crystal Reports",
    msgReportBeingEdited:	     "This report is beign edited",
    msgLoadingReport:             "Loading Report .....",
    msgLastEdited:                "Last saved on ",
    msgErrorLoadingCrystalReport:   "Error loading crystal report RPT file",
    msgUnkownReportType:    "Unkown report type or report type is empty",
    btnSyncCrystalReportLabel:"Sync Crystal Report with Data Source",
    msgErrorUpdatingCrystalReport:   "Error updating crystal report RPT file",
    msgErrorCrystalReportOpenByOtherProcess:  "Cannot update the Crystal Report because it is being used by another process." ,

    chartTypeColumn:"Column",
    chartTypeLine:"Line",
    chartTypePie:"Pie",

    xAxisLabel: "Categories",
    yAxisLabel:"Values",
    prefix:"",

    sampleDataC1 : "A",
    sampleDataC2 : "B",
    sampleDataC3 : "C",
    sampleDataC4 : "D",
    sampleDataC5 : "E",
    sampleDataC6 : "F",
    sampleDataC7 : "G",


    dataC11 : 45,
    dataC21 : 125,
    dataC31 : 50,
    dataC41 : 25,
    dataC51 : 45,
    dataC61 : 90,
    dataC71 : 150,


    dataC12 : 20,
    dataC22 : 15,
    dataC32 : 20,
    dataC42 : 40,
    dataC52 : 35,
    dataC62 : 70,
    dataC72 : 20,


    dataC13 : 70,
    dataC23 : 40,
    dataC33 : 25,
    dataC43 : 10,
    dataC53 : 70,
    dataC63 : 150,
    dataC73 : 10,


    dataC14 : 90,
    dataC24 : 25,
    dataC34 : 40,
    dataC44 : 30,
    dataC54 : 7,
    dataC64 : 2,
    dataC74 : 65,


    dataC15 : 15,
    dataC25 : 10,
    dataC35 : 100,
    dataC45 : 40,
    dataC55 : 75,
    dataC65 : 95,
    dataC75 : 25,


    dataC16 : 110,
    dataC26 : 80,
    dataC36 : 20,
    dataC46 : 35,
    dataC56 : 90,
    dataC66 : 45,
    dataC76 : 70,

    dataC17 : 110,
    dataC27 : 80,
    dataC37 : 20,
    dataC47 : 35,
    dataC57 : 90,
    dataC67 : 45,
    dataC77 : 70,

    dataC18 : 110,
    dataC28 : 80,
    dataC38 : 2,
    dataC48 : 35,
    dataC58 : 90,
    dataC68 : 45,
    dataC78 : 70,


    dataC19 : 110,
    dataC29 : 80,
    dataC39 : 20,
    dataC49 : 35,
    dataC59 : 90,
    dataC69 : 45,
    dataC79 : 70,

    dataC110 : 110,
    dataC210 : 80,
    dataC310 : 20,
    dataC410 : 35,
    dataC510 : 60,
    dataC610 : 45,
    dataC710 : 70,

    dataSectionLabel: "Data",

    createNewOrUsePageTitle: "Data Service and Instance Creation",
    createNewOrUseInstructionText: "A Chart must be connected to an instance of a data service.",
    createNewOrUseRadioHeader: "Create:",
    createNewOrUseRadio1Label: "Data service and instance",
    createNewOrUseRadio1Instructions: "Add a new data service.  An instance of the data service will also be created and connected to the chart.",
    createNewOrUseRadio2Label: "Instance of an existing data service",
    createNewOrUseRadio2Instructions: "Select an existing data service.  A new instance of the data service will be created and connected to the chart.",

    chooseTypePageTitle: "Data Service Creation",
    chooseTypeInstructionText: "Create a data service that returns:",

    selectDSPageTitle: "Create an Instance of an Existing Data Service",
    selectDSInstructionText: "Select a data service:",
    selectDSTitleLabel: "Data service label",

    typeListLabel: "Data service:",

    chooseColumnPageTitleScreen3a: "Specify column chart categories (X Axis)",
    chooseColumnPageTitleScreen3b: "Specify column chart values (Y Axis)",
    
    chooseColumnPageTitleScreen4: "Define values and categories (X and Y axes)",
    chooseColumnPageTitleScreen5: "Create user inputs for the query",
    chooseColumnPageTitle: "Specify columns for Crystal Reports",
    showAllAvailableFields:"Show all available",
    availableColumnsLabel:"Available:",
    includedColumnsLabel:"Included:",
    primaryTypeLabel: "{0} ({1})",

    categoriesXaxis:"Categories (X Axis)",
    valuesYaxis:"Values (Y Axis)",
    
    dataSourceName:"Data Source",
    axis_Label: "Axis Label",
    yAxis_Label:"Y Axis Label",
    xAxis_Label:"X Axis Label",
    xAxisType:"X Axis Type",

    xAxisFields: "X Axis Fields",
    yAxisFields: "Y Axis Fields",

    displayTitle: "Display",
    fieldTitle: "Field",
    typeTitle: "Type",
    chartWidgetTitle: "Chart widget title",
    crystalWidgetTitle: "Crystal Reports widget title",
    chartHasNoData: "No data to display",
    chartNoDataLabel: "No data",

    slaLines: "Lines",

    ranges: "Ranges",
    layoutSectionLabel: "Layout",
    sizeGroupLabel: "Size"

});
/* xcp_gauge_chart/content/xcp/widget/report/GaugeChartComponent.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: volchd
 * Date: 3/1/12
 * Time: 2:27 PM
 * To change this template use File | Settings | File Templates.
 */

Ext.define("xcp.widget.report.GaugeChartComponent", {
            extend: "Ext.Panel",
            alias: 'widget.xcp_gauge_chart',
            layout: {
                type: 'vbox',
                align: 'stretch',
                padding: 0
            },

            /**
             * Returns the field value from the Selected Row Data associated with the given component
             * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
             * @param compId  {String} (Required) The component id
             * @param fieldId  {String} (Required)
             */
            statics: {

                getValueFromRowSelection: function(context, compId, fieldId) {

                    var comp = context.getComponent(compId);
                    var value = "";
                    if (!comp) {
                        xcp.Logger.warn("Could not find the component: " + compId);
                    } else {

                        value = comp.getSelectedRowData()[fieldId];
                        return xcp.core.expr.BaseExpression.checkValue(value);
                    }
                }
            },

            // IWC The object which stores the selected row data from the chart.
            selectedRowData:{},

            // IWC: Publish the series "itemmouseup" as "seriesselected" event.
            xcpeventconfig: [
                {
                    event: "seriesselected"
                }
            ],

            // IWC: Returns the selected row data
            getSelectedRowData:function() {
                return this.selectedRowData;
            },

            constructor: function (config) {
                var me = this;
                config = config || {};
                Ext.useShims = true;
                me.config = config;
                me.chartStore = null;
                me.labelDirection = 'rotate';
                me.chartLabelFontSize = '11';
                me.chartLegend = Ext.create('Ext.panel.Panel', {height:2,width:750,border:false});

                me.chartsItems = [];
                this.runtime = Ext.isDefined(xcp.navigationManager);
                me.chartReportUtil = new xcp.widget.report.ChartReportUtil();
                me.chartLegendUtil = new xcp.widget.report.ChartLegendUtil();
                var yFieldsAmount = 0;
                me.runtimeEmptyChartData = null;

                if (this.runtime) {
                    me.xFields = config.xAxisSelectedFields;
                    me.yFields = config.yAxisSelectedFields;
                    me.chartStore = me.chartReportUtil.getRunTimeStore(config);
//                    me.chartsItems = this.getChartsItems(me.xFields, me.yFields, me.chartStore, config);

                    me.chartStore.on( 'load', function( store, records, options ) {
                        if (!(store.data.length > 0)) {
                            me.runtimeEmptyChartData = [[xcp.Strings.widget.report.Reports.chartHasNoData,0]];

                            var newStore = me.chartReportUtil.createEmptyStore(config.modelName, me.runtimeEmptyChartData, me.xFields, me.yFields, 0);

                            me.redrawChartAfterLoad(me, newStore);

                        } else {

                            me.runtimeEmptyChartData = null;

                            // Need to set remoteSort = false as chart will be using data action framework and in
                            //DataSourceAction.js remoteSort is set to true. Since we are doing sorting on the client we need to
                            // set it to false.
                            store.remoteSort = false;
                            // Removed the sorters config in the store and instead added sort fields here as there were issues
                            // while using sorters with RealtimeQuery.
//                            store.sort(config.sortingFieldName, config.sortingOrder);

                            me.redrawChartAfterLoad(me, store);
                        }
                    });

                }
                else {      // Design Time
                    //me.labelDirection = 'rotate';
                    if (config.yAxisSelectedFields) {

                        me.chartsItems = this.getDesignTimeChartsItems(config, false);
                        yFieldsAmount = me.chartReportUtil.getDesignTimeStore(config).getCount();

                        me.chartLegend = Ext.create('Ext.panel.Panel', {height:2,width:750});
                        if (config.legendDisplay && config.legendDisplay != "false")
                            me.chartLegend = this.getOwnLegend(config, me.chartsItems);
                    }
                    else{
                        config.yAxisSelectedFields = ["Y"];
                        config.xAxisSelectedFields = ["X"];
                        config.yAxisSelectedLabels = ["Y"];
                        me.chartsItems = this.getDesignTimeChartsItems(config, false);
                        yFieldsAmount = me.chartReportUtil.getDesignTimeStore(config).getCount();

                         if (config.legendDisplay && config.legendDisplay != "false")  {
                            me.chartLegend = this.getOwnLegend(config, me.chartsItems);
                         }


                    }
                }


          Ext.apply(this,Ext.apply(this.initialConfig, config), {
            title: config.title,
            border:false,
            cls: 'xcp-chart-outer-panel',
            padding: 3,
            bodyCls: 'xcp-chart-inner-panel-body',
            items:[{
                  xtype: 'panel',
                  border: false,
                  cls: 'xcp-chart-panel-body',
                layout: {
                        type: 'table',
                        columns: 3
                },
                items: [{
                xtype: 'panel',
                border:false,
                xcpSubCmp: true,
                cls: 'xcp-chart-panel-body',
                layout: {
                    type: 'column',
                    align: 'center',
                    padding: 5
                },
                items:me.chartsItems
            },{
                xtype: 'panel',
                xcpSubCmp: true,
                isViewerChildElement: false,
                cls: 'xcp-chart-panel-body',
                margin: '0 0 0 25',
                layout: {
                    align: 'stretch',
                    padding: 5
                },
                border:false,
                items:me.chartLegend
            }, {
                xtype: 'panel',
                border:false,
                xcpSubCmp: true,
                cls: 'xcp-chart-panel-body',
                width: 30
            }]
            }]
        });

        xcp.widget.report.GaugeChartComponent.superclass.constructor.call(this, config);


            },
            initComponent: function() {
                var me = this;
                xcp.widget.report.GaugeChartComponent.superclass.initComponent.call(this);
                me.addEvents(
                        /**
                         * @event seriesselected
                         * Fires when user clicks on any of the series on the chart.
                         */
                        'seriesselected'
                );
            },



    getDesignTimeChartsWithLegend:function(config, reset, legendDisplay){
        var me = this;
        var newItems = this.getDesignTimeChartsItems(config);
        var chartItemsPanel = Ext.create('Ext.panel.Panel', {
            xcpSubCmp: true,
            cls: 'xcp-chart-panel-body',
            border: false,
            layout: {
                    type: 'column',
                    align: 'stretch',
                    padding: 5
            },
            items: newItems
        });
        var legendPanel = Ext.create('Ext.panel.Panel', {
            border: false,
            xcpSubCmp: true,
           cls: 'xcp-chart-panel-body',
            align: 'stretch',
            items: []
        });
        if(legendDisplay  && legendDisplay!="false" ){
            me.chartLegend = this.getOwnLegend(config, newItems);
            legendPanel.items.add(me.chartLegend);
        }
        var emptyPanel = Ext.create('Ext.panel.Panel', {
            border: false,
            xcpSubCmp: true,
           cls: 'xcp-chart-panel-body',
           width: 30
        });
        var mainPanel =  Ext.create('Ext.panel.Panel', {
           border: false,
           cls: 'xcp-chart-panel-body',
            layout: {
                        type: 'table',
                        columns: 3
            },
            items: [chartItemsPanel, legendPanel, emptyPanel]
        });
        if(reset) {
            me.removeAll(true);
            me.add(mainPanel)
        } else{
            return chartItemsPanel;
        }
    },

    getDesignTimeChartsItems:function(config) {
        var me = this;
        me.xFields = config.xAxisSelectedFields;
        me.yFields = config.yAxisSelectedFields;
        var chartStore = me.chartReportUtil.getDesignTimeStore(config);
        var newItems = this.getChartsItems(me.xFields, me.yFields, chartStore, config);

        return newItems;


    },

            getChartsItems: function (xFields, yFields, chartStore, config) {
                var me = this;
                var gaugeChartItems = [];
                var legendLocation = "right";
                var chartWidth = 350;
                var selectedTypes = config.yAxisSelectedTypes;
                var yAxisSelectedLabels = config.yAxisSelectedLabels;

                for (var i = 0; i < yFields.length; i++) {
                    var gaugeChart = this.getChartPerAxis(null, yFields[i], yAxisSelectedLabels[i], chartWidth, legendLocation, chartStore, null, config);
                    var gaugePanel = Ext.create('Ext.panel.Panel', {
                        border: 0,
                        xcpSubCmp: true,
                        cls: 'xcp-chart-subcmp',
                        layout: {
                            type: 'table',
                            columns: 1,
                            tdAttrs: {
                                style: {
                                    'text-align': 'center',
                                    'vertical-align':'top'
                                }
                            }
                        },
                        items:  [gaugeChart, {
                            xtype: 'label',
                            style: {
                                position: 'relative',
                                'top': '-12px'
                            },
                            xcpSubCmp: true,
                            cls: 'xcp-chart-label',
                            text: yAxisSelectedLabels[i]
                        }, {
                            xtype: 'panel',
                            border: false,
                            height: 10
                        }]
                    });

                    gaugeChartItems.push(gaugePanel);
                }
                return gaugeChartItems;

            },

            getChartPerAxis: function(xField, yField, chartLabel, chartWidth, legendLocation, chartStore, type, config) {
                var me = this;
                var showLegend = false;
                if (config.legendDisplay == "true" && legendLocation != "none")
                    showLegend = true;

                var maximum = chartStore.max(yField);
                if (!maximum) maximum = 1;

                if (chartStore.getTotalCount() > 0) {
                    var record = chartStore.getAt(0);
                    me.value = record.get(yField);
                }

                var minimum = chartStore.min(yField);
                if (!minimum || minimum >= 0) minimum = 0;

                var columnOpacity = 1.0;
                var donut = 0;
                if (type == "donut")
                    donut = 30;
                //select proper color based on range selection
                var rangeAllColors = config.rangeAllColors || [];
                var rangeFromValues = config.rangeFromValues || [];
                var rangeToValues = config.rangeToValues || [];
                var color = config.rangeColor1;

                var minValue = me.getMinimum(config, chartStore, yField);
                var maxValue = me.getMaximum(config, chartStore, yField);

                if (rangeAllColors.length > 0 && rangeFromValues.length > 0 && rangeToValues.length > 0) {
                    for (i = 0; i < rangeFromValues.length; i++) {
                        var fromValue = parseFloat(rangeFromValues[i]);
                        var toValue = parseFloat(rangeToValues[i]);
                        var upperRange = toValue;
                        var lowerRange = fromValue;
                        if(fromValue > toValue)    {
                            upperRange =  fromValue;
                            lowerRange =  toValue;
                        }
                        if (me.value >= lowerRange && me.value <= upperRange) {
                            color = rangeAllColors[i];
                        }
                    }
                }
                else {
                    if (me.value > config.rangeStart2)
                        color = config.rangeColor2;
                    if (me.value > config.rangeStart3)
                        color = config.rangeColor3;
                }
                var gaugeChartComponentGradients = [];
                var gaugeChartComponentColorSet = [];
                var colorUtil = new xcp.widget.report.ChartColorUtil();
                var colorSet = [color, colorUtil.getEmptyChartColor()];
                for (var i = 0; i < colorSet.length; i++) {
                    var gradient = colorUtil.getGradient(colorSet[i], i)
                    gaugeChartComponentGradients.push(gradient);
                    gaugeChartComponentColorSet[i] = 'url(#' + gradient.id + ')';
                }
                var chart = Ext.create('Ext.chart.Chart', {
                            width:chartWidth,
                            xcpSubCmp: true,
                            cls: 'xcp-gauge-chart-cls',
                            height:250,
                            theme: 'XCPGaugeChartTheme',
                            gradients: gaugeChartComponentGradients,
                            animate: true,
                            store: chartStore,
                            insetPadding: 28,
                            flex: 1,
                            axes: [
                                {
                                    type: 'gauge',
                                    position: 'gauge',
                                    minimum: minValue,
                                    maximum: maxValue,
                                    steps: 5,
                                    margin: 7,
                                    label: {
                                        renderer: function(label) {
                                            var axesLabel;

                                            if (!me.runtime) {
                                                axesLabel = Ext.util.Format.number(label, '0'); //Value , Format
                                            } else {
                                                axesLabel = me.chartReportUtil.formatValue(me.config, yField, label);
                                            }
                                            return axesLabel;

                                        }
                                    }
                                }
                            ],
                            series: [
                                {
                                    type: 'gauge',
                                    field: yField,
                                    donut: 60,
                                    colorSet: gaugeChartComponentColorSet,
                                    tips: {
                                        trackMouse: true,
                                        maxWidth: 1000,
                                        renderer: function(storeItem, item) {
                                            var yFieldValue = storeItem.get(yField);
                                            var title = null;
                                            if (!me.runtime) {
                                                 title = chartLabel + ': ' + yFieldValue;
                                            } else {
                                                title = chartLabel + ': ' + me.chartReportUtil.formatValue(me.config, yField, yFieldValue);
                                            }
                                            this.update(title);
                                        }
                                    },
                                    listeners: {
                                        itemmouseup: function(item) {
                                            // There is no itemclick event for series so using itemmouseup

                                            if (!me.runtime) return;
                                            if (me.runtimeEmptyChartData) return;
                                            xcp.widget.report.ChartReportUtil.populateSelectedRowData(item, me);
                                        }
                                    }
                                }
                            ]
                        });
                return chart;
            },
            updateChartType:function(config) {
                var me = this;
                var selectedTypes = config.yAxisSelectedTypes;
                var currentChart;
                for (var i = 0; i < selectedTypes.length; i++) {
                    currentChart = me.items.getAt(0).items.getAt(i);
                    if (selectedTypes[i] == 'donut') {
                        currentChart.series.items[0].donut = 30;
                    } else {
                        currentChart.series.items[0].donut = 0;
                    }
                    currentChart.redraw();
                }
            },
            updateChartTitle:function() {


            },
            updateChartsLabelTitles:function(config) {

            },

            reloadDataOnSort:function(config) {
                var me = this;
                var yFields = config.yAxisSelectedFields;
                for (i = 0; i < yFields.length; i++) {
                    var chart = me.items.getAt(0).items.getAt(i);
                    chart.store = me.chartReportUtil.getDesignTimeStore(config);
                    chart.redraw();
                }
            },

            redrawChartAfterLoad:function(me, store) {
                var me = this;
                me.chartsItems = me.getChartsItems(me.xFields, me.yFields, store, me.config);
                var chartItemsPanel = Ext.create('Ext.panel.Panel', {
                    xcpSubCmp: true,
                    cls: 'xcp-chart-panel-body',
                    border: false,
                    layout: {
                            type: 'column',
                            align: 'stretch',
                            padding: 5
                    },
                    items: me.chartsItems
                });

                var legendPanel = Ext.create('Ext.panel.Panel', {
                    border: false,
                    xcpSubCmp: true,
                    cls: 'xcp-chart-panel-body',
                    align: 'stretch',
                    items: []
                });
                if(me.config.legendDisplay  && me.config.legendDisplay!="false" ){
                    me.chartLegend = this.getOwnLegend(me.config, me.chartsItems);
                    legendPanel.items.add(me.chartLegend);
                }
                var emptyPanel = Ext.create('Ext.panel.Panel', {
                    border: false,
                    xcpSubCmp: true,
                    cls: 'xcp-chart-panel-body',
                    width: 30
                });
                var mainPanel =  Ext.create('Ext.panel.Panel', {
                    border: false,
                    cls: 'xcp-chart-panel-body',
                    layout: {
                        type: 'table',
                        columns: 3
                    },
                    items: [chartItemsPanel, legendPanel, emptyPanel]
                });
                me.removeAll(true);
                me.add(mainPanel);
            } ,

            getOwnLegend:function(config, chartsItems) {
                var me = this;
                var rangeAllColors = config.rangeAllColors || [];
                var rangeFromValues = config.rangeFromValues || [];
                var rangeToValues = config.rangeToValues || [];
                var legendColors = [] ,legendLabels = [];
                var len = rangeAllColors.length;

                for (var i = 0; i < len; i++) {
                    legendLabels[i] = rangeFromValues[i] + " - " + rangeToValues[i];
                    legendColors[i] = rangeAllColors[i];
                }
                var chartsItemsLegend = [];
                for (var chartsItemIndex in chartsItems) {
                    chartsItemsLegend.push(chartsItems[chartsItemIndex].items.items[0]);

                }

                var legendPanel = me.chartLegendUtil.getLegendPanel(chartsItemsLegend, legendLabels, legendColors, false);
                return legendPanel;
            },
            getMaximum:function(config, store, yField) {
                var maximum = config.rangeEnd3;
                var maxField = 1;
                maxField = store.first().data[yField];

                if(maxField > maximum)    {
                      maximum = maxField;
                }
                var rangeToValues = config.rangeToValues || [];
                var maxRange = maximum;
                for(var i = 0; i < rangeToValues.length; i++){
                    maxRange = parseFloat(rangeToValues[i]);
                    if(maxRange > maximum) {
                         maximum  = maxRange;
                    }
                }

                var rangeFromValues = config.rangeFromValues || [];
                for(var i = 0; i < rangeFromValues.length; i++){
                    maxRange = parseFloat(rangeFromValues[i]);
                    if(maxRange > maximum) {
                         maximum  = maxRange;
                    }
                }
                return parseFloat(maximum);
            },
            getMinimum:function(config, store, yField) {
                var minimum = config.rangeStart1;
                var minField = 0;
                 minField = store.first().data[yField];
                if(minField < minimum)  {
                   minimum =  minField;
                }
                var rangeFromValues = config.rangeFromValues || [];

                var minRange = minimum;
                for(var i = 0; i < rangeFromValues.length; i++){
                    minRange = parseFloat(rangeFromValues[i]);
                    if(minRange < minimum) {
                         minimum  = minRange;
                    }
                }

                var rangeToValues = config.rangeToValues || [];

                for(var i = 0; i < rangeToValues.length; i++){
                    minRange = parseFloat(rangeToValues[i]);
                    if(minRange < minimum) {
                         minimum  = minRange;
                    }
                }

                return parseFloat(minimum);
            }
        });

/* xcp_gauge_chart/content/xcp/widget/report/XCPGaugeChartTheme.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: docadmin
 * Date: 1/8/12
 * Time: 2:50 PM
 * To change this template use File | Settings | File Templates.
 */


var widjetLabelText='11px Helvetica, Arial, Sans-serif';
var widjetValueText='10px Helvetica, Arial, Sans-serif';

Ext.define('Ext.chart.theme.XCPGaugeChartTheme', {
    extend: 'Ext.chart.theme.Base',

    constructor: function(config) {
        this.callParent([Ext.apply(
            {
                background:false,
                axis: {
                    fill: '#707070',
                    font: widjetValueText,
                    stroke: '#707070',
                    'stroke-width': 0
                },
                axisLabelTop: {
                    fill: '#707070',
                    font: widjetValueText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisLabelRight: {
                    fill: '#707070',
                    font: widjetValueText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisLabelBottom: {
                    fill: '#707070',
                    font:widjetValueText,
                    padding: 10,
                    rotate: {
                        degrees: 315
                    },
                    renderer: function(v) { return v; }
                },
                axisLabelLeft: {
                    fill: '#707070',
                    font: widjetValueText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisTitleTop: {
                    font: widjetLabelText,
                    fill: '#707070'
                },
                axisTitleRight: {
                    font: widjetLabelText,
                    fill: '#707070',
                    rotate: {
                        x:0, y:0,
                        degrees: 270
                    }
                },
                axisTitleBottom: {
                    font: widjetLabelText,
                    fill: '#707070'
                },
                axisTitleLeft: {
                    font: widjetLabelText,
                    fill: '#707070',
                    rotate: {
                        x:0, y:0,
                        degrees: 270
                    }
                }
            }
            , config)]);
    }
});/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */


Ext.namespace("xcp.Strings.action.task.GetNextTaskDataAction");
Ext.apply(xcp.Strings.action.task.GetNextTaskDataAction, {
    TasksUnavailableNotificationTemplate:  "There are no more available tasks",
    GetNextTaskErrorTemplate: "An error occurred while acquiring next task. Please try again.",
    GetNextTaskAssignNotificationTemplate: "Task '{taskName}' has been assigned to you"
});
/* xcp_get_next_task/content/xcp/action/task/GetNextTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// GetNextTaskDataAction.js

/**
 * @class xcp.action.form.GetNextTaskDataAction
 * @extends xcp.action.form.DataAction
 * Action implementation for get next task
 */
Ext.define("xcp.action.task.GetNextTaskDataAction", {
            extend: "xcp.action.form.DataAction",
            alias: "action.xcp_get_next_task",

            statics: {
                /**
                 * Handles the redirection of action success.
                 * @param {Ext.data.Model} record The Model instance
                 */
                handleRedirection: function(record) {

                    if (!Ext.isDefined(xcp.navigationManager))
                        return;

                    var activityName = record.get("activityName");
                    var processName = record.get("processName");
                    if (xcp.util.Utils.isPageExist(processName, activityName)) {
                        var taskId = record.get("taskID");
                        var url = processName + "/" + taskId + "/" + activityName;
                        xcp.navigationManager.navigate(url);
                    } else {
                        xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.GetNextTaskDataAction.GetNextTaskAssignNotificationTemplate);
                    }
                }

            },
            config: {
                actionModel:"get_next_task_model"
            },

            /**
             * Handler for the Get Next Task Action
             */
            handler: function(actionArgs, action) {
                var config = this.getConfig();

                var handleGetNextTaskSuccess = function(record, operation) {
                    xcp.event.EventBus.publish(xcp.event.ItemModified.NAME);
                    var activityName = record.get("activityName");
                    var processName = record.get("processName");
                    if (xcp.util.Utils.isPageExist(processName, activityName)) {
                        xcp.action.task.GetNextTaskDataAction.handleRedirection(record);
                    } else {
                        xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.GetNextTaskDataAction.GetNextTaskAssignNotificationTemplate, record);
                    }
                };

                var handleGetNextTaskFailure = function(record, operation) {
                    var error = operation.getError();
                    xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, '');
                    if (error !== undefined && error.status == 404) {
                        xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.GetNextTaskDataAction.TasksUnavailableNotificationTemplate);
                    }
                    xcp.Logger.log("No work queue tasks available for the user");
                };

                // Do GET for get next task action. Hence the static load method is called from the get next task model.
                get_next_task_model.load(null, {
                    scope: this,
                    success : handleGetNextTaskSuccess,
                    failure : handleGetNextTaskFailure
                });
            },

            getEnablement:function(actionArgs, action){
                return xcp.enablement.ENABLE;
            }

        });


/* xcp_get_next_task/content/xcp/data/model/GetNextTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("get_next_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/getnexttask"
    },
    "fields" : [
        {
            "name":"taskID",
            "type":"string"
        },
        {
            "name":"processName",
            "type":"string"
        },
        {
            "name":"activityName",
            "type":"string"
        },
        {
            "name":"taskName",
            "type":"string"
        }
    ]

});


/* xcp_gotopage/content/xcp/action/GotoPageAction.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.GotoPageAction
 * @extend xcp.action.Action
 *
 * Implementation of go-to-page action.
 */
Ext.define("xcp.action.GotoPageAction", {
    extend: "xcp.action.Action",
    alias: "action.xcp_gotopage",
    config : {
      text : "",
      page : ""
    },

    constructor: function(config) {
        config = config || {};

        if (!(config.redirectStyle && config.redirectStyle == "application")) {  // $NON-NLS-1$ 
            // Add enablement criteria of id for navigation to non application pages
            Ext.apply(config, {requiredAttributes: ["id"], preconditions: {targets: {validId: true}}});
        }
        this.items = [];
        this.initConfig(config);  // merge prototype's .config object
        this.callParent([this.config]);
    },

    /**
     * Handler method of user defined action
     * @param actionArgs
     * NOTE: This action can be run without target model!   .page has /typename already. (for application level pages)
     */
    handler : function(actionArgs, action) {
        var config = action.getConfig();
        var target = action.getTargets(actionArgs)[0];

        if (Ext.isEmpty(config.page) && !Ext.isEmpty(config.redirectUrl)) {
            config.page = config.redirectUrl;
        }

        if (!config.page)
            return;

        var isApplicationPage = false;
        if (config.redirectStyle && config.redirectStyle == "application")  // $NON-NLS-1$ 
            isApplicationPage = true;

        var url;
        if (target && !isApplicationPage) {
            var id = target.getId();
            var typeName = actionArgs.getTypeName(target);
            url = xcp.util.Utils.makePageUrl(typeName, id, config.page, actionArgs.component);
            xcp.navigationManager.navigate(url);
        } else {
            xcp.navigationManager.navigate(config.page);
        }
    }

});

/* xcp_gotopage/content/xcp/action/task/TaskGotoPageAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.TaskGotoPageAction
 * @extend xcp.action.Action
 *
 * Implementation of task view go-to-page action.
 */
Ext.define("xcp.action.TaskGotoPageAction", {
    extend: "xcp.action.Action",
    alias: "action.xcp_task_gotopage",
    config : {
      text : "",
      page : ""
    },

    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var config = action.getConfig();

        var taskObj = actionArgs.selection[0];

        var taskId = taskObj.getId();
        var processName = taskObj.get("process_system_name");
        var activityName = taskObj.get("activity_system_name");
        var pageUrl = processName + "/"+taskId+"/"+activityName;

        xcp.navigationManager.navigate(pageUrl);
    },
    /**
     * Returns true if the action is applicable otherwise false
     * @param actionArgs
     * @param action
     */
    getEnablement:function(actionArgs, action){
        var taskObj = action.getTargets(actionArgs)[0];
        if (taskObj){
            var processName = taskObj.get("process_system_name");
            var activityName = taskObj.get("activity_system_name");
            if (xcp.util.Utils.isPageExist(processName, activityName)) {
                return xcp.Enablement.ENABLE;
            }
        }
        return xcp.Enablement.HIDE;
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */



// HaltTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.HaltTaskDataAction");
Ext.apply(xcp.Strings.action.task.HaltTaskDataAction, {
    confirmationTitle: "Halt Task?",
    confirmationPromptTemplate: "Are you sure you want to halt this task?",
    haltTaskSuccessNotificationTemplate:  "The task has been halted.",
    haltTaskErrorTemplate: "An error occurred while halting this task. Please try again.",
    text:"Halt",
    tooltip:"Halt"
});
/* xcp_halt_task/content/xcp/action/task/HaltTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// HaltTaskDataAction.js

/**
 * @class xcp.action.task.HaltTaskAction
 * @extends xcp.action.form.DataAction
 * Action implementation for halting the task.
 */
Ext.define("xcp.action.task.HaltTaskDataAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.xcp_halt_task",

    statics: {
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {string} id  instance id
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, id, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    url = action.redirectUrlModel + "/" + id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        }

    },

    config: {

        text: xcp.Strings.action.task.HaltTaskDataAction.text,
        tooltip: xcp.Strings.action.task.HaltTaskDataAction.tooltip,
        requiredAttributes: ["task_state"],
        /**
         * @cfg {String} confirmationPrompt Pattern for string used as confirmation prompt (defaults to
         * Are you sure you want to update an item"?)
         */
        confirmationPrompt: xcp.Strings.action.task.HaltTaskDataAction.confirmationPromptTemplate,
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false,
        actionModel:"halt_task_model",
        showSuccessNotification:true
    },
    constructor: function(config) {
        config = config || {};
        var prototype = this.self.prototype;
        // copy primary attributes from prototype (so handler doesn't have to be in config)
        var prototypeConfig=Ext.copyTo({},prototype.config, ["text", "iconCls", "tooltip", "handler", "actionModel", "showSuccessNotification"]);
        Ext.applyIf(config, prototypeConfig);

        this.callParent([config]);
    },

    /**
     * Handler for the UpdateAction
     */
    handler: function(actionArgs, action) {
        var config;
        // Note that this method will run in the context of the associated component (button, menu, etc.), therefore
        // the "this" refers to the component, not to the action.  Configuration from the action is propogated to the
        // component, but functions are not, thus functions which access instance data won't work.

        if (Ext.isEmpty(action)) { //delete action invoked from form button
//            //update action's input model when action is invoked.
//            if (!Ext.isEmpty(actionArgs.selection))
//                this.setInputModel(actionArgs.selection[0]);
//
            config = this.getConfig();
            targets = [this.getActionModel()];
        }
        else {
            config = action.getConfig();
            targets = action.getTargets(actionArgs);
        }
        var model=xcp.action.form.DataAction.getModelForSelection(targets[0], this.actionModel);

        //to set model instance property "phantom" to be false since this action model is just created
        //and ExtJs expected this value to be false so it can issue a "PUT" action to the server

        model.phantom = false;

        var id = model.getId();

        var handleHaltSuccess = function(record, operation) {
            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, id);
            if (config.showSuccessNotification) {
                xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.HaltTaskDataAction.haltTaskSuccessNotificationTemplate);
            }

            xcp.action.task.HaltTaskDataAction.handleRedirection(this, id, record, operation);

        };
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    model.save({success: handleHaltSuccess, feedbackContainer: actionArgs.component, scope: this});
                }
            };

            Ext.Msg.show({
                title:  xcp.Strings.action.form.UpdateAction.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.task.HaltTaskDataAction.confirmationPromptTemplate, model),
                scope: this
            });
        } else {
            model.save({success: handleHaltSuccess, feedbackContainer: actionArgs.component, scope: this});
        }
    },
    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if (baseAction.isQueueTask(actionArgs, action)) {
            applicable = baseAction.isQueueTaskActionApplicable(actionArgs, action, true, true,false,false, true,0);
        } else {
            applicable = baseAction.isTaskActionApplicable(actionArgs, action, true, true, true, true,0);
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;

    },
    getInitialEnablement: function() {
        return xcp.Enablement.HIDE;
    }

});


/* xcp_halt_task/content/xcp/data/model/HaltTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("halt_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/halt"
    },
    "fields" : [
        {
            "name":"id"
        }
    ]
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// HoldTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.HoldTaskDataAction");
Ext.apply(xcp.Strings.action.task.HoldTaskDataAction, {
    confirmationTitle: "Hold Task?",
    confirmationPromptTemplate: "Are you sure you want to Hold this task?",
    updateSuccessNotificationTemplate:  "The task has been held.",
    updateErrorTemplate: "An error occurred while holding this task. Please try again."
});
/* xcp_hold_task/content/xcp/action/task/HoldTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// HoldTaskDataAction.js

/**
 * @class xcp.action.task.HoldTaskDataAction
 * @extends xcp.action.task.BaseTaskDataAction
 * Action implementation for hold task action.
 */
Ext.define("xcp.action.task.HoldTaskDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_hold_task",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false
    },

    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if (baseAction.isQueueTask(actionArgs, action)) {
            applicable = baseAction.isQueueTaskActionApplicable(actionArgs, action, true, true,false,false, true,[0,1]);
        } else {
            applicable = baseAction.isTaskActionApplicable(actionArgs, action, true, true, true, true,[0,1]);
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;
    },

    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.HoldTaskDataAction";
    }
});

/* xcp_hold_task/content/xcp/data/model/HoldTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp_da_def_hold_currenttask",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/hold"
    },
    "fields" : [
        {
            "name" : "id",
            "type" : "string"
        },
        {
            "name" : "holdUntil",
            "type" : "string"
        }
    ]
});


/* xcp_image/content/xcp/widget/Image.js */

// Image.js
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.Image
 * @extends Ext.Img
 * Simple helper class for easily creating image components. This simply renders an image tag to the DOM with the configured src.
 * @constructor
 * Creates a new Image
 * @param {Object} config Configuration options.
 * @xtype xcp_image
 */
Ext.define("xcp.widget.Image",  {
    extend: 'Ext.Img',
    alias: 'widget.xcp_image',
    widgetCls: 'xcp-image-widget-wrapper',
    isShow: false,
    aTagEl:null,

    initComponent : function() {
    	this.src = xcp.util.Utils.buildArtifactsUrl(this.imageSource);
        this.on('destroy',this.widgetDestroy);
        this.callParent(arguments);
    },
    
    setValue : function (value){
    	this.externalURL = value;
    	if (!Ext.isEmpty(this.aTagEl) && this.aTagEl.dom){
    		this.aTagEl.dom.href = this.externalURL;
    	} else if (this.rendered) {
            //wrap image tag when src value is set from expression
            this.wrapImageTag(this.externalURL);
        }
    },

    /**
     * @Override
     */
    afterRender: function(){
        this.callParent(arguments);

        var linkUrl;
        if (this.isInternal) {
            linkUrl = this.internalURL;
        }else {
            linkUrl = this.externalURL;
        }

        this.wrapImageTag(linkUrl);

        this.addAlternateText(this);
    },


    wrapImageTag: function(linkUrl) {
        this.imageEl = this.el;

        if (Ext.isEmpty(linkUrl)==false && Ext.isEmpty(this.aTagEl)==true) {
            //wrap img tag with <a> tag
            var aTagOpt;
    		if (this.behavior==true){
    			aTagOpt = {
        	            tag: 'a',
        	            target: '_blank',
        	            href: linkUrl
        	        };
        	}else{
        		aTagOpt = {
        	            tag: 'a',
        	            href: linkUrl
        	        };
        	}

            this.el = this.aTagEl = Ext.get(this.el.wrap(aTagOpt));
            this.el.addCls(this.widgetCls);
        }

    },

    setDisabled : function(disabled) {
    	var me = this;
    	me.callParent(arguments);
    	if(Ext.isEmpty(this.internalURL)==false || Ext.isEmpty(this.externalURL)==false){
    		if(disabled){
    			me.aTagEl.setAttribute("onclick","return false;");
    		}else{
    			me.aTagEl.removeAttribute("onclick");
    		}
    	}
    },
    widgetDestroy : function( cmp,  eOpts ){
    	if (Ext.isEmpty(this.aTagEl)==false){
    		Ext.get(this.aTagEl).remove();
    		this.aTagEl=null;
            if (this._tip) {
                this._tip.destroy();
            }
    	}
    },

    addAlternateText : function(cmp){
    	if (Ext.isEmpty(cmp.alternateText)==false){
    		cmp.getEl().dom.alt = cmp.alternateText;
    	}
    	if (Ext.isEmpty(cmp.tooltip)==false){
	    	this._tip = Ext.create('Ext.tip.ToolTip', {
	    	    target: cmp.getEl(),
	    	    html: cmp.tooltip
	    	});
    	}
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// ImportFileAction-strings.js

Ext.namespace("xcp.Strings.action.ImportFile");
Ext.apply(xcp.Strings.action.ImportFile, {
    text: "Import",
    tooltip: "Import a file"
});
/* xcp_importfile/content/xcp/action/ImportFileAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.ImportFile
 * @extend xcp.action.Action
 *
 */
Ext.define("xcp.action.ImportFile", {
    extend: "xcp.action.Action",
    alias: "action.xcp_importfile",

    config: {
        text:   xcp.Strings.action.ImportFile.text,
        tooltip: xcp.Strings.action.ImportFile.tooltip,

        requiredAttributes: ["effectivePermissions"],
        preconditions: {
            targets:{
                validId:    true,
                effectivePermissions: [xcp.Permit.BROWSE]
            }
        }

    },

    getEnablement:function(actionArgs, action) {
        if (Ext.is.iPad) {
            // No way to select files for import on iPad, so don't even show this action
            return xcp.Enablement.HIDE;
        }

        var target = action.getTargets(actionArgs)[0];
        if (target) {
            var permits = target.get('effectivePermissions');
            if (permits === undefined || permits == "") {
                return xcp.Enablement.ENABLE;
            }
            if (xcp.Permit.hasPermit(permits, xcp.Permit.WRITE)) {
                return xcp.Enablement.ENABLE;
            } else if ((xcp.Permit.hasPermit(permits, xcp.Permit.CHANGE_FOLDER_LINKS)) && (xcp.Permit.hasPermit(permits, xcp.Permit.BROWSE))) {
                return xcp.Enablement.ENABLE;
            } else
                return xcp.Enablement.HIDE;
        }
        return xcp.Enablement.ENABLE;
    },
    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var targets = action.getTargets(actionArgs);
        var target = targets[0];
        if (!target) return;

        var id = target.getId();

        //  Show this dialog only in runtime, never in design time
        if (!id && typeof(xcp) != 'undefined' && typeof(xcp.navigationManager) != 'undefined')
            id=xcp.navigationManager.currentNavigationContext.objectId;

        if (id){}
            Ext.create('xcp_import_file', {targetFolderId: id}).show();
        }
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// ImportFileAction-strings.js

Ext.namespace("xcp.Strings.action.ImportNewVersion");
Ext.apply(xcp.Strings.action.ImportNewVersion, {
    text: "Import new version",
    tooltip: "Import a new version"
});
/* xcp_importnewversion/content/xcp/action/ImportNewVersionAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.ImportNewVersion
 * @extend xcp.action.Action
 *
 */
Ext.define("xcp.action.ImportNewVersion", {
    extend: "xcp.action.Action",
    alias: "action.xcp_importnewversion",

    config: {
        text:   xcp.Strings.action.ImportNewVersion.text,
        tooltip: xcp.Strings.action.ImportNewVersion.tooltip,

        requiredAttributes: ["effectivePermissions"],
        preconditions: {
            targets:{
                validId:    true,
                effectivePermissions: [xcp.Permit.WRITE]
            }
        }
    },
    getEnablement:function(actionArgs, action){
        if (Ext.is.iPad) {
            // No way to select files for import on iPad, so don't even show this action
            return xcp.Enablement.HIDE;
        } else {
            return xcp.Enablement.ENABLE;
        }
    },
    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var targets = action.getTargets(actionArgs);
        var target = targets[0];
        if (!target) return;

        var id = target.getId();
        var name = "";
        var format = "";

        //  Show this dialog only in runtime, never in design time
        if (!id && typeof(xcp) != 'undefined' && typeof(xcp.navigationManager) != 'undefined')
            id = xcp.navigationManager.currentNavigationContext.objectId;

        if ((target.getId()) && target.getData() != 'undefined') {
            if (target.getData().object_name != 'undefined')
                name = target.getData().object_name

            if (target.getData().a_content_type != 'undefined')
                format = target.getData().a_content_type
        }

        if (id) {
            Ext.create('xcp_import_newversion', {targetObjectId: id, targetObjectName: name, targetContentType: format}).show();
        }
    }
});


/* xcp_logout/content/xcp/action/LogoutAction.js */

// LogoutAction.js
/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.Logout
 * @extend xcp.action.Action
 *
 * Implementation of go-to-page action.
 */
Ext.define("xcp.action.LogoutAction", {
    extend: "xcp.action.Action",
    alias: "action.xcp_logout",
    
    /**
     * Handler method of user defined action
     * @param actionArgs
     * NOTE: This action can be run without target model!   .page has /typename already. (for application level pages)
     */
    handler : function(actionArgs, action) {
        //remove the path from cookie XCPUIC-3503
        var path = Ext.util.Cookies.get("xcp-login-hash");
        if (path)
            Ext.util.Cookies.clear("xcp-login-hash", path);

		window.location = "j_spring_security_logout"; // $NON-NLS-1$
    }
});
/* xcp_menu/content/xcp/widget/menu/Menu.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.widget.menu.Menu", {
    extend: "Ext.menu.Menu",
    alias: "widget.xcp_menu",
    ui: 'xcp-menu',
    shadow: false,

    /**
     * @cfg {Number} markerOffset A numeric pixel value used to offset the
     * default position of the anchor arrow (defaults to 10).  When the anchor
     * position is on the top or bottom of the tooltip, markerOffset
     * will be used as a horizontal offset.  Likewise, when the marker position
     * is on the left or right side, markerOffset will be used as
     * a vertical offset.
     */
    markerOffset: 10,
    markerHeight: 8,
    markerWidth: 16,

    onRender: function(ct, position) {
        var me = this;
        me.callParent(arguments);
        me.markerCls = 'menu-marker';
        me.markerEl = me.el.createChild({
            tag: 'div',
            html: '<div class="' + me.markerCls +'-inner" />',  // $NON-NLS-L$ 
            cls: me.markerCls
        });
    },

    showBy: function(cmp, pos, off) {
        var me = this;

        if (me.floating && cmp) {
            me.layout.autoSize = true;
            me.show();

             // Component or Element
            cmp = cmp.el || cmp;
            pos = pos || me.defaultAlign;

            if (me.markerEl) {
                var param = me.syncMarker(cmp, pos, off);
                pos = param.pos;
                off = param.off;

                if (!me.markerEl.isVisible()) {
                    me.markerEl.show();
                }
            } else {
                me.markerEl.hide();
            }
        }

        me.callParent([cmp, pos, off]);
    },

    // private
    syncMarker: function(cmp, pos, off) {
        var me = this,
            markerPos,
            targetPos,
            offset,
            w,
            h,
            markerCls = 'menu-marker-',
            cmp = cmp.el || cmp,
            showMarker = true,
            isNavMenu = false,
            targetY,
            targetOffset;

        if (cmp.hasCls && cmp.hasCls('xcp_nav_button-cls')) {
            //no marker for nav menu
            isNavMenu = true;
            showMarker = false;
        }

        if (me.markerCls) {
            me.markerEl.removeCls(me.markerCls);
        }

        // Convert absolute to floatParent-relative coordinates if necessary.
        var r = cmp.getRegion();
        var xy = me.el.getAlignToXY(cmp.el || cmp, pos || me.defaultAlign, off)

        switch (pos) {
        case 'tl-bl?':
            var markerX;

            if (xy[1] >= r.bottom) {
                //align to the bottom of parent
                markerCls = markerCls + 'top';
                markerPos = 'b';
                if (xy[0] < r.x) {
                    //align to bottom right
                    targetPos = 'tr';
                    markerX = -me.markerOffset;
                } else {
                    //align to bottom left
                    targetPos = 'tl';
                    markerX = me.markerOffset + me.markerHeight;
                }

                if (isNavMenu) {
                    targetOffset = [0, 5];
                } else {
                    targetOffset = [0, -1];
                }

                offset = [markerX, 0];
            } else {
                //align to the top of parent
                markerPos = 't';
                markerCls = markerCls + 'bottom';
                if (xy[0] < r.x) {
                    //align to the top right
                    targetPos = 'br';
                    pos = 'bl-tl?';
                    targetY = -1;
                    markerX = -me.markerOffset;
                } else {
                    //align to the top left
                    targetPos = 'bl';
                    markerX = me.markerOffset + me.markerHeight;
                    targetY = 1;
                }
                targetOffset = [0, targetY];
                offset = [markerX, 0];
            }
            w = me.markerWidth;
            h = me.markerHeight;
            break;
        case 'tl-tr?':
            if (xy[0] >= r.x) {
                //align to the right of parent menu
                markerPos = 'l';
                targetPos = 'tl';
                markerCls = markerCls + 'left';
                targetOffset = [me.markerHeight / 2, 0];
                offset = [-me.markerHeight, me.markerOffset + 3];
            } else {
                //align to the left of parent menu
                markerPos = 'r';
                targetPos = 'tr';
                markerCls = markerCls + 'right';
                targetOffset = [-me.markerHeight / 2, 0];
                pos = 'tr-tl?';
                offset = [me.markerHeight, me.markerOffset + 3];
            }
            w = me.markerHeight;
            h = me.markerWidth;
            break;
        default:
            markerPos = 'b';
            targetPos = 'tl';
            offset = [1, me.markerOffset];
            break;
        }

        if (showMarker) {
            me.markerCls = markerCls;
            me.markerEl.addCls(me.markerCls);
            me.markerEl.setSize(w, h);
            me.markerEl.alignTo(me.el, markerPos + '-' + targetPos, offset);
            me.markerEl.setStyle('z-index', parseInt(me.el.getZIndex(), 10) || 0 + 1).setVisibilityMode(Ext.Element.DISPLAY);
        }

        return {pos: pos, off: targetOffset};
    },

    show: function() {
        var me = this;
        me.callParent(arguments);
        if (me.hidden === false && me.markerEl) {
            me.markerEl.show();
        }
    },

    beforeDestroy: function() {
        var me = this;
        if (me.markerEl) {
            Ext.destroy(me.markerEl);
            delete me.markerEl;
        }

        me.callParent();
    }

});

if (Ext.is.iPad) {
    // This override supports using click event on submenus items to display the submenu instead of mouse over
    // since iOS doesn't have mouse over event.
    xcp.widget.menu.Menu.override({
        onMouseOver: function(e) {},
        onMouseLeave: function(e) {},
        onClick: function(e) {
            var me = this,
                item;

            if (me.disabled) {
                e.stopEvent();
                return;
            }

            if (me.parentMenu) {
                me.parentMenu.setActiveItem(me.parentItem);
            }

            item = (e.type === 'click') ? me.getItemFromEvent(e) : me.activeItem;

            // Check to see if the item is a menu. if it is a menu, show it, else, do standard behavior
            if (item && item.menu) {
                if (!item.activated) {
                    me.setActiveItem(item);
                }
                if (item.activated) {
                    if (item.expandMenu && (!item.menu.rendered || !item.menu.isVisible())) {
                        item.expandMenu();
                    } else if (item.menu.rendered && item.menu.isVisible()) {
                        item.deferHideMenu();
                    }
                }

                // Click event may be fired without an item, so we need a second check
                if (!item || item.disabled) {
                    item = undefined;
                }
                me.fireEvent('click', me, item, e);
            } else {
                xcp.widget.menu.Menu.superclass.onClick.apply(this, arguments);
            }
        }
    });
}

/* xcp_nav_menuitem/content/xcp/widget/menu/MenuItem.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function() {
    Ext.define("xcp.widget.menu.MenuItem", {
        extend: "Ext.menu.Item",
        alias: "widget.xcp_menuitem",

        /**
         * Constructor
         * @param config
         */
        constructor: function(config) {
            if (config && config.action) {
                // Use the action as basis for button config if available.  In regular ExtJS, we'd just
                // create the button with the action in the button constructor, but we can't do that
                // in the JSON syntax so we use the action configuration to store the action initially
//                actionInst = xcp.core.ActionManager.create(config.action);
                var actionInst = xcp.core.ActionManager.getAction(config);
                this.callParent([actionInst]);
            }else{
                this.callParent([config]);
            }
        },
        /**
         * Overridden
         * @param autoActivate
         */
        deferExpand : function(autoActivate) {
            delete this.showTimer;
            // no parent menu if not placed in one
            if (this.parentMenu) {
                this.menu.show(this.container, this.parentMenu.subMenuAlign || 'tl-tr?', this.parentMenu);
            } else {
                this.menu.show(this.container);
            }
            if (autoActivate) {
                this.menu.tryActivate(0, 1);
            }
        },
        /**
         * Overridden
         */
        deferHide : function() {
            delete this.hideTimer;
            if (this.menu.over) {
                // no parent menu if not placed in one
                if (this.parentMenu) {
                    this.parentMenu.setActiveItem(this, false);
                }
            } else {
                this.menu.hide();
            }
        }
    });
})();

/* xcp_nav_menuitem/content/xcp/widget/menu/NavMenuItem.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

(function() {
    var ns = Ext.ns('xcp.widget.menu');

    Ext.define("xcp.widget.menu.NavMenuItem", {
        extend : "xcp.widget.menu.MenuItem",
        alias : "widget.xcp_nav_menuitem",

        constructor : function(config) {
            // for design mode cloning the initial configuration.
            if (!this._initialDesignConfig) {
                this._initialDesignConfig = config ? Ext.clone(config) : {};
            }

            if (Ext.is.iPad) {
                if (config.menu) {
                    // If the current item is a submenu, don't hide it upon click.  The click event will
                    // be used for submenu display instead of the mouseover event since there is no concept of
                    // mouse over on the iPad
                    Ext.apply(config, {hideOnClick: false});
                }
            }

            config = Ext.apply(config, {
                plugins : ["xcp_nav_on_event", "xcp_button_menu_onhover"].concat(config["plugins"] || [])
            });
            ns.NavMenuItem.superclass.constructor.call(this, config);
        },

        initComponent: function(){
            this.enableBubble('beforePageNavigate');
            this.callParent();
        },

		beforeRender : function() {
			this.callParent(arguments);
			this.topMenu = this.getTopMenuParent();
		},
		
        getBubbleTarget: function() {
            //bubble event to top level nav menu button          
            return this.topMenu;
        },

        getTopMenuParent: function(){
            var topMenu = this.up('xcp_menu'),
                parent = topMenu;

            while (parent) {
                parent = parent.up('xcp_menu');
                if (parent) {
                    topMenu = parent;
                }
            }

            if (topMenu) {
                topMenu = topMenu.floatParent;
            }

            return topMenu;
        }
    });
})();
/* xcp_menuseparator/content/xcp/widget/menu/MenuSeparator.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.widget.menu.MenuSeparator", {
    extend : "Ext.menu.Separator",
    alias : "widget.xcp_menuseparator"
});
/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.form.MultiValue");

Ext.apply(xcp.Strings.widget.form.MultiValue, {
	add : "Add",
	remove : "Remove",
	up : "Move Up",
	down : "Move Down"
});
/* xcp_multivalue_date_input/content/xcp/widget/form/MultiValueDateField.js */

Ext.define("xcp.widget.form.MultiValueDateField", {
    extend: 'xcp.widget.form.MultiValueInput',
    alias: 'widget.xcp_multivalue_date_input',
    dateStyle: "datetime",
    constructor : function(config) {
	    if (config) {
			 config = Ext.clone(config);
		}
        config = config || {};

    	var me = this;
		
        config.format = config.format ||  {
        	xtype: "xcp_datetime_formatter",
        	dateStyle : "datetime",
			dateFormat: "long",
			timeFormat : "long"
        };
        	
		config.columnRenderer = function (value) {
        	var format = Ext.clone(me.format);
        	delete format.xtype;
        	
        	var formatter = new xcp.formatter.DateTimeFormatter(format);
        	return formatter.format(value);
        }; 
			
        config.editor = config.editor || 
        	{
        		xtype: "xcp_date_time_input",
        		format: config.format,
				// focus on the first field in the date input widget.
				afterLayout: function () {
					this.items.get(0).focus();
				}
        	};
        	
        this.callParent([config]);
    }
});/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.form.MultiValue");

Ext.apply(xcp.Strings.widget.form.MultiValue, {
	add : "Add",
	remove : "Remove",
	up : "Move Up",
	down : "Move Down"
});
/* xcp_multivalue_number_input/content/xcp/widget/form/MultiValueNumberField.js */

Ext.define("xcp.widget.form.MultiValueNumberField", {
    extend: 'xcp.widget.form.MultiValueInput',
    alias: 'widget.xcp_multivalue_number_input',
    constructor : function(config) {
        if (config) {
			 config = Ext.clone(config);
		}
        config = config || {};
		
        config.editor = config.editor || 
        	{
        		xtype: "xcp_number_input",
				hideTrigger : true,
                keyNavEnabled : false,
                mouseWheelEnabled : false,
                autoStripChars : true,
                hstretch : true,
                allowDecimals : config.allowDecimals
        	};
        this.callParent([config]);
    },
    getValue : function() {
		var store = this.down("xcp_multivalue_input_grid").getStore();
		var data = [];
		store.each(
			function(record){
				var value = record.data.value;
				if (null != value && "" != value && !isNaN(value)) {
					data.push(record.data.value*1)
				} // else dont save the value
		});
		
		return data;
	}
});/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.form.MultiValue");

Ext.apply(xcp.Strings.widget.form.MultiValue, {
	add : "Add",
	remove : "Remove",
	up : "Move Up",
	down : "Move Down"
});
/* xcp_multivalue_text_input/content/xcp/widget/form/MultiValueTextField.js */

Ext.define("xcp.widget.form.MultiValueTextField", {
    extend: 'xcp.widget.form.MultiValueInput',
    alias: 'widget.xcp_multivalue_text_input'
});
/* xcp_nav_button/content/xcp/widget/button/LinkButton.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function(){
    Ext.define("xcp.widget.button.LinkButton", {
        extend: 'Ext.button.Button',
        alias: 'widget.xcp_linkbutton',

        //cls: 'xcp-linkbutton',

        onClick : function(e) {

            // we don't want the link to be followed on click
            if (e) {
                e.preventDefault();
            }
            // left button only
            if (e && e.button !== 0) {
                return;
            }
            if (!this.disabled) {
                if (this.enableToggle && (this.allowDepress !== false || !this.pressed)) {
                    this.toggle();
                }

                if(this.menu && !this.hasVisibleMenu() && !this.ignoreNextClick){
                    this.showMenu();
                }
                this.fireEvent("click", this, e);
                if (this.handler) {
                    this.handler.call(this.scope || this, this, e);
                }
            }
        }
    });
})();

/* xcp_nav_button/content/xcp/widget/button/NavButton.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

(function() {
    Ext.define("xcp.widget.button.NavButton", {
        extend: "xcp.widget.button.LinkButton",
        alias: "widget.xcp_nav_button",
        ui: 'xcp-nav-button',
        allowDepress: false,

        constructor : function(config) {

            // for design mode cloning the initial configuration.
            if (!this._initialDesignConfig) {
                this._initialDesignConfig = config ? Ext.clone(config) : {};
            }

            // attach navigation and menu on hover
            config = Ext.apply(config, {
                plugins : ["xcp_nav_on_event", "xcp_button_menu_onhover"].concat(config["plugins"] || [])
            });
            this.callParent(arguments);
        }
    });
})();
/* xcp_navigation_menu/content/xcp/widget/toolbar/NavToolbar.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.widget.toolbar.NavToolbar", {
    extend : "Ext.toolbar.Toolbar",
    ui: "xcp-nav-toolbar",
    alias : "widget.xcp_navigation_menu",

    showMarker: true,

    initComponent: function(){

        var config = this.initialConfig;
        //all nav menu items share the same togglegroup
        this.toggleGroup = 'navtoolbar-' + Ext.id();

        if (xcp.navigationManager && xcp.navigationManager.on) {
            xcp.navigationManager.on('navigationcomplete', this.onNavigationComplete, this);
        }
        if (this.showMarker) {
            this.createMarker();
        }
        this.callParent();

        this.initOverflowHandler();
        this.delayedShowMarkerTask = new Ext.util.DelayedTask(this.delayedShowMarkerAt, this);
    },

    onAdd : function(item) {
        item.toggleGroup = this.toggleGroup;
        item.enableToggle = true;
        return this.callParent(arguments);
    },

    remove : function(item) {
        var pressed = Ext.ButtonToggleManager.getPressed(this.toggleGroup);
        if (pressed === item) {
            this.hideCaret();
        }
        return this.callParent(arguments);
    },

    beforeRender: function() {
        //need to set flex to 1 if inside xcp_columnhbox;
        var hbox = this.up('xcp_columnhbox');
        if (hbox) {
            this.flex = 1;
        }

        return this.callParent(arguments);
    },

    afterRender: function(){
        this.callParent(arguments);
        if (this.items.items) {
            Ext.each(this.items.items, function(item){
                if (item.xtype == 'xcp_nav_button' || item.xtype == 'xcp_menu'){
                    item.on('beforepagenavigate', this.onBeforeNavigate, this);
                    item.on('beforehide', this.onNavButtonHide, this);
                    item.on('show', this.onNavButtonShow, this);
                }
            }, this)
        }
        this.on('afterlayout', this.onNavToolbarResize, this);
    },

    /**
     * Create a floating marker
     */
    createMarker: function(){
        var me = this;
        me.marker = Ext.widget('component', {
            floating: true,
            cls: 'nav-menu-caret',
            hidden: true,
            html: '<div class="inner-caret"></div>',
            doAutoRender: function(){
                //Need to render the marker to a container
                var container = me.getMarkerFloatingParent();
                if (container) {
                    this.render(container.getEl());
                }
            }
        })
    },

    getMarkerFloatingParent: function() {
        var me = this;
        //Get the column box as the floating parent
        //because the floating marker needs to be outside of the
        //columnhbox which contains the nav toolbar, so that
        //the marker can overlay the columnhbox border
        var parent = me.up('xcp_column_box');
        if (!parent) {
            parent = me;
        }

        return parent;
    },

    onNavButtonHide: function(btn, ev){
        var pressed = Ext.ButtonToggleManager.getPressed(this.toggleGroup);
        if (btn == pressed) {
            this.hideCaret();
        }
    },

    onNavButtonShow: function(btn, ev){
        var pressed = Ext.ButtonToggleManager.getPressed(this.toggleGroup);
        if (btn == pressed) {
            this.showMarkerAt(btn);
        }
    },

    onNavToolbarResize: function(){
        var pressed = Ext.ButtonToggleManager.getPressed(this.toggleGroup);
        if (pressed && pressed.isVisible() && this.marker) {
            this.showMarkerAt(pressed);
        }
    },

    onBeforeNavigate: function(btn, ev){
        if (btn.getXType() == 'xcp_nav_menuitem') {
            btn = btn.getTopMenuParent();
        }
        this.navigateFromMenu = true;
        this.showMarkerAt(btn);
    },

    /**
     *
     * @param xcpNavigationManager
     */
    onNavigationComplete: function(xcpNavigationManager){
        var navButtons = this.query('xcp_nav_button');
        var loadedUrl = xcpNavigationManager.currentNavigationContext.navigationPath;
        var match = false;
        Ext.each(navButtons, function(navBtn){
            if (navBtn.xcp_nav_url) {
                var url = navBtn.xcp_nav_url.replace("#", "");
                if (url == loadedUrl) {
                    match = true;
                    navBtn.toggle(true);
                    this.showMarkerAt(navBtn);
                    return false;
                }
            }
        }, this);
        if (!match && !this.navigateFromMenu) {
            var pressed = Ext.ButtonToggleManager.getPressed(this.toggleGroup);
            if (pressed) {
                pressed.toggle(false);
                this.hideCaret();
            }
            this.navigateFromMenu = false;
        }
    },

    /**
     * Display marker under the menu button
     * @param cmp
     */
    showMarkerAt: function(cmp){
        var delayedShowMarkerTask = this.delayedShowMarkerTask;
        if (delayedShowMarkerTask) {
            delayedShowMarkerTask.delay(1, null, this, [cmp]);
        }
    },

    hideCaret: function(){
        if (this.marker && !this.marker.isDestroyed) {
            this.marker.setVisible(false);
        }
    },

    destroy: function(){
        if (this.marker) {
            this.marker.destroy();
        }
        this.delayedShowMarkerTask = null;
        return this.callParent(arguments);
    },

    delayedShowMarkerAt : function(cmp) {
        var marker = this.marker;
        if (marker && !marker.isDestroyed && !marker.destroying && !this.isDestroyed && !this.destroying) {
            if (cmp.isDestroyed || cmp._inOverflow) {
                this.hideCaret();
            } else {
                // Get around an extjs 4.1 bug about a javascript error during window re-sizing handling.
                // The layout engine makes a bad guess about the ownerCtContext in Ext.layout.Context.invalidate.
                // A float element.ownerCtContext for a floating element should be null, so defer the alignment in a seperate timer.
                if (cmp._inOverflow)
                marker.setVisible(false);
                marker.show();
                if (marker.rendered) {
                    marker.alignTo(cmp.getEl(), 'b', [-8, -6]);
                    marker.setVisible(true);
                }
            }
        }
    },

    initOverflowHandler : function () {
        var me = this;
        me.getLayout();
        var overflowHandler = me.layout.overflowHandler;
        if (!overflowHandler) {
            return;
        }
        Ext.override(overflowHandler, {
            handleOverflow: function(ownerContext) {
                Ext.Array.each(me.items.items, function(item) {
                    item._inOverflow = false;
                });

                var ret = this.callParent(arguments);

                // The extjs box layout seems to miss 2 pixels causing the trigger wraps on to the next line.
                if (ret.reservedSpace) {
                    //add extra space to account for the vertical scrollbar width, which covers part of the overflow trigger
                    ret.reservedSpace += 18;
                }

                return ret;
            },

            createMenuConfig : function(component, hideOnClick) {
                component._inOverflow = true;
                var ret = this.callParent(arguments);
                if (!ret.text && component.textOnOverflow) {
                    ret.text = component.textOnOverflow;
                }
                if (ret.menu && ret.menu.items && ret.menu.items.items.length == 0) {
                    delete ret.menu;
                }

                return ret;
            }
        });
    }
});


/* xcp_number_input/content/xcp/widget/form/NumberField.js */

//NumberField.js
/*
* Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
*/
/**
* @class xcp.widget.form.NumberField
* @extends Ext.form.Number
* Number field widget capable of allowing user input as numbers. Supports both integer and decimal inputs
* @xtype xcp_number_input
*/
Ext.define("xcp.widget.form.NumberField", {
    extend: 'Ext.form.Number',
    alias: 'widget.xcp_number_input',
    mixins : {
        xcpFixedFieldWidthModelMixin : 'xcp.util.mixin.FixedFieldWidthModelMixin'
    },
    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {
            return newValue;
        }
    }],
    

    constructor: function(config) {
        // see xcpuic-948
        if (config && config.allowDecimals && config.allowDecimals == true){
            config.decimalPrecision = 10;
        }
        xcp.widget.form.Form.encodeFieldLabel(config);
        this.callParent(arguments);
        //reset input on blur so that it automatically scrolls back to the begining of the input
        this.on("blur", this._resetInput, this);
        this.mixins.xcpFixedFieldWidthModelMixin.constructor.call(this, "size");  // $NON-NLS-1$ 
    },

    initComponent: function() {
        var me = this,
            allowed;

        me.callParent(arguments);

        // Build regexes for masking and stripping based on the configured options
        //support e notation XCPUIC-4052, XCPUIC-4044
        // "e" => "", "eee" => "", "eeeaaa" => "",
        // "1eeee-2" => "1e-2", "1eeeaaa-2" => "1e-2", "e-2" => "-2", "aaae-2" => "-2"
        if (me.disableKeyFilter !== true) {
            var allowed = me._getAllowedChars(me.allowDecimals);
            
            me.maskRe = new RegExp('[' + allowed + ']');
            if (me.autoStripChars) {
                me.stripCharsRe = this._getStripCharsRe(allowed);
            }
        }
    },
    
    _getAllowedChars : function(allowDecimals) {
                var me = this;
        var allowed = me.baseChars + "e";
                
        if (allowDecimals) {
            allowed += me.decimalSeparator;
        }
        if (me.minValue < 0) {
            allowed += '-';
        }
        allowed = Ext.String.escapeRegex(allowed);
        
        return allowed          
    },
    
    _getStripCharsRe : function(allowed) {
                return new RegExp('[^' + allowed + ']|^[e]*|([e])(?=\\1)', 'gi');
    },

    //private method
    _resetInput: function() {
        var value = this.getValue();
        if(value !== null && typeof(value) === "number") {
            this.setValue(value);
        }
    },
    rawToValue: function(rawValue) {
        var value = this.fixPrecision(this.parseValue(rawValue));
        if (value == 0) {
            return value;
        }
        return value || rawValue || null;
    },

    processRawValue: function(value) {
                var me = this;
        if (value && value.length > 0) {
            var allowedChar = me._getAllowedChars(true);
            var newValue = value.replace(this._getStripCharsRe(allowedChar),"");
            var decimalPlace = newValue.indexOf(".");
            if (decimalPlace > -1) {
                var ePlace = newValue.toLowerCase().indexOf("e");
                if (ePlace > -1) {
                    var newValueComponents = newValue.split(/[.e]/ig);
                    if (newValueComponents.length == 3) {
                        var decimalLength = newValueComponents[1].length;
                        newValueComponents[2] -= decimalLength;

                        value = newValueComponents[0]+newValueComponents[1]+"e"+newValueComponents[2];
                    }
                }
            }
        }

        return this.callParent([value]);
    }
});/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// Paste-strings.js

Ext.namespace("xcp.Strings.action.Paste");
Ext.apply(xcp.Strings.action.Paste, {
    text: "Paste",
    tooltip: "Paste items from the clipboard"
});


/* xcp_paste/content/xcp/action/Paste.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.action.Paste
 * @extend xcp.action.Action
 *
 */
Ext.define("xcp.action.Paste", {
    extend: "xcp.action.Action",
    alias: "action.xcp_paste",

    config: {
        text: xcp.Strings.action.Paste.text,
        tooltip: xcp.Strings.action.Paste.tooltip,

        requiredAttributes: ["effectivePermissions"],
        preconditions: {
            targets:{
                validId:    true
            }
        }
    },

    constructor: function(config){
        this.callParent(arguments);
        xcp.Clipboard.on("change", this.updateEnablement, this);
        if (xcp.Clipboard.isEmpty())
            this.disable();
    },

    destroy: function(comp){
        xcp.Clipboard.un("change", this.updateEnablement, this);  // $NON-NLS-1$ 
    },

    getEnablement: function(actionArgs, action){
        if (xcp.Clipboard.isEmpty()) return xcp.Enablement.DISABLE;
        var target = action.getTargets(actionArgs)[0];
        var data=xcp.Clipboard.getData();
        if (target && data.items.length>0){
            // check target to make sure not a source
            for(var i=0, len=data.items.length; i++; i<len){
                if (target.getId() != data.items[i].getId())
                    return xcp.Enablement.DISABLE;
            }
        }
        if(!actionArgs)  return xcp.Enablement.HIDE;
        // if container is folder then get validate effective permissions on it.
        if (target) {
            var permits = target.get('effectivePermissions');
            if (permits === undefined || permits == "") {
                return xcp.Enablement.ENABLE;
            }
            if (xcp.Permit.hasPermit(permits, xcp.Permit.WRITE)) {
                return xcp.Enablement.ENABLE;
            } else if ((xcp.Permit.hasPermit(permits, xcp.Permit.CHANGE_FOLDER_LINKS)) && (xcp.Permit.hasPermit(permits, xcp.Permit.BROWSE))) {
                return xcp.Enablement.ENABLE;
            } else
                return xcp.Enablement.HIDE;

        }
        return xcp.Enablement.ENABLE;
    },

    /**
     * Handler method of user defined action
     * @param actionArgs
     */
    handler : function(actionArgs, action) {
        var data = xcp.Clipboard.getData();

        var sources = data.items;
        if (data.fn){
            data.fn.call(action,
                actionArgs,
                sources,
                action.getTargets(actionArgs),
                data.container ? data.container.getId(): null,
                data.actionConfig);
        }
        if (data.op=="cut"){  // $NON-NLS-1$ 
            xcp.Clipboard.clear();
        }
    }
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.report.Reports");
Ext.apply(xcp.Strings.widget.report.Reports, {
    componentId:                "ID",
	columnsFieldLabel:		    "Columns",
	titleGeneralSectionLabel:	"General",
	titleBasicSectionLabel:	    "Basic",
    titleFieldValue:	        "Title",
    generalDataSectionLabel:    "Data",
    rangesLabel:                "Ranges",
    defaultDisplayLabel: "Default Display",
    displayLabel: "Display",
    reportTyprField:	        "Report Type",
    timeGranularityField:	     "Time Granularity",
    titleInfoSectionLabel:	     "Info",
    titleRulesSectionLabel:	     "Display Rules",
    titleStyleSectionLabel:	     "Style",
    btnEditCrystalReportLabel:	     "Edit in Crystal Reports",
    btnFinishEditCrystalReportLabel:	     "Edit in Crystal Reports",
    msgReportBeingEdited:	     "This report is beign edited",
    msgLoadingReport:             "Loading Report .....",
    msgLastEdited:                "Last saved on ",
    msgErrorLoadingCrystalReport:   "Error loading crystal report RPT file",
    msgUnkownReportType:    "Unkown report type or report type is empty",
    btnSyncCrystalReportLabel:"Sync Crystal Report with Data Source",
    msgErrorUpdatingCrystalReport:   "Error updating crystal report RPT file",
    msgErrorCrystalReportOpenByOtherProcess:  "Cannot update the Crystal Report because it is being used by another process." ,

    chartTypeColumn:"Column",
    chartTypeLine:"Line",
    chartTypePie:"Pie",

    xAxisLabel: "Categories",
    yAxisLabel:"Values",
    prefix:"",

    sampleDataC1 : "A",
    sampleDataC2 : "B",
    sampleDataC3 : "C",
    sampleDataC4 : "D",
    sampleDataC5 : "E",
    sampleDataC6 : "F",
    sampleDataC7 : "G",


    dataC11 : 45,
    dataC21 : 125,
    dataC31 : 50,
    dataC41 : 25,
    dataC51 : 45,
    dataC61 : 90,
    dataC71 : 150,


    dataC12 : 20,
    dataC22 : 15,
    dataC32 : 20,
    dataC42 : 40,
    dataC52 : 35,
    dataC62 : 70,
    dataC72 : 20,


    dataC13 : 70,
    dataC23 : 40,
    dataC33 : 25,
    dataC43 : 10,
    dataC53 : 70,
    dataC63 : 150,
    dataC73 : 10,


    dataC14 : 90,
    dataC24 : 25,
    dataC34 : 40,
    dataC44 : 30,
    dataC54 : 7,
    dataC64 : 2,
    dataC74 : 65,


    dataC15 : 15,
    dataC25 : 10,
    dataC35 : 100,
    dataC45 : 40,
    dataC55 : 75,
    dataC65 : 95,
    dataC75 : 25,


    dataC16 : 110,
    dataC26 : 80,
    dataC36 : 20,
    dataC46 : 35,
    dataC56 : 90,
    dataC66 : 45,
    dataC76 : 70,

    dataC17 : 110,
    dataC27 : 80,
    dataC37 : 20,
    dataC47 : 35,
    dataC57 : 90,
    dataC67 : 45,
    dataC77 : 70,

    dataC18 : 110,
    dataC28 : 80,
    dataC38 : 2,
    dataC48 : 35,
    dataC58 : 90,
    dataC68 : 45,
    dataC78 : 70,


    dataC19 : 110,
    dataC29 : 80,
    dataC39 : 20,
    dataC49 : 35,
    dataC59 : 90,
    dataC69 : 45,
    dataC79 : 70,

    dataC110 : 110,
    dataC210 : 80,
    dataC310 : 20,
    dataC410 : 35,
    dataC510 : 60,
    dataC610 : 45,
    dataC710 : 70,

    dataSectionLabel: "Data",

    createNewOrUsePageTitle: "Data Service and Instance Creation",
    createNewOrUseInstructionText: "A Chart must be connected to an instance of a data service.",
    createNewOrUseRadioHeader: "Create:",
    createNewOrUseRadio1Label: "Data service and instance",
    createNewOrUseRadio1Instructions: "Add a new data service.  An instance of the data service will also be created and connected to the chart.",
    createNewOrUseRadio2Label: "Instance of an existing data service",
    createNewOrUseRadio2Instructions: "Select an existing data service.  A new instance of the data service will be created and connected to the chart.",

    chooseTypePageTitle: "Data Service Creation",
    chooseTypeInstructionText: "Create a data service that returns:",

    selectDSPageTitle: "Create an Instance of an Existing Data Service",
    selectDSInstructionText: "Select a data service:",
    selectDSTitleLabel: "Data service label",

    typeListLabel: "Data service:",

    chooseColumnPageTitleScreen3a: "Specify column chart categories (X Axis)",
    chooseColumnPageTitleScreen3b: "Specify column chart values (Y Axis)",
    
    chooseColumnPageTitleScreen4: "Define values and categories (X and Y axes)",
    chooseColumnPageTitleScreen5: "Create user inputs for the query",
    chooseColumnPageTitle: "Specify columns for Crystal Reports",
    showAllAvailableFields:"Show all available",
    availableColumnsLabel:"Available:",
    includedColumnsLabel:"Included:",
    primaryTypeLabel: "{0} ({1})",

    categoriesXaxis:"Categories (X Axis)",
    valuesYaxis:"Values (Y Axis)",
    
    dataSourceName:"Data Source",
    axis_Label: "Axis Label",
    yAxis_Label:"Y Axis Label",
    xAxis_Label:"X Axis Label",
    xAxisType:"X Axis Type",

    xAxisFields: "X Axis Fields",
    yAxisFields: "Y Axis Fields",

    displayTitle: "Display",
    fieldTitle: "Field",
    typeTitle: "Type",
    chartWidgetTitle: "Chart widget title",
    crystalWidgetTitle: "Crystal Reports widget title",
    chartHasNoData: "No data to display",
    chartNoDataLabel: "No data",

    slaLines: "Lines",

    ranges: "Ranges",
    layoutSectionLabel: "Layout",
    sizeGroupLabel: "Size"

});
/* xcp_pie_chart/content/xcp/widget/report/PieChartComponent.js */

// PieChartComponent.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */


/**
 * @class xcp.report.PieChart
 * @extends Ext.Panel
 * PieChart component
 * @constructor
 * Creates a new piechart
 * @param {Object} config Configuration options.
 * @xtype xcp_pie_chart
 */

var pieChartComponentColors = [];
var pieChartComponentLegendColors = [];
var pieChartComponentGradients = [];

Ext.define("xcp.widget.report.PieChartComponent", {
    extend: "Ext.panel.Panel",
    alias: 'widget.xcp_pie_chart',
    layout: {
        type: 'vbox',
        align: 'stretch',
        padding: 0
    },
    /**
     * Returns the field value from the Selected Row Data associated with the given component
     * @param context {xcp.core.expr.EvaluationContext} (Required) The evaluation context.
     * @param compId  {String} (Required) The component id
     * @param fieldId  {String} (Required)
     */
    statics : {

        getValueFromRowSelection: function(context, compId, fieldId) {

            var comp = context.getComponent(compId);
            var value = "";
            if (!comp) {
                xcp.Logger.warn("Could not find the component : " + compId);
            } else {

                value = comp.getSelectedRowData()[fieldId] ;
                return xcp.core.expr.BaseExpression.checkValue(value);
            }
        }
    },

    // IWC The object which stores the selected row data from the chart.
    selectedRowData:{},

    // IWC: Publish the series "itemmouseup" as "seriesselected" event.
    xcpeventconfig : [{
        event : "seriesselected"
    }],

    // IWC: Returns the selected row data
    getSelectedRowData:function(){
        return this.selectedRowData;
    },

    constructor: function (config) {
        var me = this;
        config = config || {};
        Ext.useShims = true;
        me.config = config;
        me.chartStore = null;
        me.labelDirection = 'rotate';
        me.chartLabelFontSize = '13';
        me.chartLegend = Ext.create('Ext.panel.Panel', {height:2,width:750,border:false});
        me.chartsItems = [];
        this.runtime = Ext.isDefined(xcp.navigationManager);
        me.chartReportUtil = new xcp.widget.report.ChartReportUtil();
        me.chartLegendUtil = new xcp.widget.report.ChartLegendUtil();
        var yFieldsAmount = 0;
        me.runtimeEmptyChartData = null;
        me.createGradients(me.config);
        if (this.runtime)
        {
            this.getSeriesColors(config, 10);
            var xFields = config.xAxisSelectedFields;
            var yFields = config.yAxisSelectedFields;
            me.chartStore = me.chartReportUtil.getRunTimeStore(config);
            me.chartsItems = this.getChartsItems(xFields, yFields, me.chartStore, config);
            me.chartStore.on( 'load', function( store, records, options ) {
                if( !(store.data.length>0)){
                    me.runtimeEmptyChartData = [[xcp.Strings.widget.report.Reports.chartHasNoData,0]];
                    	//store.loadData(me.runtimeEmptyChartData);

                        var newStore = me.chartReportUtil.createEmptyStore(config.modelName, me.runtimeEmptyChartData, xFields, yFields, 1);

						me.getSeriesColors(config, 0);

                        me.chartsItems = me.getChartsItems(xFields, yFields, newStore, config);
                        me.items.getAt(0).items.getAt(0).removeAll(true);
                        me.items.getAt(0).items.getAt(0).add(me.chartsItems);

						for(var i=0; i < me.chartsItems.length; i++) {
							me.chartsItems[i].items.items[0].series.items[0].donut = 0;
						}

                } else {
                    me.runtimeEmptyChartData = null;

                    me.getSeriesColors(config, store.getCount());
                    me.chartsItems = me.getChartsItems(xFields, yFields, store, config);
                    me.items.getAt(0).items.getAt(0).removeAll(true);
                    me.items.getAt(0).items.getAt(0).add(me.chartsItems);

                    me.updateChartType(config);


                    // Need to set remoteSort = false as chart will be using data action framework and in
                    //DataSourceAction.js remoteSort is set to true. Since we are doing sorting on the client we need to
                    // set it to false.
                    store.remoteSort = false;
                    // Removed the sorters config in the store and instead added sort fields here as there were issues
                    // while using sorters with RealtimeQuery.
                    if(config.sortingFieldName && config.sortingOrder)
                        store.sort(config.sortingFieldName,config.sortingOrder);

                    for(var k=0; k < me.chartsItems.length; k++) {
                        me.chartsItems[k].items.items[0].store =  store;
                    }
                }
                if(config.legendDisplay && config.legendDisplay!="false"){
                    me.items.getAt(0).items.getAt(1).removeAll(true);
                    me.items.getAt(0).items.getAt(1).add(me.getOwnLegend(config,me.chartsItems));
                }
            });

        }
        else
        {

             if(config.yAxisSelectedFields)
             {
                me.chartsItems = this.getDesignTimeChartsItems(config);
                yFieldsAmount= me.chartReportUtil.getDesignTimeStore(config).getCount();
                this.getSeriesColors(config, yFieldsAmount);
                if(config.legendDisplay && config.legendDisplay != "false")
                    me.chartLegend = this.getOwnLegend(config,me.chartsItems);
             }else{
                 config.yAxisSelectedFields = ["Y"];
                 config.xAxisSelectedFields = ["X"];
                 config.yAxisSelectedLabels = ["Y"];
                 config.yAxisSelectedTypes = ["pie"];
                 me.chartsItems = this.getDesignTimeChartsItems(config);
                 yFieldsAmount= me.chartReportUtil.getDesignTimeStore(config).getCount();
                 this.getSeriesColors(config, yFieldsAmount);
                 if(config.legendDisplay && config.legendDisplay != "false")
                     me.chartLegend = this.getOwnLegend(config,me.chartsItems);

             }

            // Refer to bug BAM-4712, the problem happens only at design time
           xcp.widget.report.ChartReportUtil.ENCODER.addCharEntities();
        }

        Ext.apply(this,Ext.apply(this.initialConfig, config), {

          title: config.title,
           border:false,
            cls: 'xcp-chart-outer-panel',
            padding: 3,
            bodyCls: 'xcp-chart-inner-panel-body',
            items:[{
                xtype: 'panel',
                border: false,
                cls: 'xcp-chart-panel-body',
                layout: {
                        type: 'table',
                        columns: 3
                },
                items: [{
                xtype: 'panel',
                border:false,
                xcpSubCmp: true,
                cls: 'xcp-chart-panel-body',
                layout: {
                    type: 'column',
                    align: 'center',
                    padding: 5
                },
                items:me.chartsItems
            },{
                xtype: 'panel',
                xcpSubCmp: true,
                isViewerChildElement: false,
                cls: 'xcp-chart-panel-body',
                margin: '0 0 0 25',
                layout: {
                    align: 'stretch',
                    padding: 5
                },
                border:false,
                items:me.chartLegend
            }, {
                xtype: 'panel',
                border:false,
                xcpSubCmp: true,
                cls: 'xcp-chart-panel-body',
                width: 30
            }]
            }]
        });

       xcp.widget.report.PieChartComponent.superclass.constructor.call(this, config);
    },
    initComponent: function()
    {
        var me = this;
        xcp.widget.report.PieChartComponent.superclass.initComponent.call(this);
        me.addEvents(
            /**
             * @event seriesselected
             * Fires when user clicks on any of the series on the chart.
             */
            'seriesselected'
        );
    },
    getDesignTimeChartsWithLegend:function(config, reset, legendDisplay){
        var me = this;
         var newItems  = this.getDesignTimeChartsItems(config);
        var chartItemsPanel = Ext.create('Ext.panel.Panel', {
            xcpSubCmp: true,
            cls: 'xcp-chart-panel-body',
            border: false,
            layout: {
                    type: 'column',
                    align: 'stretch',
                    padding: 5
            },
            items: newItems
        });
        var legendPanel = Ext.create('Ext.panel.Panel', {
            border: false,
            xcpSubCmp: true,
           cls: 'xcp-chart-panel-body',
            align: 'stretch',
            items: []
        });
        if(legendDisplay  && legendDisplay!="false" ){
            me.chartLegend = this.getOwnLegend(config,newItems);
            legendPanel.items.add(me.chartLegend);
        }
        var emptyPanel = Ext.create('Ext.panel.Panel', {
            border: false,
            xcpSubCmp: true,
           cls: 'xcp-chart-panel-body',
           width: 30
        });
        var mainPanel =  Ext.create('Ext.panel.Panel', {
           border: false,
           cls: 'xcp-chart-panel-body',
            layout: {
                        type: 'table',
                        columns: 3
            },
            items: [chartItemsPanel, legendPanel, emptyPanel]
        });
        if(reset) {
            me.removeAll(true);
            me.add(mainPanel)
        } else{
            return chartItemsPanel;
        }
    },

    getDesignTimeChartsItems:function(config){
        var me = this;

        if(config.xAxisSelectedFields == undefined) {
            config.xAxisSelectedFields = ["X"];
        }

        var xFields = config.xAxisSelectedFields;

        if(config.yAxisSelectedFields == undefined) {
            config.yAxisSelectedFields = ["Y"];
        }

        var yFields = config.yAxisSelectedFields;


        var chartStore = me.chartReportUtil.getDesignTimeStore(config);
        me.getSeriesColors(config, chartStore.getCount());
        var newItems = this.getChartsItems(xFields, yFields, chartStore, config);

        return newItems;

    },

    getChartsItems: function (xFields, yFields, chartStore, config){
        var me = this;
        var pieChartItems = [];
        var legendLocation = "right";
        var chartWidth;
        var selectedTypes = config.yAxisSelectedTypes;
        var yAxisSelectedLabels = config.yAxisSelectedLabels;
         // Multiple Y Axis against Single X Axis
            chartWidth = (750 +(yFields.length * 5)) / (yFields.length+1) ;
            for (var i=0; i<yFields.length ;i++) {
                var chart = this.getChartPerAxis(xFields[0],yFields[i], yAxisSelectedLabels[i], chartWidth, yFields.length,  chartStore, selectedTypes[i], config)
                var piePanel = Ext.create('Ext.panel.Panel', {
                border: 0,
                xcpSubCmp: true,
                cls: 'xcp-chart-subcmp',
                layout: {
                        type: 'table',
                        columns: 1,
                        tdAttrs: {
                            style: {
                                'text-align': 'center'
                            }
                        }
                    },
                    items:  [chart, {
                        xtype: 'label',
                        xcpSubCmp: true,
                        cls: 'xcp-chart-label',
                        text : yAxisSelectedLabels[i]
                    }, {
                      xtype: 'panel',
                      border: false,
                      height: 10
                    }]
                });
                pieChartItems.push(piePanel);
            }

        return pieChartItems;

    },

    getChartPerAxis : function(xField, yField,chartLabel, chartWidth,yLength, chartStore,type, config)  {
        var me = this;
        var labelCenterValues = [110,50,10,-10,-30,-50,-80]
        var maximum = chartStore.max(yField);
        if (!maximum) maximum  = 1;

        minimum = chartStore.min(yField);
        if (!minimum || minimum >= 0 ) minimum  = 0;

        var donut = 0;
        var title = null;
        if(type == "donut")
            donut = 35;


        var chart = Ext.create('Ext.chart.Chart',{
            width:240,
            height:250,
            animate: true,
            shadow: false,
            highlight:false,
            xcpSubCmp: true,
            theme: 'XCPPieChartTheme',
            gradients: pieChartComponentGradients,
            store: chartStore,
            series: [{
                type: 'pie',
                field: yField,
                donut:donut,
                tips: {
                    trackMouse: true,
                    maxWidth: 1000,
                    renderer: function(storeItem, item) {
                        // calculate and display percentage on hover
                        var total = 0;
                        chartStore.each(function(rec) {
                            total += rec.get(yField);
                        });
                            if(!me.runtime) {
                                title = me.getActualValue(xField, storeItem.get(xField)) + ': '+ storeItem.get(yField)+' (' + Math.round(storeItem.get(yField) / total * 100) + '%)';
                            } else {
                                if(me.runtimeEmptyChartData != null) {
                                     title =  xcp.Strings.widget.report.Reports.chartHasNoData;
                                } else {
                                    title = me.chartReportUtil.formatValue(me.config, xField, me.getActualValue(xField, storeItem.get(xField)))  + ': '+ me.chartReportUtil.formatValue(me.config, yField, storeItem.get(yField)) +' (' + Math.round(storeItem.get(yField) / total * 100) + '%)';
                                }
                            }
                            this.update(title);
                    }
                },
                highlight: {
                    segment: {
                        margin: 8
                    }
                },
                label: {
                    font:'11px Helvetica, Arial, Sans-serif',
                    field:xField,
                    display: me.labelDirection,
                    contrast: true,
                    renderer:function(label){
                         if(label == undefined || me.runtimeEmptyChartData != null) {
                                return xcp.Strings.widget.report.Reports.chartNoDataLabel;
                         }
                        var newValue = null;
                        if(!me.runtime) {
                            newValue = me.getActualValue(xField, label);
                        } else {
                            newValue = me.chartReportUtil.formatValue(me.config, xField,me.getActualValue(xField, label));
                        }
                        if(newValue.length > 10)
                        newValue = newValue.substr(0,10);
                        return newValue;
                    }
                },

                listeners: {
                    itemmouseup: function(item){
                        // There is no itemclick event for series so using itemmouseup

                        if (!me.runtime) return;
                        xcp.widget.report.ChartReportUtil.populateSelectedRowData(item,  me);
                    }
                }
            }]
        });
        return chart;
    },

    updateChartType:function(config){
        var me = this;
        var selectedTypes = config.yAxisSelectedTypes;

        for(var index=0; index< selectedTypes.length; index++) {
            if (selectedTypes[index] == 'donut') {
                me.chartsItems[index].items.items[0].series.items[0].donut  = 35;
            }else {
               me.chartsItems[index].items.items[0].series.items[0].donut   =  0;
            }
        }

    },
    updateChartTitle:function(){


    },
    updateChartsLabelTitles:function(config){

    },
    reloadDataOnSort:function(config){
        var me = this;
        var yFields = config.yAxisSelectedFields;
        for(i=0;i<yFields.length;i++)
        {
            var chart = me.chartsItems[i].items.items[0] ;
            chart.store = me.chartReportUtil.getDesignTimeStore(config);
            chart.redraw();
        }
    } ,
    createGradients:function(config) {
        var pieChartComponentGradientsLocal = [];
        var allColors = []
        var chartColorUtil = new xcp.widget.report.ChartColorUtil();
        allColors.push(chartColorUtil.getEmptyChartColor());
        var chartColorsLocal = chartColorUtil.getChartColors();
        for(var i = 0; i<chartColorsLocal.length; i++) {
           allColors.push(chartColorsLocal[i]);
        }
        for (var i = 0; i < allColors.length; i++) {
            pieChartComponentGradientsLocal.push(chartColorUtil.getGradient(allColors[i], i));

        }
        pieChartComponentGradients = pieChartComponentGradientsLocal;
    },
    getSeriesColors:function(config, yFieldsAmount) {
        var me = this;
        var pieChartComponentLegendColorsLocal = [];
        var pieChartComponentColorsLocal = [];
        var pieChartComponentGradientsLocal = [];
        var chartColorUtil = new xcp.widget.report.ChartColorUtil();
        if (yFieldsAmount == 0) {
            var baseColor = chartColorUtil.getEmptyChartColor();
            pieChartComponentLegendColorsLocal[0] = baseColor;
            var key = chartColorUtil.getColorKey(baseColor, 0);
            pieChartComponentColorsLocal[0] = 'url(#' + key + ')';
        } else {
            var colorIndex = 0;
            var chartColorsLocal = chartColorUtil.getChartColors();
            for(var i=0; i < yFieldsAmount; i++) {
                if(colorIndex > 9) {
                    colorIndex = 0;
                }
                var baseColor = chartColorsLocal[colorIndex];
                pieChartComponentLegendColorsLocal[i] = baseColor;
                var key = chartColorUtil.getColorKey(baseColor, (colorIndex+1));
                pieChartComponentColorsLocal[i] = 'url(#' + key + ')';
                colorIndex++;
            }
        }
        pieChartComponentLegendColors = pieChartComponentLegendColorsLocal;
        pieChartComponentColors = pieChartComponentColorsLocal;
    },

    redrawChartAfterLoad:function(config){
        var me = this;
        var yFields = config.yAxisSelectedFields;
        for(i=0;i<yFields.length;i++)
        {
            var chart = me.items.getAt(0).items.getAt(i);
            chart.redraw();
        }
    },
    generateChartItemsOnDSSelect:function(config){
            var me = this;
            me.chartsItems = me.getDesignTimeChartsItems(config);
            var yFieldsAmount = me.chartReportUtil.getDesignTimeStore(config).getCount();
            me.getSeriesColors(config, yFieldsAmount);
            alert(me.title);
            me.items.getAt(0).removeAll(true);
            me.items.getAt(0).add(me.chartsItems);
            if(config.legendDisplay && config.legendDisplay != "false")
            {
            me.chartLegend = this.getOwnLegend(config,me.chartsItems);
            me.items.getAt(0).items.getAt(1).removeAll(true);
            me.items.getAt(0).items.getAt(1).add(me.chartLegend);
            }
    },
    getActualValue: function(field, value) {
        var me = this;
        if (!me.runtime) return value;
        var newValue = me.chartReportUtil.resolvePickListValue(field, value, me.config);
        return newValue;
    } ,

    getOwnLegend:function(config,chartsItems){
        var me = this;
        var legendColors = [] ,legendLabels = [] ,oldLabel;
        var len = chartsItems[0].items.items[0].store.getCount();
        if(!len || len ==0) return;
        var legendField = chartsItems[0].items.items[0].series.items[0].label.field;
        if(!this.runtime){
            for(var i = 0; i < len; i++){
                oldLabel = chartsItems[0].items.items[0].store.data.items[i].raw[0];
                legendLabels[i] = this.getActualValue(legendField,oldLabel);
            }
        }
        else{
            if(pieChartComponentLegendColors[0].toUpperCase() == new xcp.widget.report.ChartColorUtil().getEmptyChartColor()){
                legendLabels[0] = xcp.Strings.widget.report.Reports.chartNoDataLabel;
            }
            else{
                for(var i = 0; i < len; i++){
                    oldLabel = me.chartLegendUtil.getSeriesProp(chartsItems[0].items.items[0].series.items[0],i);
                    legendLabels[i] = me.getActualValue(legendField,oldLabel).toString();
                }
            }
        }
        for (i = 0; i < len; i++) {
            legendColors[i] = pieChartComponentLegendColors[i];
        }
        var chartsItemsLegend = [];
        for(var chartsItemIndex in chartsItems) {
           chartsItemsLegend.push(chartsItems[chartsItemIndex].items.items[0]);

        }

        var myLegend = me.chartLegendUtil.getLegendPanel(chartsItemsLegend, legendLabels, legendColors, true);
        return myLegend;
    }
});

/* xcp_pie_chart/content/xcp/widget/report/ChartColorUtil.js */

/**
 * Created by IntelliJ IDEA.
 * User: shawb2
 * Date: 8/17/12
 * Time: 5:37 PM
 * To change this template use File | Settings | File Templates.
 */
 Ext.define("xcp.widget.report.ChartColorUtil",{
     getChartColors:function() {
         var chartColors = [ '#8CA608',
                     '#3399CC',
                     '#D2A01A',
                     '#B64A14',
                     '#8C314F',
                     '#587306',
                     '#356993',
                     '#CC7014',
                     '#F2CE18',
                     '#A60001'
                     ];

         return   chartColors;
     },

     getEmptyChartColor:function() {
         var emplyColor = '#EEEEEE';

         return emplyColor;
     },

     getGradient:function(baseColor, index) {
         var midColor = Ext.draw.Color.fromString(baseColor);
         var color = this.getDarkerColor(midColor);
         var key = this.getColorKey(baseColor, index)
         var gradient = {
                        id: key,
                        angle: 45,
                        stops: {
                            0: {
                                color: midColor.toString()
                            },
                            100: {
                                color: color.toString()
                            }
                        }
                    };
         return gradient;
     },

     getColorKey:function(baseColor, index) {
         var midColor = Ext.draw.Color.fromString(baseColor);
         var color = this.getDarkerColor(midColor);
         var key = 'theme-' + midColor.toString().substr(1) + '-' + color.substr(1) + '-' + index;

         return key;
     },

     getDarkerColor:function(midColor) {
       return midColor.getDarker(0.1).toString();
     }
 });


/* xcp_pie_chart/content/xcp/widget/report/XCPPieChartTheme.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Created by IntelliJ IDEA.
 * User: docadmin / mgtneven
 * Date: 1/5/12
 * Time: 10:01 AM
 * To change this template use File | Settings | File Templates.
 */
var widjetLabelText='11px Helvetica, Arial, Sans-serif';
 //move to pieCompo

//end move
Ext.define('Ext.chart.theme.XCPPieChartTheme', {
    extend: 'Ext.chart.theme.Base',

    constructor: function(config) {
        this.callParent([Ext.apply(
            {
                background:false,
                colors: pieChartComponentColors,
                axis: {
                    stroke: '#707070',
                    'stroke-width': 1
                },
                axisLabelTop: {
                    fill: '#707070',
                    font: widjetLabelText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisLabelRight: {
                    fill: '#707070',
                    font: widjetLabelText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisLabelBottom: {
                    fill: '#707070',
                    padding: 3,
                    rotate: {
                        degrees: 315
                    },
                    renderer: function(v) { return v; }
                },
                axisLabelLeft: {
                    fill: '#707070',
                    font: widjetLabelText,
                    padding: 10,
                    renderer: function(v) { return v; }
                },
                axisTitleTop: {
                    font: widjetLabelText,
                    fill: '#707070'
                },
                axisTitleRight: {
                    font: widjetLabelText,
                    fill: '#707070',
                    rotate: {
                        x:0, y:0,
                        degrees: 270
                    }
                },
                axisTitleBottom: {
                    font: widjetLabelText,
                    fill: '#707070'
                },
                axisTitleLeft: {
                    font: widjetLabelText,
                    fill: '#707070',
                    rotate: {
                        x:0, y:0,
                        degrees: 270
                    }
                }
            }, config)]);
    }
});/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// ReassignTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.ReassignTaskDataAction");
Ext.apply(xcp.Strings.action.task.ReassignTaskDataAction, {
    confirmationTitle: "Reassign Task?",
    confirmationPromptTemplate: "Are you sure you want to reassign this task?",
    updateSuccessNotificationTemplate:  "The task has been reassigned.",
    updateErrorTemplate: "An error occurred while reassigning this task. Please try again."
});
/* xcp_reassign_task/content/xcp/action/task/ReassignTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// ReassignTaskDataAction.js

/**
 * @class xcp.action.task.ReassignTaskDataAction
 * @extends xcp.action.task.BaseTaskDataAction
 * Action implementation for reassign task action.
 */
Ext.define("xcp.action.task.ReassignTaskDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_reassign_task",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false
    },

    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if (baseAction.isQueueTask(actionArgs, action)) {
            var queueName = baseAction.getTaskAttribute(actionArgs,action,"queue_name");
            var performer = baseAction.getTaskAttribute(actionArgs,action,"performer");
            var state = baseAction.getTaskAttribute(actionArgs,action,"state");
            applicable = performer !== queueName &&
                         state != 2 &&
                         baseAction.isQueueTaskActionApplicable(actionArgs,action,true,true,false,false,false);
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;
    },

    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.ReassignTaskDataAction";
    }
});

/* xcp_reassign_task/content/xcp/data/model/ReassignTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp_da_def_reassign_currenttask",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/reassign"
    },
    "fields" : [
        {
            "name" : "id",
            "type" : "string"
        },
        {
            "name" : "userName",
            "type" : "string"
        }
    ]
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// RejectTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.RejectTaskDataAction");
Ext.apply(xcp.Strings.action.task.RejectTaskDataAction, {
    confirmationTitle: "Reject Task?",
    confirmationPromptTemplate: "Are you sure you want to reject this task?",
    updateSuccessNotificationTemplate:  "The task has been rejected.",
    updateErrorTemplate: "An error occurred while rejecting this task. Please try again."
});
/* xcp_reject_task/content/xcp/action/task/RejectTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// RejectTaskDataAction.js

/**
 * @class xcp.action.task.CompleteTaskDataAction
 * @extends xcp.action.form.DataAction
 * Action implementation for completing a task.
 */
Ext.define("xcp.action.task.RejectTaskDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_reject_task",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         * @cfg {Boolean} nextTaskEnabled True to enable auto next task on this action. Context Menu will set this to false to disable
         */
        nextTaskEnabled: true,
        objectTypePropName: "activity_system_name",
        showConfirmation: false
    },

    getEnablement:function(actionArgs, action){
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if(baseAction.isContextMenuAction(action) && baseAction.isTaskViewPageExist(actionArgs, action)) {
            return xcp.Enablement.HIDE;
        }

        var isRejectable = baseAction.getTaskAttribute(actionArgs, action,"isrejectable");
        if (Ext.isEmpty(isRejectable)) {
            //Task page do not have isRejectable attribute sent from server
            isRejectable = true;
        }
        isRejectable = isRejectable &&
                        baseAction.isTaskActionApplicable(actionArgs, action, true, true, true, true, 1);
        return  isRejectable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;
    },

    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.RejectTaskDataAction";
    },

    /**
    * Return if get next task should be triggered for this action.
    */
    isGetNextTaskAction: function() {
        return this.config.nextTaskEnabled;
    }

});



/* xcp_reject_task/content/xcp/data/model/RejectTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("reject_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/reject"
    },
    "fields" : [
        {
            "name":"id"
        },{
        "name" : "path",
        "type" : "array"
        },{
        "name" : "signOffPassword",
        "type" : "string"
        }
    ]
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// RepeatTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.RepeatTaskDataAction");
Ext.apply(xcp.Strings.action.task.RepeatTaskDataAction, {
    confirmationTitle: "Repeat Task?",
    confirmationPromptTemplate: "Are you sure you want to repeat this task?",
    updateSuccessNotificationTemplate:  "The task has been repeated.",
    updateErrorTemplate: "An error occurred while repeating this task. Please try again."
});
/* xcp_repeat_task/content/xcp/action/task/RepeatTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// RepeatTaskDataAction.js

/**
 * @class xcp.action.task.RepeatTaskDataAction
 * @extends xcp.action.task.BaseTaskDataAction
 * Action implementation for repeating a task.
 */
Ext.define("xcp.action.task.RepeatTaskDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_repeat_task",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        objectTypePropName: "activity_system_name",
        showConfirmation: false
    },

    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if(baseAction.isContextMenuAction(action) && baseAction.isTaskViewPageExist(actionArgs, action)) {
            return xcp.Enablement.HIDE;
        }

        var state = baseAction.getTaskAttribute(actionArgs, action,"state");
        if (state === 1) {
            var target = action.getTargets(actionArgs)[0];
            if (target){
                var isRepeatable = target.get('executionData.currenttask.isrepeatable');
                if (Ext.isEmpty(isRepeatable)) {
                    var allowTaskPerformerToRepeat = target.get('is_repeatable') ? true : false;
                    applicable = baseAction.isTaskActionApplicable(actionArgs, action, true,true, true, allowTaskPerformerToRepeat);
                } else {
                    applicable = isRepeatable;
                }
            }
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;

    },

    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.RepeatTaskDataAction";
    },

    /**
    * Return if get next task should be triggered from this action.
    */
    isGetNextTaskAction: function() {
        return true;
    }
});

/* xcp_repeat_task/content/xcp/data/model/RepeatTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("repeat_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/repeat"
    },
    "fields" : [
        {
            "name" : "id",
            "type" : "string"
        },
        {
            "name" : "userName",
            "type" : "array"
        },
        {
        "name" : "signOffPassword",
        "type" : "string"
        }
    ]
});


/* xcp_repeating_attribute_formatter/content/xcp/formatter/RepeatingAttributeFormatter.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
(function() {
    //RegEx for supported separator styles
    var DELIM_STYLE_REGEX = "NEWLINE|SEMICOLON|COMMA|HYPEN|COLON|SPACE";

    var ELPSIS = "...";

    //Mapping to separator style to delimiters
    var DELIM_STYLE_MAP = {
        NEWLINE : "<br/>",
        SEMICOLON : ";",
        COMMA : ",",
        HYPEN : "-",
        COLON : ":",
        SPACE : " "
    };

    /**
     * Resolve the separator style and map it to the delimiter
     * @param style
     */
    var getDelimiter = function(formatConfig) {
        var delimiter ;
        if(formatConfig.separatorStyle)
        {
            if(formatConfig.separatorStyle == 'NEWLINE'){
                delimiter = DELIM_STYLE_MAP['NEWLINE'];
            }else if(formatConfig.separatorStyle == 'SINGLELINE'){
                if(formatConfig.separator){
                    delimiter = formatConfig.separator;
                    if(delimiter && delimiter.match(DELIM_STYLE_REGEX)) {
                        delimiter = DELIM_STYLE_MAP[delimiter];
                    }
                }
            }

        }
//        var delimiter = formatConfig.separatorStyle;
//
//        if(delimiter && delimiter.match(DELIM_STYLE_REGEX)) {
//            delimiter = DELIM_STYLE_MAP[delimiter];
//        }
        return delimiter;
    };

    Ext.define("xcp.formatter.RepeatingAttributeFormatter", {
        extend: "xcp.formatter.BaseFormatter",
        alias: "formatter.xcp_repeating_attribute_formatter",
        config: {
            separatorStyle : "",
            separator:",",
            displayLimit : 0
        },

        initialConfig : null,
        delimiter : null,
        displayLimit: 0,

        constructor: function(initialConfig) {
            this.initialConfig = initialConfig;
            this.delimiter = getDelimiter(initialConfig)
            if(initialConfig.displayLimit) {
                this.displayLimit = initialConfig.displayLimit;
            }
        },

        /**
          * Returns a formatted value.
          * @param value Input Multivalue/Array of datatypes, the datatype can be string, date, integer or float
          */

        format : function(value) {
            var formattedValue = value;
            if (Ext.isArray(value)) {
                formattedValue = "";

                var limit;
                //Use the displayLimit to limit values to show
                if (this.displayLimit == 0) {
                    // Show all values, not actually limited
                    limit = value.length;
                } else {
                    // A limit has been configured
                    if (value.length < this.displayLimit) {
                        // We have less than the number of values specified by the limit, so only loop with what we have
                        limit = value.length;
                    } else {
                        limit = this.displayLimit;
                    }
                }

                for(var i = 0; i < limit; i++) {
                    if(i > 0) {
                        formattedValue += this.delimiter + " ";
                    }

                    // use "&nbsp;" to give the value a size when displayed.
                    formattedValue += value[i] === null ? "&nbsp;" : value[i];
                }
                if (limit < value.length) {
                    formattedValue += ELPSIS;
                }
            }
            return formattedValue;
        }
    });

})();

/* xcp_results_list_email_link_column/content/xcp/widget/grid/ResultsListEmailLinkColumn.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
/**
 * @class xcp.widget.grid.ResultsListEmailLinkColumn
 * @extends xcp.widget.grid.ResultsListColumn
 * Represents a column within a results list where the data is presented as a Email link to the associated item's default page
 * @xtype xcp_results_list_email_link_column
 */
Ext.define("xcp.widget.grid.ResultsListEmailLinkColumn", {
    extend: "xcp.widget.grid.ResultsListColumn",
    alias:  "widget.xcp_results_list_email_link_column",

    //during constructor we initialize the renderer property with formatted html email string.
    constructor: function(cfg) {
        this.callParent(arguments);
        this.renderer = function(value, metaData, record, rowIdx, colIdx, store, view) {
           var html;
           // Render the data as a link
           html = Ext.String.format('<a href="mailto:{0}">{0}</a>',value);
           return html;
        };
    }
});/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */



// HaltTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.ResumeTaskDataAction");
Ext.apply(xcp.Strings.action.task.ResumeTaskDataAction, {
    confirmationTitle: "Resume Task?",
    confirmationPromptTemplate: "Are you sure you want to resume this task?",
    resumeTaskSuccessNotificationTemplate:  "The task has been resumed.",
    resumeTaskErrorTemplate: "An error occurred while resume this task. Please try again.",
    text:"Resume",
    tooltip:"Resume"
});
/* xcp_resume_task/content/xcp/action/task/ResumeTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// ResumeTaskDataAction.js

/**
 * @class xcp.action.form.UpdateAction
 * @extends xcp.action.form.DataAction
 * Action implementation for updating resources within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.task.ResumeTaskDataAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.xcp_resume_task",

    statics: {
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {string} id  instance id
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, id, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    url = action.redirectUrlModel + "/" + id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        }

    },
    config: {
            requiredAttributes: ["task_state"],
            text: xcp.Strings.action.task.ResumeTaskDataAction.text,
            tooltip: xcp.Strings.action.task.ResumeTaskDataAction.tooltip,
            confirmationPrompt: xcp.Strings.action.task.ResumeTaskDataAction.confirmationPromptTemplate,
            showConfirmation: false,
            actionModel:"resume_task_model",
            showSuccessNotification:true
    },

    constructor: function(config) {
        config = config || {};
        var prototype = this.self.prototype;
        // copy primary attributes from prototype (so handler doesn't have to be in config)
        var prototypeConfig=Ext.copyTo({},prototype.config, ["text", "iconCls", "tooltip", "handler", "actionModel", "showSuccessNotification"]);
        Ext.applyIf(config, prototypeConfig);

        this.callParent([config]);
    },

    /**
     * Handler for the UpdateAction
     */
    handler: function(actionArgs, action) {
        var config;
        // Note that this method will run in the context of the associated component (button, menu, etc.), therefore
        // the "this" refers to the component, not to the action.  Configuration from the action is propogated to the
        // component, but functions are not, thus functions which access instance data won't work.

        if (Ext.isEmpty(action)) { //delete action invoked from form button
//            //update action's input model when action is invoked.
//            if (!Ext.isEmpty(actionArgs.selection))
//                this.setInputModel(actionArgs.selection[0]);
//
            config = this.getConfig();
            targets = [this.getActionModel()];
        }
        else {
            config = action.getConfig();
            targets = action.getTargets(actionArgs);
        }
        var model=xcp.action.form.DataAction.getModelForSelection(targets[0], this.actionModel);

        //to set model instance property "phantom" to be false since this action model is just created
        //and ExtJs expected this value to be false so it can issue a "PUT" action to the server

        model.phantom = false;

        var id = model.getId();

        var handleResumeSuccess = function(record, operation) {
            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, id);
            if (config.showSuccessNotification) {
                xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.ResumeTaskDataAction.resumeTaskSuccessNotificationTemplate);
            }

            xcp.action.task.ResumeTaskDataAction.handleRedirection(this, id, record, operation);

        };
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    model.save({success: handleResumeSuccess, feedbackContainer: actionArgs.component, scope: this});
                }
            };

            Ext.Msg.show({
                title:  xcp.Strings.action.form.UpdateAction.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.task.ResumeTaskDataAction.confirmationPromptTemplate, model),
                scope: this
            });
        } else {
            model.save({success: handleResumeSuccess, feedbackContainer: actionArgs.component, scope: this});
        }
    },
    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;
        if (baseAction.isQueueTask(actionArgs, action)) {
            applicable = baseAction.isQueueTaskActionApplicable(actionArgs, action, true, true,false,false, true,3);
        } else {
            applicable = baseAction.isTaskActionApplicable(actionArgs, action, true, true, true, true,3);
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;
    },
    getInitialEnablement: function() {
        return xcp.Enablement.HIDE;
    }

});


/* xcp_resume_task/content/xcp/data/model/ResumeTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("resume_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/resume"
    },
    "fields" : [
        {
            "name":"id"
        }
    ]
});


/* xcp_rich_text/content/xcp/widget/Richtext.js */

// Richtext.js
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.Richtext
 * @extends Ext.Component
 * Richtext that provides the richtext display. It strips off the scripts from the richtext contents.
 * @constructor
 * Creates a new Richtext
 * @param {Object} config Configuration options.
 * @xtype xcp_rich_text
 */
Ext.define("xcp.widget.Richtext", {
    extend: 'Ext.Component',
    alias: 'widget.xcp_rich_text',

    initComponent : function() {
        //strip scripts
        this.html = this.html ? Ext.util.Format.stripScripts(this.html) : '';

        xcp.widget.Richtext.superclass.initComponent.call(this);
    }
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.selector.Selector");

Ext.apply(xcp.Strings.widget.selector.Selector, {
  	addLinkButtonLabel:			"Select",
    finishButtonLabel:			"Select",
    cancelButtonLabel:			"Cancel",
    fromRepositoryLabel:			"Select from repository",
    fromFileSystem : 	"Import file"
});

/* xcp_selector/content/xcp/widget/selector/Selector.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.widget.selector.Selector", {
            extend: 'Ext.form.FieldContainer',
            alias: 'widget.xcp_selector',
            mixins: {
                observable: 'Ext.util.Observable',
                field: 'Ext.form.field.Field'
            },
            statics : {
                NULL_OBJECT_ID : "0000000000000000",
                VALID_OBJECT_ID_LENGTH : 16,
                getWidgetById: function(xcpId) {
                    var selectors = Ext.ComponentQuery.query("xcp_selector");
                    var len = selectors.length;
                    for (var i = 0; i < len; i++) {
                        if (selectors[i].xcpId == xcpId) {
                            var component = selectors[i];
                            return selectors[i];
                        }
                    }
                    xcp.Logger.log("Selector: Could not find component with xcpId " +  xcpId);
                },

                /**
                 * Label style that indicates selector field is mandatory or not
                 */
                getRequiredIndicator:function() {
                    return "<span style=\"color:red;\"> * </span>";
                },

                getNullObjectId:function(){
                    return xcp.widget.selector.Selector.NULL_OBJECT_ID;
                }


            },
            size: 300,
            xcpeventconfig:
                    [
                        {
                            event : "change",
                            data : function(field, newValue, oldValue, options) {
                                return newValue;
                            }
                        }
                    ],
            // Override the ext method so it works on a per pixel basis instead of Exts random 6.5
            getBodyNaturalWidth:function () {
                return Math.round(this.size);
            },

            constructor: function(config) {
                var me = this;
                config = config || {};
                me.runtime = Ext.isDefined(xcp.navigationManager);
                (me.runtime) ? me.runTimeWidget(config) : me.designTimeWidget(config);
                me.config = config;
                me.mixins.observable.constructor.call(me, config);
                xcp.widget.selector.Selector.superclass.constructor.apply(this, [config]);
                me.subscriptions = new Array();
                me.removeButton = {};
                me.addButton = {};
                me.hrefObj = {};
                me.trigger = {};
                me.selectedobjectid = undefined;

            },

            /**
             * int the form field mixin
             */
            initComponent: function() {
                var me = this;
                me.callParent();
                me.initField();
                if (me.config.disabled) {
                    me.disabled = me.config.disabled;
                }
                this.paramsStore = new Ext.grid.property.Property();
                if(me.config.extraParams){

                    this.paramsStore.set(me.config.extraParams);
                }
            },

            clearSubscriptions:function () {
                var subscriptions = this.subscriptions;
                if (!subscriptions) return;
                for (var i = 0, len = subscriptions.length; i < len; i++) {
                    try {
                        xcp.event.EventBus.unsubscribe(subscriptions[i]);
                    } catch(e) {
                        xcp.Logger.log("Selector: Error during unsubscribe event" + subscriptions[i]);
                    } finally {
                        subscriptions.splice(i, 1);
                    }

                }
            },

            /**
             * callback handler registered selection event publish
             * @param id objectId of selected row
             */

            onSelectionDone: function(name, id) {
                if (id) {
                    if(Ext.isArray(id))
                        id = id[0];
                    me = this;
                    var bo = this.config.objectType;
                    this.postSelectionOperation(bo, id);
                }
            },

            /**
             * Select Operation post processor
             * @param id objectId of selected row
             * @param bo Model name of the selected data type
             * @param displayName configured displayField
             */

            postSelectionOperation : function (bo, id) {
                this.clearSubscriptions();
                this.setValue(id);
            },

            /**
             * Load the model instance
             * @param id objectId of model instance to be loaded
             * @param bo Model name to be loaded
             */

            getModelInstance : function(bo, id) {
                me = this;
                var model = Ext.ModelManager.getModel(bo);
                if (!model || id.length != xcp.widget.selector.Selector.VALID_OBJECT_ID_LENGTH
                           || id == xcp.widget.selector.Selector.getNullObjectId())
                    return;
                model.load(id, { scope: me,
                            failure: function(record, operation) {
                                //do something if the load failed
                                xcp.Logger.log("Selector: Could not load model instance for model - " + model +  " with id - " + id);
                            },
                            success: function(record, operation) {
                                this.refreshPageWithSelectedValue(record);
                            }
                        })
            },

            /**
             * Updates the Page with relevant buttons and links based on the model record values
             * @param record model instance retrieved from Model
             */

            refreshPageWithSelectedValue :function(record) {
                me = this;
                this.url = "#" + xcp.util.Utils.makePageUrl(this.config.objectType, this.selectedobjectid, undefined);//config.page
                me.selectedRecord = record;
                hrefObj = me.hrefObj.getEl();
                if (hrefObj) {
                    var href = {"href":this.url};
                    hrefObj.set(href);
                    //var html = Ext.String.format(record[this.config.displayField]);
                    var html = record.data[this.config.displayField]
                    // if displayField value is empty then add "id" as value
                    if (html == undefined || html.length == 0) {
                        xcp.Logger.log("Selector: display field value was null, hence assuming objectid");
                        if (record.data["id"]) {
                            html = record.data["id"];
                        }
                    }
                    hrefObj.update(html);
                }

                me.removeButton.setVisible(true);
                me.trigger.setVisible(true);
                me.addButton.setVisible(false);
            },

            /**
             * Returns the selected model instance
             * @returns selected row model instance
             */
            getSelectedRow : function() {
                return this.selectedRecord;
            },

            /**
             * Getter method for Form field
             **/

            getValue:function() {
                if (this.selectedobjectid && this.selectedobjectid.length == xcp.widget.selector.Selector.VALID_OBJECT_ID_LENGTH) {
                    return this.selectedobjectid;
                }else
                {
                    return xcp.widget.selector.Selector.getNullObjectId();
                }
            },

            /**
             * Setter method for Form field
             **/
            setValue : function(value) {
                var me = this;
                var oldValue = me.getValue();
                this.selectedobjectid = value;
                if (value != null)this.getModelInstance(me.config.objectType, value);
                if (value != oldValue) me.fireEvent('change', me, value, oldValue);
            },

            /**
             * Remove action handler
             * @param id objectId of selected row
             */

            removeBtnHandler:function() {
                me = this;
                me.removeButton.setVisible(false);
                me.trigger.setVisible(false);
                me.addButton.setVisible(false);
                hrefObj = me.hrefObj.getEl();
                if (hrefObj) {
                    var href = {"href":"#"};
                    hrefObj.set(href);
                    hrefObj.update(xcp.Strings.widget.selector.Selector.addLinkButtonLabel);
                }
                me.setValue(undefined);

            },

            /**
             * Click handler that creates available menu options
             * @param eventObj event object on which click gesture happened
             * @param elRef object on which click gesture happened
             */

            rendermenus:function(eventObj, elRef) {

                /**
                 * @private
                 * Click handler that invoker selector(from repository) action flow
                 */

                function selectfromrepo(menu) {
                    cmp = xcp.widget.selector.Selector.getWidgetById(this.initialConfig.xcpId)
                    //cmp.clearSubscriptions();
                    var handle = xcp.event.EventBus.subscribe(xcp.event.SelectorEvent.NAME, cmp.onSelectionDone, cmp);
                    cmp.subscriptions.push(handle);
                    var actionDef = {};
                    Ext.apply(actionDef, xcp.core.ActionManager.getUserActionDefConfig(cmp.config.objectType, cmp.config.actionFlowId));
                    if(actionDef.flowDef == undefined){
                        xcp.Logger.log("Selector: could not find action flow -" + cmp.config.actionflowId + " for the type -" + cmp.config.objectType);
                    }

                    var wizardConfig = {
                        buttonLabels:{
                            "finish":xcp.Strings.widget.selector.Selector.finishButtonLabel,
                            "cancel":xcp.Strings.widget.selector.Selector.cancelButtonLabel
                        },
                        autoScroll:true,
                        height:450,
                        width:640};

                    if(cmp.config.wizardConfig){
                        Ext.apply(wizardConfig,cmp.config.wizardConfig);
                    }

                    Ext.apply(actionDef, wizardConfig);
                    Ext.apply(actionDef, {});

                    var copyOfActionDef = xcp.util.Utils.deepCopy(actionDef);
                    copyOfActionDef.inputModel = cmp.paramsStore;
                    var wizard = Ext.create("widget.xcp_wizard", copyOfActionDef);
                    wizard.show();

                }

                /**
                 * @private
                 * Click handler that invokes import action flow
                 */

                function importfile(menu) {
                    return;
                }

                if (this.getValue() !== undefined && this.getValue().length > 1 && this.getValue() != xcp.widget.selector.Selector.getNullObjectId()) {
                    var url = elRef.href;
                    window.open(url, "View", '');
                    Ext.EventObject.stopEvent();
                    return;
                }
                Ext.EventObject.stopEvent();
                var menuArray = new Array();
                if (!this.ctxMenu) {

                    if (this.config.fromRepository) {
                        menuArray[0] = {text:xcp.Strings.widget.selector.Selector.fromRepositoryLabel,handler:selectfromrepo, xcpId: this.config.xcpId};
                    }
                    if (this.config.fromFileSystem) {
                        menuArray[1] = {text : xcp.Strings.widget.selector.Selector.fromFileSystem,handler:importfile};
                    }

                    this.ctxMenu = new Ext.menu.Menu({
                                items :menuArray

                            });
                }
                // short circuit only if one menu exists
                if (this.ctxMenu.items.length == 1) {
                    var firstItem = this.ctxMenu.items.items[0];
                    if (firstItem) {
                        firstItem.handler.call(firstItem.scope || firstItem, firstItem);
                        return;
                    }
                }
                if (menuArray.length > 0 || this.ctxMenu.items.length > 0) {
                    this.ctxMenu.showBy(this.getComponent("hrefObj").getEl());
                }

            },

            /**
             * @private
             * Utility method to register menu handlers and that updates state of the page
             */

            renderactions:function(component, scope) {
                me = this;
                component.getEl().on('click', this.rendermenus, me);
                if (this.config.objectType) {
                    var selectedValue = me.getValue();
                    if (selectedValue && selectedValue != xcp.widget.selector.Selector.getNullObjectId()) {
                        this.selectedobjectid = selectedValue;
                        this.getModelInstance(this.config.objectType, selectedValue);
                    }
                }
            },

            /**
             * @private
             * Sets up intial/on load state and caching of elements of the selector
             */

            setUpInitState:function(scope) {
                me = this;
                var removeBtn = me.getComponent('selector-remove-button');
                me.removeButton = removeBtn;
                var addBtn = me.getComponent('selector-add-button');
                addBtn.setVisible(false);
                me.addButton = addBtn;
                var hrefObj = me.getComponent("hrefObj");
                me.hrefObj = hrefObj;
                var trigger = me.getComponent("selector-contextmenu-trigger");
                me.trigger = trigger;
                //this.on('itemcontextmenu', this.itemContextMenu, me);
                if (me.isReadOnly()) {
                    me.removeButton.setVisible(false);
                    me.addButton.disabled = true;
                    var hrefObj = me.hrefObj;
                    if (!this.getValue() && this.getValue() != xcp.widget.selector.Selector.getNullObjectId()) {
                        hrefObj.setVisible(false);
                    }
                    // me.setReadOnly(me.isReadOnly());
                }
                if (this.config.mandatory) {
                    me.labelEl.update(xcp.widget.selector.Selector.getRequiredIndicator() + me.getFieldLabel() + ":");
                }
                if (this.getValue() == xcp.widget.selector.Selector.getNullObjectId()) {
                    me.trigger.setVisible(false);
                }

            },

            /**
             * Sets the read-only state of this field.
             * @param {Boolean} readOnly True to prevent the user changing the field and click the trigger.
             */
            setReadOnly: function(readOnly) {
                if (readOnly)
                    this.bodyEl.mask();
                else
                    this.bodyEl.unmask();
            },

            /**
             *
             * Returns readonly flag on parent container
             */

            isReadOnly:function() {
                return this.disabled;
            },

            /**
             *
             * Release used resources
             */

            beforeDestroy: function() {
                if (xcp.navigationManager) {
                    var subscriptions = this.subscriptions;
                    for (var i = 0, len = subscriptions.length; i < len; i++) {
                        xcp.event.EventBus.unsubscribe(subscriptions[i]);
                    }
                    delete this.subscriptions;
                    if (this.removeButton != null) this.removeButton.destroy();
                    if (this.addButton != null) this.addButton.destroy();
                }
                this.callParent(arguments);
            },

            /**
             *
             * Call back register on context menu gesture
             */
            contextMenuHandler :function() {
                me = this;
                this.itemcontextmenu.apply(this, arguments);
            },

            /**
             * set up necessary arguments to find and invoke contextmenu
             */
            actionArgsProvider: function() {
                var actionArgs = new xcp.core.ActionArgs({
                            component:  this,
                            selection: [this.selectedRecord],
                            container: null
                        });

                return actionArgs;
            },

            /**
             * Wrapper method handling context menu and its necessities
             * @param scope
             * @param event object
             * @param eOpts optional arguments to the function
             */
            itemcontextmenu: function(scope, e, eOpts) {
                me = this;
//                var target = e.getTarget();
//                if(target.nodeName=="A" || e.hasModifier()){         // show browser's menu on link or w/ modifier
//                    return false;
//                }
                e.preventDefault();
                var actionArgs = me.actionArgsProvider();
                xcp.core.ActionManager.showContextMenu(actionArgs, "ItemContextMenu", null, e);
            },

            designTimeWidget:function(config) {
                Ext.apply(config, {
                            xtype: 'fieldcontainer',
                            height: 30,
                            width: 200,
                            fieldLabel: config.fieldLabel,
                            items: [
                               /* {
                                    xtype: 'button',
                                    iconCls: 'xcp-selector-add-icon',
                                    cls:'xcp-selector-add-button'
                                },*/
                                {
                                    xtype: 'box',
                                    autoEl: {
                                        tag:'a',
                                        html:xcp.Strings.widget.selector.designer.Selector.addLinkButtonLabel,
                                        href:'#'
                                    }

                                }

                            ]
                        })
            },

            runTimeWidget:function(config) {
                me = this;
                Ext.apply(config, {
                            xtype: 'fieldcontainer',
                            height: 30,
                            width: "100%",
                            layout:{
                                type:'hbox',
                                align:top
                            },
                            items: [
                                {
                                    xtype: 'button',
                                    itemId:'selector-add-button',
                                    iconCls: 'xcp-selector-add-icon',
                                    cls:'xcp-selector-add-button',
                                    listeners: {
                                        click:{fn: this.rendermenus, scope: this}
                                    }

                                },
                                {
                                    xtype: 'box',
                                    itemId:"hrefObj",
                                    autoEl: {
                                        tag:'a',
                                        html:xcp.Strings.widget.selector.Selector.addLinkButtonLabel,
                                        href:'#'
                                    },
                                    cls:'xcp-selector-add-link',
                                    listeners: {
                                        render:{fn: this.renderactions, scope: this}
                                    }
                                },
                                {
                                    xtype: 'button',
                                    itemId:"selector-contextmenu-trigger",
                                    cls: 'xcp-selector-contextmenu',
                                    iconCls: 'xcp-selector-contextmenu-trigger',
                                    listeners: {
                                        click:{fn: this.contextMenuHandler, scope: this}
                                    }
                                },
                                {
                                    xtype: 'button',
                                    itemId:'selector-remove-button',
                                    iconCls: 'xcp-selector-remove-icon',
                                    overCls:'xcp-selector-remove-icon-over',
                                    cls:'xcp-selector-remove-button',
                                    listeners:{
                                        click:{fn: this.removeBtnHandler, scope: this},
                                        render:function() {
                                            var removeBtn = me.getComponent('selector-remove-button');
                                            removeBtn.setVisible(false);
                                        },
                                        afterrender:{fn:this.setUpInitState, scope:this}
                                    }
                                }


                            ]
                        })
            }

        });
     

/* xcp_selector_action/content/xcp/action/SelectorAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UpdateAction.js

/**
 * @class xcp.action.form.SelectorAction
 * @extends xcp.action.form.DataAction
 * Action implementation for selecting objects within a repository.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.form.SelectorAction", {
            extend: "xcp.action.form.DataAction",
            alias: "action.selector",


            config: {
                preconditions: {
                    targets:{
                        effectivePermissions: [xcp.Permit.WRITE]
                    }
                },

                getEnablement:function(actionArgs, action) {
                    var target = action.getTargets(actionArgs)[0];
                    return xcp.Enablement.ENABLE;
                }

            },

            /**
             * Handler for the SelectorAction
             */
            handler: function(actionArgs, action) {
                var selectedIds = this.inputProperties['selection'];
                var selection = undefined;
                if(Ext.isArray(selectedIds)){
                    selection = selectedIds;
                }else{
                    selection = selectedIds;
                }
                xcp.event.EventBus.publish(xcp.event.SelectorEvent.NAME, selection);
                var callBackConfig = this.callBackConfig;
                if (callBackConfig) {
                    var scope = callBackConfig.scope || new Object();
                    var handler = callBackConfig.handler;
                    if (handler && Ext.isFunction(handler)) {
                        var successData = {};
                        handler.call(scope, successData);
                    }

                }

            }

        });

/* xcp_tab/content/xcp/widget/layout/Tab.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * Marker component for design mode support.
 */
Ext.define("xcp.widget.layout.HeaderTab", {
    extend : "Ext.tab.Tab",
    alias: "widget.xcp_header_tab",
    ui: "xcp-tab-ui"
});

/**
 * The panel that can be included in a TabGroup.
 */
Ext.define("xcp.widget.layout.Tab", {
    extend : "Ext.panel.Panel",
    alias: "widget.xcp_tab",
    bodyStyle: "padding: 5px;",
    autoScroll: true,

    constructor : function(config) {
        if (config && config.icon) {
            config.icon = xcp.util.Utils.buildArtifactsUrl(config.icon);
        }

        this.callParent(arguments);

        // If Hidden mixing call setVisible(true), extjs TabPanel.onItemBeforeShow() will automatically make the visible tab to be the active one.
        Ext.override(this, {
            setHidden: function(hidden) {
                if (!hidden) {
                    // this flag is read in TabGroup.js.
                    this.ownerCt._noActiveTabSwitch = true;
                }

                var ret = this.callParent(arguments);
                this.ownerCt._noActiveTabSwitch = false;

                return ret;
            }
        });
    },

    setVisible : function(visible) {
        // fix "visible" works not working
        var ret = this.callParent(arguments);
        if (this.tab) {
            this.tab.setVisible(visible);
            this.tab.ownerCt.showMarker();
        }
        return ret;
    },

    /**
     * set the icon URL based on path from the design mode.
     * @param url
     */
    setIconUrl : function (url) {
        return this.setIcon(xcp.util.Utils.buildArtifactsUrl(url));
    }
});

/* xcp_tab_group/content/xcp/widget/layout/TabGroup.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
(function() {
    /**
     * Marker component for design mode support and styling.
     */
    var XcpTabBar = Ext.define("xcp.widget.layout.TabBar", {
        extend : "Ext.tab.Bar",
        alias: "widget.xcp_tab_bar",
        bodyBorder: false,
        plain: true,

        initComponent: function() {
            var me = this;
            me.callParent(arguments);
            me.createMarker();
            this.delayedShowMarkerTask = new Ext.util.DelayedTask(this.delayedShowMarker, this);
            me.tabPanel.on("tabchange", this.showMarker, this);
            me.tabPanel.on("afterlayout", this.showMarker, this);
        },

        /**
         * Create a floating marker
         */
        createMarker: function(){
            var me = this;
            me.marker = Ext.widget('component', {
                floating: true,
                shadow: false,
                floatParent: me,
                cls: 'xcp-tab-bar-caret',
                hidden: true,
                doAutoRender: function(){
                    this.render(me.getEl());
                }
            });
        },

        /**
         * Display marker under the menu button
         */
        showMarker: function() {
            var me = this;
            if (!me.queuedShowMarkerTask) {
                var PageLayoutUtils = xcp.util.PageLayoutUtils;
                PageLayoutUtils.on("afterlayout", function() {
                    me.queuedShowMarkerTask = false;
                    // need another timer to get-around extjs' issue on rendering float components.
                    me.delayedShowMarkerTask.delay(1);
                }, this, {single: true});

                PageLayoutUtils.defer(Ext.emptyFn);
                me.queuedShowMarkerTask = true;
            }
        },

        /**
         * Display marker under the menu button
         */
        delayedShowMarker: function() {
            var me = this;
            var marker = me.marker;
            if (marker && !marker.isDestroyed && !marker.destroying && !me.isDestroyed && !me.destroying) {
                // Get around an extjs 4.1 bug about a javascript error during window re-sizing handling.
                // The layout engine makes a bad guess about the ownerCtContext in Ext.layout.Context.invalidate.
                // A float element.ownerCtContext for a floating element should be null, so defer the alignment in a seperate timer.
                var activeTab = me.tabPanel.activeTab;
                if (!activeTab || !activeTab.isVisible(true)) {
                    marker.setVisible(false);
                } else {
                    marker.setVisible(false);
                    marker.show();
                    if (marker.rendered) {
                        if (me.tabPanel.tabPosition=="top") {
                            marker.alignTo(activeTab.tab.getEl(), 'tl-bl', [10, -2]);
                        } else {
                            marker.alignTo(activeTab.tab.getEl(), 'bl-tl', [10, 2]);
                        }
                        marker.setVisible(true);
                    }
                }
            }
        },

        destroy: function(){
            this.delayedShowMarkerTask = null;
            if (this.marker) {
                this.marker.destroy();
            }
            return this.callParent(arguments);
        }
    });

    /**
     * ExtJs doesn't support menubar alike scroller; use ext/examples/ux/TabScrollerMenu
     */
    Ext.define('xcp.widget.layout.TabScrollerMenu', {
        extend: 'Ext.ux.TabScrollerMenu',
        alias: 'plugin.xcp_tabscrollermenu',
        pageSize: 1000,

        autoGenMenuItem: function(item) {
            /** The base class doesn't support icon **/
            var ret = this.callParent(arguments);
            if (item.icon) {
                ret.icon = item.icon;
            }

            return ret;
        },

        /**
         * fix bass class not handling hiddenByLayout, making menu items becoming less and less on switching tabs.
         */
        generateTabMenuItems: function() {
            var me = this,
                tabPanel = me.tabPanel,
                curActive = tabPanel.getActiveTab();
            tabPanel.items.each(function(item) {
                if (item.id != curActive.id && (!item.hidden || item.hiddenByLayout)) {
                    me.tabsMenu.add(me.autoGenMenuItem(item));
                }
            });
        }
    });


    var ExtTabBar = Ext.tab.Bar;

    /**
     * The tab group as an tabpanel
     */
    Ext.define("xcp.widget.layout.TabGroup", {
        extend : "Ext.tab.Panel",
        alias: "widget.xcp_tab_group",
        bodyBorder: false,
        tabBar : {
            defaultType: "xcp_header_tab"
        },
        plugins: [{
            ptype: 'xcp_tabscrollermenu'
        }],

        constructor : function(config) {
            config = config || {};
            if (!config.title) {
                delete config.title;
            }
            if (!config.height) {
                config.minHeight = 200;
            }

            return this.callParent(arguments);
        },

        initComponent : function() {
            try {
                // get around that Ext.tab.Panel has hard-coded the use of  Ext.tab.Bar
                Ext.tab.Bar = XcpTabBar;
                return this.callParent(arguments);
            } finally {
                // restore the base Ext.tab.Bar
                Ext.tab.Bar = ExtTabBar;
            }
        },

        setActiveTab: function() {
            // this is to get-around SetHidden mixing calling setVisible, which will auto activate the tab.
            // this flag is set in Tab.js
            if (!this._noActiveTabSwitch) {
                return this.callParent(arguments);
            } else {
                return this.activeTab;
            }
        },

        add : function() {
            // restore the base Ext.tab.Bar to avoid children creating xcp.widget.layout.TabBar
            Ext.tab.Bar = ExtTabBar;
            return this.callParent(arguments);
        },

        onAdd: function(item) {
            var me = this;
            var tabcfg = item.tabConfig;
            if (!tabcfg) {
                tabcfg = item.tabConfig = {};
            }
            tabcfg.xtype = "xcp_header_tab";
            if (me.tabWidth && Ext.isNumber(me.tabWidth)) {
                tabcfg.width = me.tabWidth;
            }
            if (item.tabCls) {
                tabcfg.cls = item.tabCls;
            }
            if (item.icon) {
                tabcfg.icon = item.icon;
            }

            // disable deferredRender when there are expressions
            var plugins;
            if (!item.isComponent)  {
                plugins = item.plugins;
            }  else {
                var initialConfig = item.initialConfig;
                if (initialConfig) {
                    plugins = initialConfig.plugins;
                }
            }
            if (plugins && Ext.isArray(plugins) && plugins.length > 0) {
                me.layout.deferredRender = false;
            }

            return me.callParent(arguments);
        }
    });
})();



/* xcp_tbseparator/content/xcp/widget/toolbar/ToolbarSeparator.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.widget.toolbar.ToolbarSeparator", {
    extend : "Ext.toolbar.Separator",
    alias : "widget.xcp_tbseparator"
});

/* xcp_text_area/content/xcp/widget/form/TextArea.js */

//TextArea.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.form.TextArea
 * @extends Ext.form.TextArea
 * Text field widget capable of allowing user input
 * @xtype xcp_text_area
 */
Ext.define("xcp.widget.form.TextArea", {
    extend: 'Ext.form.field.TextArea',
    alias: 'widget.xcp_text_area',
    mixins : {
        xcpFixedFieldWidthModelMixin : 'xcp.util.mixin.FixedFieldWidthModelMixin'
    },
    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {
            return newValue;
        }
    }],

    constructor: function(config) {
        xcp.widget.form.Form.encodeFieldLabel(config);
        this.callParent(arguments);
        //reset text on blur so that it automatically scrolls back to the begining of the text
        this.on("blur", this._resetText, this);
        this.mixins.xcpFixedFieldWidthModelMixin.constructor.call(this, "size");  // $NON-NLS-1$ 
    },

    //private method
    _resetText: function() {
        var el = this.inputEl.dom;
        var inputVal = el.value;
        el.value = "";
        if(inputVal) {
            setTimeout(function(){el.value = inputVal;},0);
        }
    }
});

/* xcp_text_input/content/xcp/widget/form/TextField.js */

//TextField.js
/*
 * Copyright (c) 2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.form.TextField
 * @extends Ext.form.Text
 * Text field widget capable of allowing user input
 * @xtype xcp_text_input
 */
Ext.define("xcp.widget.form.TextField", {
    extend: 'Ext.form.Text',
    alias: 'widget.xcp_text_input',
    mixins : {
        xcpFixedFieldWidthModelMixin : 'xcp.util.mixin.FixedFieldWidthModelMixin'
    },

    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {
            return newValue;
        }
    }],

    constructor: function(config) {
        xcp.widget.form.Form.encodeFieldLabel(config);
        this.callParent(arguments);

        //reset text on blur so that it automatically scrolls back to the begining of the text
        // iPad works automatically. Enabling this can cause submitting blank values back to the server.
        if (!Ext.is.iPad) {
            this.on("blur", this._resetText, this);
        }
        this.mixins.xcpFixedFieldWidthModelMixin.constructor.call(this, "size");  // $NON-NLS-1$ 
    },

    //private method
    _resetText: function() {
        var el = this.inputEl.dom;
        var inputVal = el.value;
        el.value = "";
        if(inputVal) {
            setTimeout(function(){el.value = inputVal;},0);
        }
    }
});

/* xcp_toolbar/content/xcp/widget/toolbar/Toolbar.js */

/*
 * Copyright (c) 2010-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.define("xcp.widget.toolbar.Toolbar", {
    extend : "Ext.toolbar.Toolbar",
    ui: "xcp-toolbar",
    alias : "widget.xcp_toolbar",
    enableOverflow: true
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UnassignTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.UnassignTaskDataAction");
Ext.apply(xcp.Strings.action.task.UnassignTaskDataAction, {
    confirmationTitle: "Unassign Task?",
    confirmationPromptTemplate: "Are you sure you want to unassign this task?",
    unassignTaskSuccessNotificationTemplate:  "The task has been unassigned.",
    unassignTaskErrorTemplate: "An error occurred while unassigning this task. Please try again.",
    text:"Unassign",
    tooltip:"Unassign"
});
/* xcp_unassign_task/content/xcp/action/task/UnassignTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UnassignTaskDataAction.js

/**
 * @class xcp.action.form.UpdateAction
 * @extends xcp.action.form.DataAction
 * Action implementation for updating resources within an xCP application.  It should be associated with components
 * that are contained within an xcp.widget.form.Form (xtype:xcp_form) instance.
 */
Ext.define("xcp.action.task.UnassignTaskDataAction", {
            extend: "xcp.action.task.BaseTaskDataAction",
            alias: "action.xcp_unassign_task",

            statics: {
                /**
                 * Handles the redirection of action success.
                 * @param {xcp.action.form.DataAction} action  The DataAction
                 * @param {string} id  instance id
                 * @param {Ext.data.Model} record The Model instance
                 * @param {Object} operation operation
                 */
                handleRedirection: function(action, id, record, operation) {
                    if (!Ext.isDefined(xcp.navigationManager))
                        return;

                    if (action.redirectStyle == xcp.action.form.DataAction.REDIRECT_SPECIFIED) {
                        var url = action.redirectUrl;
                        if (action.redirectUrlModel != '') {
                            //instance page
                            url = action.redirectUrlModel + "/" + id + "/" + action.redirectUrl;
                        }

                        xcp.navigationManager.navigate(url);

                    } else {
                        xcp.action.form.DataAction.handleRedirection(action, record, operation);
                    }
                }

            },
            config: {
                requiredAttributes: ["task_state","workqueue_name"],
                text: xcp.Strings.action.task.UnassignTaskDataAction.text,
                tooltip: xcp.Strings.action.task.UnassignTaskDataAction.tooltip,
                confirmationPrompt: xcp.Strings.action.task.UnassignTaskDataAction.confirmationPromptTemplate,
                showConfirmation: false,
                actionModel:"unassign_task_model",
                showSuccessNotification:true
            },

            constructor: function(config) {
                config = config || {};
                var prototype = this.self.prototype;
                // copy primary attributes from prototype (so handler doesn't have to be in config)
                var prototypeConfig=Ext.copyTo({},prototype.config, ["text", "iconCls", "tooltip", "handler", "actionModel", "showSuccessNotification"]);
                Ext.applyIf(config, prototypeConfig);

                this.callParent([config]);
            },

            /**
             * Handler for the UpdateAction
             */
            handler: function(actionArgs, action) {
                var config;
                // Note that this method will run in the context of the associated component (button, menu, etc.), therefore
                // the "this" refers to the component, not to the action.  Configuration from the action is propogated to the
                // component, but functions are not, thus functions which access instance data won't work.

                if (Ext.isEmpty(action)) { //delete action invoked from form button
//            //update action's input model when action is invoked.
//            if (!Ext.isEmpty(actionArgs.selection))
//                this.setInputModel(actionArgs.selection[0]);
//
                    config = this.getConfig();
                    targets = [this.getActionModel()];
                }
                else {
                    config = action.getConfig();
                    targets = action.getTargets(actionArgs);
                }
                var model=xcp.action.form.DataAction.getModelForSelection(targets[0], this.actionModel);

                //to set model instance property "phantom" to be false since this action model is just created
                //and ExtJs expected this value to be false so it can issue a "PUT" action to the server

                model.phantom = false;

                var id = model.getId();

                var handleUnassignSuccess = function(record, operation) {
                    xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, id);
                    if (config.showSuccessNotification) {
                        xcp.action.form.DataAction.notifyActionSuccess(this, xcp.Strings.action.task.UnassignTaskDataAction.unassignTaskSuccessNotificationTemplate);
                    }

                    xcp.action.task.UnassignTaskDataAction.handleRedirection(this, id, record, operation);

                };
                // Show confirmation if configured
                if (config.showConfirmation) {
                    var confirmationCallback = function(btn) {
                        if (btn == "yes") {
                            model.save({success: handleUnassignSuccess, feedbackContainer: actionArgs.component, scope: this});
                        }
                    };

                    Ext.Msg.show({
                                title:  xcp.Strings.action.form.UpdateAction.confirmationTitle,
                                buttons: Ext.MessageBox.YESNO,
                                fn: confirmationCallback,
                                icon: Ext.MessageBox.WARNING,
                                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.task.UnassignTaskDataAction.confirmationPromptTemplate, model),
                                scope: this
                            });
                } else {
                    model.save({success: handleUnassignSuccess, feedbackContainer: actionArgs.component, scope: this});
                }
            },
            getEnablement:function(actionArgs, action){
                var applicable = false;
                var baseAction = xcp.action.task.BaseTaskDataAction;
                if (baseAction.isQueueTask(actionArgs, action)) {
                    var queueName = baseAction.getTaskAttribute(actionArgs,action,"queue_name");
                    var performer = baseAction.getTaskAttribute(actionArgs,action,"performer");
                    var state = baseAction.getTaskAttribute(actionArgs,action,"state");
                    applicable = performer !== queueName &&
                                 state != 2 &&
                                 baseAction.isQueueTaskActionApplicable(actionArgs,action,true,true,false,false,true);
                }
                return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;
            },
            getInitialEnablement: function() {
                return xcp.Enablement.HIDE;
            }
        });


/* xcp_unassign_task/content/xcp/data/model/UnassignTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.define("unassign_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/unassign"
    },
    "fields" : [
        {
            "name":"id"
        }
    ]
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */



// UnholdTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.UnholdTaskDataAction");
Ext.apply(xcp.Strings.action.task.UnholdTaskDataAction, {
    confirmationTitle: "Unhold Task?",
    confirmationPromptTemplate: "Are you sure you want to unhold this task?",
    updateSuccessNotificationTemplate:  "The task has been unheld.",
    updateErrorTemplate: "An error occurred while unholding this task. Please try again.",
    text:"Unhold",
    tooltip:"Unhold"
});
/* xcp_unhold_task/content/xcp/action/task/UnholdTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UnholdTaskDataAction.js

/**
 * @class xcp.action.task.UnholdTaskDataAction
 * @extends xcp.action.task.BaseTaskDataAction
 * Action implementation for unhold task action.
 */
Ext.define("xcp.action.task.UnholdTaskDataAction", {
    extend: "xcp.action.task.BaseTaskDataAction",
    alias: "action.xcp_unhold_task",

    config: {
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false,
        text: xcp.Strings.action.task.UnholdTaskDataAction.text,
        tooltip: xcp.Strings.action.task.UnholdTaskDataAction.tooltip,
        actionModel: "unhold_task_model"
    },

    getEnablement:function(actionArgs, action){
        var applicable = false;
        var baseAction = xcp.action.task.BaseTaskDataAction;

        if (baseAction.isQueueTask(actionArgs, action)) {
            applicable = baseAction.isQueueTaskActionApplicable(actionArgs, action, true, true,false,false, true,[4,5,6]);
        } else {
            applicable = baseAction.isTaskActionApplicable(actionArgs, action, true, true, true, true,[4,5,6]);
        }
        return applicable ? xcp.Enablement.ENABLE : xcp.Enablement.HIDE;
    },

    getLocaleBundleName: function() {
        return "xcp.Strings.action.task.UnholdTaskDataAction";
    }
});

/* xcp_unhold_task/content/xcp/data/model/UnholdTaskModel.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */
Ext.define("unhold_task_model",{
    "extend" :"xcp.data.Model",
    "proxy" : {
        "type" : "xcp_rest",
        "url" : "application/tasks/{id}/unhold"
    },
    "fields" : [
        {
            "name":"id"
        }
    ]
});

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UpdateTaskDataAction-strings.js

Ext.namespace("xcp.Strings.action.task.UpdateTaskDataAction");
Ext.apply(xcp.Strings.action.task.UpdateTaskDataAction, {
    confirmationTitle: "Update Task?",
    confirmationPromptTemplate: "Are you sure you want to update this task?",
    updateSuccessNotificationTemplate:  "The task has been updated.",
    updateErrorTemplate: "An error occurred while updating this task. Please try again."
});
/* xcp_update_task/content/xcp/action/task/UpdateTaskDataAction.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// UpdateTaskDataAction.js

/**
 * @class xcp.action.task.UpdateTaskDataAction
 * @extends xcp.action.form.DataAction
 * Action implementation for updating a task.
 */
Ext.define("xcp.action.task.UpdateTaskDataAction", {
    extend: "xcp.action.form.DataAction",
    alias: "action.xcp_update_task",

    statics: {
        /**
         * Handles the redirection of action success.
         * @param {xcp.action.form.DataAction} action  The DataAction
         * @param {string} id  instance id
         * @param {Ext.data.Model} record The Model instance
         * @param {Object} operation operation
         */
        handleRedirection: function(action, id, record, operation) {
            if (!Ext.isDefined(xcp.navigationManager))
                return;

            if (xcp.action.form.DataAction.REDIRECT_SPECIFIED == action.redirectStyle) {
                var url = action.redirectUrl;
                if (action.redirectUrlModel != '') {
                    //instance page
                    url = action.redirectUrlModel + "/" + id + "/" + action.redirectUrl;
                }

                xcp.navigationManager.navigate(url);

            } else {
                xcp.action.form.DataAction.handleRedirection(action, record, operation);
            }
        }

    },

    config: {
        /**
         * @cfg {String} confirmationPrompt Pattern for string used as confirmation prompt (defaults to
         * Are you sure you want to update a task"?)
         */
        confirmationPrompt: xcp.Strings.action.task.UpdateTaskDataAction.confirmationPromptTemplate,
        /**
         * @cfg {Boolean} showConfirmation True to show a confirmation before creating the resource (defaults to false)
         */
        showConfirmation: false
    },

    getEnablement:function(actionArgs, action){
        return xcp.action.task.BaseTaskDataAction.isTaskActionApplicable(actionArgs, action, true, true, true, true, 1) ?
            xcp.Enablement.ENABLE :
            xcp.Enablement.HIDE;
    },

    /**
     * Handler for the UpdateAction
     */
    handler: function(actionArgs, action) {
        var config = this.getConfig();

        var model = this.getActionModel();

        //to set model instance property "phantom" to be false since this action model is just created
        //and ExtJs expected this value to be false so it can issue a "PUT" action to the server
        model.phantom = false;

        var id = model.getId();

        var handleUpdateSuccess = function(record, operation) {
            xcp.event.EventBus.publish(xcp.event.ItemModified.NAME, id);

            if (this.showSuccessNotification) {
                xcp.action.form.DataAction.notifyActionSuccess(this.ownerCt || actionArgs.component, xcp.Strings.action.task.UpdateTaskDataAction.updateSuccessNotificationTemplate, model);
            }

            xcp.action.task.UpdateTaskDataAction.handleRedirection(this, id, record, operation);

        };
        // Show confirmation if configured
        if (config.showConfirmation) {
            var confirmationCallback = function(btn) {
                if (btn == "yes") {
                    model.save({success: handleUpdateSuccess, feedbackContainer: this.ownerCt || actionArgs.component, scope: this, actionConfig: config});
                }
            };

            Ext.Msg.show({
                title:  xcp.Strings.action.task.UpdateTaskDataAction.confirmationTitle,
                buttons: Ext.MessageBox.YESNO,
                fn: confirmationCallback,
                icon: Ext.MessageBox.WARNING,
                msg: xcp.action.form.DataAction.formatTemplateString(xcp.Strings.action.task.UpdateTaskDataAction.confirmationPromptTemplate, model),
                scope: this
            });
        } else {
            model.save({success: handleUpdateSuccess, feedbackContainer: this.ownerCt || actionArgs.component, scope: this, actionConfig: config});
        }
    },
    getInitialEnablement: function() {
        return xcp.Enablement.HIDE;
    }
});
// UserButton-strings.js

Ext.namespace("xcp.Strings.widget.button.UserButton");

Ext.apply(xcp.Strings.widget.button.UserButton, {
	settings : "Settings",
	logout : "Sign out",
    textOnOverflow: "Settings & Sign out"
});
/* xcp_user_button/content/xcp/widget/button/UserButton.js */

// UserButton.js
	
Ext.define("xcp.widget.button.UserButton", {
	extend: "Ext.button.Button",
	alias: "widget.xcp_user_button",
	scale: "medium",
	cls: "float",
	iconCls:"xcp-userButton-userIcon",
	componentCls: "xcp-userButton",
	menuAlign: "tl-bl?",

	xcp_unifyWidths: function() {
		var menu = this.menu;
		var userNameRoleWidget = menu.items.get(0);
		var settingsWidget = menu.items.get(1).items.get(0);
		var logoutWidget = menu.items.get(1).items.get(1);
		var newWidth = userNameRoleWidget.getSize().width;
		if (newWidth < settingsWidget.getSize().width) {
			newWidth = settingsWidget.getSize().width;
		}
		
		if (newWidth < logoutWidget.getSize().width) {
			newWidth = logoutWidget.getSize().width;
		}

		userNameRoleWidget.setWidth(newWidth);
		settingsWidget.setWidth(newWidth);
		logoutWidget.setWidth(newWidth); 
	},
	listeners: {
		beforerender: {
			fn : function(){
				var text = "";
				if (xcp && xcp.core && xcp.core.UserProfile && xcp.currentUser) {
					var role = xcp.core.UserProfile.getRole();
					var roleLabel = "";
					
					// Find the correct label for the active role
					for (i=0;i<xcp.currentUser["userRoles"].length;i++) {
						if (role == xcp.currentUser["userRoles"][i].value) {
							roleLabel = xcp.currentUser["userRoles"][i].label;
							break;
						}
					}
					
					text = "<div><div><b>"+xcp.currentUser.currentUser+"</b></div><div>"+roleLabel+"</div></div>";
				}
			
				this.menu.items.get(0).setText(text);
			}
		},
		menushow: {
			fn : function() {
				this.xcp_unifyWidths();
			}
		}
	},

    constructor: function(config) {
        this.textOnOverflow = xcp.Strings.widget.button.UserButton.textOnOverflow;
        var namespace = "";
   	    if (xcp && xcp.appContext && xcp.appContext.namespace){
   	    	namespace = xcp.appContext.namespace;
        }
        Ext.apply(config, {
            // outer menu that holds all of our stuff
            menu : {
                xtype: 'menu',
                items:[
                    {
                        // the non button item
                        xtype: "menuitem",
                        canActivate: false,
                        hideOnClick: false,
                        plain: true,
                        // note that the function exectutes returning a string for text NOT the function
                        height: 38,
                        // check this
                        padding : "4 0 0 10",
                        cls: "xcp-userButton-userNameRole"
                    },
                    {
                        // so then we put all of our buttons in a button group within the menu
                        xtype: 'buttongroup',
                        frame: false,
                        columns: 1,
                        defaults: {
                            xtype: 'button',
                            scale: 'small',
                            iconAlign: 'left',
                            textAlign: 'left',
                            overCls: 'xcp-userButton-optionMouseOver',
                            listeners: {
                                click : {
                                    fn: function() {
                                        // close the menu when clicked
                                        // up to the button group then the menu then the button
                                        this.ownerCt.ownerCt.ownerButton.hideMenu();
                                    }
                                }
                            }
                        },
                        items:
                            [
                                {
                                    iconCls:"xcp-userButton-settingsIcon",
                                    text: xcp.Strings.widget.button.UserButton.settings,
                                    action : {
                                        redirectStyle : "specified",
                                        actionType : "xcp_gotopage",
                                        redirectUrl : namespace + "_user_preferences"
                                    }
                                },
                                {
                                    iconCls:"xcp-userButton-logoutIcon",
                                    text: xcp.Strings.widget.button.UserButton.logout,
                                    action : {
                                        actionType : "xcp_logout"
                                    }
                                }
                            ]
                    }
                ]
            }
        });

        this.callParent(arguments);
    }

});

/* xcp_validation_error_window/content/xcp/widget/window/ValidationErrorWindow.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

// ValidationErrorWindow.js
/**
 * @class xcp.widget.window.ValidationErrorWindow
 * @extends Ext.container.Container
 * 
 */
Ext.define("xcp.widget.window.ValidationErrorWindow", {
    extend: "Ext.container.Container",
    alias: "widget.xcp_validation_error_window",
    minHeight: 25,
    config: {
        message:""
    },
    
    constructor: function(config) {
    	this.initConfig(config);
        var localConfig = {
            layout: 'column',
            cls: 'xcp-notification-error',
            items: [{
                xtype: 'component',
                columnWidth: 1.0,
                html: Ext.util.Format.stripScripts(config.message || ""), // allow rich text.
                margin: '0 10 0 0'
            }]
        };
        if(config.showCloseIcon) {
            localConfig.items.push({
                listeners: {
                    'afterrender': function(component) {
                        component.mon(component.getEl(), 'click', function() {
                            var ownerCt = component.ownerCt;
                            ownerCt.ownerCt.remove(ownerCt);
                        }, component);
                    }
                },
                xtype : 'box',
                width : 16,
                cls : 'xcp-statusicon xcp-notify-close-icon',
                overCls : 'xcp-notify-close-icon-hover',
                margin : '0 10 0 5'
            });
        }
        this.callParent([Ext.apply(config, localConfig)]);
    },

    initEvents : function() {
        this.callParent(arguments);
        Ext.EventManager.onWindowResize(this.doLayout, this, [false]);
        this.on("beforedestroy", function() {
            Ext.EventManager.removeResizeListener(this.doLayout, this);
        }, this);
    },

    doLayout : function() {
        this.on("afterlayout", function() {
            if (this.getHeight() < this.minHeight) {
                this.setSize(null, this.minHeight);
            }
        }, this, {single: true});

        return this.callParent(arguments);
    },

    renderMe: function(container) {
    	container.insert(0, this);
    }
});/*
 * Copyright (c) 2012-2012. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.form.ValueDisplay");

Ext.apply(xcp.Strings.widget.form.ValueDisplay, {
    trueStr: "true",
    falseStr: "false"
});
/* xcp_value_display/content/xcp/widget/form/ValueDisplay.js */

// ValueDisplay.js
/*
 * Copyright (c) 2011-2012. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.form.ValueDisplay
 * @extends Ext.form.Display
 * A read-only display of the label and value of an attribute
 * @xtype xcp_value_display
 */
Ext.define("xcp.widget.form.ValueDisplay", {
    extend: 'Ext.form.Display',
    alias: 'widget.xcp_value_display',
    xcpeventconfig : [{
        event : "change",
        data : function(field, newValue, oldValue, options) {
            return newValue;
        }
    }],
    constructor: function(config) {
        //Check if formatting is configured
        if (config && config.format) {
            //Create formatter instance
            this._formatter = xcp.core.FormatManager.create(config.format);
        }
        if(config && config.repeatingAttributeFormat) {
            //this._repeatingAttributeFormatter = xcp.core.FormatManager.create(config.repeatingAttributeFormat);
            this._repeatingAttributeFormatter = Ext.create('formatter.xcp_repeating_attribute_formatter', config.repeatingAttributeFormat);
        }

        xcp.widget.form.Form.encodeFieldLabel(config);

        xcp.widget.form.ValueDisplay.superclass.constructor.apply(this, arguments);
    },

    setValue: function(value) {
        var oldRawValue = this.getRawValue();

        //Apply formatting if configured.
        xcp.widget.form.ValueDisplay.superclass.setValue.apply(this, arguments);
        value = xcp.formatter.Util.formatWidgetValues(this, value,
                            xcp.Strings.widget.form.ValueDisplay.trueStr,
                            xcp.Strings.widget.form.ValueDisplay.falseStr);

        this.setRawValue(value);


        if (this.rendered && !this.isDestroyed && !this.width && this.getRawValue() != oldRawValue) {
            this.updateLayout();
        }
    },

    /**
     * Resolves the value to corresponding label if the valuedisplay is associated with a picklist, returns the value otherwise.
     * @param value value to resolve
     */
    resolvePickListValue: function(value) {
        if (!this.store && this.valueType && (this.valueType.indexOf("xcp.picklist.") == 0)) {
            this.store = this.valueType;
        }

        if (this.store) {
            var store = Ext.data.StoreManager.lookup(this.store);
            value = xcp.formatter.Util.resolvePickListLabel(store, value);
        }
        return value;
    },

    //private
    _updateFormatCls:function() {

        //Set the format class, if available on the input element.
        if (this.formatCls) {
            this.inputEl.addCls(this.formatCls);
        }
    },

    getValue: function() {
        return this.value;
    }    
});
/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

Ext.namespace("xcp.Strings.widget.window.Wizard");

Ext.apply(xcp.Strings.widget.window.Wizard, {
	backButtonLabel:			"< Back",
    nextButtonLabel:			"Next >",
    closeButtonLabel:			"Close",
    cancelButtonLabel:			"Cancel",
    finishButtonLabel:			"Finish",
    dummyCompTitle:             "Loading Wizard...",
    stepLoadingFailure:         "Error while retrieving step page json : {0}"
});

/* xcp_wizard/content/xcp/widget/window/Wizard.js */

/*
 * Copyright (c) 2010-2011. EMC Corporation.  All Rights Reserved.
 */

/**
 * @class xcp.widget.window.Wizard
 * @extends Ext.window.Window
 * xCP Wizard component
 * @xtype xcp_wizard
 */
Ext.define("xcp.widget.window.Wizard", {
    extend : "Ext.window.Window",
    alias : "widget.xcp_wizard",
    config : {
        "buttonLabels" : {
            "finish" : xcp.Strings.widget.window.Wizard.finishButtonLabel,
            "cancel" :  xcp.Strings.widget.window.Wizard.cancelButtonLabel,
            "next" : xcp.Strings.widget.window.Wizard.nextButtonLabel,
            "back":xcp.Strings.widget.window.Wizard.backButtonLabel,
            "close":xcp.Strings.widget.window.Wizard.closeButtonLabel
        }
    },
    statics : {
        ACTION_FLOW_CONTAINER_XCP_ID : "action_container_instance",
        /**
         * Builds the step page url from the stepname
         * @param stepName
         */
        buildStepUrl : function(stepName) {
            var stepPath = "/ui/steps/" + stepName;
            var stepUrl = xcp.util.Utils.buildResourceUrl(stepPath, true);
            return stepUrl;
        },

        /**
         * Returns the step page json
         * @param stepName
         * @param callback
         * @param scope
         */
        getStepJson : function(stepName, callback, scope) {
            Ext.Ajax.request({
                url: xcp.widget.window.Wizard.buildStepUrl(stepName),
                disableCaching : false,
                scope: scope,
                success: function(response, options) {
                    var responseText = response.responseText;
                    var stepJSON = Ext.JSON.decode(responseText);
                    callback.call(scope, stepJSON);
                },
                failure: function(response, options) {
                    //TODO throw fatal error
                    throw new Error (Ext.String.format(xcp.Strings.widget.window.Wizard.stepLoadingFailure, stepName));
                }
            });
        }
    },
    /**
     * Constructor
     * @param config
     */
    constructor: function(config)
    {
        //Cache all configured wizard pages
        if(!config.buttonLabels) {
            config.buttonLabels = this.config.buttonLabels;
        }
        this.config = config;
        var flowDef = this.config.flowDef;

        var buttonLabels = this.config.buttonLabels;
        this.backButton = new Ext.Button({text:buttonLabels.back, handler:this.processStep, scope:this, transition:'back', hidden: true});
        this.nextButton = new Ext.Button({text:buttonLabels.next, handler:this.processStep, scope:this, transition:'next', hidden: true});
        this.finishButton = new Ext.Button({text:buttonLabels.finish, handler:this.processStep, scope:this, transition:'finish', hidden: true});
        this.cancelButton = new Ext.Button({text:buttonLabels.cancel, handler:this.processStep, scope:this, transition:'cancel', hidden: true});
        this.closeButton = new Ext.Button({text:buttonLabels.close, handler:this.onClose, scope:this, transition:'close'});

        Ext.applyIf(config, {
            buttons: [this.backButton, this.nextButton, this.finishButton, this.cancelButton, this.closeButton]
        });
        //constrain the window to the parent container, so that the entire window is shown while resizing
        Ext.applyIf(config, {"constrain":true});

        //lazy component creation
        this.config.layout = "card";  // $NON-NLS-1$ 
        this.config.activeItem= 0,
        this.config.layoutConfig =  {
            "deferredRender": true
        };
        
        //this._allComponentConfigs = config.items;
        this.config.items = [];

        var dataServiceActions = flowDef[xcp.core.actionflow.FlowEngine.FLOW_DATA_ACTION_SECTION_NAME];
        var exeConfig = this.config[xcp.core.actionflow.FlowEngine.FLOW_DATA_ACTION_EXE_CONFIG];
        this.applyPostExecutionConfig(dataServiceActions, exeConfig);
        if (!dataServiceActions) {
            this.addDummyComponent();
        } else {

            //Set action container
            if (!Ext.isArray(dataServiceActions)) {
                dataServiceActions = [dataServiceActions];
            }
            var actionContainerConfig = {
                "xtype" : "xcp_action_container",
                "xcpId" : xcp.widget.window.Wizard.ACTION_FLOW_CONTAINER_XCP_ID,
                "actions":dataServiceActions
            };
            this.config.items.push(actionContainerConfig);
        }


        xcp.widget.window.Wizard.superclass.constructor.apply(this, [this.config]);

    },
    /**
     * Apply the post execution config on action flow data action instances
     * @param dataServiceActions
     * @param exeConfig
     */
    applyPostExecutionConfig: function(dataServiceActions, exeConfig) {
        if (dataServiceActions && dataServiceActions.length > 0 && exeConfig) {
            for (var index=0; index < dataServiceActions.length; index++) {
                Ext.apply(dataServiceActions[index], exeConfig);
            }
        }
    },
    /**
     * Initialize the component
     */
    initComponent : function() {
        if (this.config.flowDef) {
            var flowConfig = {
                flowDef:this.config.flowDef,
                inputModel:this.config.inputModel,
                container:this
            };
            this.flow = new xcp.core.actionflow.FlowEngine(flowConfig);
        }
        this.on("afterrender", this.addFirstComponent);
        xcp.widget.window.Wizard.superclass.initComponent.apply(this, arguments);
    },
    /**
     * Adds a dummy component. This is needed to render the wizard.
     * After rendering this will be replaced by the first step page
     */
    addDummyComponent : function() {
        var dummyConfig = {id:'dummyComp', xtype:'panel', title:xcp.Strings.widget.window.Wizard.dummyCompTitle};
        this.config.items.push(dummyConfig);
    },
    /**
     * Adds the first step page to the wizard
     */
    addFirstComponent : function() {
        var firstStepId = this.flow.getCurrentViewId();
        this.showComponent(firstStepId);
    },
    /**
     * Adds the component to the wizard
     * @param componentId
     */
    showComponent : function(componentId) {
        this.currentComponentId = componentId;
        var currentComponentXcpId = this.flow.getViewStateXcpId(componentId);
        var currentComponent = this.getComponentForXcpId(currentComponentXcpId);
        if (!currentComponent) {
            var pageUrl = this.flow.getCurrentViewPageUrl();
            xcp.widget.window.Wizard.getStepJson(pageUrl, this.renderPage, this);
        }
        else {

            this.getLayout().setActiveItem(currentComponent.id);
            this.setButtonEnablement();
            xcp.core.FeedbackManager.clearFeedback(this.getCurrentComponent(),"xcp_error_message_window",false);
            xcp.core.FeedbackManager.clearFeedback(this.getCurrentComponent(),"xcp_validation_error_window",false);
        }
    },
    /**
     * Renders the step json in the wizard
     * @param stepConfig
     */
    renderPage : function(stepConfig) {
        //Add Id to the pageConfig
        var xcpId = this.flow.getCurrentViewXcpId();

        var pageConfig = {
            "xcpId":xcpId,
            "includeFeedbackTypes":['systemErrors', 'validationErrors', 'notifications']
        };
        var page = Ext.create('widget.xcp_page', pageConfig);
        //pass on the flow execution context to the page
        page.getFlowExecutionContext = this.getFlowExecutionContext;
        page.flow = this.flow;

        page.replaceChild(stepConfig);
        this.insert(this.items.length,  page);
        this.setButtonEnablement();
        var currentComponent = this.getComponentForXcpId(xcpId);
        this.getLayout().setActiveItem(currentComponent.id);
        this.resolveActionInstanceExpressionBindings(xcpId);
        if (this.getComponent("dummyComp")) {
            this.remove("dummyComp");
        }
    },
    /**
     * Shows or hides the buttons in the wizard based on the possible transitions of the current state config
     */
    setButtonEnablement: function() {
        var transitionIds = this.flow.getCurrentViewTransitionIds();
        if(transitionIds) {
            if (this.initialConfig.buttons && this.initialConfig.buttons.length > 0) {
                for (var i=0; i < this.initialConfig.buttons.length; i++) {
                    var button = this.initialConfig.buttons[i];
                    if (!transitionIds[button.transition])
                        button.hide();
                    else
                        button.show();
                    }
            }
        }
    },
    /**
     * Handler to close button
     * @param button
     */
    onClose : function(button) {
        xcp.widget.window.Wizard.superclass.close.call(this);
        if(this.config.handleRedirection && Ext.isFunction(this.config.handleRedirection)) {
            this.config.handleRedirection.call(this.config, this.config.actionModel.id);
        }
    },
    /**
     * Utility method that returns the current component shown in the wizard
     */
    getCurrentComponent: function() {
        var xcpId = this.flow.getViewStateXcpId(this.currentComponentId);
        return this.getComponentForXcpId(xcpId);
    },
    /**
     * Handler of the wizard buttons, which the propels the state transition
     * @param button
     */
    processStep : function(button) {
        var me = this;
        // call back handler in success scenario
        var callback = function(nextStateId) {
            if(nextStateId) {
                if (nextStateId == xcp.core.actionflow.FlowEngine.CLOSE_DIALOG_STATE) {
                    me.onClose(button);
                } else {
                    me.showComponent(nextStateId);
                }
            }
        } ;
        // callback handler in error scenarios
        var errorCallback = function(nextStateId,errorMessage) {
            if(nextStateId) {
                {
                    me.showComponent(nextStateId);
                    me.getLayout().setActiveItem(nextStateId);
                    // show the error message
                    xcp.core.FeedbackManager.showFeedback(me.getCurrentComponent(), "", errorMessage, "systemErrors");
                    me.setButtonEnablement();
                }
            }
        } ;

        var transitionContext = new xcp.core.actionflow.TransitionContext({
                 eventId:button.transition,
                 component : this.getCurrentComponent(),
                 callback: callback,
                 errorCallback: errorCallback,
                 callbackScope: me});
        this.flow.evaluateTransition(transitionContext);
    },
    getFlowExecutionContext:function() {
        return this.flow.flowExecutionContext;
    },
    /**
     * Resolve the action expression binding for actions, this is mainly required in action flow where expression
     * pointing to a step page widget can only be resolved after the step page is visited by user
     * @param actionInstanceId
     */
    resolveActionInstanceExpressionBindings: function(stepId) {
        var stepXcpId = stepId;
        var processExpressionConfig =  function(actionInst) {
            if (!actionInst) {
                 return;
            }
            if (actionInst.plugins) {
                for (var i = 0, len = actionInst.plugins.length; i < len; i++) {
                    if (actionInst.plugins[i] instanceof xcp.core.expr.ExpressionPropertiesPlugin) {
                        actionInst.plugins[i].processExpressionConfig(stepXcpId);
                    }
                }
            }

        };
        var actionContainer = this.getActionContainer();
        if (actionContainer) {
            var actionInstanceMap = actionContainer.getActionInstances();
            var count = actionInstanceMap.getCount();
            for (var i=0; i < count; i++) {
                processExpressionConfig(actionInstanceMap.getAt(i));
            }
        }
    },
    /**
     * Return the action container instance associated with this wizard.
     */

    getActionContainer: function() {
        return this.getComponentForXcpId(xcp.widget.window.Wizard.ACTION_FLOW_CONTAINER_XCP_ID);
    },
    /**
     * Returns the component (card) for given xcpId
     * @param xcpId
     */
    getComponentForXcpId: function(xcpId) {
        var me = this;
        var query = "component[xcpId='" + xcpId+ "']";
        var component = me.query(query);
        if (component && component.length != 0) {
            return component[0];
        }
        return null;

    }

});
